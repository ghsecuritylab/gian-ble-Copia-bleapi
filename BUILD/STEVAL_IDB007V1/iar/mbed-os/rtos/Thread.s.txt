###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:57
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\rtos\Thread.cpp
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --c++ --no_rtti --no_exceptions --guard_calls
#        --no_static_destruction -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\Thread.d -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\Thread.s.txt -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\Thread.o
#        .\mbed-os\rtos\Thread.cpp
#    Locale       =  Italian_Italy.1252
#    List file    =  .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\Thread.s.txt
#    Object file  =  .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\Thread.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\rtos\Thread.cpp
      1          /* mbed Microcontroller Library
      2           * Copyright (c) 2006-2012 ARM Limited
      3           *
      4           * Permission is hereby granted, free of charge, to any person obtaining a copy
      5           * of this software and associated documentation files (the "Software"), to deal
      6           * in the Software without restriction, including without limitation the rights
      7           * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      8           * copies of the Software, and to permit persons to whom the Software is
      9           * furnished to do so, subject to the following conditions:
     10           *
     11           * The above copyright notice and this permission notice shall be included in
     12           * all copies or substantial portions of the Software.
     13           *
     14           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     15           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     16           * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     17           * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     18           * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     19           * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     20           * SOFTWARE.
     21           */
     22          #include "rtos/Thread.h"

   \                                 In section .rodata, align 4
   \   __absolute mbed::Callback<void ()>::ops const mbed::Callback<void ()>::generate<>(mbed::Callback<void ()>::function_context<void (*)(void *), void> const &)::ops
   \                     _ZZN4mbed8CallbackIFvvEE8generateINS2_16function_contextIPFvPvEvEEEEvRKT_E3ops:
   \   00000000   0x........         DC32 _ZN4mbed8CallbackIFvvEE13function_callINS2_16function_contextIPFvPvEvEEEEvPKv
   \   00000004   0x........         DC32 _ZN4mbed8CallbackIFvvEE13function_moveINS2_16function_contextIPFvPvEvEEEEvS5_PKv
   \   00000008   0x........         DC32 _ZN4mbed8CallbackIFvvEE13function_dtorINS2_16function_contextIPFvPvEvEEEEvS5_

   \                                 In section .text, align 2
   \   __interwork __softfp void mbed::Callback<void ()>::function_call<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void const *)
   \                     _ZN4mbed8CallbackIFvvEE13function_callINS2_16function_contextIPFvPvEvEEEEvPKv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0x6848             LDR      R0,[R1, #+4]
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x4788             BLX      R1
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void mbed::Callback<void ()>::function_move<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *, void const *)
   \                     _ZN4mbed8CallbackIFvvEE13function_moveINS2_16function_contextIPFvPvEvEEEEvS5_PKv: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD001             BEQ      ??function_move_0
   \   00000004   0xC90C             LDM      R1!,{R2,R3}
   \   00000006   0xC00C             STM      R0!,{R2,R3}
   \                     ??function_move_0: (+1)
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void mbed::Callback<void ()>::function_dtor<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *)
   \                     _ZN4mbed8CallbackIFvvEE13function_dtorINS2_16function_contextIPFvPvEvEEEEvS5_: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp void mbed::callback<>(void (*)(void *), void *)
   \                     _ZN4mbed8callbackIvvvEENS_8CallbackIFT1_vEEEPFS2_PT_EPT0_: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0xC078             STM      R0!,{R3-R6}
   \   0000000C   0x3810             SUBS     R0,R0,#+16
   \   0000000E   0xD001             BEQ      ??callback_0
   \   00000010   0x6001             STR      R1,[R0, #+0]
   \   00000012   0x6042             STR      R2,[R0, #+4]
   \                     ??callback_0: (+1)
   \   00000014   0x4901             LDR      R1,??callback_1
   \   00000016   0x60C1             STR      R1,[R0, #+12]
   \   00000018   0xBC70             POP      {R4-R6}
   \   0000001A   0x4770             BX       LR               ;; return
   \                     ??callback_1:
   \   0000001C   0x........         DC32     _ZZN4mbed8CallbackIFvvEE8generateINS2_16function_contextIPFvPvEvEEEEvRKT_E3ops
     23          
     24          #include "mbed.h"
     25          #include "rtos/rtos_idle.h"
     26          #include "mbed_assert.h"
     27          
     28          #define ALIGN_UP(pos, align) ((pos) % (align) ? (pos) +  ((align) - (pos) % (align)) : (pos))
     29          MBED_STATIC_ASSERT(ALIGN_UP(0, 8) == 0, "ALIGN_UP macro error");
     30          MBED_STATIC_ASSERT(ALIGN_UP(1, 8) == 8, "ALIGN_UP macro error");
     31          
     32          #define ALIGN_DOWN(pos, align) ((pos) - ((pos) % (align)))
     33          MBED_STATIC_ASSERT(ALIGN_DOWN(7, 8) == 0, "ALIGN_DOWN macro error");
     34          MBED_STATIC_ASSERT(ALIGN_DOWN(8, 8) == 8, "ALIGN_DOWN macro error");
     35          

   \                                 In section .bss, align 4
     36          static void (*terminate_hook)(osThreadId_t id) = 0;
   \                     terminate_hook:
   \   00000000                      DS8 4

   \                                 In section .text, align 2, keep-with-next
     37          extern "C" void thread_terminate_hook(osThreadId_t id)
     38          {
     39              if (terminate_hook != (void (*)(osThreadId_t))NULL) {
   \                     thread_terminate_hook: (+1)
   \   00000000   0x....             LDR      R1,??DataTable8
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x000A             MOVS     R2,R1
   \   00000006   0xD100             BNE      ??thread_terminate_hook_0
   \   00000008   0x4770             BX       LR
     40                  terminate_hook(id);
   \                     ??thread_terminate_hook_0: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x4788             BLX      R1
     41              }
     42          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
     43          
     44          namespace rtos {
     45          

   \                                 In section .text, align 4, keep-with-next
     46          void Thread::constructor(osPriority priority,
     47                  uint32_t stack_size, unsigned char *stack_mem, const char *name) {
   \                     _ZN4rtos6Thread11constructorE12osPriority_tjPhPKc: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     48          
     49              const uintptr_t unaligned_mem = reinterpret_cast<uintptr_t>(stack_mem);
     50              const uintptr_t aligned_mem = ALIGN_UP(unaligned_mem, 8);
   \   00000006   0x2007             MOVS     R0,#+7
   \   00000008   0x4203             TST      R3,R0
   \   0000000A   0xD005             BEQ      ??constructor_0
   \   0000000C   0x001E             MOVS     R6,R3
   \   0000000E   0x3608             ADDS     R6,R6,#+8
   \   00000010   0x2707             MOVS     R7,#+7
   \   00000012   0x401F             ANDS     R7,R7,R3
   \   00000014   0x1BF6             SUBS     R6,R6,R7
   \   00000016   0xE000             B        ??constructor_1
   \                     ??constructor_0: (+1)
   \   00000018   0x001E             MOVS     R6,R3
     51              const uint32_t offset = aligned_mem - unaligned_mem;
   \                     ??constructor_1: (+1)
   \   0000001A   0x1AF1             SUBS     R1,R6,R3
     52              const uint32_t aligned_size = ALIGN_DOWN(stack_size - offset, 8);
   \   0000001C   0x1A51             SUBS     R1,R2,R1
   \   0000001E   0x4008             ANDS     R0,R0,R1
   \   00000020   0x1A08             SUBS     R0,R1,R0
   \   00000022   0x9000             STR      R0,[SP, #+0]
     53          
     54              _tid = 0;
   \   00000024   0x0027             MOVS     R7,R4
   \   00000026   0x3714             ADDS     R7,R7,#+20
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x6038             STR      R0,[R7, #+0]
     55              _dynamic_stack = (stack_mem == NULL);
   \   0000002C   0x2B00             CMP      R3,#+0
   \   0000002E   0xD101             BNE      ??constructor_2
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0xE000             B        ??constructor_3
   \                     ??constructor_2: (+1)
   \   00000034   0x2100             MOVS     R1,#+0
   \                     ??constructor_3: (+1)
   \   00000036   0x223C             MOVS     R2,#+60
   \   00000038   0x54A1             STRB     R1,[R4, R2]
     56              _finished = false;
   \   0000003A   0x21C0             MOVS     R1,#+192
   \   0000003C   0x5460             STRB     R0,[R4, R1]
     57              memset(&_obj_mem, 0, sizeof(_obj_mem));
   \   0000003E   0x2148             MOVS     R1,#+72
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x3078             ADDS     R0,R0,#+120
   \   00000044   0x.... 0x....      BL       __aeabi_memclr4
     58              memset(&_attr, 0, sizeof(_attr));
   \   00000048   0x2124             MOVS     R1,#+36
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x3018             ADDS     R0,R0,#+24
   \   0000004E   0x.... 0x....      BL       __aeabi_memclr4
     59              _attr.priority = priority;
   \   00000052   0x61FD             STR      R5,[R7, #+28]
     60              _attr.stack_size = aligned_size;
   \   00000054   0x9800             LDR      R0,[SP, #+0]
   \   00000056   0x61B8             STR      R0,[R7, #+24]
   \   00000058   0x9806             LDR      R0,[SP, #+24]
     61              _attr.name = name ? name : "application_unnamed_thread";
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD101             BNE      ??constructor_4
   \   0000005E   0xBF00             Nop      
   \   00000060   0x....             ADR.N    R0,?_3
   \                     ??constructor_4: (+1)
   \   00000062   0x6078             STR      R0,[R7, #+4]
     62              _attr.stack_mem = reinterpret_cast<uint32_t*>(aligned_mem);
   \   00000064   0x617E             STR      R6,[R7, #+20]
     63          }
   \   00000066   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
     64          

   \                                 In section .text, align 4, keep-with-next
     65          void Thread::constructor(Callback<void()> task,
     66                  osPriority priority, uint32_t stack_size, unsigned char *stack_mem, const char *name) {
   \                     _ZN4rtos6Thread11constructorEN4mbed8CallbackIFvvEEE12osPriority_tjPhPKc: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0011             MOVS     R1,R2
   \   0000000A   0x001A             MOVS     R2,R3
     67              constructor(priority, stack_size, stack_mem, name);
   \   0000000C   0x9809             LDR      R0,[SP, #+36]
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x9B08             LDR      R3,[SP, #+32]
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       _ZN4rtos6Thread11constructorE12osPriority_tjPhPKc
     68          
     69              switch (start(task)) {
   \   00000018   0x68E2             LDR      R2,[R4, #+12]
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD003             BEQ      ??constructor_5
   \   0000001E   0x0021             MOVS     R1,R4
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x6852             LDR      R2,[R2, #+4]
   \   00000024   0x4790             BLX      R2
   \                     ??constructor_5: (+1)
   \   00000026   0x68E0             LDR      R0,[R4, #+12]
   \   00000028   0x9003             STR      R0,[SP, #+12]
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x.... 0x....      BL       _ZN4rtos6Thread5startEN4mbed8CallbackIFvvEEE
   \   00000032   0x0004             MOVS     R4,R0
   \   00000034   0x9903             LDR      R1,[SP, #+12]
   \   00000036   0x2900             CMP      R1,#+0
   \   00000038   0xD002             BEQ      ??constructor_6
   \   0000003A   0x4668             MOV      R0,SP
   \   0000003C   0x6889             LDR      R1,[R1, #+8]
   \   0000003E   0x4788             BLX      R1
   \                     ??constructor_6: (+1)
   \   00000040   0x2004             MOVS     R0,#+4
   \   00000042   0x43C0             MVNS     R0,R0            ;; #-5
   \   00000044   0x1A24             SUBS     R4,R4,R0
   \   00000046   0xD007             BEQ      ??constructor_7
   \   00000048   0x1E64             SUBS     R4,R4,#+1
   \   0000004A   0xD003             BEQ      ??constructor_8
   \   0000004C   0x1E64             SUBS     R4,R4,#+1
   \   0000004E   0xD106             BNE      ??constructor_9
     70                  case osErrorResource:
     71                      error("OS ran out of threads!\n");
   \   00000050   0x....             ADR.N    R0,?_4
   \   00000052   0xE002             B        ??constructor_10
     72                      break;
     73                  case osErrorParameter:
     74                      error("Thread already running!\n");
   \                     ??constructor_8: (+1)
   \   00000054   0x....             ADR.N    R0,?_5
   \   00000056   0xE000             B        ??constructor_10
     75                      break;
     76                  case osErrorNoMemory:
     77                      error("Error allocating the stack memory\n");
   \                     ??constructor_7: (+1)
   \   00000058   0x....             ADR.N    R0,?_6
   \                     ??constructor_10: (+1)
   \   0000005A   0x.... 0x....      BL       error
     78                  default:
     79                      break;
     80              }
     81          }
   \                     ??constructor_9: (+1)
   \   0000005E   0xB005             ADD      SP,SP,#+20
   \   00000060   0xBD30             POP      {R4,R5,PC}       ;; return
     82          

   \                                 In section .text, align 4, keep-with-next
     83          osStatus Thread::start(Callback<void()> task) {
   \                     _ZN4rtos6Thread5startEN4mbed8CallbackIFvvEEE: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
     84              _mutex.lock();
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000000A   0x3054             ADDS     R0,R0,#+84
   \   0000000C   0x.... 0x....      BL       _ZN4rtos5Mutex4lockEj
     85          
     86              if ((_tid != 0) || _finished) {
   \   00000010   0x0025             MOVS     R5,R4
   \   00000012   0x3510             ADDS     R5,R5,#+16
   \   00000014   0x6868             LDR      R0,[R5, #+4]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD103             BNE      ??start_0
   \   0000001A   0x20C0             MOVS     R0,#+192
   \   0000001C   0x5C20             LDRB     R0,[R4, R0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD005             BEQ      ??start_1
     87                  _mutex.unlock();
   \                     ??start_0: (+1)
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x3054             ADDS     R0,R0,#+84
   \   00000026   0x.... 0x....      BL       _ZN4rtos5Mutex6unlockEv
     88                  return osErrorParameter;
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xE053             B.N      ??start_2
     89              }
     90          
     91              if (_attr.stack_mem == NULL) {
   \                     ??start_1: (+1)
   \   0000002E   0x69A8             LDR      R0,[R5, #+24]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD10E             BNE      ??start_3
     92                  _attr.stack_mem = new uint32_t[_attr.stack_size/sizeof(uint32_t)];
   \   00000034   0x69E8             LDR      R0,[R5, #+28]
   \   00000036   0x2103             MOVS     R1,#+3
   \   00000038   0x4388             BICS     R0,R0,R1
   \   0000003A   0x.... 0x....      BL       _Znaj
   \   0000003E   0x61A8             STR      R0,[R5, #+24]
     93                  MBED_ASSERT(_attr.stack_mem != NULL);
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD106             BNE      ??start_3
   \   00000044   0x225D             MOVS     R2,#+93
   \   00000046   0xBF00             Nop      
   \   00000048   0x....             ADR.N    R1,?_1
   \   0000004A   0xBF00             Nop      
   \   0000004C   0x....             ADR.N    R0,?_0
   \   0000004E   0x.... 0x....      BL       mbed_assert_internal
     94              }
     95          
     96              //Fill the stack with a magic word for maximum usage checking
     97              for (uint32_t i = 0; i < (_attr.stack_size / sizeof(uint32_t)); i++) {
   \                     ??start_3: (+1)
   \   00000052   0x2700             MOVS     R7,#+0
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x69AA             LDR      R2,[R5, #+24]
   \   00000058   0x....             LDR      R0,??DataTable10  ;; 0xe25a2ea5
   \   0000005A   0xE002             B        ??start_4
     98                  ((uint32_t *)_attr.stack_mem)[i] = 0xE25A2EA5;
   \                     ??start_5: (+1)
   \   0000005C   0x6010             STR      R0,[R2, #+0]
     99              }
   \   0000005E   0x1C49             ADDS     R1,R1,#+1
   \   00000060   0x1D12             ADDS     R2,R2,#+4
   \                     ??start_4: (+1)
   \   00000062   0x69EB             LDR      R3,[R5, #+28]
   \   00000064   0x089B             LSRS     R3,R3,#+2
   \   00000066   0x4299             CMP      R1,R3
   \   00000068   0xD3F8             BCC      ??start_5
    100          
    101              memset(&_obj_mem, 0, sizeof(_obj_mem));
   \   0000006A   0x2148             MOVS     R1,#+72
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x3078             ADDS     R0,R0,#+120
   \   00000070   0x.... 0x....      BL       __aeabi_memclr4
    102              _attr.cb_size = sizeof(_obj_mem);
   \   00000074   0x2048             MOVS     R0,#+72
   \   00000076   0x6168             STR      R0,[R5, #+20]
    103              _attr.cb_mem = &_obj_mem;
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x3078             ADDS     R0,R0,#+120
   \   0000007C   0x6128             STR      R0,[R5, #+16]
    104              _task = task;
   \   0000007E   0x1D20             ADDS     R0,R4,#+4
   \   00000080   0x42B0             CMP      R0,R6
   \   00000082   0xD00E             BEQ      ??start_6
   \   00000084   0x6829             LDR      R1,[R5, #+0]
   \   00000086   0x2900             CMP      R1,#+0
   \   00000088   0xD001             BEQ      ??start_7
   \   0000008A   0x6889             LDR      R1,[R1, #+8]
   \   0000008C   0x4788             BLX      R1
   \                     ??start_7: (+1)
   \   0000008E   0x1D20             ADDS     R0,R4,#+4
   \   00000090   0xD007             BEQ      ??start_6
   \   00000092   0x68F2             LDR      R2,[R6, #+12]
   \   00000094   0x2A00             CMP      R2,#+0
   \   00000096   0xD002             BEQ      ??start_8
   \   00000098   0x0031             MOVS     R1,R6
   \   0000009A   0x6852             LDR      R2,[R2, #+4]
   \   0000009C   0x4790             BLX      R2
   \                     ??start_8: (+1)
   \   0000009E   0x68F0             LDR      R0,[R6, #+12]
   \   000000A0   0x6028             STR      R0,[R5, #+0]
    105              _tid = osThreadNew(Thread::_thunk, this, &_attr);
   \                     ??start_6: (+1)
   \   000000A2   0x0022             MOVS     R2,R4
   \   000000A4   0x3218             ADDS     R2,R2,#+24
   \   000000A6   0x0021             MOVS     R1,R4
   \   000000A8   0x....             LDR      R0,??DataTable12
   \   000000AA   0x.... 0x....      BL       osThreadNew
   \   000000AE   0x6068             STR      R0,[R5, #+4]
    106              if (_tid == NULL) {
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD112             BNE      ??start_9
    107                  if (_dynamic_stack) {
   \   000000B4   0x203C             MOVS     R0,#+60
   \   000000B6   0x5C20             LDRB     R0,[R4, R0]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD003             BEQ      ??start_10
    108                      delete[] (uint32_t *)(_attr.stack_mem);
   \   000000BC   0x69A8             LDR      R0,[R5, #+24]
   \   000000BE   0x.... 0x....      BL       _ZdaPv
    109                      _attr.stack_mem = (uint32_t*)NULL;
   \   000000C2   0x61AF             STR      R7,[R5, #+24]
    110                  }
    111                  _mutex.unlock();
   \                     ??start_10: (+1)
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0x3054             ADDS     R0,R0,#+84
   \   000000C8   0x.... 0x....      BL       _ZN4rtos5Mutex6unlockEv
    112                  _join_sem.release();
   \   000000CC   0x0020             MOVS     R0,R4
   \   000000CE   0x3040             ADDS     R0,R0,#+64
   \   000000D0   0x.... 0x....      BL       _ZN4rtos9Semaphore7releaseEv
    113                  return osErrorResource;
   \   000000D4   0x2002             MOVS     R0,#+2
   \                     ??start_2: (+1)
   \   000000D6   0x43C0             MVNS     R0,R0            ;; #-3
   \   000000D8   0xBDF2             POP      {R1,R4-R7,PC}
    114              }
    115          
    116              _mutex.unlock();
   \                     ??start_9: (+1)
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0x3054             ADDS     R0,R0,#+84
   \   000000DE   0x.... 0x....      BL       _ZN4rtos5Mutex6unlockEv
    117              return osOK;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    118          }
    119          

   \                                 In section .text, align 2, keep-with-next
    120          osStatus Thread::terminate() {
   \                     _ZN4rtos6Thread9terminateEv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    121              osStatus_t ret = osOK;
   \   00000004   0x2500             MOVS     R5,#+0
    122              _mutex.lock();
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000000A   0x3054             ADDS     R0,R0,#+84
   \   0000000C   0x.... 0x....      BL       _ZN4rtos5Mutex4lockEj
    123          
    124              // Set the Thread's tid to NULL and
    125              // release the semaphore before terminating
    126              // since this thread could be terminating itself
    127              osThreadId_t local_id = _tid;
   \   00000010   0x6966             LDR      R6,[R4, #+20]
    128              _join_sem.release();
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x3040             ADDS     R0,R0,#+64
   \   00000016   0x.... 0x....      BL       _ZN4rtos9Semaphore7releaseEv
    129              _tid = (osThreadId_t)NULL;
   \   0000001A   0x6165             STR      R5,[R4, #+20]
    130              if (!_finished) {
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x30C0             ADDS     R0,R0,#+192
   \   00000020   0x7801             LDRB     R1,[R0, #+0]
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD105             BNE      ??terminate_0
    131                  _finished = true;
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x7001             STRB     R1,[R0, #+0]
    132                  ret = osThreadTerminate(local_id);
   \   0000002A   0x0030             MOVS     R0,R6
   \   0000002C   0x.... 0x....      BL       osThreadTerminate
   \   00000030   0x0005             MOVS     R5,R0
    133              }
    134              _mutex.unlock();
   \                     ??terminate_0: (+1)
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x3054             ADDS     R0,R0,#+84
   \   00000036   0x.... 0x....      BL       _ZN4rtos5Mutex6unlockEv
    135              return ret;
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    136          }
    137          

   \                                 In section .text, align 4, keep-with-next
    138          osStatus Thread::join() {
   \                     _ZN4rtos6Thread4joinEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    139              int32_t ret = _join_sem.wait();
    140              if (ret < 0) {
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x43ED             MVNS     R5,R5            ;; #-1
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x3040             ADDS     R0,R0,#+64
   \   0000000C   0x.... 0x....      BL       _ZN4rtos9Semaphore4waitEj
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD501             BPL      ??join_0
    141                  return osError;
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}
    142              }
    143          
    144              // The semaphore has been released so this thread is being
    145              // terminated or has been terminated. Once the mutex has
    146              // been locked it is ensured that the thread is deleted.
    147              _mutex.lock();
   \                     ??join_0: (+1)
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x3054             ADDS     R0,R0,#+84
   \   0000001E   0x.... 0x....      BL       _ZN4rtos5Mutex4lockEj
    148              MBED_ASSERT(NULL == _tid);
   \   00000022   0x6960             LDR      R0,[R4, #+20]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD006             BEQ      ??join_1
   \   00000028   0x2294             MOVS     R2,#+148
   \   0000002A   0xBF00             Nop      
   \   0000002C   0x....             ADR.N    R1,?_1
   \   0000002E   0xBF00             Nop      
   \   00000030   0x....             ADR.N    R0,?_2
   \   00000032   0x.... 0x....      BL       mbed_assert_internal
    149              _mutex.unlock();
   \                     ??join_1: (+1)
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x3054             ADDS     R0,R0,#+84
   \   0000003A   0x.... 0x....      BL       _ZN4rtos5Mutex6unlockEv
    150          
    151              // Release sem so any other threads joining this thread wake up
    152              _join_sem.release();
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x3040             ADDS     R0,R0,#+64
   \   00000042   0x.... 0x....      BL       _ZN4rtos9Semaphore7releaseEv
    153              return osOK;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    154          }
    155          

   \                                 In section .text, align 2, keep-with-next
    156          osStatus Thread::set_priority(osPriority priority) {
   \                     _ZN4rtos6Thread12set_priorityE12osPriority_t: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    157              osStatus_t ret;
    158              _mutex.lock();
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000000A   0x3054             ADDS     R0,R0,#+84
   \   0000000C   0x.... 0x....      BL       _ZN4rtos5Mutex4lockEj
    159          
    160              ret = osThreadSetPriority(_tid, priority);
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x6960             LDR      R0,[R4, #+20]
   \   00000014   0x.... 0x....      BL       osThreadSetPriority
   \   00000018   0x....             B.N      ?Subroutine0
    161          
    162              _mutex.unlock();
    163              return ret;
    164          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x0005             MOVS     R5,R0
   \                     ??Subroutine0_0: (+1)
   \   00000002   0x0020             MOVS     R0,R4
   \   00000004   0x3054             ADDS     R0,R0,#+84
   \   00000006   0x.... 0x....      BL       _ZN4rtos5Mutex6unlockEv
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    165          

   \                                 In section .text, align 2, keep-with-next
    166          osPriority Thread::get_priority() {
   \                     _ZN4rtos6Thread12get_priorityEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    167              osPriority_t ret;
    168              _mutex.lock();
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000008   0x3054             ADDS     R0,R0,#+84
   \   0000000A   0x.... 0x....      BL       _ZN4rtos5Mutex4lockEj
    169          
    170              ret = osThreadGetPriority(_tid);
   \   0000000E   0x6960             LDR      R0,[R4, #+20]
   \   00000010   0x.... 0x....      BL       osThreadGetPriority
   \   00000014                      REQUIRE ?Subroutine0
   \   00000014                      ;; // Fall through to label ?Subroutine0
    171          
    172              _mutex.unlock();
    173              return ret;
    174          }
    175          

   \                                 In section .text, align 2, keep-with-next
    176          int32_t Thread::signal_set(int32_t flags) {
   \                     _ZN4rtos6Thread10signal_setEi: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    177              return osThreadFlagsSet(_tid, flags);
   \   00000002   0x6940             LDR      R0,[R0, #+20]
   \   00000004   0x.... 0x....      BL       osThreadFlagsSet
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    178          }
    179          

   \                                 In section .text, align 2, keep-with-next
    180          Thread::State Thread::get_state() {
   \                     _ZN4rtos6Thread9get_stateEv: (+1)
   \   00000000   0xB558             PUSH     {R3,R4,R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    181              uint8_t state = osThreadTerminated;
   \   00000004   0x2604             MOVS     R6,#+4
    182          
    183              _mutex.lock();
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000000A   0x3054             ADDS     R0,R0,#+84
   \   0000000C   0x.... 0x....      BL       _ZN4rtos5Mutex4lockEj
    184          
    185              if (_tid != NULL) {
   \   00000010   0x6960             LDR      R0,[R4, #+20]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ      ??get_state_0
    186          #if defined(MBED_OS_BACKEND_RTX5)
    187                  state = _obj_mem.state;
   \   00000016   0x2079             MOVS     R0,#+121
   \   00000018   0x5C26             LDRB     R6,[R4, R0]
    188          #else
    189                  state = osThreadGetState(_tid);
    190          #endif
    191              }
    192          
    193              _mutex.unlock();
   \                     ??get_state_0: (+1)
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x3054             ADDS     R0,R0,#+84
   \   0000001E   0x.... 0x....      BL       _ZN4rtos5Mutex6unlockEv
    194          
    195              State user_state;
    196          
    197              switch(state) {
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD016             BEQ      ??get_state_1
   \   00000026   0x2E01             CMP      R6,#+1
   \   00000028   0xD016             BEQ      ??get_state_2
   \   0000002A   0x2E02             CMP      R6,#+2
   \   0000002C   0xD016             BEQ      ??get_state_3
   \   0000002E   0x2E13             CMP      R6,#+19
   \   00000030   0xD016             BEQ      ??get_state_4
   \   00000032   0x2E23             CMP      R6,#+35
   \   00000034   0xD016             BEQ      ??get_state_5
   \   00000036   0x2E33             CMP      R6,#+51
   \   00000038   0xD016             BEQ      ??get_state_6
   \   0000003A   0x2E43             CMP      R6,#+67
   \   0000003C   0xD016             BEQ      ??get_state_7
   \   0000003E   0x2E53             CMP      R6,#+83
   \   00000040   0xD016             BEQ      ??get_state_8
   \   00000042   0x2E63             CMP      R6,#+99
   \   00000044   0xD016             BEQ      ??get_state_9
   \   00000046   0x2E73             CMP      R6,#+115
   \   00000048   0xD016             BEQ      ??get_state_10
   \   0000004A   0x2E83             CMP      R6,#+131
   \   0000004C   0xD016             BEQ      ??get_state_11
   \   0000004E   0x2E93             CMP      R6,#+147
   \   00000050   0xD016             BEQ      ??get_state_12
   \   00000052   0xE017             B        ??get_state_13
    198                  case osThreadInactive:
    199                      user_state = Inactive;
   \                     ??get_state_1: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
    200                      break;
   \   00000056   0xBD52             POP      {R1,R4,R6,PC}
    201                  case osThreadReady:
    202                      user_state = Ready;
   \                     ??get_state_2: (+1)
   \   00000058   0x2001             MOVS     R0,#+1
    203                      break;
   \   0000005A   0xBD52             POP      {R1,R4,R6,PC}
    204                  case osThreadRunning:
    205                      user_state = Running;
   \                     ??get_state_3: (+1)
   \   0000005C   0x2002             MOVS     R0,#+2
    206                      break;
   \   0000005E   0xBD52             POP      {R1,R4,R6,PC}
    207          #if defined(MBED_OS_BACKEND_RTX5)
    208                  case osRtxThreadWaitingDelay:
    209                      user_state = WaitingDelay;
   \                     ??get_state_4: (+1)
   \   00000060   0x2003             MOVS     R0,#+3
    210                      break;
   \   00000062   0xBD52             POP      {R1,R4,R6,PC}
    211                  case osRtxThreadWaitingJoin:
    212                      user_state = WaitingJoin;
   \                     ??get_state_5: (+1)
   \   00000064   0x2004             MOVS     R0,#+4
    213                      break;
   \   00000066   0xBD52             POP      {R1,R4,R6,PC}
    214                  case osRtxThreadWaitingThreadFlags:
    215                      user_state = WaitingThreadFlag;
   \                     ??get_state_6: (+1)
   \   00000068   0x2005             MOVS     R0,#+5
    216                      break;
   \   0000006A   0xBD52             POP      {R1,R4,R6,PC}
    217                  case osRtxThreadWaitingEventFlags:
    218                      user_state = WaitingEventFlag;
   \                     ??get_state_7: (+1)
   \   0000006C   0x2006             MOVS     R0,#+6
    219                      break;
   \   0000006E   0xBD52             POP      {R1,R4,R6,PC}
    220                  case osRtxThreadWaitingMutex:
    221                      user_state = WaitingMutex;
   \                     ??get_state_8: (+1)
   \   00000070   0x2007             MOVS     R0,#+7
    222                      break;
   \   00000072   0xBD52             POP      {R1,R4,R6,PC}
    223                  case osRtxThreadWaitingSemaphore:
    224                      user_state = WaitingSemaphore;
   \                     ??get_state_9: (+1)
   \   00000074   0x2008             MOVS     R0,#+8
    225                      break;
   \   00000076   0xBD52             POP      {R1,R4,R6,PC}
    226                  case osRtxThreadWaitingMemoryPool:
    227                      user_state = WaitingMemoryPool;
   \                     ??get_state_10: (+1)
   \   00000078   0x2009             MOVS     R0,#+9
    228                      break;
   \   0000007A   0xBD52             POP      {R1,R4,R6,PC}
    229                  case osRtxThreadWaitingMessageGet:
    230                      user_state = WaitingMessageGet;
   \                     ??get_state_11: (+1)
   \   0000007C   0x200A             MOVS     R0,#+10
    231                      break;
   \   0000007E   0xBD52             POP      {R1,R4,R6,PC}
    232                  case osRtxThreadWaitingMessagePut:
    233                      user_state = WaitingMessagePut;
   \                     ??get_state_12: (+1)
   \   00000080   0x200B             MOVS     R0,#+11
    234                      break;
   \   00000082   0xBD52             POP      {R1,R4,R6,PC}
    235          #endif
    236                  case osThreadTerminated:
    237                  default:
    238                      user_state = Deleted;
   \                     ??get_state_13: (+1)
   \   00000084   0x2010             MOVS     R0,#+16
    239                      break;
    240              }
    241          
    242              return user_state;
   \   00000086   0xBD52             POP      {R1,R4,R6,PC}    ;; return
    243          }
    244          

   \                                 In section .text, align 2, keep-with-next
    245          uint32_t Thread::stack_size() {
   \                     _ZN4rtos6Thread10stack_sizeEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    246              uint32_t size = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    247              _mutex.lock();
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000000A   0x3054             ADDS     R0,R0,#+84
   \   0000000C   0x.... 0x....      BL       _ZN4rtos5Mutex4lockEj
    248          
    249              if (_tid != NULL) {
   \   00000010   0x6960             LDR      R0,[R4, #+20]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ      ??stack_size_0
    250                  size = osThreadGetStackSize(_tid);
   \   00000016   0x.... 0x....      BL       osThreadGetStackSize
   \   0000001A   0x0005             MOVS     R5,R0
    251              }
    252          
    253              _mutex.unlock();
   \                     ??stack_size_0: (+1)
   \   0000001C   0x....             B.N      ??Subroutine0_0
    254              return size;
    255          }
    256          

   \                                 In section .text, align 2, keep-with-next
    257          uint32_t Thread::free_stack() {
   \                     _ZN4rtos6Thread10free_stackEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    258              uint32_t size = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    259              _mutex.lock();
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000000A   0x3054             ADDS     R0,R0,#+84
   \   0000000C   0x.... 0x....      BL       _ZN4rtos5Mutex4lockEj
    260          
    261          #if defined(MBED_OS_BACKEND_RTX5)
    262              if (_tid != NULL) {
   \   00000010   0x6960             LDR      R0,[R4, #+20]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ      ??free_stack_0
    263                  os_thread_t *thread = (os_thread_t *)_tid;
    264                  size = (uint32_t)thread->sp - (uint32_t)thread->stack_mem;
   \   00000016   0x6B81             LDR      R1,[R0, #+56]
   \   00000018   0x6B00             LDR      R0,[R0, #+48]
   \   0000001A   0x1A0D             SUBS     R5,R1,R0
    265              }
    266          #endif
    267          
    268              _mutex.unlock();
   \                     ??free_stack_0: (+1)
   \   0000001C   0x....             B.N      ??Subroutine0_0
    269              return size;
    270          }
    271          

   \                                 In section .text, align 2, keep-with-next
    272          uint32_t Thread::used_stack() {
   \                     _ZN4rtos6Thread10used_stackEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    273              uint32_t size = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    274              _mutex.lock();
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000000A   0x3054             ADDS     R0,R0,#+84
   \   0000000C   0x.... 0x....      BL       _ZN4rtos5Mutex4lockEj
    275          
    276          #if defined(MBED_OS_BACKEND_RTX5)
    277              if (_tid != NULL) {
   \   00000010   0x6960             LDR      R0,[R4, #+20]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ      ??used_stack_0
    278                  os_thread_t *thread = (os_thread_t *)_tid;
    279                  size = ((uint32_t)thread->stack_mem + thread->stack_size) - thread->sp;
   \   00000016   0x6B01             LDR      R1,[R0, #+48]
   \   00000018   0x6B42             LDR      R2,[R0, #+52]
   \   0000001A   0x1889             ADDS     R1,R1,R2
   \   0000001C   0x6B80             LDR      R0,[R0, #+56]
   \   0000001E   0x1A0D             SUBS     R5,R1,R0
    280              }
    281          #endif
    282          
    283              _mutex.unlock();
   \                     ??used_stack_0: (+1)
   \   00000020   0x....             B.N      ??Subroutine0_0
    284              return size;
    285          }
    286          

   \                                 In section .text, align 2, keep-with-next
    287          uint32_t Thread::max_stack() {
   \                     _ZN4rtos6Thread9max_stackEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    288              uint32_t size = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    289              _mutex.lock();
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000000A   0x3054             ADDS     R0,R0,#+84
   \   0000000C   0x.... 0x....      BL       _ZN4rtos5Mutex4lockEj
    290          
    291              if (_tid != NULL) {
   \   00000010   0x6961             LDR      R1,[R4, #+20]
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD00B             BEQ      ??max_stack_0
    292          #if defined(MBED_OS_BACKEND_RTX5)
    293                  os_thread_t *thread = (os_thread_t *)_tid;
    294                  uint32_t high_mark = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x....             LDR      R2,??DataTable10  ;; 0xe25a2ea5
   \   0000001A   0xE001             B        ??max_stack_1
    295                  while (((uint32_t *)(thread->stack_mem))[high_mark] == 0xE25A2EA5)
    296                      high_mark++;
   \                     ??max_stack_2: (+1)
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x1D2D             ADDS     R5,R5,#+4
   \                     ??max_stack_1: (+1)
   \   00000020   0x6B0B             LDR      R3,[R1, #+48]
   \   00000022   0x595B             LDR      R3,[R3, R5]
   \   00000024   0x4293             CMP      R3,R2
   \   00000026   0xD0F9             BEQ      ??max_stack_2
    297                  size = thread->stack_size - (high_mark * sizeof(uint32_t));
   \   00000028   0x6B49             LDR      R1,[R1, #+52]
   \   0000002A   0x0080             LSLS     R0,R0,#+2
   \   0000002C   0x1A0D             SUBS     R5,R1,R0
    298          #else
    299                  size = osThreadGetStackSize(_tid) - osThreadGetStackSpace(_tid);
    300          #endif
    301              }
    302          
    303              _mutex.unlock();
   \                     ??max_stack_0: (+1)
   \   0000002E   0x....             B.N      ??Subroutine0_0
    304              return size;
    305          }
    306          

   \                                 In section .text, align 2, keep-with-next
    307          const char *Thread::get_name() {
    308              return _attr.name;
   \                     _ZN4rtos6Thread8get_nameEv: (+1)
   \   00000000   0x6980             LDR      R0,[R0, #+24]
   \   00000002   0x4770             BX       LR               ;; return
    309          }
    310          

   \                                 In section .text, align 2, keep-with-next
    311          int32_t Thread::signal_clr(int32_t flags) {
   \                     _ZN4rtos6Thread10signal_clrEi: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    312              return osThreadFlagsClear(flags);
   \   00000002   0x.... 0x....      BL       osThreadFlagsClear
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    313          }
    314          

   \                                 In section .text, align 2, keep-with-next
    315          osEvent Thread::signal_wait(int32_t signals, uint32_t millisec) {
   \                     _ZN4rtos6Thread11signal_waitEij: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0008             MOVS     R0,R1
    316              uint32_t res;
    317              osEvent evt;
    318              uint32_t options = osFlagsWaitAll;
   \   00000008   0x2101             MOVS     R1,#+1
    319              if (signals == 0) {
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE      ??signal_wait_0
    320                  options = osFlagsWaitAny;
   \   0000000E   0x2100             MOVS     R1,#+0
    321                  signals = 0x7FFFFFFF;
   \   00000010   0x....             LDR      R0,??DataTable13  ;; 0x7fffffff
    322              }
    323              res = osThreadFlagsWait(signals, options, millisec);
   \                     ??signal_wait_0: (+1)
   \   00000012   0x.... 0x....      BL       osThreadFlagsWait
    324              if (res & osFlagsError) {
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD510             BPL      ??signal_wait_1
    325                  switch (res) {
   \   0000001A   0x2105             MOVS     R1,#+5
   \   0000001C   0x43C9             MVNS     R1,R1            ;; #-6
   \   0000001E   0x1A40             SUBS     R0,R0,R1
   \   00000020   0xD004             BEQ      ??signal_wait_2
   \   00000022   0x1EC0             SUBS     R0,R0,#+3
   \   00000024   0xD008             BEQ      ??signal_wait_3
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0xD002             BEQ      ??signal_wait_4
   \   0000002A   0xE003             B        ??signal_wait_5
    326                      case osFlagsErrorISR:
    327                          evt.status = osErrorISR;
   \                     ??signal_wait_2: (+1)
   \   0000002C   0x9100             STR      R1,[SP, #+0]
    328                          break;
   \   0000002E   0xE008             B        ??signal_wait_6
    329                      case osFlagsErrorResource:
    330                          evt.status = osOK;
    331                          break;
    332                      case osFlagsErrorTimeout:
    333                          evt.status = (osStatus)osEventTimeout;
   \                     ??signal_wait_4: (+1)
   \   00000030   0x2040             MOVS     R0,#+64
   \   00000032   0xE001             B.N      ??signal_wait_3
    334                          break;
    335                      case osFlagsErrorParameter:
    336                      default:
    337                          evt.status = (osStatus)osErrorValue;
   \                     ??signal_wait_5: (+1)
   \   00000034   0x207E             MOVS     R0,#+126
   \   00000036   0x43C0             MVNS     R0,R0            ;; #-127
   \                     ??signal_wait_3: (+1)
   \   00000038   0x9000             STR      R0,[SP, #+0]
    338                          break;
   \   0000003A   0xE002             B        ??signal_wait_6
    339                  }
    340              } else {
    341                  evt.status = (osStatus)osEventSignal;
   \                     ??signal_wait_1: (+1)
   \   0000003C   0x2108             MOVS     R1,#+8
   \   0000003E   0x9100             STR      R1,[SP, #+0]
    342                  evt.value.signals = res;
   \   00000040   0x9001             STR      R0,[SP, #+4]
    343              }
    344          
    345              return evt;
   \                     ??signal_wait_6: (+1)
   \   00000042   0x4668             MOV      R0,SP
   \   00000044   0xC80E             LDM      R0!,{R1-R3}
   \   00000046   0xC40E             STM      R4!,{R1-R3}
   \   00000048   0xB004             ADD      SP,SP,#+16
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
    346          }
    347          

   \                                 In section .text, align 2, keep-with-next
    348          osStatus Thread::wait(uint32_t millisec) {
   \                     _ZN4rtos6Thread4waitEj: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    349              return osDelay(millisec);
   \   00000002   0x.... 0x....      BL       osDelay
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    350          }
    351          

   \                                 In section .text, align 2, keep-with-next
    352          osStatus Thread::yield() {
   \                     _ZN4rtos6Thread5yieldEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    353              return osThreadYield();
   \   00000002   0x.... 0x....      BL       osThreadYield
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    354          }
    355          

   \                                 In section .text, align 2, keep-with-next
    356          osThreadId Thread::gettid() {
   \                     _ZN4rtos6Thread6gettidEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    357              return osThreadGetId();
   \   00000002   0x.... 0x....      BL       osThreadGetId
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    358          }
    359          

   \                                 In section .text, align 2, keep-with-next
    360          void Thread::attach_idle_hook(void (*fptr)(void)) {
   \                     _ZN4rtos6Thread16attach_idle_hookEPFvvE: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    361              rtos_attach_idle_hook(fptr);
   \   00000002   0x.... 0x....      BL       rtos_attach_idle_hook
    362          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    363          

   \                                 In section .text, align 2, keep-with-next
    364          void Thread::attach_terminate_hook(void (*fptr)(osThreadId_t id)) {
    365              terminate_hook = fptr;
   \                     _ZN4rtos6Thread21attach_terminate_hookEPFvPvE: (+1)
   \   00000000   0x....             LDR      R1,??DataTable13_1
   \   00000002   0x6008             STR      R0,[R1, #+0]
    366          }
   \   00000004   0x4770             BX       LR               ;; return
    367          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp rtos::Thread::deleter ~Thread()
   \                     _ZN4rtos6ThreadD0Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x.... 0x....      BL       _ZN4rtos6ThreadD1Ev
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       _ZdlPv
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp rtos::Thread::subobject ~Thread()
   \                     _ZN4rtos6ThreadD2Ev: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN4rtos6ThreadD1Ev
   \   00000006   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    368          Thread::~Thread() {
   \                     _ZN4rtos6ThreadD1Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x....             LDR      R0,??DataTable13_2
   \   00000006   0x6020             STR      R0,[R4, #+0]
    369              // terminate is thread safe
    370              terminate();
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       _ZN4rtos6Thread9terminateEv
    371              if (_dynamic_stack) {
   \   0000000E   0x203C             MOVS     R0,#+60
   \   00000010   0x5C20             LDRB     R0,[R4, R0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ      `?~Thread_0`
    372                  delete[] (uint32_t*)(_attr.stack_mem);
   \   00000016   0x6AA0             LDR      R0,[R4, #+40]
   \   00000018   0x.... 0x....      BL       _ZdaPv
    373                  _attr.stack_mem = (uint32_t*)NULL;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x62A0             STR      R0,[R4, #+40]
    374              }
    375          }
   \                     `?~Thread_0`: (+1)
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x3054             ADDS     R0,R0,#+84
   \   00000024   0x.... 0x....      BL       _ZN4rtos5MutexD1Ev
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x3040             ADDS     R0,R0,#+64
   \   0000002C   0x.... 0x....      BL       _ZN4rtos9SemaphoreD1Ev
   \   00000030   0x6921             LDR      R1,[R4, #+16]
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD002             BEQ      `?~Thread_1`
   \   00000036   0x1D20             ADDS     R0,R4,#+4
   \   00000038   0x6889             LDR      R1,[R1, #+8]
   \   0000003A   0x4788             BLX      R1
   \                     `?~Thread_1`: (+1)
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    376          

   \                                 In section .text, align 2, keep-with-next
    377          void Thread::_thunk(void * thread_ptr)
    378          {
   \                     _ZN4rtos6Thread6_thunkEPv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    379              Thread *t = (Thread*)thread_ptr;
    380              t->_task();
   \   00000004   0x0025             MOVS     R5,R4
   \   00000006   0x3510             ADDS     R5,R5,#+16
   \   00000008   0x6828             LDR      R0,[R5, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD105             BNE      ??_thunk_0
   \   0000000E   0x2284             MOVS     R2,#+132
   \   00000010   0x0092             LSLS     R2,R2,#+2        ;; #+528
   \   00000012   0x....             LDR      R1,??DataTable13_3
   \   00000014   0x....             LDR      R0,??DataTable13_4
   \   00000016   0x.... 0x....      BL       mbed_assert_internal
   \                     ??_thunk_0: (+1)
   \   0000001A   0x1D20             ADDS     R0,R4,#+4
   \   0000001C   0x6829             LDR      R1,[R5, #+0]
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x4788             BLX      R1
    381              t->_mutex.lock();
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x3054             ADDS     R0,R0,#+84
   \   0000002A   0x.... 0x....      BL       _ZN4rtos5Mutex4lockEj
    382              t->_tid = (osThreadId)NULL;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x6068             STR      R0,[R5, #+4]
    383              t->_finished = true;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x21C0             MOVS     R1,#+192
   \   00000036   0x5460             STRB     R0,[R4, R1]
    384              t->_join_sem.release();
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x3040             ADDS     R0,R0,#+64
   \   0000003C   0x.... 0x....      BL       _ZN4rtos9Semaphore7releaseEv
    385              // rtos will release the mutex automatically
    386          }
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x61 0x70          DC8 "application_unnamed_thread"
   \              0x70 0x6C    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x5F    
   \              0x75 0x6E    
   \              0x6E 0x61    
   \              0x6D 0x65    
   \              0x64 0x5F    
   \              0x74 0x68    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x4F 0x53          DC8 "OS ran out of threads!\012"
   \              0x20 0x72    
   \              0x61 0x6E    
   \              0x20 0x6F    
   \              0x75 0x74    
   \              0x20 0x6F    
   \              0x66 0x20    
   \              0x74 0x68    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x73 0x21    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x54 0x68          DC8 "Thread already running!\012"
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x20 0x61    
   \              0x6C 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x20 0x72    
   \              0x75 0x6E    
   \              0x6E 0x69    
   \              0x6E 0x67    
   \              0x21 0x0A    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x45 0x72          DC8 "Error allocating the stack memory\012"
   \              0x72 0x6F    
   \              0x72 0x20    
   \              0x61 0x6C    
   \              0x6C 0x6F    
   \              0x63 0x61    
   \              0x74 0x69    
   \              0x6E 0x67    
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x63 0x6B    
   \              0x20 0x6D    
   \              0x65 0x6D    
   \              0x6F 0x72    
   \              0x79 0x0A    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     terminate_hook

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x5F 0x61          DC8 "_attr.stack_mem != NULL"
   \              0x74 0x74    
   \              0x72 0x2E    
   \              0x73 0x74    
   \              0x61 0x63    
   \              0x6B 0x5F    
   \              0x6D 0x65    
   \              0x6D 0x20    
   \              0x21 0x3D    
   \              0x20 0x4E    
   \              0x55 0x4C    
   \              0x4C 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x2E 0x5C          DC8 ".\\mbed-os\\rtos\\Thread.cpp"
   \              0x6D 0x62    
   \              0x65 0x64    
   \              0x2D 0x6F    
   \              0x73 0x5C    
   \              0x72 0x74    
   \              0x6F 0x73    
   \              0x5C 0x54    
   \              0x68 0x72    
   \              0x65 0x61    
   \              0x64 0x2E    
   \              0x63 0x70    
   \              0x70 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xE25A2EA5         DC32     0xe25a2ea5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     _ZN4rtos6Thread6_thunkEPv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x7FFFFFFF         DC32     0x7fffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     terminate_hook

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     _ZTVN4rtos6ThreadE+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     _ZZNK4mbed8CallbackIFvvEE4callEvEs_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     _ZZNK4mbed8CallbackIFvvEE4callEvEs

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x4E 0x55          DC8 "NULL == _tid"
   \              0x4C 0x4C    
   \              0x20 0x3D    
   \              0x3D 0x20    
   \              0x5F 0x74    
   \              0x69 0x64    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    387          
    388          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   mbed::Callback<void ()>::function_call<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void const *)
         8   -- Indirect call
       0   mbed::Callback<void ()>::function_dtor<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *)
       0   mbed::Callback<void ()>::function_move<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *, void const *)
      12   mbed::callback<>(void (*)(void *), void *)
      16   rtos::Thread::_thunk(void *)
        16   -- Indirect call
        16   -> mbed_assert_internal
        16   -> rtos::Mutex::lock(unsigned int)
        16   -> rtos::Semaphore::release()
       8   rtos::Thread::attach_idle_hook(void (*)())
         8   -> rtos_attach_idle_hook
       0   rtos::Thread::attach_terminate_hook(void (*)(void *))
      32   rtos::Thread::constructor(mbed::Callback<void ()>, osPriority_t, unsigned int, unsigned char *, char const *)
        32   -- Indirect call
        32   -> error
        32   -> rtos::Thread::constructor(osPriority_t, unsigned int, unsigned char *, char const *)
        32   -> rtos::Thread::start(mbed::Callback<void ()>)
      24   rtos::Thread::constructor(osPriority_t, unsigned int, unsigned char *, char const *)
        24   -> __aeabi_memclr4
       8   rtos::Thread::deleter ~Thread()
         8   -> operator delete(void *)
         8   -> rtos::Thread::~Thread()
      16   rtos::Thread::free_stack()
        16   -> rtos::Mutex::lock(unsigned int)
        16   -> rtos::Mutex::unlock()
       0   rtos::Thread::get_name()
      16   rtos::Thread::get_priority()
        16   -> osThreadGetPriority
        16   -> rtos::Mutex::lock(unsigned int)
        16   -> rtos::Mutex::unlock()
      16   rtos::Thread::get_state()
        16   -> rtos::Mutex::lock(unsigned int)
        16   -> rtos::Mutex::unlock()
       8   rtos::Thread::gettid()
         8   -> osThreadGetId
      16   rtos::Thread::join()
        16   -> mbed_assert_internal
        16   -> rtos::Mutex::lock(unsigned int)
        16   -> rtos::Mutex::unlock()
        16   -> rtos::Semaphore::release()
        16   -> rtos::Semaphore::wait(unsigned int)
      16   rtos::Thread::max_stack()
        16   -> rtos::Mutex::lock(unsigned int)
        16   -> rtos::Mutex::unlock()
      16   rtos::Thread::set_priority(osPriority_t)
        16   -> osThreadSetPriority
        16   -> rtos::Mutex::lock(unsigned int)
        16   -> rtos::Mutex::unlock()
       8   rtos::Thread::signal_clr(signed int)
         8   -> osThreadFlagsClear
       8   rtos::Thread::signal_set(signed int)
         8   -> osThreadFlagsSet
      24   rtos::Thread::signal_wait(signed int, unsigned int)
        24   -> osThreadFlagsWait
      16   rtos::Thread::stack_size()
        16   -> osThreadGetStackSize
        16   -> rtos::Mutex::lock(unsigned int)
        16   -> rtos::Mutex::unlock()
      24   rtos::Thread::start(mbed::Callback<void ()>)
        24   -- Indirect call
        24   -> __aeabi_memclr4
        24   -> mbed_assert_internal
        24   -> operator delete[](void *)
        24   -> operator new[](std::size_t)
        24   -> osThreadNew
        24   -> rtos::Mutex::lock(unsigned int)
        24   -> rtos::Mutex::unlock()
        24   -> rtos::Semaphore::release()
       8   rtos::Thread::subobject ~Thread()
         8   -> rtos::Thread::~Thread()
      16   rtos::Thread::terminate()
        16   -> osThreadTerminate
        16   -> rtos::Mutex::lock(unsigned int)
        16   -> rtos::Mutex::unlock()
        16   -> rtos::Semaphore::release()
      16   rtos::Thread::used_stack()
        16   -> rtos::Mutex::lock(unsigned int)
        16   -> rtos::Mutex::unlock()
       8   rtos::Thread::wait(unsigned int)
         8   -> osDelay
       8   rtos::Thread::yield()
         8   -> osThreadYield
       8   rtos::Thread::~Thread()
         8   -- Indirect call
         8   -> operator delete[](void *)
         8   -> rtos::Mutex::~Mutex()
         8   -> rtos::Semaphore::~Semaphore()
         8   -> rtos::Thread::terminate()
       8   thread_terminate_hook
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable8
      14  ?Subroutine0
      24  ?_0
      28  ?_1
      16  ?_2
      28  ?_3
      24  ?_4
      28  ?_5
      36  ?_6
      12  mbed::Callback<void ()>::function_call<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void const *)
       2  mbed::Callback<void ()>::function_dtor<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *)
      10  mbed::Callback<void ()>::function_move<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *, void const *)
      32  mbed::callback<>(void (*)(void *), void *)
      12  ops
      66  rtos::Thread::_thunk(void *)
       8  rtos::Thread::attach_idle_hook(void (*)())
       6  rtos::Thread::attach_terminate_hook(void (*)(void *))
      98  rtos::Thread::constructor(mbed::Callback<void ()>, osPriority_t, unsigned int, unsigned char *, char const *)
     104  rtos::Thread::constructor(osPriority_t, unsigned int, unsigned char *, char const *)
      16  rtos::Thread::deleter ~Thread()
      30  rtos::Thread::free_stack()
       4  rtos::Thread::get_name()
      20  rtos::Thread::get_priority()
     136  rtos::Thread::get_state()
       8  rtos::Thread::gettid()
      74  rtos::Thread::join()
      48  rtos::Thread::max_stack()
      26  rtos::Thread::set_priority(osPriority_t)
       8  rtos::Thread::signal_clr(signed int)
      10  rtos::Thread::signal_set(signed int)
      76  rtos::Thread::signal_wait(signed int, unsigned int)
      30  rtos::Thread::stack_size()
     230  rtos::Thread::start(mbed::Callback<void ()>)
       8  rtos::Thread::subobject ~Thread()
      62  rtos::Thread::terminate()
      34  rtos::Thread::used_stack()
       8  rtos::Thread::wait(unsigned int)
       8  rtos::Thread::yield()
      64  rtos::Thread::~Thread()
       4  terminate_hook
      16  thread_terminate_hook
     436  -- Other

 
     4 bytes in section .bss
   448 bytes in section .rodata
 1 484 bytes in section .text
 
 1 428 bytes of CODE  memory (+  56 bytes shared)
     0 bytes of CONST memory (+ 448 bytes shared)
     4 bytes of DATA  memory

Errors: none
Warnings: none

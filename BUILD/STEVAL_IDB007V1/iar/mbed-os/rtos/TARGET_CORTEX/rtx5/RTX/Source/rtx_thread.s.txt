###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:55
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_thread.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_thread.d
#        -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_thread.s.txt
#        -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_thread.o
#        .\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_thread.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_thread.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_thread.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_thread.c
      1          /*
      2           * Copyright (c) 2013-2017 ARM Limited. All rights reserved.
      3           *
      4           * SPDX-License-Identifier: Apache-2.0
      5           *
      6           * Licensed under the Apache License, Version 2.0 (the License); you may
      7           * not use this file except in compliance with the License.
      8           * You may obtain a copy of the License at
      9           *
     10           * www.apache.org/licenses/LICENSE-2.0
     11           *
     12           * Unless required by applicable law or agreed to in writing, software
     13           * distributed under the License is distributed on an AS IS BASIS, WITHOUT
     14           * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15           * See the License for the specific language governing permissions and
     16           * limitations under the License.
     17           *
     18           * -----------------------------------------------------------------------------
     19           *
     20           * Project:     CMSIS-RTOS RTX
     21           * Title:       Thread functions
     22           *
     23           * -----------------------------------------------------------------------------
     24           */
     25          
     26          #include "rtx_lib.h"

  typedef uint8_t BOOL;  //already defined in "hal_type.h"
                  ^
"C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\TARGET_STEVAL_IDB007V1\device\system_BlueNRG1.h",240  Warning[Pe301]: typedef name has already been declared (with same type)
     27          #include "rt_OsEventObserver.h"
     28          
     29          //  ==== Helper functions ====
     30          
     31          /// Set Thread Flags.
     32          /// \param[in]  thread          thread object.
     33          /// \param[in]  flags           specifies the flags to set.
     34          /// \return thread flags after setting.
     35          static uint32_t ThreadFlagsSet (os_thread_t *thread, uint32_t flags) {
     36          #if (__EXCLUSIVE_ACCESS == 0U)
     37            uint32_t primask = __get_PRIMASK();
     38          #endif
     39            uint32_t thread_flags;
     40          
     41          #if (__EXCLUSIVE_ACCESS == 0U)
     42            __disable_irq();
     43          
     44            thread->thread_flags |= flags;
     45            thread_flags = thread->thread_flags;
     46          
     47            if (primask == 0U) {
     48              __enable_irq();
     49            }
     50          #else
     51            thread_flags = atomic_set32(&thread->thread_flags, flags);
     52          #endif
     53          
     54            return thread_flags;
     55          }
     56          
     57          /// Clear Thread Flags.
     58          /// \param[in]  thread          thread object.
     59          /// \param[in]  flags           specifies the flags to clear.
     60          /// \return thread flags before clearing.
     61          static uint32_t ThreadFlagsClear (os_thread_t *thread, uint32_t flags) {
     62          #if (__EXCLUSIVE_ACCESS == 0U)
     63            uint32_t primask = __get_PRIMASK();
     64          #endif
     65            uint32_t thread_flags;
     66          
     67          #if (__EXCLUSIVE_ACCESS == 0U)
     68            __disable_irq();
     69          
     70            thread_flags = thread->thread_flags;
     71            thread->thread_flags &= ~flags;
     72          
     73            if (primask == 0U) {
     74              __enable_irq();
     75            }
     76          #else
     77            thread_flags = atomic_clr32(&thread->thread_flags, flags);
     78          #endif
     79          
     80            return thread_flags;
     81          }
     82          
     83          /// Check Thread Flags.
     84          /// \param[in]  thread          thread object.
     85          /// \param[in]  flags           specifies the flags to check.
     86          /// \param[in]  options         specifies flags options (osFlagsXxxx).
     87          /// \return thread flags before clearing or 0 if specified flags have not been set.

   \                                 In section .text, align 2, keep-with-next
     88          static uint32_t ThreadFlagsCheck (os_thread_t *thread, uint32_t flags, uint32_t options) {
   \                     ThreadFlagsCheck: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0013             MOVS     R3,R2
     89          #if (__EXCLUSIVE_ACCESS == 0U)
     90            uint32_t primask;
     91          #endif
     92            uint32_t thread_flags;
     93          
     94            if ((options & osFlagsNoClear) == 0U) {
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x079A             LSLS     R2,R3,#+30
   \   00000008   0xD414             BMI      ??ThreadFlagsCheck_0
     95          #if (__EXCLUSIVE_ACCESS == 0U)
     96              primask = __get_PRIMASK();
   \   0000000A   0xF3EF 0x8510      MRS      R5,PRIMASK
     97              __disable_irq();
   \   0000000E   0xB672             CPSID    I
     98          
     99              thread_flags = thread->thread_flags;
   \   00000010   0x6A86             LDR      R6,[R0, #+40]
   \   00000012   0x0032             MOVS     R2,R6
    100              if ((((options & osFlagsWaitAll) != 0U) && ((thread_flags & flags) != flags)) ||
    101                  (((options & osFlagsWaitAll) == 0U) && ((thread_flags & flags) == 0U))) {
   \   00000014   0x000F             MOVS     R7,R1
   \   00000016   0x4017             ANDS     R7,R7,R2
   \   00000018   0x401C             ANDS     R4,R4,R3
   \   0000001A   0xD007             BEQ      ??ThreadFlagsCheck_1
   \   0000001C   0x428F             CMP      R7,R1
   \   0000001E   0xD107             BNE      ??ThreadFlagsCheck_2
    102                thread_flags = 0U;
    103              } else {
    104                thread->thread_flags &= ~flags;
   \                     ??ThreadFlagsCheck_3: (+1)
   \   00000020   0x438E             BICS     R6,R6,R1
   \   00000022   0x6286             STR      R6,[R0, #+40]
    105              }
    106          
    107              if (primask == 0U) {
   \                     ??ThreadFlagsCheck_4: (+1)
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD110             BNE      ??ThreadFlagsCheck_5
    108                __enable_irq();
   \   00000028   0xB662             CPSIE    I
   \   0000002A   0xE00E             B        ??ThreadFlagsCheck_5
    109              }
   \                     ??ThreadFlagsCheck_1: (+1)
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD1F7             BNE      ??ThreadFlagsCheck_3
   \                     ??ThreadFlagsCheck_2: (+1)
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0xE7F7             B        ??ThreadFlagsCheck_4
    110          #else
    111              if ((options & osFlagsWaitAll) != 0U) {
    112                thread_flags = atomic_chk32_all(&thread->thread_flags, flags);
    113              } else {
    114                thread_flags = atomic_chk32_any(&thread->thread_flags, flags);
    115              }
    116          #endif
    117            } else {
    118              thread_flags = thread->thread_flags;
   \                     ??ThreadFlagsCheck_0: (+1)
   \   00000034   0x6A82             LDR      R2,[R0, #+40]
    119              if ((((options & osFlagsWaitAll) != 0U) && ((thread_flags & flags) != flags)) ||
    120                  (((options & osFlagsWaitAll) == 0U) && ((thread_flags & flags) == 0U))) {
   \   00000036   0x0008             MOVS     R0,R1
   \   00000038   0x4010             ANDS     R0,R0,R2
   \   0000003A   0x401C             ANDS     R4,R4,R3
   \   0000003C   0xD002             BEQ      ??ThreadFlagsCheck_6
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD102             BNE      ??ThreadFlagsCheck_7
   \   00000042   0xE002             B        ??ThreadFlagsCheck_5
   \                     ??ThreadFlagsCheck_6: (+1)
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD100             BNE      ??ThreadFlagsCheck_5
    121                thread_flags = 0U;
   \                     ??ThreadFlagsCheck_7: (+1)
   \   00000048   0x2200             MOVS     R2,#+0
    122              }
    123            }
    124          
    125            return thread_flags;
   \                     ??ThreadFlagsCheck_5: (+1)
   \   0000004A   0x0010             MOVS     R0,R2
   \   0000004C   0xBCF0             POP      {R4-R7}
   \   0000004E   0x4770             BX       LR               ;; return
    126          }
    127          
    128          
    129          //  ==== Library functions ====
    130          
    131          /// Put a Thread into specified Object list sorted by Priority (Highest at Head).
    132          /// \param[in]  object          generic object.
    133          /// \param[in]  thread          thread object.

   \                                 In section .text, align 2, keep-with-next
    134          void osRtxThreadListPut (volatile os_object_t *object, os_thread_t *thread) {
    135            os_thread_t *prev, *next;
    136            int32_t      priority;
    137          
    138            if (thread == NULL) {
   \                     osRtxThreadListPut: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD100             BNE      ??osRtxThreadListPut_0
   \   00000004   0x4770             BX       LR
    139              return;
    140            }
    141          
    142            priority = thread->priority;
   \                     ??osRtxThreadListPut_0: (+1)
   \   00000006   0xB410             PUSH     {R4}
   \   00000008   0x2220             MOVS     R2,#+32
   \   0000000A   0x568A             LDRSB    R2,[R1, R2]
    143          
    144            prev = (os_thread_t *)(uint32_t)object;
    145            next = object->thread_list;
   \   0000000C   0x6883             LDR      R3,[R0, #+8]
   \   0000000E   0xE001             B        ??osRtxThreadListPut_1
    146            while ((next != NULL) && (next->priority >= priority)) {
    147              prev = next;
   \                     ??osRtxThreadListPut_2: (+1)
   \   00000010   0x0018             MOVS     R0,R3
    148              next = next->thread_next;
   \   00000012   0x689B             LDR      R3,[R3, #+8]
    149            }
   \                     ??osRtxThreadListPut_1: (+1)
   \   00000014   0x2B00             CMP      R3,#+0
   \   00000016   0xD003             BEQ      ??osRtxThreadListPut_3
   \   00000018   0x2420             MOVS     R4,#+32
   \   0000001A   0x571C             LDRSB    R4,[R3, R4]
   \   0000001C   0x4294             CMP      R4,R2
   \   0000001E   0xDAF7             BGE      ??osRtxThreadListPut_2
    150            thread->thread_prev = prev;
   \                     ??osRtxThreadListPut_3: (+1)
   \   00000020   0x60C8             STR      R0,[R1, #+12]
    151            thread->thread_next = next;
   \   00000022   0x608B             STR      R3,[R1, #+8]
    152            prev->thread_next = thread;
   \   00000024   0x6081             STR      R1,[R0, #+8]
    153            if (next != NULL) {
   \   00000026   0x2B00             CMP      R3,#+0
   \   00000028   0xD000             BEQ      ??osRtxThreadListPut_4
    154              next->thread_prev = thread;
   \   0000002A   0x60D9             STR      R1,[R3, #+12]
    155            }
    156          }
   \                     ??osRtxThreadListPut_4: (+1)
   \   0000002C   0xBC10             POP      {R4}
   \   0000002E   0x4770             BX       LR               ;; return
    157          
    158          /// Get a Thread with Highest Priority from specified Object list and remove it.
    159          /// \param[in]  object          generic object.
    160          /// \return thread object. 

   \                                 In section .text, align 2, keep-with-next
    161          os_thread_t *osRtxThreadListGet (volatile os_object_t *object) {
   \                     osRtxThreadListGet: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    162            os_thread_t *thread;
    163          
    164            thread = object->thread_list;
   \   00000002   0x6888             LDR      R0,[R1, #+8]
    165            if (thread != NULL) {
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD007             BEQ      ??osRtxThreadListGet_0
    166              object->thread_list = thread->thread_next;
   \   00000008   0x6882             LDR      R2,[R0, #+8]
   \   0000000A   0x608A             STR      R2,[R1, #+8]
    167              if (thread->thread_next != NULL) {
   \   0000000C   0x6882             LDR      R2,[R0, #+8]
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD000             BEQ      ??osRtxThreadListGet_1
    168                thread->thread_next->thread_prev = (os_thread_t *)(uint32_t)object;
   \   00000012   0x60D1             STR      R1,[R2, #+12]
    169              }
    170              thread->thread_prev = NULL;
   \                     ??osRtxThreadListGet_1: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x60C1             STR      R1,[R0, #+12]
    171            }
    172          
    173            return thread;
   \                     ??osRtxThreadListGet_0: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    174          }
    175          
    176          /// Retrieve Thread list root.
    177          /// \param[in]  thread          thread object.

   \                                 In section .text, align 2, keep-with-next
    178          void *osRtxThreadListRoot (os_thread_t *thread) {
   \                     osRtxThreadListRoot: (+1)
   \   00000000   0xE000             B        ??osRtxThreadListRoot_0
    179          
    180            while ((thread != NULL) && (thread->id == osRtxIdThread)) {
    181              thread = thread->thread_prev;
   \                     ??osRtxThreadListRoot_1: (+1)
   \   00000002   0x68C0             LDR      R0,[R0, #+12]
    182            }
   \                     ??osRtxThreadListRoot_0: (+1)
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD002             BEQ      ??osRtxThreadListRoot_2
   \   00000008   0x7801             LDRB     R1,[R0, #+0]
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD0F9             BEQ      ??osRtxThreadListRoot_1
    183            return ((void *)thread);
   \                     ??osRtxThreadListRoot_2: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    184          }
    185          
    186          /// Re-sort a Thread in linked Object list by Priority (Highest at Head).
    187          /// \param[in]  thread          thread object.

   \                                 In section .text, align 2, keep-with-next
    188          void osRtxThreadListSort (os_thread_t *thread) {
   \                     osRtxThreadListSort: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    189            os_object_t *object;
    190            os_thread_t *thread0;
    191          
    192            // Search for object
    193            thread0 = thread;
   \   00000004   0x0025             MOVS     R5,R4
    194            while (thread0->id == osRtxIdThread) {
   \                     ??osRtxThreadListSort_0: (+1)
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD103             BNE      ??osRtxThreadListSort_1
    195              thread0 = thread0->thread_prev;
   \   0000000C   0x68ED             LDR      R5,[R5, #+12]
    196              if (thread0 == NULL) { 
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD1F9             BNE      ??osRtxThreadListSort_0
    197                return;
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}
    198              }
    199            }
    200            object = (os_object_t *)thread0;
    201          
    202            osRtxThreadListRemove(thread);
   \                     ??osRtxThreadListSort_1: (+1)
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       osRtxThreadListRemove
    203            osRtxThreadListPut(object, thread);
   \   0000001A   0x0021             MOVS     R1,R4
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0x.... 0x....      BL       osRtxThreadListPut
    204          }
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    205          
    206          /// Remove a Thread from linked Object list.
    207          /// \param[in]  thread          thread object.

   \                                 In section .text, align 2, keep-with-next
    208          void osRtxThreadListRemove (os_thread_t *thread) {
    209          
    210            if (thread->thread_prev != NULL) {
   \                     osRtxThreadListRemove: (+1)
   \   00000000   0x68C1             LDR      R1,[R0, #+12]
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD008             BEQ      ??osRtxThreadListRemove_0
    211              thread->thread_prev->thread_next = thread->thread_next;
   \   00000006   0x6882             LDR      R2,[R0, #+8]
   \   00000008   0x608A             STR      R2,[R1, #+8]
    212              if (thread->thread_next != NULL) {
   \   0000000A   0x6881             LDR      R1,[R0, #+8]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD001             BEQ      ??osRtxThreadListRemove_1
    213                thread->thread_next->thread_prev = thread->thread_prev;
   \   00000010   0x68C2             LDR      R2,[R0, #+12]
   \   00000012   0x60CA             STR      R2,[R1, #+12]
    214              }
    215              thread->thread_prev = NULL;
   \                     ??osRtxThreadListRemove_1: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x60C1             STR      R1,[R0, #+12]
    216            }
    217          }
   \                     ??osRtxThreadListRemove_0: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    218          
    219          /// Unlink a Thread from specified linked list.
    220          /// \param[in]  thread          thread object.

   \                                 In section .text, align 2, keep-with-next
    221          void osRtxThreadListUnlink (os_thread_t **thread_list, os_thread_t *thread) {
    222          
    223            if (thread->thread_next != NULL) {
   \                     osRtxThreadListUnlink: (+1)
   \   00000000   0x688A             LDR      R2,[R1, #+8]
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD001             BEQ      ??osRtxThreadListUnlink_0
    224              thread->thread_next->thread_prev = thread->thread_prev;
   \   00000006   0x68CB             LDR      R3,[R1, #+12]
   \   00000008   0x60D3             STR      R3,[R2, #+12]
    225            }
    226            if (thread->thread_prev != NULL) {
   \                     ??osRtxThreadListUnlink_0: (+1)
   \   0000000A   0x688A             LDR      R2,[R1, #+8]
   \   0000000C   0x68CB             LDR      R3,[R1, #+12]
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD003             BEQ      ??osRtxThreadListUnlink_1
    227              thread->thread_prev->thread_next = thread->thread_next;
   \   00000012   0x609A             STR      R2,[R3, #+8]
    228              thread->thread_prev = NULL;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x60C8             STR      R0,[R1, #+12]
   \   00000018   0x4770             BX       LR
    229            } else {
    230              *thread_list = thread->thread_next;
   \                     ??osRtxThreadListUnlink_1: (+1)
   \   0000001A   0x6002             STR      R2,[R0, #+0]
    231            }
    232          }
   \   0000001C   0x4770             BX       LR               ;; return
    233          
    234          /// Mark a Thread as Ready and put it into Ready list (sorted by Priority).
    235          /// \param[in]  thread          thread object.

   \                                 In section .text, align 2, keep-with-next
    236          void osRtxThreadReadyPut (os_thread_t *thread) {
   \                     osRtxThreadReadyPut: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    237          
    238            thread->state = osRtxThreadReady;
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x7041             STRB     R1,[R0, #+1]
    239            osRtxThreadListPut(&osRtxInfo.thread.ready, thread);
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0x....             LDR      R0,??DataTable6
   \   0000000A   0x.... 0x....      BL       osRtxThreadListPut
    240          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
    241          
    242          /// Insert a Thread into the Delay list sorted by Delay (Lowest at Head).
    243          /// \param[in]  thread          thread object.
    244          /// \param[in]  delay           delay value.

   \                                 In section .text, align 2, keep-with-next
    245          void osRtxThreadDelayInsert (os_thread_t *thread, uint32_t delay) {
   \                     osRtxThreadDelayInsert: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    246            os_thread_t *prev, *next;
    247          
    248            if (delay == osWaitForever) {
   \   00000002   0x....             LDR      R3,??DataTable6_1
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x43ED             MVNS     R5,R5            ;; #-1
   \   0000000A   0x42A9             CMP      R1,R5
   \   0000000C   0x4626             MOV      R6,R4
   \   0000000E   0xD10E             BNE      ??osRtxThreadDelayInsert_0
    249              prev = NULL;
    250              next = osRtxInfo.thread.wait_list;
   \   00000010   0x6B1A             LDR      R2,[R3, #+48]
   \   00000012   0xE001             B        ??osRtxThreadDelayInsert_1
    251              while (next != NULL)  {
    252                prev = next;
   \                     ??osRtxThreadDelayInsert_2: (+1)
   \   00000014   0x0016             MOVS     R6,R2
    253                next = next->delay_next;
   \   00000016   0x6912             LDR      R2,[R2, #+16]
    254              }
   \                     ??osRtxThreadDelayInsert_1: (+1)
   \   00000018   0x2A00             CMP      R2,#+0
   \   0000001A   0xD1FB             BNE      ??osRtxThreadDelayInsert_2
    255              thread->delay = delay;
   \   0000001C   0x61C5             STR      R5,[R0, #+28]
    256              thread->delay_prev = prev;
   \   0000001E   0x6146             STR      R6,[R0, #+20]
    257              thread->delay_next = next;
   \   00000020   0x6104             STR      R4,[R0, #+16]
    258              if (prev != NULL) {
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD001             BEQ      ??osRtxThreadDelayInsert_3
    259                prev->delay_next = thread;
   \   00000026   0x6130             STR      R0,[R6, #+16]
   \   00000028   0xE019             B        ??osRtxThreadDelayInsert_4
    260              } else {
    261                osRtxInfo.thread.wait_list = thread;
   \                     ??osRtxThreadDelayInsert_3: (+1)
   \   0000002A   0x6318             STR      R0,[R3, #+48]
   \   0000002C   0xE017             B        ??osRtxThreadDelayInsert_4
    262              }
    263              if (next != NULL) {
    264                next->delay_prev = thread;
    265              }
    266            } else {
    267              prev = NULL;
    268              next = osRtxInfo.thread.delay_list;
   \                     ??osRtxThreadDelayInsert_0: (+1)
   \   0000002E   0x6ADA             LDR      R2,[R3, #+44]
   \   00000030   0xE002             B        ??osRtxThreadDelayInsert_5
    269              while ((next != NULL) && (next->delay <= delay)) {
    270                delay -= next->delay;
   \                     ??osRtxThreadDelayInsert_6: (+1)
   \   00000032   0x1B09             SUBS     R1,R1,R4
    271                prev = next;
   \   00000034   0x0016             MOVS     R6,R2
    272                next = next->delay_next;
   \   00000036   0x6912             LDR      R2,[R2, #+16]
    273              }
   \                     ??osRtxThreadDelayInsert_5: (+1)
   \   00000038   0x2A00             CMP      R2,#+0
   \   0000003A   0xD002             BEQ      ??osRtxThreadDelayInsert_7
   \   0000003C   0x69D4             LDR      R4,[R2, #+28]
   \   0000003E   0x42A1             CMP      R1,R4
   \   00000040   0xD2F7             BCS      ??osRtxThreadDelayInsert_6
    274              thread->delay = delay;
   \                     ??osRtxThreadDelayInsert_7: (+1)
   \   00000042   0x61C1             STR      R1,[R0, #+28]
    275              thread->delay_prev = prev;
   \   00000044   0x6146             STR      R6,[R0, #+20]
    276              thread->delay_next = next;
   \   00000046   0x6102             STR      R2,[R0, #+16]
    277              if (prev != NULL) {
   \   00000048   0x2E00             CMP      R6,#+0
   \   0000004A   0xD001             BEQ      ??osRtxThreadDelayInsert_8
    278                prev->delay_next = thread;
   \   0000004C   0x6130             STR      R0,[R6, #+16]
   \   0000004E   0xE000             B        ??osRtxThreadDelayInsert_9
    279              } else {
    280                osRtxInfo.thread.delay_list = thread;
   \                     ??osRtxThreadDelayInsert_8: (+1)
   \   00000050   0x62D8             STR      R0,[R3, #+44]
    281              }
    282              if (next != NULL) {
   \                     ??osRtxThreadDelayInsert_9: (+1)
   \   00000052   0x2A00             CMP      R2,#+0
   \   00000054   0xD003             BEQ      ??osRtxThreadDelayInsert_4
    283                next->delay -= delay;
   \   00000056   0x69D3             LDR      R3,[R2, #+28]
   \   00000058   0x1A59             SUBS     R1,R3,R1
   \   0000005A   0x61D1             STR      R1,[R2, #+28]
    284                next->delay_prev = thread;
   \   0000005C   0x6150             STR      R0,[R2, #+20]
    285              }
    286            }
    287          }
   \                     ??osRtxThreadDelayInsert_4: (+1)
   \   0000005E   0xBC70             POP      {R4-R6}
   \   00000060   0x4770             BX       LR               ;; return
    288          
    289          /// Remove a Thread from the Delay list.
    290          /// \param[in]  thread          thread object.

   \                                 In section .text, align 2, keep-with-next
    291          void osRtxThreadDelayRemove (os_thread_t *thread) {
   \                     osRtxThreadDelayRemove: (+1)
   \   00000000   0xB410             PUSH     {R4}
    292          
    293            if (thread->delay == osWaitForever) {
   \   00000002   0x6941             LDR      R1,[R0, #+20]
   \   00000004   0x69C2             LDR      R2,[R0, #+28]
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x43DB             MVNS     R3,R3            ;; #-1
   \   0000000A   0x429A             CMP      R2,R3
   \   0000000C   0xD110             BNE      ??osRtxThreadDelayRemove_0
    294              if ((thread->delay_prev == NULL) && (osRtxInfo.thread.wait_list != thread)) {
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD103             BNE      ??osRtxThreadDelayRemove_1
   \   00000012   0x....             LDR      R2,??DataTable6_1
   \   00000014   0x6B12             LDR      R2,[R2, #+48]
   \   00000016   0x4282             CMP      R2,R0
   \   00000018   0xD123             BNE      ??osRtxThreadDelayRemove_2
    295                return;
    296              }
    297              if (thread->delay_next != NULL) {
   \                     ??osRtxThreadDelayRemove_1: (+1)
   \   0000001A   0x6903             LDR      R3,[R0, #+16]
   \   0000001C   0x2B00             CMP      R3,#+0
   \   0000001E   0xD000             BEQ      ??osRtxThreadDelayRemove_3
    298                thread->delay_next->delay_prev = thread->delay_prev;
   \   00000020   0x6159             STR      R1,[R3, #+20]
    299              }
    300              if (thread->delay_prev != NULL) {
   \                     ??osRtxThreadDelayRemove_3: (+1)
   \   00000022   0x6941             LDR      R1,[R0, #+20]
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD113             BNE      ??osRtxThreadDelayRemove_4
    301                thread->delay_prev->delay_next = thread->delay_next;
    302                thread->delay_prev = NULL;
    303              } else {
    304                osRtxInfo.thread.wait_list = thread->delay_next;
   \   00000028   0x6900             LDR      R0,[R0, #+16]
   \   0000002A   0x....             LDR      R1,??DataTable6_1
   \   0000002C   0x6308             STR      R0,[R1, #+48]
   \   0000002E   0xE018             B        ??osRtxThreadDelayRemove_2
    305              }
    306            } else {
    307              if ((thread->delay_prev == NULL) && (osRtxInfo.thread.delay_list != thread)) {
   \                     ??osRtxThreadDelayRemove_0: (+1)
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD103             BNE      ??osRtxThreadDelayRemove_5
   \   00000034   0x....             LDR      R3,??DataTable6_1
   \   00000036   0x6ADB             LDR      R3,[R3, #+44]
   \   00000038   0x4283             CMP      R3,R0
   \   0000003A   0xD112             BNE      ??osRtxThreadDelayRemove_2
    308                return;
    309              }
    310              if (thread->delay_next != NULL) {
   \                     ??osRtxThreadDelayRemove_5: (+1)
   \   0000003C   0x6903             LDR      R3,[R0, #+16]
   \   0000003E   0x2B00             CMP      R3,#+0
   \   00000040   0xD003             BEQ      ??osRtxThreadDelayRemove_6
    311                thread->delay_next->delay += thread->delay;
   \   00000042   0x69DC             LDR      R4,[R3, #+28]
   \   00000044   0x18A2             ADDS     R2,R4,R2
   \   00000046   0x61DA             STR      R2,[R3, #+28]
    312                thread->delay_next->delay_prev = thread->delay_prev;
   \   00000048   0x6159             STR      R1,[R3, #+20]
    313              }
    314              if (thread->delay_prev != NULL) {
   \                     ??osRtxThreadDelayRemove_6: (+1)
   \   0000004A   0x6941             LDR      R1,[R0, #+20]
   \   0000004C   0x2900             CMP      R1,#+0
   \   0000004E   0xD005             BEQ      ??osRtxThreadDelayRemove_7
    315                thread->delay_prev->delay_next = thread->delay_next;
   \                     ??osRtxThreadDelayRemove_4: (+1)
   \   00000050   0x6901             LDR      R1,[R0, #+16]
   \   00000052   0x6942             LDR      R2,[R0, #+20]
   \   00000054   0x6111             STR      R1,[R2, #+16]
    316                thread->delay_prev = NULL;
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x6141             STR      R1,[R0, #+20]
   \   0000005A   0xE002             B        ??osRtxThreadDelayRemove_2
    317              } else {
    318                osRtxInfo.thread.delay_list = thread->delay_next;
   \                     ??osRtxThreadDelayRemove_7: (+1)
   \   0000005C   0x6900             LDR      R0,[R0, #+16]
   \   0000005E   0x....             LDR      R1,??DataTable6_1
   \   00000060   0x62C8             STR      R0,[R1, #+44]
    319              }
    320            }
    321          }
   \                     ??osRtxThreadDelayRemove_2: (+1)
   \   00000062   0xBC10             POP      {R4}
   \   00000064   0x4770             BX       LR               ;; return
    322          
    323          /// Process Thread Delay Tick (executed each System Tick).

   \                                 In section .text, align 2, keep-with-next
    324          void osRtxThreadDelayTick (void) {
   \                     osRtxThreadDelayTick: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    325            os_thread_t *thread;
    326          
    327            thread = osRtxInfo.thread.delay_list;
   \   00000002   0x....             LDR      R4,??DataTable6_1
   \   00000004   0x6AE5             LDR      R5,[R4, #+44]
    328            if (thread == NULL) {
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD100             BNE      .+4
   \   0000000A   0xE07E             B        ??osRtxThreadDelayTick_0
    329              return;
    330            }
    331          
    332            thread->delay--;
   \   0000000C   0x69E8             LDR      R0,[R5, #+28]
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x61E8             STR      R0,[R5, #+28]
    333          
    334            if (thread->delay == 0U) {
   \   00000012   0xD17A             BNE      ??osRtxThreadDelayTick_0
    335              do {
    336                switch (thread->state) {
   \                     ??osRtxThreadDelayTick_1: (+1)
   \   00000014   0x7868             LDRB     R0,[R5, #+1]
   \   00000016   0x2813             CMP      R0,#+19
   \   00000018   0xD00E             BEQ      ??osRtxThreadDelayTick_2
   \   0000001A   0x2833             CMP      R0,#+51
   \   0000001C   0xD00F             BEQ      ??osRtxThreadDelayTick_3
   \   0000001E   0x2843             CMP      R0,#+67
   \   00000020   0xD010             BEQ      ??osRtxThreadDelayTick_4
   \   00000022   0x2853             CMP      R0,#+83
   \   00000024   0xD019             BEQ      ??osRtxThreadDelayTick_5
   \   00000026   0x2863             CMP      R0,#+99
   \   00000028   0xD022             BEQ      ??osRtxThreadDelayTick_6
   \   0000002A   0x2873             CMP      R0,#+115
   \   0000002C   0xD02B             BEQ      ??osRtxThreadDelayTick_7
   \   0000002E   0x2883             CMP      R0,#+131
   \   00000030   0xD034             BEQ      ??osRtxThreadDelayTick_8
   \   00000032   0x2893             CMP      R0,#+147
   \   00000034   0xD03D             BEQ      ??osRtxThreadDelayTick_9
   \   00000036   0xE046             B        ??osRtxThreadDelayTick_10
    337                  case osRtxThreadWaitingDelay:
    338                    EvrRtxThreadDelayCompleted();
   \                     ??osRtxThreadDelayTick_2: (+1)
   \   00000038   0x.... 0x....      BL       EvrRtxThreadDelayCompleted
    339                    break;
   \   0000003C   0xE043             B        ??osRtxThreadDelayTick_10
    340                  case osRtxThreadWaitingThreadFlags:
    341                    EvrRtxThreadFlagsWaitTimeout();
   \                     ??osRtxThreadDelayTick_3: (+1)
   \   0000003E   0x.... 0x....      BL       EvrRtxThreadFlagsWaitTimeout
    342                    break;
   \   00000042   0xE040             B        ??osRtxThreadDelayTick_10
    343                  case osRtxThreadWaitingEventFlags:
    344                    EvrRtxEventFlagsWaitTimeout((osEventFlagsId_t)osRtxThreadListRoot(thread));
   \                     ??osRtxThreadDelayTick_4: (+1)
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0xE000             B        ??osRtxThreadDelayTick_11
   \                     ??osRtxThreadDelayTick_12: (+1)
   \   00000048   0x68C0             LDR      R0,[R0, #+12]
   \                     ??osRtxThreadDelayTick_11: (+1)
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD002             BEQ      ??osRtxThreadDelayTick_13
   \   0000004E   0x7801             LDRB     R1,[R0, #+0]
   \   00000050   0x2901             CMP      R1,#+1
   \   00000052   0xD0F9             BEQ      ??osRtxThreadDelayTick_12
   \                     ??osRtxThreadDelayTick_13: (+1)
   \   00000054   0x.... 0x....      BL       EvrRtxEventFlagsWaitTimeout
    345                    break;
   \   00000058   0xE035             B        ??osRtxThreadDelayTick_10
    346                  case osRtxThreadWaitingMutex:
    347                    EvrRtxMutexAcquireTimeout((osMutexId_t)osRtxThreadListRoot(thread));
   \                     ??osRtxThreadDelayTick_5: (+1)
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0xE000             B        ??osRtxThreadDelayTick_14
   \                     ??osRtxThreadDelayTick_15: (+1)
   \   0000005E   0x68C0             LDR      R0,[R0, #+12]
   \                     ??osRtxThreadDelayTick_14: (+1)
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD002             BEQ      ??osRtxThreadDelayTick_16
   \   00000064   0x7801             LDRB     R1,[R0, #+0]
   \   00000066   0x2901             CMP      R1,#+1
   \   00000068   0xD0F9             BEQ      ??osRtxThreadDelayTick_15
   \                     ??osRtxThreadDelayTick_16: (+1)
   \   0000006A   0x.... 0x....      BL       EvrRtxMutexAcquireTimeout
    348                    break;
   \   0000006E   0xE02A             B        ??osRtxThreadDelayTick_10
    349                  case osRtxThreadWaitingSemaphore:
    350                    EvrRtxSemaphoreAcquireTimeout((osSemaphoreId_t)osRtxThreadListRoot(thread));
   \                     ??osRtxThreadDelayTick_6: (+1)
   \   00000070   0x0028             MOVS     R0,R5
   \   00000072   0xE000             B        ??osRtxThreadDelayTick_17
   \                     ??osRtxThreadDelayTick_18: (+1)
   \   00000074   0x68C0             LDR      R0,[R0, #+12]
   \                     ??osRtxThreadDelayTick_17: (+1)
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD002             BEQ      ??osRtxThreadDelayTick_19
   \   0000007A   0x7801             LDRB     R1,[R0, #+0]
   \   0000007C   0x2901             CMP      R1,#+1
   \   0000007E   0xD0F9             BEQ      ??osRtxThreadDelayTick_18
   \                     ??osRtxThreadDelayTick_19: (+1)
   \   00000080   0x.... 0x....      BL       EvrRtxSemaphoreAcquireTimeout
    351                    break;
   \   00000084   0xE01F             B        ??osRtxThreadDelayTick_10
    352                  case osRtxThreadWaitingMemoryPool:
    353                    EvrRtxMemoryPoolAllocTimeout((osMemoryPoolId_t)osRtxThreadListRoot(thread));
   \                     ??osRtxThreadDelayTick_7: (+1)
   \   00000086   0x0028             MOVS     R0,R5
   \   00000088   0xE000             B        ??osRtxThreadDelayTick_20
   \                     ??osRtxThreadDelayTick_21: (+1)
   \   0000008A   0x68C0             LDR      R0,[R0, #+12]
   \                     ??osRtxThreadDelayTick_20: (+1)
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD002             BEQ      ??osRtxThreadDelayTick_22
   \   00000090   0x7801             LDRB     R1,[R0, #+0]
   \   00000092   0x2901             CMP      R1,#+1
   \   00000094   0xD0F9             BEQ      ??osRtxThreadDelayTick_21
   \                     ??osRtxThreadDelayTick_22: (+1)
   \   00000096   0x.... 0x....      BL       EvrRtxMemoryPoolAllocTimeout
    354                    break;
   \   0000009A   0xE014             B        ??osRtxThreadDelayTick_10
    355                  case osRtxThreadWaitingMessageGet:
    356                    EvrRtxMessageQueueGetTimeout((osMessageQueueId_t)osRtxThreadListRoot(thread));
   \                     ??osRtxThreadDelayTick_8: (+1)
   \   0000009C   0x0028             MOVS     R0,R5
   \   0000009E   0xE000             B        ??osRtxThreadDelayTick_23
   \                     ??osRtxThreadDelayTick_24: (+1)
   \   000000A0   0x68C0             LDR      R0,[R0, #+12]
   \                     ??osRtxThreadDelayTick_23: (+1)
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD002             BEQ      ??osRtxThreadDelayTick_25
   \   000000A6   0x7801             LDRB     R1,[R0, #+0]
   \   000000A8   0x2901             CMP      R1,#+1
   \   000000AA   0xD0F9             BEQ      ??osRtxThreadDelayTick_24
   \                     ??osRtxThreadDelayTick_25: (+1)
   \   000000AC   0x.... 0x....      BL       EvrRtxMessageQueueGetTimeout
    357                    break;
   \   000000B0   0xE009             B        ??osRtxThreadDelayTick_10
    358                  case osRtxThreadWaitingMessagePut:
    359                    EvrRtxMessageQueuePutTimeout((osMessageQueueId_t)osRtxThreadListRoot(thread));
   \                     ??osRtxThreadDelayTick_9: (+1)
   \   000000B2   0x0028             MOVS     R0,R5
   \   000000B4   0xE000             B        ??osRtxThreadDelayTick_26
   \                     ??osRtxThreadDelayTick_27: (+1)
   \   000000B6   0x68C0             LDR      R0,[R0, #+12]
   \                     ??osRtxThreadDelayTick_26: (+1)
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD002             BEQ      ??osRtxThreadDelayTick_28
   \   000000BC   0x7801             LDRB     R1,[R0, #+0]
   \   000000BE   0x2901             CMP      R1,#+1
   \   000000C0   0xD0F9             BEQ      ??osRtxThreadDelayTick_27
   \                     ??osRtxThreadDelayTick_28: (+1)
   \   000000C2   0x.... 0x....      BL       EvrRtxMessageQueuePutTimeout
    360                    break;
    361                  default:
    362                    break;
    363                }
    364                EvrRtxThreadUnblocked(thread, (osRtxThreadRegPtr(thread))[0]);
   \                     ??osRtxThreadDelayTick_10: (+1)
   \   000000C6   0x6BA8             LDR      R0,[R5, #+56]
   \   000000C8   0x3020             ADDS     R0,R0,#+32
   \   000000CA   0x6801             LDR      R1,[R0, #+0]
   \   000000CC   0x0028             MOVS     R0,R5
   \   000000CE   0x.... 0x....      BL       EvrRtxThreadUnblocked
    365                osRtxThreadListRemove(thread);
   \   000000D2   0x68E8             LDR      R0,[R5, #+12]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD008             BEQ      ??osRtxThreadDelayTick_29
   \   000000D8   0x68A9             LDR      R1,[R5, #+8]
   \   000000DA   0x6081             STR      R1,[R0, #+8]
   \   000000DC   0x68A8             LDR      R0,[R5, #+8]
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD001             BEQ      ??osRtxThreadDelayTick_30
   \   000000E2   0x68E9             LDR      R1,[R5, #+12]
   \   000000E4   0x60C1             STR      R1,[R0, #+12]
   \                     ??osRtxThreadDelayTick_30: (+1)
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x60E8             STR      R0,[R5, #+12]
    366                osRtxThreadReadyPut(thread);
   \                     ??osRtxThreadDelayTick_29: (+1)
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0x7068             STRB     R0,[R5, #+1]
   \   000000EE   0x0029             MOVS     R1,R5
   \   000000F0   0x0020             MOVS     R0,R4
   \   000000F2   0x301C             ADDS     R0,R0,#+28
   \   000000F4   0x.... 0x....      BL       osRtxThreadListPut
    367                thread = thread->delay_next;
   \   000000F8   0x692D             LDR      R5,[R5, #+16]
    368              } while ((thread != NULL) && (thread->delay == 0U));
   \   000000FA   0x2D00             CMP      R5,#+0
   \   000000FC   0xD004             BEQ      ??osRtxThreadDelayTick_31
   \   000000FE   0x69E8             LDR      R0,[R5, #+28]
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD087             BEQ      ??osRtxThreadDelayTick_1
    369              if (thread != NULL) {
    370                thread->delay_prev = NULL;
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0x6168             STR      R0,[R5, #+20]
    371              }
    372              osRtxInfo.thread.delay_list = thread;
   \                     ??osRtxThreadDelayTick_31: (+1)
   \   00000108   0x62E5             STR      R5,[R4, #+44]
    373            }
    374          }
   \                     ??osRtxThreadDelayTick_0: (+1)
   \   0000010A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    375          
    376          /// Get pointer to Thread registers (R0..R3)
    377          /// \param[in]  thread          thread object.
    378          /// \return pointer to registers R0-R3.

   \                                 In section .text, align 2, keep-with-next
    379          uint32_t *osRtxThreadRegPtr (os_thread_t *thread) {
    380            return ((uint32_t *)(thread->sp + STACK_OFFSET_R0(thread->stack_frame)));
   \                     osRtxThreadRegPtr: (+1)
   \   00000000   0x6B80             LDR      R0,[R0, #+56]
   \   00000002   0x3020             ADDS     R0,R0,#+32
   \   00000004   0x4770             BX       LR               ;; return
    381          }
    382          
    383          /// Block running Thread execution and register it as Ready to Run.
    384          /// \param[in]  thread          running thread object.

   \                                 In section .text, align 2, keep-with-next
    385          void osRtxThreadBlock (os_thread_t *thread) {
   \                     osRtxThreadBlock: (+1)
   \   00000000   0xB410             PUSH     {R4}
    386            os_thread_t *prev, *next;
    387            int32_t      priority;
    388          
    389            thread->state = osRtxThreadReady;
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x7041             STRB     R1,[R0, #+1]
    390          
    391            priority = thread->priority;
   \   00000006   0x2120             MOVS     R1,#+32
   \   00000008   0x5641             LDRSB    R1,[R0, R1]
   \   0000000A   0x....             LDR      R2,??DataTable6
    392          
    393            prev = (os_thread_t *)(uint32_t)&osRtxInfo.thread.ready;
    394            next = prev->thread_next;
   \   0000000C   0x6893             LDR      R3,[R2, #+8]
   \   0000000E   0xE001             B        ??osRtxThreadBlock_0
    395          
    396            while ((next != NULL) && (next->priority > priority)) {
    397              prev = next;
   \                     ??osRtxThreadBlock_1: (+1)
   \   00000010   0x001A             MOVS     R2,R3
    398              next = next->thread_next;
   \   00000012   0x689B             LDR      R3,[R3, #+8]
    399            }
   \                     ??osRtxThreadBlock_0: (+1)
   \   00000014   0x2B00             CMP      R3,#+0
   \   00000016   0xD003             BEQ      ??osRtxThreadBlock_2
   \   00000018   0x2420             MOVS     R4,#+32
   \   0000001A   0x571C             LDRSB    R4,[R3, R4]
   \   0000001C   0x42A1             CMP      R1,R4
   \   0000001E   0xDBF7             BLT      ??osRtxThreadBlock_1
    400            thread->thread_prev = prev;
   \                     ??osRtxThreadBlock_2: (+1)
   \   00000020   0x60C2             STR      R2,[R0, #+12]
    401            thread->thread_next = next;
   \   00000022   0x6083             STR      R3,[R0, #+8]
    402            prev->thread_next = thread;
   \   00000024   0x6090             STR      R0,[R2, #+8]
    403            if (next != NULL) {
   \   00000026   0x2B00             CMP      R3,#+0
   \   00000028   0xD000             BEQ      ??osRtxThreadBlock_3
    404              next->thread_prev = thread;
   \   0000002A   0x60D8             STR      R0,[R3, #+12]
    405            }
    406          }
   \                     ??osRtxThreadBlock_3: (+1)
   \   0000002C   0xBC10             POP      {R4}
   \   0000002E   0x4770             BX       LR               ;; return
    407          
    408          /// Switch to specified Thread.
    409          /// \param[in]  thread          thread object.

   \                                 In section .text, align 2, keep-with-next
    410          void osRtxThreadSwitch (os_thread_t *thread) {
   \                     osRtxThreadSwitch: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    411          
    412            thread->state = osRtxThreadRunning;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x7060             STRB     R0,[R4, #+1]
    413            osRtxInfo.thread.run.next = thread;
   \   00000008   0x....             LDR      R0,??DataTable6_1
   \   0000000A   0x6184             STR      R4,[R0, #+24]
    414            osRtxThreadStackCheck();
   \   0000000C   0x.... 0x....      BL       osRtxThreadStackCheck
    415            EvrRtxThreadSwitch(thread);
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       EvrRtxThreadSwitch
    416          }
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    417          
    418          /// Notify the OS event observer of an imminent thread switch.

   \                                 In section .text, align 2, keep-with-next
    419          void thread_switch_helper(void) {
    420            if (osEventObs && osEventObs->thread_switch) {
   \                     thread_switch_helper: (+1)
   \   00000000   0x....             LDR      R0,??DataTable10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD100             BNE      ??thread_switch_helper_0
   \   00000008   0x4770             BX       LR
   \                     ??thread_switch_helper_0: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x6901             LDR      R1,[R0, #+16]
   \   0000000E   0x0008             MOVS     R0,R1
   \   00000010   0xD003             BEQ      ??thread_switch_helper_1
    421              osEventObs->thread_switch(osRtxInfo.thread.run.next->context);
   \   00000012   0x....             LDR      R0,??DataTable6_1
   \   00000014   0x6980             LDR      R0,[R0, #+24]
   \   00000016   0x6C40             LDR      R0,[R0, #+68]
   \   00000018   0x4788             BLX      R1
    422            }
    423          }
   \                     ??thread_switch_helper_1: (+1)
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    424          
    425          /// Dispatch specified Thread or Ready Thread with Highest Priority.
    426          /// \param[in]  thread          thread object or NULL.

   \                                 In section .text, align 2, keep-with-next
    427          void osRtxThreadDispatch (os_thread_t *thread) {
   \                     osRtxThreadDispatch: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    428            uint8_t      kernel_state;
    429            os_thread_t *thread_running;
    430          
    431            kernel_state   = osRtxKernelGetState();
   \   00000004   0x....             LDR      R5,??DataTable10_1
   \   00000006   0x7A28             LDRB     R0,[R5, #+8]
    432            thread_running = osRtxThreadGetRunning();
   \   00000008   0x696E             LDR      R6,[R5, #+20]
    433          #if (__ARM_ARCH_7A__ != 0U)
    434            // On Cortex-A PendSV_Handler is executed before final context switch.
    435            if ((thread_running != NULL) && (thread_running->state != osRtxThreadRunning)) {
    436              thread_running = osRtxInfo.thread.run.next;
    437            }
    438          #endif
    439          
    440            if (thread == NULL) {
   \   0000000A   0xD110             BNE      ??osRtxThreadDispatch_0
    441              thread = osRtxInfo.thread.ready.thread_list;
   \   0000000C   0x6A6C             LDR      R4,[R5, #+36]
    442              if ((kernel_state == osRtxKernelRunning) &&
    443                  (thread_running != NULL) && (thread != NULL) && 
    444                  (thread->priority > thread_running->priority)) {
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD12A             BNE      ??osRtxThreadDispatch_1
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD028             BEQ      ??osRtxThreadDispatch_1
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD026             BEQ      ??osRtxThreadDispatch_1
   \   0000001A   0x2020             MOVS     R0,#+32
   \   0000001C   0x5630             LDRSB    R0,[R6, R0]
   \   0000001E   0x2120             MOVS     R1,#+32
   \   00000020   0x5661             LDRSB    R1,[R4, R1]
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xDA20             BGE      ??osRtxThreadDispatch_1
    445                // Preempt running Thread
    446                osRtxThreadListRemove(thread);
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       osRtxThreadListRemove
    447                osRtxThreadBlock(thread_running);
   \   0000002C   0xE009             B.N      ??osRtxThreadDispatch_2
    448                osRtxThreadSwitch(thread);
    449              }
    450            } else {
    451              if ((kernel_state == osRtxKernelRunning) &&
    452                  (thread_running != NULL) &&
    453                  (thread->priority > thread_running->priority)) {
   \                     ??osRtxThreadDispatch_0: (+1)
   \   0000002E   0x2802             CMP      R0,#+2
   \   00000030   0xD113             BNE      ??osRtxThreadDispatch_3
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD011             BEQ      ??osRtxThreadDispatch_3
   \   00000036   0x2020             MOVS     R0,#+32
   \   00000038   0x5630             LDRSB    R0,[R6, R0]
   \   0000003A   0x2120             MOVS     R1,#+32
   \   0000003C   0x5661             LDRSB    R1,[R4, R1]
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xDA0B             BGE      ??osRtxThreadDispatch_3
    454                // Preempt running Thread
    455                osRtxThreadBlock(thread_running);
   \                     ??osRtxThreadDispatch_2: (+1)
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0x.... 0x....      BL       osRtxThreadBlock
    456                osRtxThreadSwitch(thread);
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0x7060             STRB     R0,[R4, #+1]
   \   0000004C   0x61AC             STR      R4,[R5, #+24]
   \   0000004E   0x.... 0x....      BL       osRtxThreadStackCheck
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       EvrRtxThreadSwitch
    457              } else {
   \   00000058   0xBD70             POP      {R4-R6,PC}
    458                // Put Thread into Ready list
    459                osRtxThreadReadyPut(thread);
   \                     ??osRtxThreadDispatch_3: (+1)
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x7060             STRB     R0,[R4, #+1]
   \   0000005E   0x0021             MOVS     R1,R4
   \   00000060   0x0028             MOVS     R0,R5
   \   00000062   0x301C             ADDS     R0,R0,#+28
   \   00000064   0x.... 0x....      BL       osRtxThreadListPut
    460              }
    461            }
    462          }
   \                     ??osRtxThreadDispatch_1: (+1)
   \   00000068   0xBD70             POP      {R4-R6,PC}       ;; return
    463          
    464          /// Exit Thread wait state.
    465          /// \param[in]  thread          thread object.
    466          /// \param[in]  ret_val         return value.
    467          /// \param[in]  dispatch        dispatch flag.

   \                                 In section .text, align 2, keep-with-next
    468          void osRtxThreadWaitExit (os_thread_t *thread, uint32_t ret_val, bool dispatch) {
   \                     osRtxThreadWaitExit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    469            uint32_t *reg;
    470          
    471            EvrRtxThreadUnblocked(thread, ret_val);
   \   00000008   0x.... 0x....      BL       EvrRtxThreadUnblocked
    472          
    473            reg = osRtxThreadRegPtr(thread);
    474            reg[0] = ret_val;
   \   0000000C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000000E   0x3020             ADDS     R0,R0,#+32
   \   00000010   0x6005             STR      R5,[R0, #+0]
    475          
    476            osRtxThreadDelayRemove(thread);
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       osRtxThreadDelayRemove
    477            if (dispatch) {
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD003             BEQ      ??osRtxThreadWaitExit_0
    478              osRtxThreadDispatch(thread);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       osRtxThreadDispatch
   \   00000022   0xBD70             POP      {R4-R6,PC}
    479            } else {
    480              osRtxThreadReadyPut(thread);
   \                     ??osRtxThreadWaitExit_0: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x7060             STRB     R0,[R4, #+1]
   \   00000028   0x0021             MOVS     R1,R4
   \   0000002A   0x....             LDR      R0,??DataTable10_2
   \   0000002C   0x.... 0x....      BL       osRtxThreadListPut
    481            }
    482          }
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    483          
    484          /// Enter Thread wait state.
    485          /// \param[in]  state           new thread state.
    486          /// \param[in]  timeout         timeout.
    487          /// \return true - success, false - failure.

   \                                 In section .text, align 2, keep-with-next
    488          bool osRtxThreadWaitEnter (uint8_t state, uint32_t timeout) {
   \                     osRtxThreadWaitEnter: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000F             MOVS     R7,R1
    489            os_thread_t *thread;
    490          
    491            thread = osRtxThreadGetRunning();
   \   00000006   0x....             LDR      R4,??DataTable10_1
   \   00000008   0x6965             LDR      R5,[R4, #+20]
    492            if (thread == NULL) {
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD009             BEQ      ??osRtxThreadWaitEnter_0
    493              return false;
    494            }
    495          
    496            if (osRtxKernelGetState() != osRtxKernelRunning) {
   \   0000000E   0x7A20             LDRB     R0,[R4, #+8]
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD003             BEQ      ??osRtxThreadWaitEnter_1
    497              osRtxThreadListRemove(thread);
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x.... 0x....      BL       osRtxThreadListRemove
    498              return false;
   \   0000001A   0xE002             B.N      ??osRtxThreadWaitEnter_0
    499            }
    500          
    501            if (osRtxInfo.thread.ready.thread_list == NULL) {
   \                     ??osRtxThreadWaitEnter_1: (+1)
   \   0000001C   0x6A60             LDR      R0,[R4, #+36]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD101             BNE      ??osRtxThreadWaitEnter_2
    502              return false;
   \                     ??osRtxThreadWaitEnter_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBDF2             POP      {R1,R4-R7,PC}
    503            }
    504          
    505            EvrRtxThreadBlocked(thread, timeout);
   \                     ??osRtxThreadWaitEnter_2: (+1)
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0x.... 0x....      BL       EvrRtxThreadBlocked
    506          
    507            thread->state = state;
   \   0000002C   0x706E             STRB     R6,[R5, #+1]
    508            osRtxThreadDelayInsert(thread, timeout);
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x428F             CMP      R7,R1
   \   00000036   0x4613             MOV      R3,R2
   \   00000038   0xD10E             BNE      ??osRtxThreadWaitEnter_3
   \   0000003A   0x6B20             LDR      R0,[R4, #+48]
   \   0000003C   0xE001             B        ??osRtxThreadWaitEnter_4
   \                     ??osRtxThreadWaitEnter_5: (+1)
   \   0000003E   0x0003             MOVS     R3,R0
   \   00000040   0x6900             LDR      R0,[R0, #+16]
   \                     ??osRtxThreadWaitEnter_4: (+1)
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD1FB             BNE      ??osRtxThreadWaitEnter_5
   \   00000046   0x61E9             STR      R1,[R5, #+28]
   \   00000048   0x616B             STR      R3,[R5, #+20]
   \   0000004A   0x612A             STR      R2,[R5, #+16]
   \   0000004C   0x2B00             CMP      R3,#+0
   \   0000004E   0xD001             BEQ      ??osRtxThreadWaitEnter_6
   \   00000050   0x611D             STR      R5,[R3, #+16]
   \   00000052   0xE019             B        ??osRtxThreadWaitEnter_7
   \                     ??osRtxThreadWaitEnter_6: (+1)
   \   00000054   0x6325             STR      R5,[R4, #+48]
   \   00000056   0xE017             B        ??osRtxThreadWaitEnter_7
   \                     ??osRtxThreadWaitEnter_3: (+1)
   \   00000058   0x6AE0             LDR      R0,[R4, #+44]
   \   0000005A   0xE002             B        ??osRtxThreadWaitEnter_8
   \                     ??osRtxThreadWaitEnter_9: (+1)
   \   0000005C   0x1A7F             SUBS     R7,R7,R1
   \   0000005E   0x0003             MOVS     R3,R0
   \   00000060   0x6900             LDR      R0,[R0, #+16]
   \                     ??osRtxThreadWaitEnter_8: (+1)
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD002             BEQ      ??osRtxThreadWaitEnter_10
   \   00000066   0x69C1             LDR      R1,[R0, #+28]
   \   00000068   0x428F             CMP      R7,R1
   \   0000006A   0xD2F7             BCS      ??osRtxThreadWaitEnter_9
   \                     ??osRtxThreadWaitEnter_10: (+1)
   \   0000006C   0x61EF             STR      R7,[R5, #+28]
   \   0000006E   0x616B             STR      R3,[R5, #+20]
   \   00000070   0x6128             STR      R0,[R5, #+16]
   \   00000072   0x2B00             CMP      R3,#+0
   \   00000074   0xD001             BEQ      ??osRtxThreadWaitEnter_11
   \   00000076   0x611D             STR      R5,[R3, #+16]
   \   00000078   0xE000             B        ??osRtxThreadWaitEnter_12
   \                     ??osRtxThreadWaitEnter_11: (+1)
   \   0000007A   0x62E5             STR      R5,[R4, #+44]
   \                     ??osRtxThreadWaitEnter_12: (+1)
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD003             BEQ      ??osRtxThreadWaitEnter_7
   \   00000080   0x69C1             LDR      R1,[R0, #+28]
   \   00000082   0x1BC9             SUBS     R1,R1,R7
   \   00000084   0x61C1             STR      R1,[R0, #+28]
   \   00000086   0x6145             STR      R5,[R0, #+20]
    509            thread = osRtxThreadListGet(&osRtxInfo.thread.ready);
   \                     ??osRtxThreadWaitEnter_7: (+1)
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x301C             ADDS     R0,R0,#+28
   \   0000008C   0x.... 0x....      BL       osRtxThreadListGet
   \   00000090   0x0005             MOVS     R5,R0
    510            osRtxThreadSwitch(thread);
   \   00000092   0x2002             MOVS     R0,#+2
   \   00000094   0x7068             STRB     R0,[R5, #+1]
   \   00000096   0x61A5             STR      R5,[R4, #+24]
   \   00000098   0x.... 0x....      BL       osRtxThreadStackCheck
   \   0000009C   0x0028             MOVS     R0,R5
   \   0000009E   0x.... 0x....      BL       EvrRtxThreadSwitch
    511          
    512            return true;
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    513          }
    514          
    515          /// Check current running Thread Stack.

   \                                 In section .text, align 4
    516          __WEAK void osRtxThreadStackCheck (void) {
    517            os_thread_t *thread;
    518          
    519            thread = osRtxThreadGetRunning();
   \                     osRtxThreadStackCheck: (+1)
   \   00000000   0x4808             LDR      R0,??osRtxThreadStackCheck_0
   \   00000002   0x6941             LDR      R1,[R0, #+20]
    520            if (thread != NULL) {
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD100             BNE      ??osRtxThreadStackCheck_1
   \   00000008   0x4770             BX       LR
    521              if ((thread->sp <= (uint32_t)thread->stack_mem) ||
    522                  (*((uint32_t *)thread->stack_mem) != osRtxStackMagicWord)) {
   \                     ??osRtxThreadStackCheck_1: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x6B08             LDR      R0,[R1, #+48]
   \   0000000E   0x6B8A             LDR      R2,[R1, #+56]
   \   00000010   0x4290             CMP      R0,R2
   \   00000012   0xD203             BCS      ??osRtxThreadStackCheck_2
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x4A04             LDR      R2,??osRtxThreadStackCheck_0+0x4  ;; 0xe25a2ea5
   \   00000018   0x4290             CMP      R0,R2
   \   0000001A   0xD002             BEQ      ??osRtxThreadStackCheck_3
    523                osRtxErrorNotify(osRtxErrorStackUnderflow, thread);
   \                     ??osRtxThreadStackCheck_2: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       osRtxErrorNotify
    524              }
    525            }
    526          }
   \                     ??osRtxThreadStackCheck_3: (+1)
   \   00000022   0xBD01             POP      {R0,PC}          ;; return
   \                     ??osRtxThreadStackCheck_0:
   \   00000024   0x........         DC32     osRtxInfo
   \   00000028   0xE25A2EA5         DC32     0xe25a2ea5
    527          
    528          /// Thread post ISR processing.
    529          /// \param[in]  thread          thread object.

   \                                 In section .text, align 2, keep-with-next
    530          void osRtxThreadPostProcess (os_thread_t *thread) {
   \                     osRtxThreadPostProcess: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    531            uint32_t thread_flags;
    532          
    533            if ((thread->state == osRtxThreadInactive) ||
    534                (thread->state == osRtxThreadTerminated)) {
   \   00000004   0x7860             LDRB     R0,[R4, #+1]
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0xD023             BEQ      ??osRtxThreadPostProcess_0
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD021             BEQ      ??osRtxThreadPostProcess_0
    535              return;
    536            }
    537          
    538            // Check if Thread is waiting for Thread Flags
    539            if (thread->state == osRtxThreadWaitingThreadFlags) {
   \   0000000E   0x2833             CMP      R0,#+51
   \   00000010   0xD11F             BNE      ??osRtxThreadPostProcess_0
    540              thread_flags = ThreadFlagsCheck(thread, thread->wait_flags, thread->flags_options);
   \   00000012   0x0026             MOVS     R6,R4
   \   00000014   0x3624             ADDS     R6,R6,#+36
   \   00000016   0x2023             MOVS     R0,#+35
   \   00000018   0x5C22             LDRB     R2,[R4, R0]
   \   0000001A   0x6831             LDR      R1,[R6, #+0]
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       ThreadFlagsCheck
   \   00000022   0x0005             MOVS     R5,R0
    541              if (thread_flags != 0U) {
   \   00000024   0xD015             BEQ      ??osRtxThreadPostProcess_0
    542                osRtxThreadWaitExit(thread, thread_flags, false);
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       EvrRtxThreadUnblocked
   \   0000002E   0x6970             LDR      R0,[R6, #+20]
   \   00000030   0x3020             ADDS     R0,R0,#+32
   \   00000032   0x6005             STR      R5,[R0, #+0]
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       osRtxThreadDelayRemove
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x7060             STRB     R0,[R4, #+1]
   \   0000003E   0x0021             MOVS     R1,R4
   \   00000040   0x....             LDR      R0,??DataTable10_2
   \   00000042   0x.... 0x....      BL       osRtxThreadListPut
    543                EvrRtxThreadFlagsWaitCompleted(thread->wait_flags, thread->flags_options, thread_flags);
   \   00000046   0x002A             MOVS     R2,R5
   \   00000048   0x2023             MOVS     R0,#+35
   \   0000004A   0x5C21             LDRB     R1,[R4, R0]
   \   0000004C   0x6830             LDR      R0,[R6, #+0]
   \   0000004E   0x.... 0x....      BL       EvrRtxThreadFlagsWaitCompleted
    544              }
    545            }
    546          }
   \                     ??osRtxThreadPostProcess_0: (+1)
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
    547          
    548          
    549          //  ==== Service Calls ====
    550          
    551          //  Service Calls definitions
    552          SVC0_4M(ThreadNew,           osThreadId_t,    osThreadFunc_t, void *, const osThreadAttr_t *, void *)
    553          SVC0_1 (ThreadGetName,       const char *,    osThreadId_t)
    554          SVC0_0 (ThreadGetId,         osThreadId_t)
    555          SVC0_1 (ThreadGetState,      osThreadState_t, osThreadId_t)
    556          SVC0_1 (ThreadGetStackSize,  uint32_t, osThreadId_t)
    557          SVC0_1 (ThreadGetStackSpace, uint32_t, osThreadId_t)
    558          SVC0_2 (ThreadSetPriority,   osStatus_t,      osThreadId_t, osPriority_t)
    559          SVC0_1 (ThreadGetPriority,   osPriority_t,    osThreadId_t)
    560          SVC0_0 (ThreadYield,         osStatus_t)
    561          SVC0_1 (ThreadSuspend,       osStatus_t,      osThreadId_t)
    562          SVC0_1 (ThreadResume,        osStatus_t,      osThreadId_t)
    563          SVC0_1 (ThreadDetach,        osStatus_t,      osThreadId_t)
    564          SVC0_1 (ThreadJoin,          osStatus_t,      osThreadId_t)
    565          SVC0_0N(ThreadExit,          void)
    566          SVC0_1 (ThreadTerminate,     osStatus_t,      osThreadId_t)
    567          SVC0_0 (ThreadGetCount,      uint32_t)
    568          SVC0_2 (ThreadEnumerate,     uint32_t,        osThreadId_t *, uint32_t)
    569          SVC0_2 (ThreadFlagsSet,      uint32_t,        osThreadId_t, uint32_t)
    570          SVC0_1 (ThreadFlagsClear,    uint32_t,        uint32_t)
    571          SVC0_0 (ThreadFlagsGet,      uint32_t)
    572          SVC0_3 (ThreadFlagsWait,     uint32_t,        uint32_t, uint32_t, uint32_t)
    573          
    574          /// Create a thread and add it to Active Threads.
    575          /// \note API identical to osThreadContextNew

   \                                 In section .text, align 2, keep-with-next
    576          osThreadId_t svcRtxThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr, void *context) {
   \                     svcRtxThreadNew: (+1)
   \   00000000   0xB5FB             PUSH     {R0,R1,R3-R7,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    577            os_thread_t  *thread;
    578            uint32_t      attr_bits;
    579            void         *stack_mem;
    580            uint32_t      stack_size;
    581            osPriority_t  priority;
    582            uint8_t       flags;
    583            const char   *name;
    584            uint32_t     *ptr;
    585            uint32_t      n;
    586          #if (__DOMAIN_NS == 1U)
    587            TZ_ModuleId_t tz_module;
    588            TZ_MemoryId_t tz_memory;
    589          #endif
    590          
    591            // Check parameters
    592            if (func == NULL) {
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD104             BNE      ??svcRtxThreadNew_0
    593              EvrRtxThreadError(NULL, osErrorParameter);
   \   00000008   0x2103             MOVS     R1,#+3
   \   0000000A   0x43C9             MVNS     R1,R1            ;; #-4
   \   0000000C   0x.... 0x....      BL       EvrRtxThreadError
    594              return NULL;
   \   00000010   0xE0CD             B.N      ??svcRtxThreadNew_1
    595            }
    596          
    597            // Process attributes
    598            if (attr != NULL) {
   \                     ??svcRtxThreadNew_0: (+1)
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD03B             BEQ      ??svcRtxThreadNew_2
    599              name       = attr->name;
   \   00000016   0x6810             LDR      R0,[R2, #+0]
   \   00000018   0x9002             STR      R0,[SP, #+8]
    600              attr_bits  = attr->attr_bits;
   \   0000001A   0x6850             LDR      R0,[R2, #+4]
    601              thread     = attr->cb_mem;
   \   0000001C   0x6895             LDR      R5,[R2, #+8]
    602              stack_mem  = attr->stack_mem;
   \   0000001E   0x6917             LDR      R7,[R2, #+16]
    603              stack_size = attr->stack_size;
   \   00000020   0x6951             LDR      R1,[R2, #+20]
   \   00000022   0x9100             STR      R1,[SP, #+0]
    604              priority   = attr->priority;
   \   00000024   0x6991             LDR      R1,[R2, #+24]
    605          #if (__DOMAIN_NS == 1U)
    606              tz_module  = attr->tz_module;
    607          #endif
    608              if (thread != NULL) {
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD00F             BEQ      ??svcRtxThreadNew_3
    609                if (((uint32_t)thread & 3U) || (attr->cb_size < sizeof(os_thread_t))) {
   \   0000002A   0x07AB             LSLS     R3,R5,#+30
   \   0000002C   0xD110             BNE      ??svcRtxThreadNew_4
   \   0000002E   0x68D2             LDR      R2,[R2, #+12]
   \   00000030   0x2A48             CMP      R2,#+72
   \   00000032   0xD30D             BCC      ??svcRtxThreadNew_4
    610                  EvrRtxThreadError(NULL, osRtxErrorInvalidControlBlock);
    611                  return NULL;
    612                }
    613              } else {
    614                if (attr->cb_size != 0U) {
    615                  EvrRtxThreadError(NULL, osRtxErrorInvalidControlBlock);
    616                  return NULL;
    617                }
    618              }
    619              if (stack_mem != NULL) {
   \                     ??svcRtxThreadNew_5: (+1)
   \   00000034   0x2F00             CMP      R7,#+0
   \   00000036   0xD004             BEQ      ??svcRtxThreadNew_6
    620                if (((uint32_t)stack_mem & 7U) || (stack_size == 0U)) {
   \   00000038   0x077A             LSLS     R2,R7,#+29
   \   0000003A   0xD138             BNE      ??svcRtxThreadNew_7
   \   0000003C   0x9A00             LDR      R2,[SP, #+0]
   \   0000003E   0x2A00             CMP      R2,#+0
   \   00000040   0xD035             BEQ      ??svcRtxThreadNew_7
    621                  EvrRtxThreadError(NULL, osRtxErrorInvalidThreadStack);
    622                  return NULL;
    623                }
    624              }
    625              if (priority == osPriorityNone) {
   \                     ??svcRtxThreadNew_6: (+1)
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0xD10A             BNE      ??svcRtxThreadNew_8
    626                priority = osPriorityNormal;
   \   00000046   0x2118             MOVS     R1,#+24
   \   00000048   0xE00B             B        ??svcRtxThreadNew_9
    627              } else {
   \                     ??svcRtxThreadNew_3: (+1)
   \   0000004A   0x68D2             LDR      R2,[R2, #+12]
   \   0000004C   0x2A00             CMP      R2,#+0
   \   0000004E   0xD0F1             BEQ      ??svcRtxThreadNew_5
   \                     ??svcRtxThreadNew_4: (+1)
   \   00000050   0x2108             MOVS     R1,#+8
   \   00000052   0x43C9             MVNS     R1,R1            ;; #-9
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      BL       EvrRtxThreadError
   \   0000005A   0xE0A8             B.N      ??svcRtxThreadNew_1
    628                if ((priority < osPriorityIdle) || (priority > osPriorityISR)) {
   \                     ??svcRtxThreadNew_8: (+1)
   \   0000005C   0x1E4A             SUBS     R2,R1,#+1
   \   0000005E   0x2A38             CMP      R2,#+56
   \   00000060   0xD20F             BCS      ??svcRtxThreadNew_10
   \                     ??svcRtxThreadNew_9: (+1)
   \   00000062   0x466A             MOV      R2,SP
   \   00000064   0x7111             STRB     R1,[R2, #+4]
   \   00000066   0x4669             MOV      R1,SP
   \   00000068   0x7148             STRB     R0,[R1, #+5]
    629                  EvrRtxThreadError(NULL, osRtxErrorInvalidPriority);
    630                  return NULL;
    631                }
    632              }
    633            } else {
    634              name       = NULL;
    635              attr_bits  = 0U;
    636              thread     = NULL;
    637              stack_mem  = NULL;
    638              stack_size = 0U;
    639              priority   = osPriorityNormal;
    640          #if (__DOMAIN_NS == 1U)
    641              tz_module  = 0U;
    642          #endif
    643            }
    644          
    645            // Check stack size
    646            if ((stack_size != 0U) && ((stack_size & 7U) || (stack_size < (64U + 8U)))) {
   \   0000006A   0x9800             LDR      R0,[SP, #+0]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD118             BNE      ??svcRtxThreadNew_11
    647              EvrRtxThreadError(NULL, osRtxErrorInvalidThreadStack);
    648              return NULL;
    649            }
    650          
    651            // Allocate object memory if not provided
    652            if (thread == NULL) {
   \                     ??svcRtxThreadNew_12: (+1)
   \   00000070   0x2D00             CMP      R5,#+0
   \   00000072   0xD131             BNE      ??svcRtxThreadNew_13
    653              if (osRtxInfo.mpi.thread != NULL) {
   \                     ??svcRtxThreadNew_14: (+1)
   \   00000074   0x....             LDR      R6,??DataTable13
   \   00000076   0x6AB0             LDR      R0,[R6, #+40]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD01E             BEQ      ??svcRtxThreadNew_15
    654                thread = osRtxMemoryPoolAlloc(osRtxInfo.mpi.thread);
   \   0000007C   0x.... 0x....      BL       osRtxMemoryPoolAlloc
   \   00000080   0xE020             B        ??svcRtxThreadNew_16
    655              } else {
   \                     ??svcRtxThreadNew_10: (+1)
   \   00000082   0x210B             MOVS     R1,#+11
   \   00000084   0x43C9             MVNS     R1,R1            ;; #-12
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x.... 0x....      BL       EvrRtxThreadError
   \   0000008C   0xE08F             B.N      ??svcRtxThreadNew_1
   \                     ??svcRtxThreadNew_2: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x9002             STR      R0,[SP, #+8]
   \   00000092   0x466A             MOV      R2,SP
   \   00000094   0x7150             STRB     R0,[R2, #+5]
   \   00000096   0x2700             MOVS     R7,#+0
   \   00000098   0x9000             STR      R0,[SP, #+0]
   \   0000009A   0x2018             MOVS     R0,#+24
   \   0000009C   0x4669             MOV      R1,SP
   \   0000009E   0x7108             STRB     R0,[R1, #+4]
   \   000000A0   0xE7E8             B        ??svcRtxThreadNew_14
   \                     ??svcRtxThreadNew_11: (+1)
   \   000000A2   0x9800             LDR      R0,[SP, #+0]
   \   000000A4   0x0740             LSLS     R0,R0,#+29
   \   000000A6   0xD102             BNE      ??svcRtxThreadNew_7
   \   000000A8   0x9800             LDR      R0,[SP, #+0]
   \   000000AA   0x2848             CMP      R0,#+72
   \   000000AC   0xD2E0             BCS      ??svcRtxThreadNew_12
   \                     ??svcRtxThreadNew_7: (+1)
   \   000000AE   0x210A             MOVS     R1,#+10
   \   000000B0   0x43C9             MVNS     R1,R1            ;; #-11
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x.... 0x....      BL       EvrRtxThreadError
   \   000000B8   0xE079             B.N      ??svcRtxThreadNew_1
    656                thread = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_thread_t), 1U);
   \                     ??svcRtxThreadNew_15: (+1)
   \   000000BA   0x2201             MOVS     R2,#+1
   \   000000BC   0x2148             MOVS     R1,#+72
   \   000000BE   0x6A30             LDR      R0,[R6, #+32]
   \   000000C0   0x.... 0x....      BL       osRtxMemoryAlloc
   \                     ??svcRtxThreadNew_16: (+1)
   \   000000C4   0x0005             MOVS     R5,R0
    657              }
    658              if (thread == NULL) {
   \   000000C6   0xD105             BNE      ??svcRtxThreadNew_17
    659                EvrRtxThreadError(NULL, osErrorNoMemory);
   \   000000C8   0x2104             MOVS     R1,#+4
   \   000000CA   0x43C9             MVNS     R1,R1            ;; #-5
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x.... 0x....      BL       EvrRtxThreadError
    660                return NULL;
   \   000000D2   0xE06C             B.N      ??svcRtxThreadNew_1
    661              }
    662              flags = osRtxFlagSystemObject;
   \                     ??svcRtxThreadNew_17: (+1)
   \   000000D4   0x2401             MOVS     R4,#+1
   \   000000D6   0xE000             B        ??svcRtxThreadNew_18
    663            } else {
    664              flags = 0U;
   \                     ??svcRtxThreadNew_13: (+1)
   \   000000D8   0x2400             MOVS     R4,#+0
    665            }
    666          
    667            // Allocate stack memory if not provided
    668            if (stack_mem == NULL) {
   \                     ??svcRtxThreadNew_18: (+1)
   \   000000DA   0x2F00             CMP      R7,#+0
   \   000000DC   0xD113             BNE      ??svcRtxThreadNew_19
    669              if (stack_size == 0U) {
   \   000000DE   0x....             LDR      R6,??DataTable13
   \   000000E0   0x9800             LDR      R0,[SP, #+0]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD14A             BNE      ??svcRtxThreadNew_20
    670                stack_size = osRtxConfig.thread_stack_size;
   \   000000E6   0x....             LDR      R0,??DataTable14
   \   000000E8   0x6D40             LDR      R0,[R0, #+84]
   \   000000EA   0x9000             STR      R0,[SP, #+0]
    671                if (osRtxInfo.mpi.stack != NULL) {
   \   000000EC   0x6A70             LDR      R0,[R6, #+36]
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD044             BEQ      ??svcRtxThreadNew_20
    672                  stack_mem = osRtxMemoryPoolAlloc(osRtxInfo.mpi.stack);
   \   000000F2   0x.... 0x....      BL       osRtxMemoryPoolAlloc
   \   000000F6   0x0007             MOVS     R7,R0
    673                  if (stack_mem != NULL) {
   \   000000F8   0xD047             BEQ      ??svcRtxThreadNew_21
    674                    flags |= osRtxThreadFlagDefStack;
   \   000000FA   0x0020             MOVS     R0,R4
   \   000000FC   0x2410             MOVS     R4,#+16
   \   000000FE   0x4304             ORRS     R4,R4,R0
    675                  }
    676                } else {
    677                  stack_mem = osRtxMemoryAlloc(osRtxInfo.mem.stack, stack_size, 0U);
    678                }
    679              } else {
    680                stack_mem = osRtxMemoryAlloc(osRtxInfo.mem.stack, stack_size, 0U);
    681              }
    682              if (stack_mem == NULL) {
    683                EvrRtxThreadError(NULL, osErrorNoMemory);
    684                if (flags & osRtxFlagSystemObject) {
    685                  if (osRtxInfo.mpi.thread != NULL) {
    686                    osRtxMemoryPoolFree(osRtxInfo.mpi.thread, thread);
    687                  } else {
    688                    osRtxMemoryFree(osRtxInfo.mem.common, thread);
    689                  }
    690                }
    691                return NULL;
    692              }
    693              flags |= osRtxFlagSystemMemory;
   \                     ??svcRtxThreadNew_22: (+1)
   \   00000100   0x0020             MOVS     R0,R4
   \   00000102   0x2402             MOVS     R4,#+2
   \   00000104   0x4304             ORRS     R4,R4,R0
    694            }
    695          
    696          #if (__DOMAIN_NS == 1U)
    697            // Allocate secure process stack
    698            if (tz_module != 0U) {
    699              tz_memory = TZ_AllocModuleContext_S(tz_module);
    700              if (tz_memory == 0U) {
    701                EvrRtxThreadError(NULL, osRtxErrorTZ_AllocContext_S);
    702                if (flags & osRtxFlagSystemMemory) {
    703                  if (flags & osRtxThreadFlagDefStack) {
    704                    osRtxMemoryPoolFree(osRtxInfo.mpi.stack, thread->stack_mem);
    705                  } else {
    706                    osRtxMemoryFree(osRtxInfo.mem.stack, thread->stack_mem);
    707                  }
    708                }
    709                if (flags & osRtxFlagSystemObject) {
    710                  if (osRtxInfo.mpi.thread != NULL) {
    711                    osRtxMemoryPoolFree(osRtxInfo.mpi.thread, thread);
    712                  } else {
    713                    osRtxMemoryFree(osRtxInfo.mem.common, thread);
    714                  }
    715                }
    716                return NULL;
    717              }
    718            } else {
    719              tz_memory = 0U;
    720            }
    721          #endif
    722          
    723            // Initialize control block
    724            thread->id            = osRtxIdThread;
   \                     ??svcRtxThreadNew_19: (+1)
   \   00000106   0x2001             MOVS     R0,#+1
   \   00000108   0x7028             STRB     R0,[R5, #+0]
    725            thread->state         = osRtxThreadReady;
   \   0000010A   0x7068             STRB     R0,[R5, #+1]
    726            thread->flags         = flags;
   \   0000010C   0x70AC             STRB     R4,[R5, #+2]
    727            thread->attr          = (uint8_t)attr_bits;
   \   0000010E   0x4668             MOV      R0,SP
   \   00000110   0x7940             LDRB     R0,[R0, #+5]
   \   00000112   0x70E8             STRB     R0,[R5, #+3]
    728            thread->name          = name;
   \   00000114   0x9802             LDR      R0,[SP, #+8]
   \   00000116   0x6068             STR      R0,[R5, #+4]
    729            thread->thread_next   = NULL;
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0x60A8             STR      R0,[R5, #+8]
    730            thread->thread_prev   = NULL;
   \   0000011C   0x60E8             STR      R0,[R5, #+12]
    731            thread->delay_next    = NULL;
   \   0000011E   0x6128             STR      R0,[R5, #+16]
    732            thread->delay_prev    = NULL;
   \   00000120   0x6168             STR      R0,[R5, #+20]
    733            thread->thread_join   = NULL;
   \   00000122   0x61A8             STR      R0,[R5, #+24]
    734            thread->delay         = 0U;
   \   00000124   0x61E8             STR      R0,[R5, #+28]
    735            thread->priority      = (int8_t)priority;
   \   00000126   0x4669             MOV      R1,SP
   \   00000128   0x7909             LDRB     R1,[R1, #+4]
   \   0000012A   0x2220             MOVS     R2,#+32
   \   0000012C   0x54A9             STRB     R1,[R5, R2]
    736            thread->priority_base = (int8_t)priority;
   \   0000012E   0x0029             MOVS     R1,R5
   \   00000130   0x3121             ADDS     R1,R1,#+33
   \   00000132   0x466A             MOV      R2,SP
   \   00000134   0x7912             LDRB     R2,[R2, #+4]
   \   00000136   0x700A             STRB     R2,[R1, #+0]
    737            thread->stack_frame   = STACK_FRAME_INIT;
   \   00000138   0x22FD             MOVS     R2,#+253
   \   0000013A   0x704A             STRB     R2,[R1, #+1]
    738            thread->flags_options = 0U;
   \   0000013C   0x7088             STRB     R0,[R1, #+2]
    739            thread->wait_flags    = 0U;
   \   0000013E   0x002C             MOVS     R4,R5
   \   00000140   0x3424             ADDS     R4,R4,#+36
   \   00000142   0x6020             STR      R0,[R4, #+0]
    740            thread->thread_flags  = 0U;
   \   00000144   0x6060             STR      R0,[R4, #+4]
    741            thread->mutex_list    = NULL;
   \   00000146   0x60A0             STR      R0,[R4, #+8]
    742            thread->stack_mem     = stack_mem;
   \   00000148   0x60E7             STR      R7,[R4, #+12]
    743            thread->stack_size    = stack_size;
   \   0000014A   0x9800             LDR      R0,[SP, #+0]
   \   0000014C   0x6120             STR      R0,[R4, #+16]
    744            thread->sp            = (uint32_t)stack_mem + stack_size - 64U;
   \   0000014E   0x9800             LDR      R0,[SP, #+0]
   \   00000150   0x1838             ADDS     R0,R7,R0
   \   00000152   0x3840             SUBS     R0,R0,#+64
   \   00000154   0x6160             STR      R0,[R4, #+20]
   \   00000156   0x9804             LDR      R0,[SP, #+16]
   \   00000158   0x61A0             STR      R0,[R4, #+24]
    745            thread->thread_addr   = (uint32_t)func;
    746          #if (__DOMAIN_NS == 1U)
    747            thread->tz_memory     = tz_memory;
    748          #endif
    749          
    750            // Initialize stack
    751             ptr   = (uint32_t *)stack_mem;
    752            *ptr++ = osRtxStackMagicWord;
   \   0000015A   0x....             LDR      R0,??DataTable14_1  ;; 0xe25a2ea5
   \   0000015C   0x6038             STR      R0,[R7, #+0]
   \   0000015E   0x1D3E             ADDS     R6,R7,#+4
    753            if (osRtxConfig.flags & osRtxConfigStackWatermark) {
   \   00000160   0x....             LDR      R0,??DataTable14
   \   00000162   0x7800             LDRB     R0,[R0, #+0]
   \   00000164   0x0740             LSLS     R0,R0,#+29
   \   00000166   0xD524             BPL      ??svcRtxThreadNew_23
    754              for (n = (stack_size/4U) - (16U + 1U); n; n--) {
   \   00000168   0x9800             LDR      R0,[SP, #+0]
   \   0000016A   0x0880             LSRS     R0,R0,#+2
   \   0000016C   0x3811             SUBS     R0,R0,#+17
   \   0000016E   0xD021             BEQ      ??svcRtxThreadNew_24
   \   00000170   0x....             LDR      R1,??DataTable14_2  ;; 0xcccccccc
    755                *ptr++ = osRtxStackFillPattern;
   \                     ??svcRtxThreadNew_25: (+1)
   \   00000172   0x6031             STR      R1,[R6, #+0]
   \   00000174   0x1D36             ADDS     R6,R6,#+4
    756              }
   \   00000176   0x1E40             SUBS     R0,R0,#+1
   \   00000178   0xD01C             BEQ      ??svcRtxThreadNew_24
   \   0000017A   0xE7FA             B        ??svcRtxThreadNew_25
    757            } else {
   \                     ??svcRtxThreadNew_20: (+1)
   \   0000017C   0x2200             MOVS     R2,#+0
   \   0000017E   0x9900             LDR      R1,[SP, #+0]
   \   00000180   0x6970             LDR      R0,[R6, #+20]
   \   00000182   0x.... 0x....      BL       osRtxMemoryAlloc
   \   00000186   0x0007             MOVS     R7,R0
   \   00000188   0xD1BA             BNE      ??svcRtxThreadNew_22
   \                     ??svcRtxThreadNew_21: (+1)
   \   0000018A   0x2104             MOVS     R1,#+4
   \   0000018C   0x43C9             MVNS     R1,R1            ;; #-5
   \   0000018E   0x2000             MOVS     R0,#+0
   \   00000190   0x.... 0x....      BL       EvrRtxThreadError
   \   00000194   0x07E0             LSLS     R0,R4,#+31
   \   00000196   0xD50A             BPL      ??svcRtxThreadNew_1
   \   00000198   0x6AB0             LDR      R0,[R6, #+40]
   \   0000019A   0x2800             CMP      R0,#+0
   \   0000019C   0xD003             BEQ      ??svcRtxThreadNew_26
   \   0000019E   0x0029             MOVS     R1,R5
   \   000001A0   0x.... 0x....      BL       osRtxMemoryPoolFree
   \   000001A4   0xE003             B        ??svcRtxThreadNew_1
   \                     ??svcRtxThreadNew_26: (+1)
   \   000001A6   0x0029             MOVS     R1,R5
   \   000001A8   0x6A30             LDR      R0,[R6, #+32]
   \   000001AA   0x.... 0x....      BL       osRtxMemoryFree
   \                     ??svcRtxThreadNew_1: (+1)
   \   000001AE   0x2000             MOVS     R0,#+0
   \   000001B0   0xE027             B        ??svcRtxThreadNew_27
    758              ptr = (uint32_t *)thread->sp;
   \                     ??svcRtxThreadNew_23: (+1)
   \   000001B2   0x6966             LDR      R6,[R4, #+20]
    759            }
    760            for (n = 13U; n; n--) {
    761              *ptr++ = 0U;                        // R4..R11, R0..R3, R12
   \                     ??svcRtxThreadNew_24: (+1)
   \   000001B4   0x2134             MOVS     R1,#+52
   \   000001B6   0x0030             MOVS     R0,R6
   \   000001B8   0x.... 0x....      BL       __aeabi_memclr4
    762            }
   \   000001BC   0x0030             MOVS     R0,R6
   \   000001BE   0x3034             ADDS     R0,R0,#+52
    763            *ptr++   = (uint32_t)osThreadExit;    // LR
   \   000001C0   0x....             LDR      R1,??DataTable15
   \   000001C2   0x6001             STR      R1,[R0, #+0]
    764            *ptr++   = (uint32_t)func;            // PC
   \   000001C4   0x9904             LDR      R1,[SP, #+16]
   \   000001C6   0x6041             STR      R1,[R0, #+4]
    765            *ptr++   = xPSR_INIT(
    766                        (osRtxConfig.flags & osRtxConfigPrivilegedMode),
    767                        ((uint32_t)func & 1U)
    768                       );                         // xPSR
   \   000001C8   0x2180             MOVS     R1,#+128
   \   000001CA   0x0449             LSLS     R1,R1,#+17       ;; #+16777216
   \   000001CC   0x6081             STR      R1,[R0, #+8]
    769            *(ptr-8) = (uint32_t)argument;        // R0
   \   000001CE   0x9905             LDR      R1,[SP, #+20]
   \   000001D0   0x3814             SUBS     R0,R0,#+20
   \   000001D2   0x6001             STR      R1,[R0, #+0]
    770          
    771            // Register post ISR processing function
    772            osRtxInfo.post_process.thread = osRtxThreadPostProcess;
   \   000001D4   0x....             LDR      R0,??DataTable15_1
   \   000001D6   0x....             LDR      R1,??DataTable15_2
   \   000001D8   0x6608             STR      R0,[R1, #+96]
    773          
    774            EvrRtxThreadCreated(thread);
   \   000001DA   0x0028             MOVS     R0,R5
   \   000001DC   0x.... 0x....      BL       EvrRtxThreadCreated
    775          
    776            /* Notify the OS event observer of a new thread. */
    777            if (osEventObs && osEventObs->thread_create) {
   \   000001E0   0x....             LDR      R0,??DataTable15_3
   \   000001E2   0x6800             LDR      R0,[R0, #+0]
   \   000001E4   0x2800             CMP      R0,#+0
   \   000001E6   0xD006             BEQ      ??svcRtxThreadNew_28
   \   000001E8   0x6882             LDR      R2,[R0, #+8]
   \   000001EA   0x0010             MOVS     R0,R2
   \   000001EC   0xD003             BEQ      ??svcRtxThreadNew_28
    778              thread->context = osEventObs->thread_create((int)thread, context);
   \   000001EE   0x9906             LDR      R1,[SP, #+24]
   \   000001F0   0x0028             MOVS     R0,R5
   \   000001F2   0x4790             BLX      R2
   \   000001F4   0xE000             B        ??svcRtxThreadNew_29
    779            } else {
    780              thread->context = context;
   \                     ??svcRtxThreadNew_28: (+1)
   \   000001F6   0x9806             LDR      R0,[SP, #+24]
   \                     ??svcRtxThreadNew_29: (+1)
   \   000001F8   0x6220             STR      R0,[R4, #+32]
    781            }
    782          
    783            osRtxThreadDispatch(thread);
   \   000001FA   0x0028             MOVS     R0,R5
   \   000001FC   0x.... 0x....      BL       osRtxThreadDispatch
    784          
    785            return thread;
   \   00000200   0x0028             MOVS     R0,R5
   \                     ??svcRtxThreadNew_27: (+1)
   \   00000202   0xB007             ADD      SP,SP,#+28
   \   00000204   0xBDF0             POP      {R4-R7,PC}       ;; return
    786          }
    787          
    788          /// Get name of a thread.
    789          /// \note API identical to osThreadGetName

   \                                 In section .text, align 2, keep-with-next
    790          const char *svcRtxThreadGetName (osThreadId_t thread_id) {
   \                     svcRtxThreadGetName: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    791            os_thread_t *thread = (os_thread_t *)thread_id;
    792          
    793            // Check parameters
    794            if ((thread == NULL) || (thread->id != osRtxIdThread)) {
   \   00000004   0xD005             BEQ      ??svcRtxThreadGetName_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD102             BNE      ??svcRtxThreadGetName_0
    795              EvrRtxThreadGetName(thread, NULL);
    796              return NULL;
    797            }
    798          
    799            // Check object state
    800            if (thread->state == osRtxObjectInactive) {
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE      ??svcRtxThreadGetName_1
    801              EvrRtxThreadGetName(thread, NULL);
   \                     ??svcRtxThreadGetName_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       EvrRtxThreadGetName
    802              return NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}
    803            }
    804          
    805            EvrRtxThreadGetName(thread, thread->name);
   \                     ??svcRtxThreadGetName_1: (+1)
   \   0000001E   0x6861             LDR      R1,[R4, #+4]
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       EvrRtxThreadGetName
    806          
    807            return thread->name;
   \   00000026   0x6860             LDR      R0,[R4, #+4]
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    808          }
    809          
    810          /// Return the thread ID of the current running thread.
    811          /// \note API identical to osThreadGetId

   \                                 In section .text, align 2, keep-with-next
    812          osThreadId_t svcRtxThreadGetId (void) {
   \                     svcRtxThreadGetId: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    813            os_thread_t *thread;
    814          
    815            thread = osRtxThreadGetRunning();
   \   00000002   0x....             LDR      R0,??DataTable15_2
   \   00000004   0x6944             LDR      R4,[R0, #+20]
    816            EvrRtxThreadGetId(thread);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       EvrRtxThreadGetId
    817            return thread;
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    818          }
    819          
    820          /// Get current thread state of a thread.
    821          /// \note API identical to osThreadGetState

   \                                 In section .text, align 2, keep-with-next
    822          osThreadState_t svcRtxThreadGetState (osThreadId_t thread_id) {
   \                     svcRtxThreadGetState: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    823            os_thread_t *thread = (os_thread_t *)thread_id;
    824          
    825            // Check parameters
    826            if ((thread == NULL) || (thread->id != osRtxIdThread)) {
   \   00000004   0xD002             BEQ      ??svcRtxThreadGetState_0
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD006             BEQ      ??svcRtxThreadGetState_1
    827              EvrRtxThreadGetState(thread, osThreadError);
   \                     ??svcRtxThreadGetState_0: (+1)
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0x43E4             MVNS     R4,R4            ;; #-1
   \   00000010   0x0021             MOVS     R1,R4
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       EvrRtxThreadGetState
    828              return osThreadError;
   \   00000018   0xE007             B        ??svcRtxThreadGetState_2
    829            }
    830          
    831            EvrRtxThreadGetState(thread, (osThreadState_t)(thread->state & osRtxThreadStateMask));
   \                     ??svcRtxThreadGetState_1: (+1)
   \   0000001A   0x240F             MOVS     R4,#+15
   \   0000001C   0x7869             LDRB     R1,[R5, #+1]
   \   0000001E   0x4021             ANDS     R1,R1,R4
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       EvrRtxThreadGetState
    832          
    833            return ((osThreadState_t)(thread->state & osRtxThreadStateMask));
   \   00000026   0x7868             LDRB     R0,[R5, #+1]
   \   00000028   0x4004             ANDS     R4,R4,R0
   \                     ??svcRtxThreadGetState_2: (+1)
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    834          }
    835          
    836          /// Get stack size of a thread.
    837          /// \note API identical to osThreadGetStackSize

   \                                 In section .text, align 2, keep-with-next
    838          uint32_t svcRtxThreadGetStackSize (osThreadId_t thread_id) {
   \                     svcRtxThreadGetStackSize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    839            os_thread_t *thread = (os_thread_t *)thread_id;
    840          
    841            // Check parameters
    842            if ((thread == NULL) || (thread->id != osRtxIdThread)) {
   \   00000004   0xD005             BEQ      ??svcRtxThreadGetStackSize_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD102             BNE      ??svcRtxThreadGetStackSize_0
    843              EvrRtxThreadGetStackSize(thread, 0U);
    844              return 0U;
    845            }
    846          
    847            // Check object state
    848            if (thread->state == osRtxObjectInactive) {
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE      ??svcRtxThreadGetStackSize_1
    849              EvrRtxThreadGetStackSize(thread, 0U);
   \                     ??svcRtxThreadGetStackSize_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       EvrRtxThreadGetStackSize
    850              return 0U;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}
    851            }
    852          
    853            EvrRtxThreadGetStackSize(thread, thread->stack_size);
   \                     ??svcRtxThreadGetStackSize_1: (+1)
   \   0000001E   0x6B61             LDR      R1,[R4, #+52]
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       EvrRtxThreadGetStackSize
    854          
    855            return thread->stack_size;
   \   00000026   0x6B60             LDR      R0,[R4, #+52]
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    856          }
    857          
    858          /// Get available stack space of a thread based on stack watermark recording during execution.
    859          /// \note API identical to osThreadGetStackSpace

   \                                 In section .text, align 2, keep-with-next
    860          uint32_t svcRtxThreadGetStackSpace (osThreadId_t thread_id) {
   \                     svcRtxThreadGetStackSpace: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    861            os_thread_t *thread = (os_thread_t *)thread_id;
    862            uint32_t    *stack;
    863            uint32_t     space;
    864          
    865            // Check parameters
    866            if ((thread == NULL) || (thread->id != osRtxIdThread)) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD010             BEQ      ??svcRtxThreadGetStackSpace_0
   \   00000006   0x7801             LDRB     R1,[R0, #+0]
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD10D             BNE      ??svcRtxThreadGetStackSpace_0
    867              EvrRtxThreadGetStackSpace(thread, 0U);
    868              return 0U;
    869            }
    870          
    871            // Check object state
    872            if (thread->state == osRtxObjectInactive) {
   \   0000000C   0x7841             LDRB     R1,[R0, #+1]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD00A             BEQ      ??svcRtxThreadGetStackSpace_0
    873              EvrRtxThreadGetStackSpace(thread, 0U);
    874              return 0U;
    875            }
    876          
    877            if ((osRtxConfig.flags & osRtxConfigStackWatermark) == 0U) {
   \   00000012   0x2404             MOVS     R4,#+4
   \   00000014   0x....             LDR      R1,??DataTable14
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x4021             ANDS     R1,R1,R4
   \   0000001A   0xD005             BEQ      ??svcRtxThreadGetStackSpace_0
    878              EvrRtxThreadGetStackSpace(thread, 0U);
    879              return 0U;
    880            }
    881          
    882            stack = thread->stack_mem;
    883            if (*stack++ != osRtxStackMagicWord) {
   \   0000001C   0x6B02             LDR      R2,[R0, #+48]
   \   0000001E   0x1D11             ADDS     R1,R2,#+4
   \   00000020   0x6812             LDR      R2,[R2, #+0]
   \   00000022   0x....             LDR      R3,??DataTable14_1  ;; 0xe25a2ea5
   \   00000024   0x429A             CMP      R2,R3
   \   00000026   0xD004             BEQ      ??svcRtxThreadGetStackSpace_1
    884              EvrRtxThreadGetStackSpace(thread, 0U);
   \                     ??svcRtxThreadGetStackSpace_0: (+1)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x.... 0x....      BL       EvrRtxThreadGetStackSpace
    885              return 0U;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD10             POP      {R4,PC}
    886            }
    887            for (space = 4U; space < thread->stack_size; space += 4U) {
   \                     ??svcRtxThreadGetStackSpace_1: (+1)
   \   00000032   0x....             LDR      R2,??DataTable14_2  ;; 0xcccccccc
   \   00000034   0xE001             B        ??svcRtxThreadGetStackSpace_2
    888              if (*stack++ != osRtxStackFillPattern) {
   \                     ??svcRtxThreadGetStackSpace_3: (+1)
   \   00000036   0x1D09             ADDS     R1,R1,#+4
   \   00000038   0x1D24             ADDS     R4,R4,#+4
   \                     ??svcRtxThreadGetStackSpace_2: (+1)
   \   0000003A   0x6B43             LDR      R3,[R0, #+52]
   \   0000003C   0x429C             CMP      R4,R3
   \   0000003E   0xD202             BCS      ??svcRtxThreadGetStackSpace_4
   \   00000040   0x680B             LDR      R3,[R1, #+0]
   \   00000042   0x4293             CMP      R3,R2
   \   00000044   0xD0F7             BEQ      ??svcRtxThreadGetStackSpace_3
    889                break;
    890              }
    891            }
    892          
    893            EvrRtxThreadGetStackSpace(thread, space);
   \                     ??svcRtxThreadGetStackSpace_4: (+1)
   \   00000046   0x0021             MOVS     R1,R4
   \   00000048   0x.... 0x....      BL       EvrRtxThreadGetStackSpace
    894          
    895            return space;
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
    896          }
    897          
    898          /// Change priority of a thread.
    899          /// \note API identical to osThreadSetPriority

   \                                 In section .text, align 2, keep-with-next
    900          osStatus_t svcRtxThreadSetPriority (osThreadId_t thread_id, osPriority_t priority) {
   \                     svcRtxThreadSetPriority: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    901            os_thread_t *thread = (os_thread_t *)thread_id;
    902          
    903            // Check parameters
    904            if ((thread == NULL) || (thread->id != osRtxIdThread) ||
    905                (priority < osPriorityIdle) || (priority > osPriorityISR)) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD005             BEQ      ??svcRtxThreadSetPriority_0
   \   00000006   0x7802             LDRB     R2,[R0, #+0]
   \   00000008   0x2A01             CMP      R2,#+1
   \   0000000A   0xD102             BNE      ??svcRtxThreadSetPriority_0
   \   0000000C   0x1E4A             SUBS     R2,R1,#+1
   \   0000000E   0x2A38             CMP      R2,#+56
   \   00000010   0xD301             BCC      ??svcRtxThreadSetPriority_1
    906              EvrRtxThreadError(thread, osErrorParameter);
   \                     ??svcRtxThreadSetPriority_0: (+1)
   \   00000012   0x2403             MOVS     R4,#+3
   \   00000014   0xE006             B.N      ??svcRtxThreadSetPriority_2
    907              return osErrorParameter;
    908            }
    909          
    910            // Check object state
    911            if ((thread->state == osRtxThreadInactive) ||
    912                (thread->state == osRtxThreadTerminated)) {
   \                     ??svcRtxThreadSetPriority_1: (+1)
   \   00000016   0x1C42             ADDS     R2,R0,#+1
   \   00000018   0x7813             LDRB     R3,[R2, #+0]
   \   0000001A   0x001C             MOVS     R4,R3
   \   0000001C   0xD001             BEQ      ??svcRtxThreadSetPriority_3
   \   0000001E   0x2B04             CMP      R3,#+4
   \   00000020   0xD106             BNE      ??svcRtxThreadSetPriority_4
    913              EvrRtxThreadError(thread, osErrorResource);
   \                     ??svcRtxThreadSetPriority_3: (+1)
   \   00000022   0x2402             MOVS     R4,#+2
   \                     ??svcRtxThreadSetPriority_2: (+1)
   \   00000024   0x43E4             MVNS     R4,R4            ;; #-3
   \   00000026   0x0021             MOVS     R1,R4
   \   00000028   0x.... 0x....      BL       EvrRtxThreadError
    914              return osErrorResource;
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0xBD10             POP      {R4,PC}
    915            }
    916          
    917            if (thread->priority   != (int8_t)priority) {
   \                     ??svcRtxThreadSetPriority_4: (+1)
   \   00000030   0x231F             MOVS     R3,#+31
   \   00000032   0x56D3             LDRSB    R3,[R2, R3]
   \   00000034   0xB24C             SXTB     R4,R1
   \   00000036   0x42A3             CMP      R3,R4
   \   00000038   0xD007             BEQ      ??svcRtxThreadSetPriority_5
    918              thread->priority      = (int8_t)priority;
   \   0000003A   0x77D1             STRB     R1,[R2, #+31]
    919              thread->priority_base = (int8_t)priority;
   \   0000003C   0x2221             MOVS     R2,#+33
   \   0000003E   0x5481             STRB     R1,[R0, R2]
    920              osRtxThreadListSort(thread);
   \   00000040   0x.... 0x....      BL       osRtxThreadListSort
    921              osRtxThreadDispatch(NULL);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x.... 0x....      BL       osRtxThreadDispatch
    922            }
    923          
    924            return osOK;
   \                     ??svcRtxThreadSetPriority_5: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xBD10             POP      {R4,PC}          ;; return
    925          }
    926          
    927          /// Get current priority of a thread.
    928          /// \note API identical to osThreadGetPriority

   \                                 In section .text, align 2, keep-with-next
    929          osPriority_t svcRtxThreadGetPriority (osThreadId_t thread_id) {
   \                     svcRtxThreadGetPriority: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    930            os_thread_t *thread = (os_thread_t *)thread_id;
    931          
    932            // Check parameters
    933            if ((thread == NULL) || (thread->id != osRtxIdThread)) {
   \   00000004   0xD007             BEQ      ??svcRtxThreadGetPriority_0
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD104             BNE      ??svcRtxThreadGetPriority_0
    934              EvrRtxThreadGetPriority(thread, osPriorityError);
    935              return osPriorityError;
    936            }
    937          
    938            // Check object state
    939            if ((thread->state == osRtxThreadInactive) ||
    940                (thread->state == osRtxThreadTerminated)) {
   \   0000000C   0x7868             LDRB     R0,[R5, #+1]
   \   0000000E   0x0001             MOVS     R1,R0
   \   00000010   0xD001             BEQ      ??svcRtxThreadGetPriority_0
   \   00000012   0x2804             CMP      R0,#+4
   \   00000014   0xD107             BNE      ??svcRtxThreadGetPriority_1
    941              EvrRtxThreadGetPriority(thread, osPriorityError);
   \                     ??svcRtxThreadGetPriority_0: (+1)
   \   00000016   0x2400             MOVS     R4,#+0
   \   00000018   0x43E4             MVNS     R4,R4            ;; #-1
   \   0000001A   0x0021             MOVS     R1,R4
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0x.... 0x....      BL       EvrRtxThreadGetPriority
    942              return osPriorityError;
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}
    943            }
    944          
    945            EvrRtxThreadGetPriority(thread, (osPriority_t)thread->priority);
   \                     ??svcRtxThreadGetPriority_1: (+1)
   \   00000026   0x2020             MOVS     R0,#+32
   \   00000028   0x5629             LDRSB    R1,[R5, R0]
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x.... 0x....      BL       EvrRtxThreadGetPriority
    946          
    947            return ((osPriority_t)thread->priority);
   \   00000030   0x2020             MOVS     R0,#+32
   \   00000032   0x5628             LDRSB    R0,[R5, R0]
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    948          }
    949          
    950          /// Pass control to next thread that is in state READY.
    951          /// \note API identical to osThreadYield

   \                                 In section .text, align 2, keep-with-next
    952          osStatus_t svcRtxThreadYield (void) {
   \                     svcRtxThreadYield: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    953            uint8_t      kernel_state;
    954            os_thread_t *thread_running;
    955            os_thread_t *thread_ready;
    956          
    957            kernel_state   = osRtxKernelGetState();
    958            thread_running = osRtxThreadGetRunning();
   \   00000002   0x....             LDR      R4,??DataTable15_2
   \   00000004   0x6966             LDR      R6,[R4, #+20]
    959            thread_ready   = osRtxInfo.thread.ready.thread_list;
   \   00000006   0x6A65             LDR      R5,[R4, #+36]
    960            if ((kernel_state == osRtxKernelRunning) &&
    961                (thread_ready != NULL) && (thread_running != NULL) &&
    962                (thread_ready->priority == thread_running->priority)) {
   \   00000008   0x7A20             LDRB     R0,[R4, #+8]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD11B             BNE      ??svcRtxThreadYield_0
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD019             BEQ      ??svcRtxThreadYield_0
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD017             BEQ      ??svcRtxThreadYield_0
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0x5628             LDRSB    R0,[R5, R0]
   \   0000001A   0x2120             MOVS     R1,#+32
   \   0000001C   0x5671             LDRSB    R1,[R6, R1]
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD111             BNE      ??svcRtxThreadYield_0
    963              osRtxThreadListRemove(thread_ready);
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0x.... 0x....      BL       osRtxThreadListRemove
    964              osRtxThreadReadyPut(thread_running);
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x7070             STRB     R0,[R6, #+1]
   \   0000002C   0x0031             MOVS     R1,R6
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x301C             ADDS     R0,R0,#+28
   \   00000032   0x.... 0x....      BL       osRtxThreadListPut
    965              osRtxThreadSwitch(thread_ready);
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0x7068             STRB     R0,[R5, #+1]
   \   0000003A   0x61A5             STR      R5,[R4, #+24]
   \   0000003C   0x.... 0x....      BL       osRtxThreadStackCheck
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0x.... 0x....      BL       EvrRtxThreadSwitch
    966            }
    967          
    968            return osOK;
   \                     ??svcRtxThreadYield_0: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xBD70             POP      {R4-R6,PC}       ;; return
    969          }
    970          
    971          /// Suspend execution of a thread.
    972          /// \note API identical to osThreadSuspend

   \                                 In section .text, align 2, keep-with-next
    973          osStatus_t svcRtxThreadSuspend (osThreadId_t thread_id) {
   \                     svcRtxThreadSuspend: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
    974            os_thread_t *thread = (os_thread_t *)thread_id;
    975          
    976            // Check parameters
    977            if ((thread == NULL) || (thread->id != osRtxIdThread)) {
   \   00000004   0xD002             BEQ      ??svcRtxThreadSuspend_0
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD001             BEQ      ??svcRtxThreadSuspend_1
    978              EvrRtxThreadError(thread, osErrorParameter);
   \                     ??svcRtxThreadSuspend_0: (+1)
   \   0000000C   0x2403             MOVS     R4,#+3
   \   0000000E   0xE010             B.N      ??svcRtxThreadSuspend_2
    979              return osErrorParameter;
    980            }
    981          
    982            // Check object state
    983            switch (thread->state & osRtxThreadStateMask) {
   \                     ??svcRtxThreadSuspend_1: (+1)
   \   00000010   0x7868             LDRB     R0,[R5, #+1]
   \   00000012   0x0700             LSLS     R0,R0,#+28
   \   00000014   0x0F00             LSRS     R0,R0,#+28
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD00C             BEQ      ??svcRtxThreadSuspend_3
   \   0000001A   0xD309             BCC      ??svcRtxThreadSuspend_4
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD00D             BEQ      ??svcRtxThreadSuspend_5
   \   00000020   0xD206             BCS      ??svcRtxThreadSuspend_4
    984              case osRtxThreadRunning:
    985                if ((osRtxKernelGetState() != osRtxKernelRunning) ||
    986                    (osRtxInfo.thread.ready.thread_list == NULL)) {
   \   00000022   0x....             LDR      R4,??DataTable15_2
   \   00000024   0x7A20             LDRB     R0,[R4, #+8]
   \   00000026   0x2802             CMP      R0,#+2
   \   00000028   0xD102             BNE      ??svcRtxThreadSuspend_4
   \   0000002A   0x6A60             LDR      R0,[R4, #+36]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD10B             BNE      ??svcRtxThreadSuspend_6
    987                  EvrRtxThreadError(thread, osErrorResource);
    988                  return osErrorResource;
    989                }
    990                break;
    991              case osRtxThreadReady:
    992                osRtxThreadListRemove(thread);
    993                break;
    994              case osRtxThreadBlocked:
    995                osRtxThreadListRemove(thread);
    996                osRtxThreadDelayRemove(thread);
    997                break;
    998              case osRtxThreadInactive:
    999              case osRtxThreadTerminated:
   1000              default:
   1001                EvrRtxThreadError(thread, osErrorResource);
   \                     ??svcRtxThreadSuspend_4: (+1)
   \   00000030   0x2402             MOVS     R4,#+2
   \                     ??svcRtxThreadSuspend_2: (+1)
   \   00000032   0x....             B.N      ?Subroutine0
   \                     ??svcRtxThreadSuspend_3: (+1)
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x.... 0x....      BL       osRtxThreadListRemove
   \   0000003A   0xE005             B        ??svcRtxThreadSuspend_6
   \                     ??svcRtxThreadSuspend_5: (+1)
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x.... 0x....      BL       osRtxThreadListRemove
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0x.... 0x....      BL       osRtxThreadDelayRemove
   1002                return osErrorResource;
   1003            }
   1004          
   1005            EvrRtxThreadSuspended(thread);
   \                     ??svcRtxThreadSuspend_6: (+1)
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       EvrRtxThreadSuspended
   1006          
   1007            if (thread->state == osRtxThreadRunning) {
   \   0000004E   0x....             LDR      R4,??DataTable15_2
   \   00000050   0x7868             LDRB     R0,[R5, #+1]
   \   00000052   0x2802             CMP      R0,#+2
   \   00000054   0xD10C             BNE      ??svcRtxThreadSuspend_7
   1008              osRtxThreadSwitch(osRtxThreadListGet(&osRtxInfo.thread.ready));
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x301C             ADDS     R0,R0,#+28
   \   0000005A   0x.... 0x....      BL       osRtxThreadListGet
   \   0000005E   0x0006             MOVS     R6,R0
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x7070             STRB     R0,[R6, #+1]
   \   00000064   0x61A6             STR      R6,[R4, #+24]
   \   00000066   0x.... 0x....      BL       osRtxThreadStackCheck
   \   0000006A   0x0030             MOVS     R0,R6
   \   0000006C   0x.... 0x....      BL       EvrRtxThreadSwitch
   1009            }
   1010          
   1011            // Update Thread State and put it into Delay list
   1012            thread->state = osRtxThreadBlocked;
   \                     ??svcRtxThreadSuspend_7: (+1)
   \   00000070   0x2003             MOVS     R0,#+3
   \   00000072   0x7068             STRB     R0,[R5, #+1]
   1013            thread->thread_prev = NULL;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x60E8             STR      R0,[R5, #+12]
   1014            thread->thread_next = NULL;
   \   00000078   0x60A8             STR      R0,[R5, #+8]
   1015            osRtxThreadDelayInsert(thread, osWaitForever);
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x6B22             LDR      R2,[R4, #+48]
   \   0000007E   0xE001             B        ??svcRtxThreadSuspend_8
   \                     ??svcRtxThreadSuspend_9: (+1)
   \   00000080   0x0011             MOVS     R1,R2
   \   00000082   0x6912             LDR      R2,[R2, #+16]
   \                     ??svcRtxThreadSuspend_8: (+1)
   \   00000084   0x2A00             CMP      R2,#+0
   \   00000086   0xD1FB             BNE      ??svcRtxThreadSuspend_9
   \   00000088   0x2200             MOVS     R2,#+0
   \   0000008A   0x43D2             MVNS     R2,R2            ;; #-1
   \   0000008C   0x61EA             STR      R2,[R5, #+28]
   \   0000008E   0x6169             STR      R1,[R5, #+20]
   \   00000090   0x6128             STR      R0,[R5, #+16]
   \   00000092   0x2900             CMP      R1,#+0
   \   00000094   0xD001             BEQ      ??svcRtxThreadSuspend_10
   \   00000096   0x610D             STR      R5,[R1, #+16]
   \   00000098   0xBD70             POP      {R4-R6,PC}
   \                     ??svcRtxThreadSuspend_10: (+1)
   \   0000009A   0x6325             STR      R5,[R4, #+48]
   1016          
   1017            return osOK;
   \   0000009C   0xBD70             POP      {R4-R6,PC}       ;; return
   1018          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x43E4             MVNS     R4,R4            ;; #-3
   \   00000002   0x0021             MOVS     R1,R4
   \   00000004   0x0028             MOVS     R0,R5
   \   00000006   0x.... 0x....      BL       EvrRtxThreadError
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xBD70             POP      {R4-R6,PC}
   1019          
   1020          /// Resume execution of a thread.
   1021          /// \note API identical to osThreadResume

   \                                 In section .text, align 2, keep-with-next
   1022          osStatus_t svcRtxThreadResume (osThreadId_t thread_id) {
   \                     svcRtxThreadResume: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   1023            os_thread_t *thread = (os_thread_t *)thread_id;
   1024          
   1025            // Check parameters
   1026            if ((thread == NULL) || (thread->id != osRtxIdThread)) {
   \   00000004   0xD002             BEQ      ??svcRtxThreadResume_0
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD001             BEQ      ??svcRtxThreadResume_1
   1027              EvrRtxThreadError(thread, osErrorParameter);
   \                     ??svcRtxThreadResume_0: (+1)
   \   0000000C   0x2403             MOVS     R4,#+3
   \   0000000E   0xE005             B.N      ??svcRtxThreadResume_2
   1028              return osErrorParameter;
   1029            }
   1030          
   1031            // Check object state
   1032            if ((thread->state & osRtxThreadStateMask) != osRtxThreadBlocked) {
   \                     ??svcRtxThreadResume_1: (+1)
   \   00000010   0x7868             LDRB     R0,[R5, #+1]
   \   00000012   0x0700             LSLS     R0,R0,#+28
   \   00000014   0x0F00             LSRS     R0,R0,#+28
   \   00000016   0x2803             CMP      R0,#+3
   \   00000018   0xD001             BEQ      ??svcRtxThreadResume_3
   1033              EvrRtxThreadError(thread, osErrorResource);
   \   0000001A   0x2402             MOVS     R4,#+2
   1034              return osErrorResource;
   1035            }
   \                     ??svcRtxThreadResume_2: (+1)
   \   0000001C   0x....             B.N      ?Subroutine2
   1036          
   1037            EvrRtxThreadResumed(thread);
   \                     ??svcRtxThreadResume_3: (+1)
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0x.... 0x....      BL       EvrRtxThreadResumed
   1038          
   1039            // Wakeup Thread
   1040            osRtxThreadListRemove(thread);
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0x.... 0x....      BL       osRtxThreadListRemove
   1041            osRtxThreadDelayRemove(thread);
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x.... 0x....      BL       osRtxThreadDelayRemove
   1042            osRtxThreadDispatch(thread);
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x.... 0x....      BL       osRtxThreadDispatch
   1043          
   1044            return osOK;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1045          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x43E4             MVNS     R4,R4            ;; #-3
   \   00000002   0x0021             MOVS     R1,R4
   \   00000004   0x0028             MOVS     R0,R5
   \   00000006   0x.... 0x....      BL       EvrRtxThreadError
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
   1046          
   1047          /// Free Thread resources.
   1048          /// \param[in]  thread          thread object.

   \                                 In section .text, align 2, keep-with-next
   1049          static void osRtxThreadFree (os_thread_t *thread) {
   \                     osRtxThreadFree: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1050          
   1051            // Mark object as inactive
   1052            thread->state = osRtxThreadInactive;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x7060             STRB     R0,[R4, #+1]
   1053          
   1054          #if (__DOMAIN_NS == 1U)
   1055            // Free secure process stack
   1056            if (thread->tz_memory != 0U) {
   1057              TZ_FreeModuleContext_S(thread->tz_memory);
   1058            }
   1059          #endif
   1060          
   1061            // Free stack memory
   1062            if (thread->flags & osRtxFlagSystemMemory) {
   \   00000008   0x78A0             LDRB     R0,[R4, #+2]
   \   0000000A   0x0781             LSLS     R1,R0,#+30
   \   0000000C   0xD50A             BPL      ??osRtxThreadFree_0
   1063              if (thread->flags & osRtxThreadFlagDefStack) {
   \   0000000E   0x6B21             LDR      R1,[R4, #+48]
   \   00000010   0x....             LDR      R2,??DataTable20
   \   00000012   0x06C0             LSLS     R0,R0,#+27
   \   00000014   0xD503             BPL      ??osRtxThreadFree_1
   1064                osRtxMemoryPoolFree(osRtxInfo.mpi.stack, thread->stack_mem);
   \   00000016   0x6910             LDR      R0,[R2, #+16]
   \   00000018   0x.... 0x....      BL       osRtxMemoryPoolFree
   \   0000001C   0xE002             B        ??osRtxThreadFree_0
   1065              } else {
   1066                osRtxMemoryFree(osRtxInfo.mem.stack, thread->stack_mem);
   \                     ??osRtxThreadFree_1: (+1)
   \   0000001E   0x6810             LDR      R0,[R2, #+0]
   \   00000020   0x.... 0x....      BL       osRtxMemoryFree
   1067              }
   1068            }
   1069          
   1070            // Free object memory
   1071            if (thread->flags & osRtxFlagSystemObject) {
   \                     ??osRtxThreadFree_0: (+1)
   \   00000024   0x78A0             LDRB     R0,[R4, #+2]
   \   00000026   0x07C0             LSLS     R0,R0,#+31
   \   00000028   0xD50B             BPL      ??osRtxThreadFree_2
   1072              if (osRtxInfo.mpi.thread != NULL) {
   \   0000002A   0x....             LDR      R2,??DataTable20
   \   0000002C   0x6950             LDR      R0,[R2, #+20]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD003             BEQ      ??osRtxThreadFree_3
   1073                osRtxMemoryPoolFree(osRtxInfo.mpi.thread, thread);
   \   00000032   0x0021             MOVS     R1,R4
   \   00000034   0x.... 0x....      BL       osRtxMemoryPoolFree
   \   00000038   0xBD10             POP      {R4,PC}
   1074              } else {
   1075                osRtxMemoryFree(osRtxInfo.mem.common, thread);
   \                     ??osRtxThreadFree_3: (+1)
   \   0000003A   0x0021             MOVS     R1,R4
   \   0000003C   0x68D0             LDR      R0,[R2, #+12]
   \   0000003E   0x.... 0x....      BL       osRtxMemoryFree
   1076              }
   1077            }
   1078          }
   \                     ??osRtxThreadFree_2: (+1)
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   1079          
   1080          /// Detach a thread (thread storage can be reclaimed when thread terminates).
   1081          /// \note API identical to osThreadDetach

   \                                 In section .text, align 2, keep-with-next
   1082          osStatus_t svcRtxThreadDetach (osThreadId_t thread_id) {
   \                     svcRtxThreadDetach: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   1083            os_thread_t *thread = (os_thread_t *)thread_id;
   1084          
   1085            // Check parameters
   1086            if ((thread == NULL) || (thread->id != osRtxIdThread)) {
   \   00000004   0xD002             BEQ      ??svcRtxThreadDetach_0
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD001             BEQ      ??svcRtxThreadDetach_1
   1087              EvrRtxThreadError(thread, osErrorParameter);
   \                     ??svcRtxThreadDetach_0: (+1)
   \   0000000C   0x2403             MOVS     R4,#+3
   \   0000000E   0xE00E             B.N      ??svcRtxThreadDetach_2
   1088              return osErrorParameter;
   1089            }
   1090          
   1091            // Check object attributes
   1092            if ((thread->attr & osThreadJoinable) == 0U) {
   \                     ??svcRtxThreadDetach_1: (+1)
   \   00000010   0x78E8             LDRB     R0,[R5, #+3]
   \   00000012   0x07C1             LSLS     R1,R0,#+31
   \   00000014   0xD407             BMI      ??svcRtxThreadDetach_3
   1093              EvrRtxThreadError(thread, osRtxErrorThreadNotJoinable);
   \   00000016   0x210C             MOVS     R1,#+12
   \   00000018   0x43C9             MVNS     R1,R1            ;; #-13
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0x.... 0x....      BL       EvrRtxThreadError
   1094              return osErrorResource;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x43C0             MVNS     R0,R0            ;; #-3
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}
   1095            }
   1096          
   1097            // Check object state
   1098            if (thread->state == osRtxThreadInactive) {
   \                     ??svcRtxThreadDetach_3: (+1)
   \   00000026   0x7869             LDRB     R1,[R5, #+1]
   \   00000028   0x000A             MOVS     R2,R1
   \   0000002A   0xD101             BNE      ??svcRtxThreadDetach_4
   1099              EvrRtxThreadError(thread, osErrorResource);
   \   0000002C   0x2402             MOVS     R4,#+2
   1100              return osErrorResource;
   1101            }
   \                     ??svcRtxThreadDetach_2: (+1)
   \   0000002E   0x....             B.N      ?Subroutine2
   1102          
   1103            if (thread->state == osRtxThreadTerminated) {
   \                     ??svcRtxThreadDetach_4: (+1)
   \   00000030   0x2904             CMP      R1,#+4
   \   00000032   0xD107             BNE      ??svcRtxThreadDetach_5
   1104              osRtxThreadListUnlink(&osRtxInfo.thread.terminate_list, thread);
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x....             LDR      R0,??DataTable21
   \   00000038   0x.... 0x....      BL       osRtxThreadListUnlink
   1105              osRtxThreadFree(thread);
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x.... 0x....      BL       osRtxThreadFree
   \   00000042   0xE002             B        ??svcRtxThreadDetach_6
   1106            } else {
   1107              thread->attr &= ~osThreadJoinable;
   \                     ??svcRtxThreadDetach_5: (+1)
   \   00000044   0x21FE             MOVS     R1,#+254
   \   00000046   0x4001             ANDS     R1,R1,R0
   \   00000048   0x70E9             STRB     R1,[R5, #+3]
   1108            }
   1109          
   1110            EvrRtxThreadDetached(thread);
   \                     ??svcRtxThreadDetach_6: (+1)
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0x.... 0x....      BL       EvrRtxThreadDetached
   1111          
   1112            return osOK;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1113          }
   1114          
   1115          /// Wait for specified thread to terminate.
   1116          /// \note API identical to osThreadJoin

   \                                 In section .text, align 2, keep-with-next
   1117          osStatus_t svcRtxThreadJoin (osThreadId_t thread_id) {
   \                     svcRtxThreadJoin: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1118            os_thread_t *thread = (os_thread_t *)thread_id;
   1119          
   1120            // Check parameters
   1121            if ((thread == NULL) || (thread->id != osRtxIdThread)) {
   \   00000004   0xD002             BEQ      ??svcRtxThreadJoin_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD001             BEQ      ??svcRtxThreadJoin_1
   1122              EvrRtxThreadError(thread, osErrorParameter);
   \                     ??svcRtxThreadJoin_0: (+1)
   \   0000000C   0x2503             MOVS     R5,#+3
   \   0000000E   0xE00E             B.N      ??svcRtxThreadJoin_2
   1123              return osErrorParameter;
   1124            }
   1125          
   1126            // Check object attributes
   1127            if ((thread->attr & osThreadJoinable) == 0U) {
   \                     ??svcRtxThreadJoin_1: (+1)
   \   00000010   0x78E0             LDRB     R0,[R4, #+3]
   \   00000012   0x07C0             LSLS     R0,R0,#+31
   \   00000014   0xD405             BMI      ??svcRtxThreadJoin_3
   1128              EvrRtxThreadError(thread, osRtxErrorThreadNotJoinable);
   \   00000016   0x210C             MOVS     R1,#+12
   \   00000018   0x43C9             MVNS     R1,R1            ;; #-13
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       EvrRtxThreadError
   1129              return osErrorResource;
   \   00000020   0xE04D             B        ??svcRtxThreadJoin_4
   1130            }
   1131          
   1132            // Check object state
   1133            if ((thread->state == osRtxThreadInactive) ||
   1134                (thread->state == osRtxThreadRunning)) {
   \                     ??svcRtxThreadJoin_3: (+1)
   \   00000022   0x7860             LDRB     R0,[R4, #+1]
   \   00000024   0x0001             MOVS     R1,R0
   \   00000026   0xD001             BEQ      ??svcRtxThreadJoin_5
   \   00000028   0x2802             CMP      R0,#+2
   \   0000002A   0xD101             BNE      ??svcRtxThreadJoin_6
   1135              EvrRtxThreadError(thread, osErrorResource);
   \                     ??svcRtxThreadJoin_5: (+1)
   \   0000002C   0x2502             MOVS     R5,#+2
   1136              return osErrorResource;
   1137            }
   \                     ??svcRtxThreadJoin_2: (+1)
   \   0000002E   0x....             B.N      ?Subroutine1
   1138          
   1139            if (thread->state == osRtxThreadTerminated) {
   \                     ??svcRtxThreadJoin_6: (+1)
   \   00000030   0x....             LDR      R5,??DataTable22
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD10C             BNE      ??svcRtxThreadJoin_7
   1140              osRtxThreadListUnlink(&osRtxInfo.thread.terminate_list, thread);
   \   00000036   0x0021             MOVS     R1,R4
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0x3034             ADDS     R0,R0,#+52
   \   0000003C   0x.... 0x....      BL       osRtxThreadListUnlink
   1141              osRtxThreadFree(thread);
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       osRtxThreadFree
   1142            } else {
   1143              EvrRtxThreadJoinPending(thread);
   1144              // Suspend current Thread
   1145              if (osRtxThreadWaitEnter(osRtxThreadWaitingJoin, osWaitForever)) {
   1146                thread->thread_join = osRtxThreadGetRunning();
   1147              }
   1148              return osErrorResource;
   1149            }
   1150          
   1151            EvrRtxThreadJoined(thread);
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       EvrRtxThreadJoined
   1152          
   1153            return osOK;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??svcRtxThreadJoin_7: (+1)
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       EvrRtxThreadJoinPending
   \   00000056   0x696E             LDR      R6,[R5, #+20]
   \   00000058   0x2E00             CMP      R6,#+0
   \   0000005A   0xD030             BEQ      ??svcRtxThreadJoin_4
   \   0000005C   0x7A28             LDRB     R0,[R5, #+8]
   \   0000005E   0x2802             CMP      R0,#+2
   \   00000060   0xD003             BEQ      ??svcRtxThreadJoin_8
   \   00000062   0x0030             MOVS     R0,R6
   \   00000064   0x.... 0x....      BL       osRtxThreadListRemove
   \   00000068   0xE029             B        ??svcRtxThreadJoin_4
   \                     ??svcRtxThreadJoin_8: (+1)
   \   0000006A   0x6A68             LDR      R0,[R5, #+36]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD026             BEQ      ??svcRtxThreadJoin_4
   \   00000070   0x2700             MOVS     R7,#+0
   \   00000072   0x43FF             MVNS     R7,R7            ;; #-1
   \   00000074   0x0039             MOVS     R1,R7
   \   00000076   0x0030             MOVS     R0,R6
   \   00000078   0x.... 0x....      BL       EvrRtxThreadBlocked
   \   0000007C   0x2023             MOVS     R0,#+35
   \   0000007E   0x7070             STRB     R0,[R6, #+1]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x6B2A             LDR      R2,[R5, #+48]
   \   00000086   0xE001             B        ??svcRtxThreadJoin_9
   \                     ??svcRtxThreadJoin_10: (+1)
   \   00000088   0x0011             MOVS     R1,R2
   \   0000008A   0x6912             LDR      R2,[R2, #+16]
   \                     ??svcRtxThreadJoin_9: (+1)
   \   0000008C   0x2A00             CMP      R2,#+0
   \   0000008E   0xD1FB             BNE      ??svcRtxThreadJoin_10
   \   00000090   0x61F7             STR      R7,[R6, #+28]
   \   00000092   0x6171             STR      R1,[R6, #+20]
   \   00000094   0x6130             STR      R0,[R6, #+16]
   \   00000096   0x2900             CMP      R1,#+0
   \   00000098   0xD001             BEQ      ??svcRtxThreadJoin_11
   \   0000009A   0x610E             STR      R6,[R1, #+16]
   \   0000009C   0xE000             B        ??svcRtxThreadJoin_12
   \                     ??svcRtxThreadJoin_11: (+1)
   \   0000009E   0x632E             STR      R6,[R5, #+48]
   \                     ??svcRtxThreadJoin_12: (+1)
   \   000000A0   0x0028             MOVS     R0,R5
   \   000000A2   0x301C             ADDS     R0,R0,#+28
   \   000000A4   0x.... 0x....      BL       osRtxThreadListGet
   \   000000A8   0x0006             MOVS     R6,R0
   \   000000AA   0x2002             MOVS     R0,#+2
   \   000000AC   0x7070             STRB     R0,[R6, #+1]
   \   000000AE   0x61AE             STR      R6,[R5, #+24]
   \   000000B0   0x.... 0x....      BL       osRtxThreadStackCheck
   \   000000B4   0x0030             MOVS     R0,R6
   \   000000B6   0x.... 0x....      BL       EvrRtxThreadSwitch
   \   000000BA   0x6968             LDR      R0,[R5, #+20]
   \   000000BC   0x61A0             STR      R0,[R4, #+24]
   \                     ??svcRtxThreadJoin_4: (+1)
   \   000000BE   0x2002             MOVS     R0,#+2
   \   000000C0   0x43C0             MVNS     R0,R0            ;; #-3
   \   000000C2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1154          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x43ED             MVNS     R5,R5            ;; #-3
   \   00000002   0x0029             MOVS     R1,R5
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       EvrRtxThreadError
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0xBDF2             POP      {R1,R4-R7,PC}
   1155          
   1156          /// Terminate execution of current running thread.
   1157          /// \note API identical to osThreadExit

   \                                 In section .text, align 2, keep-with-next
   1158          void svcRtxThreadExit (void) {
   \                     svcRtxThreadExit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1159            os_thread_t *thread;
   1160          
   1161            thread = osRtxThreadGetRunning();
   \   00000002   0x....             LDR      R4,??DataTable22
   \   00000004   0x6965             LDR      R5,[R4, #+20]
   1162            if (thread == NULL) {
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD049             BEQ      ??svcRtxThreadExit_0
   1163              return;
   1164            }
   1165          
   1166            // Release owned Mutexes
   1167            osRtxMutexOwnerRelease(thread->mutex_list);
   \   0000000A   0x6AE8             LDR      R0,[R5, #+44]
   \   0000000C   0x.... 0x....      BL       osRtxMutexOwnerRelease
   1168          
   1169            // Wakeup Thread waiting to Join
   1170            if (thread->thread_join != NULL) {
   \   00000010   0x69AE             LDR      R6,[R5, #+24]
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD014             BEQ      ??svcRtxThreadExit_1
   1171              osRtxThreadWaitExit(thread->thread_join, (uint32_t)osOK, false);
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x0030             MOVS     R0,R6
   \   0000001A   0x.... 0x....      BL       EvrRtxThreadUnblocked
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6BB1             LDR      R1,[R6, #+56]
   \   00000022   0x3120             ADDS     R1,R1,#+32
   \   00000024   0x6008             STR      R0,[R1, #+0]
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0x.... 0x....      BL       osRtxThreadDelayRemove
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x7070             STRB     R0,[R6, #+1]
   \   00000030   0x0031             MOVS     R1,R6
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x301C             ADDS     R0,R0,#+28
   \   00000036   0x.... 0x....      BL       osRtxThreadListPut
   1172              EvrRtxThreadJoined(thread->thread_join);
   \   0000003A   0x69A8             LDR      R0,[R5, #+24]
   \   0000003C   0x.... 0x....      BL       EvrRtxThreadJoined
   1173            }
   1174          
   1175            // Switch to next Ready Thread
   1176            if ((osRtxKernelGetState() != osRtxKernelRunning) ||
   1177                (osRtxInfo.thread.ready.thread_list == NULL)) {
   \                     ??svcRtxThreadExit_1: (+1)
   \   00000040   0x7A20             LDRB     R0,[R4, #+8]
   \   00000042   0x2802             CMP      R0,#+2
   \   00000044   0xD12B             BNE      ??svcRtxThreadExit_0
   \   00000046   0x6A60             LDR      R0,[R4, #+36]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD028             BEQ      ??svcRtxThreadExit_0
   1178              return;
   1179            }
   1180            thread->sp = __get_PSP();
   \   0000004C   0xF3EF 0x8009      MRS      R0,PSP
   \   00000050   0x63A8             STR      R0,[R5, #+56]
   1181            osRtxThreadSwitch(osRtxThreadListGet(&osRtxInfo.thread.ready));
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x301C             ADDS     R0,R0,#+28
   \   00000056   0x.... 0x....      BL       osRtxThreadListGet
   \   0000005A   0x0006             MOVS     R6,R0
   \   0000005C   0x2002             MOVS     R0,#+2
   \   0000005E   0x7070             STRB     R0,[R6, #+1]
   \   00000060   0x61A6             STR      R6,[R4, #+24]
   \   00000062   0x.... 0x....      BL       osRtxThreadStackCheck
   \   00000066   0x0030             MOVS     R0,R6
   \   00000068   0x.... 0x....      BL       EvrRtxThreadSwitch
   1182            osRtxThreadSetRunning(NULL);
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x6160             STR      R0,[R4, #+20]
   1183          
   1184            if (((thread->attr & osThreadJoinable) == 0U) || (thread->thread_join != NULL)) {
   \   00000070   0x78E9             LDRB     R1,[R5, #+3]
   \   00000072   0x07C9             LSLS     R1,R1,#+31
   \   00000074   0xD502             BPL      ??svcRtxThreadExit_2
   \   00000076   0x69A9             LDR      R1,[R5, #+24]
   \   00000078   0x2900             CMP      R1,#+0
   \   0000007A   0xD003             BEQ      ??svcRtxThreadExit_3
   1185              osRtxThreadFree(thread);
   \                     ??svcRtxThreadExit_2: (+1)
   \   0000007C   0x0028             MOVS     R0,R5
   \   0000007E   0x.... 0x....      BL       osRtxThreadFree
   \   00000082   0xE009             B        ??svcRtxThreadExit_4
   1186            } else {
   1187              // Update Thread State and put it into Terminate Thread list
   1188              thread->state = osRtxThreadTerminated;
   \                     ??svcRtxThreadExit_3: (+1)
   \   00000084   0x2104             MOVS     R1,#+4
   \   00000086   0x7069             STRB     R1,[R5, #+1]
   1189              thread->thread_prev = NULL;
   \   00000088   0x60E8             STR      R0,[R5, #+12]
   1190              thread->thread_next = osRtxInfo.thread.terminate_list;
   \   0000008A   0x6B60             LDR      R0,[R4, #+52]
   \   0000008C   0x60A8             STR      R0,[R5, #+8]
   1191              if (osRtxInfo.thread.terminate_list != NULL) {
   \   0000008E   0x6B60             LDR      R0,[R4, #+52]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD000             BEQ      ??svcRtxThreadExit_5
   1192                osRtxInfo.thread.terminate_list->thread_prev = thread;
   \   00000094   0x60C5             STR      R5,[R0, #+12]
   1193              }
   1194              osRtxInfo.thread.terminate_list = thread;
   \                     ??svcRtxThreadExit_5: (+1)
   \   00000096   0x6365             STR      R5,[R4, #+52]
   1195            }
   1196          
   1197            EvrRtxThreadDestroyed(thread);
   \                     ??svcRtxThreadExit_4: (+1)
   \   00000098   0x0028             MOVS     R0,R5
   \   0000009A   0x.... 0x....      BL       EvrRtxThreadDestroyed
   1198          }
   \                     ??svcRtxThreadExit_0: (+1)
   \   0000009E   0xBD70             POP      {R4-R6,PC}       ;; return
   1199          
   1200          /// Terminate execution of a thread.
   1201          /// \note API identical to osThreadTerminate

   \                                 In section .text, align 2, keep-with-next
   1202          osStatus_t svcRtxThreadTerminate (osThreadId_t thread_id) {
   \                     svcRtxThreadTerminate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   1203            os_thread_t *thread = (os_thread_t *)thread_id;
   1204          
   1205            // Check parameters
   1206            if ((thread == NULL) || (thread->id != osRtxIdThread)) {
   \   00000004   0xD002             BEQ      ??svcRtxThreadTerminate_0
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD001             BEQ      ??svcRtxThreadTerminate_1
   1207              EvrRtxThreadError(thread, osErrorParameter);
   \                     ??svcRtxThreadTerminate_0: (+1)
   \   0000000C   0x2403             MOVS     R4,#+3
   \   0000000E   0xE041             B.N      ??svcRtxThreadTerminate_2
   1208              return osErrorParameter;
   1209            }
   1210          
   1211            // Check object state
   1212            switch (thread->state & osRtxThreadStateMask) {
   \                     ??svcRtxThreadTerminate_1: (+1)
   \   00000010   0x7868             LDRB     R0,[R5, #+1]
   \   00000012   0x0700             LSLS     R0,R0,#+28
   \   00000014   0x0F00             LSRS     R0,R0,#+28
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD004             BEQ      ??svcRtxThreadTerminate_3
   \   0000001A   0xD33A             BCC      ??svcRtxThreadTerminate_4
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD005             BEQ      ??svcRtxThreadTerminate_5
   \   00000020   0xD30A             BCC      ??svcRtxThreadTerminate_6
   \   00000022   0xE036             B        ??svcRtxThreadTerminate_4
   1213              case osRtxThreadRunning:
   1214                break;
   1215              case osRtxThreadReady:
   1216                osRtxThreadListRemove(thread);
   \                     ??svcRtxThreadTerminate_3: (+1)
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0x.... 0x....      BL       osRtxThreadListRemove
   1217                break;
   \   0000002A   0xE005             B        ??svcRtxThreadTerminate_6
   1218              case osRtxThreadBlocked:
   1219                osRtxThreadListRemove(thread);
   \                     ??svcRtxThreadTerminate_5: (+1)
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x.... 0x....      BL       osRtxThreadListRemove
   1220                osRtxThreadDelayRemove(thread);
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       osRtxThreadDelayRemove
   1221                break;
   1222              case osRtxThreadInactive:
   1223              case osRtxThreadTerminated:
   1224              default:
   1225                EvrRtxThreadError(thread, osErrorResource);
   1226                return osErrorResource;
   1227            }
   1228          
   1229            if (osEventObs && osEventObs->thread_destroy) {
   \                     ??svcRtxThreadTerminate_6: (+1)
   \   00000038   0x....             LDR      R0,??DataTable24
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD004             BEQ      ??svcRtxThreadTerminate_7
   \   00000040   0x68C1             LDR      R1,[R0, #+12]
   \   00000042   0x0008             MOVS     R0,R1
   \   00000044   0xD001             BEQ      ??svcRtxThreadTerminate_7
   1230              osEventObs->thread_destroy(thread->context);
   \   00000046   0x6C68             LDR      R0,[R5, #+68]
   \   00000048   0x4788             BLX      R1
   1231            }
   1232          
   1233            // Release owned Mutexes
   1234            osRtxMutexOwnerRelease(thread->mutex_list);
   \                     ??svcRtxThreadTerminate_7: (+1)
   \   0000004A   0x6AE8             LDR      R0,[R5, #+44]
   \   0000004C   0x.... 0x....      BL       osRtxMutexOwnerRelease
   1235          
   1236            // Wakeup Thread waiting to Join
   1237            if (thread->thread_join != NULL) {
   \   00000050   0x69AC             LDR      R4,[R5, #+24]
   \   00000052   0x2C00             CMP      R4,#+0
   \   00000054   0xD013             BEQ      ??svcRtxThreadTerminate_8
   1238              osRtxThreadWaitExit(thread->thread_join, (uint32_t)osOK, false);
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       EvrRtxThreadUnblocked
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x6BA1             LDR      R1,[R4, #+56]
   \   00000062   0x3120             ADDS     R1,R1,#+32
   \   00000064   0x6008             STR      R0,[R1, #+0]
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       osRtxThreadDelayRemove
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x7060             STRB     R0,[R4, #+1]
   \   00000070   0x0021             MOVS     R1,R4
   \   00000072   0x....             LDR      R0,??DataTable25
   \   00000074   0x.... 0x....      BL       osRtxThreadListPut
   1239              EvrRtxThreadJoined(thread->thread_join);
   \   00000078   0x69A8             LDR      R0,[R5, #+24]
   \   0000007A   0x.... 0x....      BL       EvrRtxThreadJoined
   1240            }
   1241          
   1242            // Switch to next Ready Thread when terminating running Thread
   1243            if (thread->state == osRtxThreadRunning) {
   \                     ??svcRtxThreadTerminate_8: (+1)
   \   0000007E   0x7868             LDRB     R0,[R5, #+1]
   \   00000080   0x2802             CMP      R0,#+2
   \   00000082   0xD11B             BNE      ??svcRtxThreadTerminate_9
   1244              if ((osRtxKernelGetState() != osRtxKernelRunning) ||
   1245                  (osRtxInfo.thread.ready.thread_list == NULL)) {
   \   00000084   0x....             LDR      R4,??DataTable22
   \   00000086   0x7A20             LDRB     R0,[R4, #+8]
   \   00000088   0x2802             CMP      R0,#+2
   \   0000008A   0xD102             BNE      ??svcRtxThreadTerminate_4
   \   0000008C   0x6A60             LDR      R0,[R4, #+36]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD101             BNE      ??svcRtxThreadTerminate_10
   1246                EvrRtxThreadError(thread, osErrorResource);
   \                     ??svcRtxThreadTerminate_4: (+1)
   \   00000092   0x2402             MOVS     R4,#+2
   1247                return osErrorResource;
   1248              }
   \                     ??svcRtxThreadTerminate_2: (+1)
   \   00000094   0x....             B.N      ?Subroutine0
   1249              thread->sp = __get_PSP();
   \                     ??svcRtxThreadTerminate_10: (+1)
   \   00000096   0xF3EF 0x8009      MRS      R0,PSP
   \   0000009A   0x63A8             STR      R0,[R5, #+56]
   1250              osRtxThreadSwitch(osRtxThreadListGet(&osRtxInfo.thread.ready));
   \   0000009C   0x0020             MOVS     R0,R4
   \   0000009E   0x301C             ADDS     R0,R0,#+28
   \   000000A0   0x.... 0x....      BL       osRtxThreadListGet
   \   000000A4   0x0006             MOVS     R6,R0
   \   000000A6   0x2002             MOVS     R0,#+2
   \   000000A8   0x7070             STRB     R0,[R6, #+1]
   \   000000AA   0x61A6             STR      R6,[R4, #+24]
   \   000000AC   0x.... 0x....      BL       osRtxThreadStackCheck
   \   000000B0   0x0030             MOVS     R0,R6
   \   000000B2   0x.... 0x....      BL       EvrRtxThreadSwitch
   1251              osRtxThreadSetRunning(NULL);
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x6160             STR      R0,[R4, #+20]
   1252            } else {
   \   000000BA   0xE002             B        ??svcRtxThreadTerminate_11
   1253              osRtxThreadDispatch(NULL);
   \                     ??svcRtxThreadTerminate_9: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x.... 0x....      BL       osRtxThreadDispatch
   1254            }
   1255          
   1256            if (((thread->attr & osThreadJoinable) == 0U) || (thread->thread_join != NULL)) {
   \                     ??svcRtxThreadTerminate_11: (+1)
   \   000000C2   0x78E8             LDRB     R0,[R5, #+3]
   \   000000C4   0x07C0             LSLS     R0,R0,#+31
   \   000000C6   0xD502             BPL      ??svcRtxThreadTerminate_12
   \   000000C8   0x69A8             LDR      R0,[R5, #+24]
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD003             BEQ      ??svcRtxThreadTerminate_13
   1257              osRtxThreadFree(thread);
   \                     ??svcRtxThreadTerminate_12: (+1)
   \   000000CE   0x0028             MOVS     R0,R5
   \   000000D0   0x.... 0x....      BL       osRtxThreadFree
   \   000000D4   0xE00B             B        ??svcRtxThreadTerminate_14
   1258            } else {
   1259              // Update Thread State and put it into Terminate Thread list
   1260              thread->state = osRtxThreadTerminated;
   \                     ??svcRtxThreadTerminate_13: (+1)
   \   000000D6   0x2004             MOVS     R0,#+4
   \   000000D8   0x7068             STRB     R0,[R5, #+1]
   1261              thread->thread_prev = NULL;
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x60E8             STR      R0,[R5, #+12]
   1262              thread->thread_next = osRtxInfo.thread.terminate_list;
   \   000000DE   0x....             LDR      R4,??DataTable22
   \   000000E0   0x6B60             LDR      R0,[R4, #+52]
   \   000000E2   0x60A8             STR      R0,[R5, #+8]
   1263              if (osRtxInfo.thread.terminate_list != NULL) {
   \   000000E4   0x6B60             LDR      R0,[R4, #+52]
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD000             BEQ      ??svcRtxThreadTerminate_15
   1264                osRtxInfo.thread.terminate_list->thread_prev = thread;
   \   000000EA   0x60C5             STR      R5,[R0, #+12]
   1265              }
   1266              osRtxInfo.thread.terminate_list = thread;
   \                     ??svcRtxThreadTerminate_15: (+1)
   \   000000EC   0x6365             STR      R5,[R4, #+52]
   1267            }
   1268          
   1269            EvrRtxThreadDestroyed(thread);
   \                     ??svcRtxThreadTerminate_14: (+1)
   \   000000EE   0x0028             MOVS     R0,R5
   \   000000F0   0x.... 0x....      BL       EvrRtxThreadDestroyed
   1270          
   1271            return osOK;
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0xBD70             POP      {R4-R6,PC}       ;; return
   1272          }
   1273          
   1274          /// Get number of active threads.
   1275          /// \note API identical to osThreadGetCount

   \                                 In section .text, align 2, keep-with-next
   1276          uint32_t svcRtxThreadGetCount (void) {
   \                     svcRtxThreadGetCount: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1277            os_thread_t *thread;
   1278            uint32_t     count;
   1279          
   1280            // Running Thread
   1281            count = 1U;
   \   00000002   0x2401             MOVS     R4,#+1
   1282          
   1283            // Ready List
   1284            for (thread = osRtxInfo.thread.ready.thread_list;
   \   00000004   0x....             LDR      R0,??DataTable22
   \   00000006   0x6A41             LDR      R1,[R0, #+36]
   \   00000008   0xE001             B        ??svcRtxThreadGetCount_0
   1285                 (thread != NULL); thread = thread->thread_next, count++) {};
   \                     ??svcRtxThreadGetCount_1: (+1)
   \   0000000A   0x6889             LDR      R1,[R1, #+8]
   \   0000000C   0x1C64             ADDS     R4,R4,#+1
   \                     ??svcRtxThreadGetCount_0: (+1)
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD1FB             BNE      ??svcRtxThreadGetCount_1
   1286          
   1287            // Delay List
   1288            for (thread = osRtxInfo.thread.delay_list;
   \   00000012   0x6AC1             LDR      R1,[R0, #+44]
   \   00000014   0xE001             B        ??svcRtxThreadGetCount_2
   1289                 (thread != NULL); thread = thread->delay_next,  count++) {};
   \                     ??svcRtxThreadGetCount_3: (+1)
   \   00000016   0x6909             LDR      R1,[R1, #+16]
   \   00000018   0x1C64             ADDS     R4,R4,#+1
   \                     ??svcRtxThreadGetCount_2: (+1)
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD1FB             BNE      ??svcRtxThreadGetCount_3
   1290          
   1291            // Wait List
   1292            for (thread = osRtxInfo.thread.wait_list;
   \   0000001E   0x6B00             LDR      R0,[R0, #+48]
   \   00000020   0xE001             B        ??svcRtxThreadGetCount_4
   1293                 (thread != NULL); thread = thread->delay_next,  count++) {};
   \                     ??svcRtxThreadGetCount_5: (+1)
   \   00000022   0x6900             LDR      R0,[R0, #+16]
   \   00000024   0x1C64             ADDS     R4,R4,#+1
   \                     ??svcRtxThreadGetCount_4: (+1)
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD1FB             BNE      ??svcRtxThreadGetCount_5
   1294          
   1295            EvrRtxThreadGetCount(count);
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       EvrRtxThreadGetCount
   1296          
   1297            return count;
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
   1298          }
   1299          
   1300          /// Enumerate active threads.
   1301          /// \note API identical to osThreadEnumerate

   \                                 In section .text, align 2, keep-with-next
   1302          uint32_t svcRtxThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items) {
   \                     svcRtxThreadEnumerate: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1303            os_thread_t *thread;
   1304            uint32_t     count;
   1305          
   1306            // Check parameters
   1307            if ((thread_array == NULL) || (array_items == 0U)) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD001             BEQ      ??svcRtxThreadEnumerate_0
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD104             BNE      ??svcRtxThreadEnumerate_1
   1308              EvrRtxThreadEnumerate(thread_array, array_items, 0U);
   \                     ??svcRtxThreadEnumerate_0: (+1)
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x.... 0x....      BL       EvrRtxThreadEnumerate
   1309              return 0U;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}
   1310            }
   1311          
   1312            // Running Thread
   1313            *thread_array++ = osRtxThreadGetRunning();
   \                     ??svcRtxThreadEnumerate_1: (+1)
   \   00000014   0x....             LDR      R2,??DataTable22
   \   00000016   0x6953             LDR      R3,[R2, #+20]
   \   00000018   0x6003             STR      R3,[R0, #+0]
   \   0000001A   0x1D00             ADDS     R0,R0,#+4
   1314            count = 1U;
   \   0000001C   0x2401             MOVS     R4,#+1
   1315          
   1316            // Ready List
   1317            for (thread = osRtxInfo.thread.ready.thread_list;
   \   0000001E   0x6A53             LDR      R3,[R2, #+36]
   \   00000020   0xE003             B        ??svcRtxThreadEnumerate_2
   1318                 (thread != NULL) && (count < array_items); thread = thread->thread_next, count++) {
   1319              *thread_array++ = thread;
   \                     ??svcRtxThreadEnumerate_3: (+1)
   \   00000022   0x6003             STR      R3,[R0, #+0]
   \   00000024   0x1D00             ADDS     R0,R0,#+4
   1320            }
   \   00000026   0x689B             LDR      R3,[R3, #+8]
   \   00000028   0x1C64             ADDS     R4,R4,#+1
   \                     ??svcRtxThreadEnumerate_2: (+1)
   \   0000002A   0x2B00             CMP      R3,#+0
   \   0000002C   0xD001             BEQ      ??svcRtxThreadEnumerate_4
   \   0000002E   0x428C             CMP      R4,R1
   \   00000030   0xD3F7             BCC      ??svcRtxThreadEnumerate_3
   1321          
   1322            // Delay List
   1323            for (thread = osRtxInfo.thread.delay_list;
   \                     ??svcRtxThreadEnumerate_4: (+1)
   \   00000032   0x6AD3             LDR      R3,[R2, #+44]
   \   00000034   0xE003             B        ??svcRtxThreadEnumerate_5
   1324                 (thread != NULL) && (count < array_items); thread = thread->delay_next,  count++) {
   1325              *thread_array++ = thread;
   \                     ??svcRtxThreadEnumerate_6: (+1)
   \   00000036   0x6003             STR      R3,[R0, #+0]
   \   00000038   0x1D00             ADDS     R0,R0,#+4
   1326            }
   \   0000003A   0x691B             LDR      R3,[R3, #+16]
   \   0000003C   0x1C64             ADDS     R4,R4,#+1
   \                     ??svcRtxThreadEnumerate_5: (+1)
   \   0000003E   0x2B00             CMP      R3,#+0
   \   00000040   0xD001             BEQ      ??svcRtxThreadEnumerate_7
   \   00000042   0x428C             CMP      R4,R1
   \   00000044   0xD3F7             BCC      ??svcRtxThreadEnumerate_6
   1327          
   1328            // Wait List
   1329            for (thread = osRtxInfo.thread.wait_list;
   \                     ??svcRtxThreadEnumerate_7: (+1)
   \   00000046   0x6B12             LDR      R2,[R2, #+48]
   \   00000048   0xE003             B        ??svcRtxThreadEnumerate_8
   1330                 (thread != NULL) && (count < array_items); thread = thread->delay_next,  count++) {
   1331              *thread_array++ = thread;
   \                     ??svcRtxThreadEnumerate_9: (+1)
   \   0000004A   0x6002             STR      R2,[R0, #+0]
   \   0000004C   0x1D00             ADDS     R0,R0,#+4
   1332            }
   \   0000004E   0x6912             LDR      R2,[R2, #+16]
   \   00000050   0x1C64             ADDS     R4,R4,#+1
   \                     ??svcRtxThreadEnumerate_8: (+1)
   \   00000052   0x2A00             CMP      R2,#+0
   \   00000054   0xD001             BEQ      ??svcRtxThreadEnumerate_10
   \   00000056   0x428C             CMP      R4,R1
   \   00000058   0xD3F7             BCC      ??svcRtxThreadEnumerate_9
   1333          
   1334            EvrRtxThreadEnumerate(thread_array - count, array_items, count);
   \                     ??svcRtxThreadEnumerate_10: (+1)
   \   0000005A   0x0022             MOVS     R2,R4
   \   0000005C   0x00A3             LSLS     R3,R4,#+2
   \   0000005E   0x425D             RSBS     R5,R3,#+0
   \   00000060   0x1940             ADDS     R0,R0,R5
   \   00000062   0x.... 0x....      BL       EvrRtxThreadEnumerate
   1335          
   1336            return count;
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1337          }
   1338          
   1339          /// Set the specified Thread Flags of a thread.
   1340          /// \note API identical to osThreadFlagsSet

   \                                 In section .text, align 2, keep-with-next
   1341          uint32_t svcRtxThreadFlagsSet (osThreadId_t thread_id, uint32_t flags) {
   \                     svcRtxThreadFlagsSet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1342            os_thread_t *thread = (os_thread_t *)thread_id;
   1343            uint32_t     thread_flags;
   1344            uint32_t     thread_flags0;
   1345          
   1346            // Check parameters
   1347            if ((thread == NULL) || (thread->id != osRtxIdThread) ||
   1348                (flags & ~((1U << osRtxThreadFlagsLimit) - 1U))) {
   \   00000004   0xD004             BEQ      ??svcRtxThreadFlagsSet_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE      ??svcRtxThreadFlagsSet_0
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD501             BPL      ??svcRtxThreadFlagsSet_1
   1349              EvrRtxThreadError(thread, osErrorParameter);
   \                     ??svcRtxThreadFlagsSet_0: (+1)
   \   00000010   0x2503             MOVS     R5,#+3
   \   00000012   0xE005             B.N      ??svcRtxThreadFlagsSet_2
   1350              return ((uint32_t)osErrorParameter);
   1351            }
   1352          
   1353            // Check object state
   1354            if ((thread->state == osRtxThreadInactive) ||
   1355                (thread->state == osRtxThreadTerminated)) {
   \                     ??svcRtxThreadFlagsSet_1: (+1)
   \   00000014   0x7860             LDRB     R0,[R4, #+1]
   \   00000016   0x0002             MOVS     R2,R0
   \   00000018   0xD001             BEQ      ??svcRtxThreadFlagsSet_3
   \   0000001A   0x2804             CMP      R0,#+4
   \   0000001C   0xD101             BNE      ??svcRtxThreadFlagsSet_4
   1356              EvrRtxThreadError(thread, osErrorResource);
   \                     ??svcRtxThreadFlagsSet_3: (+1)
   \   0000001E   0x2502             MOVS     R5,#+2
   1357              return ((uint32_t)osErrorResource);
   1358            }
   \                     ??svcRtxThreadFlagsSet_2: (+1)
   \   00000020   0x....             B.N      ?Subroutine1
   1359          
   1360            // Set Thread Flags
   1361            thread_flags = ThreadFlagsSet(thread, flags);
   \                     ??svcRtxThreadFlagsSet_4: (+1)
   \   00000022   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000026   0xB672             CPSID    I
   \   00000028   0x0025             MOVS     R5,R4
   \   0000002A   0x3524             ADDS     R5,R5,#+36
   \   0000002C   0x686A             LDR      R2,[R5, #+4]
   \   0000002E   0x4311             ORRS     R1,R1,R2
   \   00000030   0x6069             STR      R1,[R5, #+4]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD100             BNE      ??svcRtxThreadFlagsSet_5
   \   00000036   0xB662             CPSIE    I
   \                     ??svcRtxThreadFlagsSet_5: (+1)
   \   00000038   0x000F             MOVS     R7,R1
   1362          
   1363            // Check if Thread is waiting for Thread Flags
   1364            if (thread->state == osRtxThreadWaitingThreadFlags) {
   \   0000003A   0x7860             LDRB     R0,[R4, #+1]
   \   0000003C   0x2833             CMP      R0,#+51
   \   0000003E   0xD123             BNE      ??svcRtxThreadFlagsSet_6
   1365              thread_flags0 = ThreadFlagsCheck(thread, thread->wait_flags, thread->flags_options);
   \   00000040   0x2023             MOVS     R0,#+35
   \   00000042   0x5C22             LDRB     R2,[R4, R0]
   \   00000044   0x6829             LDR      R1,[R5, #+0]
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       ThreadFlagsCheck
   \   0000004C   0x0006             MOVS     R6,R0
   1366              if (thread_flags0 != 0U) {
   \   0000004E   0xD01B             BEQ      ??svcRtxThreadFlagsSet_6
   1367                if ((thread->flags_options & osFlagsNoClear) == 0U) {
   \   00000050   0x2023             MOVS     R0,#+35
   \   00000052   0x5C20             LDRB     R0,[R4, R0]
   \   00000054   0x0780             LSLS     R0,R0,#+30
   \   00000056   0xD403             BMI      ??svcRtxThreadFlagsSet_7
   1368                  thread_flags = thread_flags0 & ~thread->wait_flags;
   \   00000058   0x6828             LDR      R0,[R5, #+0]
   \   0000005A   0x43C7             MVNS     R7,R0
   \   0000005C   0x4037             ANDS     R7,R7,R6
   \   0000005E   0xE000             B        ??svcRtxThreadFlagsSet_8
   1369                } else {
   1370                  thread_flags = thread_flags0;
   \                     ??svcRtxThreadFlagsSet_7: (+1)
   \   00000060   0x0037             MOVS     R7,R6
   1371                }
   1372                osRtxThreadWaitExit(thread, thread_flags0, true);
   \                     ??svcRtxThreadFlagsSet_8: (+1)
   \   00000062   0x0031             MOVS     R1,R6
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       EvrRtxThreadUnblocked
   \   0000006A   0x6968             LDR      R0,[R5, #+20]
   \   0000006C   0x3020             ADDS     R0,R0,#+32
   \   0000006E   0x6006             STR      R6,[R0, #+0]
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       osRtxThreadDelayRemove
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       osRtxThreadDispatch
   1373                EvrRtxThreadFlagsWaitCompleted(thread->wait_flags, thread->flags_options, thread_flags0);
   \   0000007C   0x0032             MOVS     R2,R6
   \   0000007E   0x2023             MOVS     R0,#+35
   \   00000080   0x5C21             LDRB     R1,[R4, R0]
   \   00000082   0x6828             LDR      R0,[R5, #+0]
   \   00000084   0x.... 0x....      BL       EvrRtxThreadFlagsWaitCompleted
   1374              }
   1375            }
   1376          
   1377            EvrRtxThreadFlagsSetDone(thread, thread_flags);
   \                     ??svcRtxThreadFlagsSet_6: (+1)
   \   00000088   0x0039             MOVS     R1,R7
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       EvrRtxThreadFlagsSetDone
   1378          
   1379            return thread_flags;
   \   00000090   0x0038             MOVS     R0,R7
   \   00000092   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1380          }
   1381          
   1382          /// Clear the specified Thread Flags of current running thread.
   1383          /// \note API identical to osThreadFlagsClear

   \                                 In section .text, align 2, keep-with-next
   1384          uint32_t svcRtxThreadFlagsClear (uint32_t flags) {
   \                     svcRtxThreadFlagsClear: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0001             MOVS     R1,R0
   1385            os_thread_t *thread;
   1386            uint32_t     thread_flags;
   1387          
   1388            thread = osRtxThreadGetRunning();
   \   00000004   0x....             LDR      R0,??DataTable35
   \   00000006   0x6940             LDR      R0,[R0, #+20]
   1389            if (thread == NULL) {
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD106             BNE      ??svcRtxThreadFlagsClear_0
   1390              EvrRtxThreadError(NULL, osRtxErrorKernelNotRunning);
   \   0000000C   0x2107             MOVS     R1,#+7
   \   0000000E   0x43C9             MVNS     R1,R1            ;; #-8
   \   00000010   0x.... 0x....      BL       EvrRtxThreadError
   1391              return ((uint32_t)osError);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000018   0xBD10             POP      {R4,PC}
   1392            }
   1393          
   1394            // Check parameters
   1395            if (flags & ~((1U << osRtxThreadFlagsLimit) - 1U)) {
   \                     ??svcRtxThreadFlagsClear_0: (+1)
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD505             BPL      ??svcRtxThreadFlagsClear_1
   1396              EvrRtxThreadError(thread, osErrorParameter);
   \   0000001E   0x2403             MOVS     R4,#+3
   \   00000020   0x43E4             MVNS     R4,R4            ;; #-4
   \   00000022   0x0021             MOVS     R1,R4
   \   00000024   0x.... 0x....      BL       EvrRtxThreadError
   1397              return ((uint32_t)osErrorParameter);
   \   00000028   0xE017             B        ??svcRtxThreadFlagsClear_2
   1398            }
   1399          
   1400            // Check object state
   1401            if ((thread->state == osRtxThreadInactive) ||
   1402                (thread->state == osRtxThreadTerminated)) {
   \                     ??svcRtxThreadFlagsClear_1: (+1)
   \   0000002A   0x7842             LDRB     R2,[R0, #+1]
   \   0000002C   0x0013             MOVS     R3,R2
   \   0000002E   0xD001             BEQ      ??svcRtxThreadFlagsClear_3
   \   00000030   0x2A04             CMP      R2,#+4
   \   00000032   0xD105             BNE      ??svcRtxThreadFlagsClear_4
   1403              EvrRtxThreadError(thread, osErrorResource);
   \                     ??svcRtxThreadFlagsClear_3: (+1)
   \   00000034   0x2402             MOVS     R4,#+2
   \   00000036   0x43E4             MVNS     R4,R4            ;; #-3
   \   00000038   0x0021             MOVS     R1,R4
   \   0000003A   0x.... 0x....      BL       EvrRtxThreadError
   1404              return ((uint32_t)osErrorResource);
   \   0000003E   0xE00C             B        ??svcRtxThreadFlagsClear_2
   1405            }
   1406          
   1407            // Clear Thread Flags
   1408            thread_flags = ThreadFlagsClear(thread, flags);
   \                     ??svcRtxThreadFlagsClear_4: (+1)
   \   00000040   0xF3EF 0x8210      MRS      R2,PRIMASK
   \   00000044   0xB672             CPSID    I
   \   00000046   0x6A83             LDR      R3,[R0, #+40]
   \   00000048   0x001C             MOVS     R4,R3
   \   0000004A   0x438B             BICS     R3,R3,R1
   \   0000004C   0x6283             STR      R3,[R0, #+40]
   \   0000004E   0x2A00             CMP      R2,#+0
   \   00000050   0xD100             BNE      ??svcRtxThreadFlagsClear_5
   \   00000052   0xB662             CPSIE    I
   1409          
   1410            EvrRtxThreadFlagsClearDone(thread_flags);
   \                     ??svcRtxThreadFlagsClear_5: (+1)
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       EvrRtxThreadFlagsClearDone
   1411          
   1412            return thread_flags;
   \                     ??svcRtxThreadFlagsClear_2: (+1)
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
   1413          }
   1414          
   1415          /// Get the current Thread Flags of current running thread.
   1416          /// \note API identical to osThreadFlagsGet

   \                                 In section .text, align 2, keep-with-next
   1417          uint32_t svcRtxThreadFlagsGet (void) {
   \                     svcRtxThreadFlagsGet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1418            os_thread_t *thread;
   1419          
   1420            thread = osRtxThreadGetRunning();
   \   00000002   0x....             LDR      R0,??DataTable35
   \   00000004   0x6944             LDR      R4,[R0, #+20]
   1421            if (thread == NULL) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD004             BEQ      ??svcRtxThreadFlagsGet_0
   1422              EvrRtxThreadFlagsGet(0U);
   1423              return 0U;
   1424            }
   1425          
   1426            // Check object state
   1427            if ((thread->state == osRtxThreadInactive) ||
   1428                (thread->state == osRtxThreadTerminated)) {
   \   0000000A   0x7860             LDRB     R0,[R4, #+1]
   \   0000000C   0x0001             MOVS     R1,R0
   \   0000000E   0xD001             BEQ      ??svcRtxThreadFlagsGet_0
   \   00000010   0x2804             CMP      R0,#+4
   \   00000012   0xD104             BNE      ??svcRtxThreadFlagsGet_1
   1429              EvrRtxThreadFlagsGet(0U);
   \                     ??svcRtxThreadFlagsGet_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       EvrRtxThreadFlagsGet
   1430              return 0U;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}
   1431            }
   1432          
   1433            EvrRtxThreadFlagsGet(thread->thread_flags);
   \                     ??svcRtxThreadFlagsGet_1: (+1)
   \   0000001E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000020   0x.... 0x....      BL       EvrRtxThreadFlagsGet
   1434          
   1435            return thread->thread_flags;
   \   00000024   0x6AA0             LDR      R0,[R4, #+40]
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   1436          }
   1437          
   1438          /// Wait for one or more Thread Flags of the current running thread to become signaled.
   1439          /// \note API identical to osThreadFlagsWait

   \                                 In section .text, align 2, keep-with-next
   1440          uint32_t svcRtxThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout) {
   \                     svcRtxThreadFlagsWait: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1441            os_thread_t *thread;
   1442            uint32_t     thread_flags;
   1443          
   1444            thread = osRtxThreadGetRunning();
   \   00000006   0x....             LDR      R0,??DataTable35
   \   00000008   0x6946             LDR      R6,[R0, #+20]
   1445            if (thread == NULL) {
   \   0000000A   0x2E00             CMP      R6,#+0
   \   0000000C   0xD106             BNE      ??svcRtxThreadFlagsWait_0
   1446              EvrRtxThreadError(NULL, osRtxErrorKernelNotRunning);
   \   0000000E   0x2107             MOVS     R1,#+7
   \   00000010   0x43C9             MVNS     R1,R1            ;; #-8
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       EvrRtxThreadError
   1447              return ((uint32_t)osError);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE02D             B        ??svcRtxThreadFlagsWait_1
   1448            }
   1449          
   1450            // Check parameters
   1451            if (flags & ~((1U << osRtxThreadFlagsLimit) - 1U)) {
   \                     ??svcRtxThreadFlagsWait_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD507             BPL      ??svcRtxThreadFlagsWait_2
   1452              EvrRtxThreadError(thread, osErrorParameter);
   \   00000020   0x2403             MOVS     R4,#+3
   \   00000022   0x43E4             MVNS     R4,R4            ;; #-4
   \   00000024   0x0021             MOVS     R1,R4
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0x.... 0x....      BL       EvrRtxThreadError
   1453              return ((uint32_t)osErrorParameter);
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0xBDF2             POP      {R1,R4-R7,PC}
   1454            }
   1455          
   1456            // Check Thread Flags
   1457            thread_flags = ThreadFlagsCheck(thread, flags, options);
   \                     ??svcRtxThreadFlagsWait_2: (+1)
   \   00000030   0x002A             MOVS     R2,R5
   \   00000032   0x0021             MOVS     R1,R4
   \   00000034   0x0030             MOVS     R0,R6
   \   00000036   0x.... 0x....      BL       ThreadFlagsCheck
   \   0000003A   0x0007             MOVS     R7,R0
   1458            if (thread_flags != 0U) {
   \   0000003C   0xD006             BEQ      ??svcRtxThreadFlagsWait_3
   1459              EvrRtxThreadFlagsWaitCompleted(flags, options, thread_flags);
   \   0000003E   0x003A             MOVS     R2,R7
   \   00000040   0x0029             MOVS     R1,R5
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       EvrRtxThreadFlagsWaitCompleted
   1460              return thread_flags;
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}
   1461            }
   1462          
   1463            // Check if timeout is specified
   1464            if (timeout != 0U) {
   \                     ??svcRtxThreadFlagsWait_3: (+1)
   \   0000004C   0x9800             LDR      R0,[SP, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD00D             BEQ      ??svcRtxThreadFlagsWait_4
   1465              // Store waiting flags and options
   1466              EvrRtxThreadFlagsWaitPending(flags, options, timeout);
   \   00000052   0x4602             MOV      R2,R0
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       EvrRtxThreadFlagsWaitPending
   1467              thread->wait_flags = flags;
   \   0000005C   0x6274             STR      R4,[R6, #+36]
   1468              thread->flags_options = (uint8_t)options;
   \   0000005E   0x2023             MOVS     R0,#+35
   \   00000060   0x5435             STRB     R5,[R6, R0]
   1469              // Suspend current Thread
   1470              osRtxThreadWaitEnter(osRtxThreadWaitingThreadFlags, timeout);
   \   00000062   0x9900             LDR      R1,[SP, #+0]
   \   00000064   0x2033             MOVS     R0,#+51
   \   00000066   0x.... 0x....      BL       osRtxThreadWaitEnter
   1471              return ((uint32_t)osErrorTimeout);
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xE004             B        ??svcRtxThreadFlagsWait_1
   1472            }
   1473          
   1474            EvrRtxThreadFlagsWaitNotCompleted(flags, options);
   \                     ??svcRtxThreadFlagsWait_4: (+1)
   \   0000006E   0x0029             MOVS     R1,R5
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       EvrRtxThreadFlagsWaitNotCompleted
   1475          
   1476            return ((uint32_t)osErrorResource);
   \   00000076   0x2002             MOVS     R0,#+2
   \                     ??svcRtxThreadFlagsWait_1: (+1)
   \   00000078   0x43C0             MVNS     R0,R0            ;; #-3
   \   0000007A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1477          }
   1478          
   1479          
   1480          //  ==== ISR Calls ====
   1481          
   1482          /// Set the specified Thread Flags of a thread.
   1483          /// \note API identical to osThreadFlagsSet
   1484          __STATIC_INLINE
   1485          uint32_t isrRtxThreadFlagsSet (osThreadId_t thread_id, uint32_t flags) {
   1486            os_thread_t *thread = (os_thread_t *)thread_id;
   1487            uint32_t     thread_flags;
   1488          
   1489            // Check parameters
   1490            if ((thread == NULL) || (thread->id != osRtxIdThread) ||
   1491                (flags & ~((1U << osRtxThreadFlagsLimit) - 1U))) {
   1492              EvrRtxThreadError(thread, osErrorParameter);
   1493              return ((uint32_t)osErrorParameter);
   1494            }
   1495          
   1496            // Check object state
   1497            if ((thread->state == osRtxThreadInactive) ||
   1498                (thread->state == osRtxThreadTerminated)) {
   1499              EvrRtxThreadError(thread, osErrorResource);
   1500              return ((uint32_t)osErrorResource);
   1501            }
   1502          
   1503            // Set Thread Flags
   1504            thread_flags = ThreadFlagsSet(thread, flags);
   1505          
   1506            // Register post ISR processing
   1507            osRtxPostProcess((os_object_t *)thread);
   1508          
   1509            EvrRtxThreadFlagsSetDone(thread, thread_flags);
   1510          
   1511            return thread_flags;
   1512          }
   1513          
   1514          
   1515          //  ==== Public API ====
   1516          
   1517          /// Create a thread and add it to Active Threads.

   \                                 In section .text, align 2, keep-with-next
   1518          osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
   \                     osThreadNew: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1519            return osThreadContextNew(func, argument, attr, NULL);
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x.... 0x....      BL       osThreadContextNew
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
   1520          }
   1521          

   \                                 In section .text, align 4, keep-with-next
   1522          osThreadId_t osThreadContextNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr, void *context) {
   \                     osThreadContextNew: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0015             MOVS     R5,R2
   1523            EvrRtxThreadNew(func, argument, attr);
   \   00000008   0x.... 0x....      BL       EvrRtxThreadNew
   1524            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   0000000C   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD103             BNE      ??osThreadContextNew_0
   \   00000014   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD006             BEQ      ??osThreadContextNew_1
   1525              EvrRtxThreadError(NULL, osErrorISR);
   \                     ??osThreadContextNew_0: (+1)
   \   0000001C   0x2105             MOVS     R1,#+5
   \   0000001E   0x43C9             MVNS     R1,R1            ;; #-6
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      BL       EvrRtxThreadError
   1526              return NULL;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBDF2             POP      {R1,R4-R7,PC}
   1527            }
   1528            return __svcThreadNew(func, argument, attr, context);
   \                     ??osThreadContextNew_1: (+1)
   \   0000002A   0xF3EF 0x8014      MRS      R0,CONTROL
   \   0000002E   0x0780             LSLS     R0,R0,#+30
   \   00000030   0xD406             BMI      ??osThreadContextNew_2
   \   00000032   0xF3EF 0x8008      MRS      R0,MSP
   \   00000036   0x3820             SUBS     R0,R0,#+32
   \   00000038   0x2107             MOVS     R1,#+7
   \   0000003A   0x4388             BICS     R0,R0,R1
   \   0000003C   0xF380 0x8809      MSR      PSP,R0
   \                     ??osThreadContextNew_2: (+1)
   \   00000040   0x....             LDR      R0,??DataTable42
   \   00000042   0x4607             mov r7,R0
   \   00000044   0x9B00             LDR      R3,[SP, #+0]
   \   00000046   0x002A             MOVS     R2,R5
   \   00000048   0x0031             MOVS     R1,R6
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0xDF00             SVC      0x0
   \   0000004E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1529          }
   1530          
   1531          /// Get name of a thread.

   \                                 In section .text, align 4, keep-with-next
   1532          const char *osThreadGetName (osThreadId_t thread_id) {
   \                     osThreadGetName: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1533            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8105      MRS      R1,IPSR
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE      ??osThreadGetName_0
   \   0000000A   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD004             BEQ      ??osThreadGetName_1
   1534              EvrRtxThreadGetName(thread_id, NULL);
   \                     ??osThreadGetName_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x.... 0x....      BL       EvrRtxThreadGetName
   1535              return NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD80             POP      {R7,PC}
   1536            }
   1537            return __svcThreadGetName(thread_id);
   \                     ??osThreadGetName_1: (+1)
   \   0000001C   0x....             LDR      R1,??DataTable43
   \   0000001E   0x460F             mov r7,R1
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBD80             POP      {R7,PC}          ;; return
   1538          }
   1539          
   1540          /// Return the thread ID of the current running thread.

   \                                 In section .text, align 4, keep-with-next
   1541          osThreadId_t osThreadGetId (void) {
   \                     osThreadGetId: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1542            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD103             BNE      ??osThreadGetId_0
   \   0000000A   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ      ??osThreadGetId_1
   1543              EvrRtxThreadGetId(NULL);
   \                     ??osThreadGetId_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       EvrRtxThreadGetId
   1544              return NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD80             POP      {R7,PC}
   1545            }
   1546            return __svcThreadGetId();
   \                     ??osThreadGetId_1: (+1)
   \   0000001C   0x....             LDR      R0,??DataTable44
   \   0000001E   0x4607             mov r7,R0
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBD80             POP      {R7,PC}          ;; return
   1547          }
   1548          
   1549          /// Get current thread state of a thread.

   \                                 In section .text, align 4, keep-with-next
   1550          osThreadState_t osThreadGetState (osThreadId_t thread_id) {
   \                     osThreadGetState: (+1)
   \   00000000   0xB598             PUSH     {R3,R4,R7,LR}
   1551            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8105      MRS      R1,IPSR
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE      ??osThreadGetState_0
   \   0000000A   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD006             BEQ      ??osThreadGetState_1
   1552              EvrRtxThreadGetState(thread_id, osThreadError);
   \                     ??osThreadGetState_0: (+1)
   \   00000012   0x2400             MOVS     R4,#+0
   \   00000014   0x43E4             MVNS     R4,R4            ;; #-1
   \   00000016   0x0021             MOVS     R1,R4
   \   00000018   0x.... 0x....      BL       EvrRtxThreadGetState
   1553              return osThreadError;
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xBD92             POP      {R1,R4,R7,PC}
   1554            }
   1555            return __svcThreadGetState(thread_id);
   \                     ??osThreadGetState_1: (+1)
   \   00000020   0x....             LDR      R1,??DataTable45
   \   00000022   0x460F             mov r7,R1
   \   00000024   0xDF00             SVC      0x0
   \   00000026   0xBD92             POP      {R1,R4,R7,PC}    ;; return
   1556          }
   1557          
   1558          /// Get stack size of a thread.

   \                                 In section .text, align 4, keep-with-next
   1559          uint32_t osThreadGetStackSize (osThreadId_t thread_id) {
   \                     osThreadGetStackSize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1560            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8105      MRS      R1,IPSR
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE      ??osThreadGetStackSize_0
   \   0000000A   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD004             BEQ      ??osThreadGetStackSize_1
   1561              EvrRtxThreadGetStackSize(thread_id, 0U);
   \                     ??osThreadGetStackSize_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x.... 0x....      BL       EvrRtxThreadGetStackSize
   1562              return 0U;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD80             POP      {R7,PC}
   1563            }
   1564            return __svcThreadGetStackSize(thread_id);
   \                     ??osThreadGetStackSize_1: (+1)
   \   0000001C   0x....             LDR      R1,??DataTable45_1
   \   0000001E   0x460F             mov r7,R1
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBD80             POP      {R7,PC}          ;; return
   1565          }
   1566          
   1567          /// Get available stack space of a thread based on stack watermark recording during execution.

   \                                 In section .text, align 4, keep-with-next
   1568          uint32_t osThreadGetStackSpace (osThreadId_t thread_id) {
   \                     osThreadGetStackSpace: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1569            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8105      MRS      R1,IPSR
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE      ??osThreadGetStackSpace_0
   \   0000000A   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD004             BEQ      ??osThreadGetStackSpace_1
   1570              EvrRtxThreadGetStackSpace(thread_id, 0U);
   \                     ??osThreadGetStackSpace_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x.... 0x....      BL       EvrRtxThreadGetStackSpace
   1571              return 0U;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD80             POP      {R7,PC}
   1572            }
   1573            return __svcThreadGetStackSpace(thread_id);
   \                     ??osThreadGetStackSpace_1: (+1)
   \   0000001C   0x....             LDR      R1,??DataTable46
   \   0000001E   0x460F             mov r7,R1
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBD80             POP      {R7,PC}          ;; return
   1574          }
   1575          
   1576          /// Change priority of a thread.

   \                                 In section .text, align 4, keep-with-next
   1577          osStatus_t osThreadSetPriority (osThreadId_t thread_id, osPriority_t priority) {
   \                     osThreadSetPriority: (+1)
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1578            EvrRtxThreadSetPriority(thread_id, priority);
   \   00000006   0x.... 0x....      BL       EvrRtxThreadSetPriority
   1579            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   0000000A   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD103             BNE      ??osThreadSetPriority_0
   \   00000012   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD000             BEQ      ??osThreadSetPriority_1
   1580              EvrRtxThreadError(thread_id, osErrorISR);
   \                     ??osThreadSetPriority_0: (+1)
   \   0000001A   0x....             B.N      ?Subroutine4
   1581              return osErrorISR;
   1582            }
   1583            return __svcThreadSetPriority(thread_id, priority);
   \                     ??osThreadSetPriority_1: (+1)
   \   0000001C   0x....             LDR      R0,??DataTable46_1
   \   0000001E   0x4607             mov r7,R0
   \   00000020   0x0029             MOVS     R1,R5
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0xDF00             SVC      0x0
   \   00000026   0xBDB0             POP      {R4,R5,R7,PC}    ;; return
   1584          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x2505             MOVS     R5,#+5
   \   00000002   0x43ED             MVNS     R5,R5            ;; #-6
   \   00000004   0x0029             MOVS     R1,R5
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       EvrRtxThreadError
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xBDB0             POP      {R4,R5,R7,PC}
   1585          
   1586          /// Get current priority of a thread.

   \                                 In section .text, align 4, keep-with-next
   1587          osPriority_t osThreadGetPriority (osThreadId_t thread_id) {
   \                     osThreadGetPriority: (+1)
   \   00000000   0xB598             PUSH     {R3,R4,R7,LR}
   1588            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8105      MRS      R1,IPSR
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE      ??osThreadGetPriority_0
   \   0000000A   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD006             BEQ      ??osThreadGetPriority_1
   1589              EvrRtxThreadGetPriority(thread_id, osPriorityError);
   \                     ??osThreadGetPriority_0: (+1)
   \   00000012   0x2400             MOVS     R4,#+0
   \   00000014   0x43E4             MVNS     R4,R4            ;; #-1
   \   00000016   0x0021             MOVS     R1,R4
   \   00000018   0x.... 0x....      BL       EvrRtxThreadGetPriority
   1590              return osPriorityError;
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xBD92             POP      {R1,R4,R7,PC}
   1591            }
   1592            return __svcThreadGetPriority(thread_id);
   \                     ??osThreadGetPriority_1: (+1)
   \   00000020   0x....             LDR      R1,??DataTable46_2
   \   00000022   0x460F             mov r7,R1
   \   00000024   0xDF00             SVC      0x0
   \   00000026   0xBD92             POP      {R1,R4,R7,PC}    ;; return
   1593          }
   1594          
   1595          /// Pass control to next thread that is in state READY.

   \                                 In section .text, align 4, keep-with-next
   1596          osStatus_t osThreadYield (void) {
   \                     osThreadYield: (+1)
   \   00000000   0xB598             PUSH     {R3,R4,R7,LR}
   1597            EvrRtxThreadYield();
   \   00000002   0x.... 0x....      BL       EvrRtxThreadYield
   1598            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000006   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD103             BNE      ??osThreadYield_0
   \   0000000E   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD000             BEQ      ??osThreadYield_1
   1599              EvrRtxThreadError(NULL, osErrorISR);
   \                     ??osThreadYield_0: (+1)
   \   00000016   0x....             B.N      ?Subroutine3
   1600              return osErrorISR;
   1601            }
   1602            return __svcThreadYield();
   \                     ??osThreadYield_1: (+1)
   \   00000018   0x....             LDR      R0,??DataTable46_3
   \   0000001A   0x4607             mov r7,R0
   \   0000001C   0xDF00             SVC      0x0
   \   0000001E   0xBD92             POP      {R1,R4,R7,PC}    ;; return
   1603          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x2405             MOVS     R4,#+5
   \   00000002   0x43E4             MVNS     R4,R4            ;; #-6
   \   00000004   0x0021             MOVS     R1,R4
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       EvrRtxThreadError
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xBD92             POP      {R1,R4,R7,PC}
   1604          
   1605          /// Suspend execution of a thread.

   \                                 In section .text, align 4, keep-with-next
   1606          osStatus_t osThreadSuspend (osThreadId_t thread_id) {
   \                     osThreadSuspend: (+1)
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1607            EvrRtxThreadSuspend(thread_id);
   \   00000004   0x.... 0x....      BL       EvrRtxThreadSuspend
   1608            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000008   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE      ??osThreadSuspend_0
   \   00000010   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD000             BEQ      ??osThreadSuspend_1
   1609              EvrRtxThreadError(thread_id, osErrorISR);
   \                     ??osThreadSuspend_0: (+1)
   \   00000018   0x....             B.N      ?Subroutine4
   1610              return osErrorISR;
   1611            }
   1612            return __svcThreadSuspend(thread_id);
   \                     ??osThreadSuspend_1: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable46_4
   \   0000001C   0x4607             mov r7,R0
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBDB0             POP      {R4,R5,R7,PC}    ;; return
   1613          }
   1614          
   1615          /// Resume execution of a thread.

   \                                 In section .text, align 4, keep-with-next
   1616          osStatus_t osThreadResume (osThreadId_t thread_id) {
   \                     osThreadResume: (+1)
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1617            EvrRtxThreadResume(thread_id);
   \   00000004   0x.... 0x....      BL       EvrRtxThreadResume
   1618            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000008   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE      ??osThreadResume_0
   \   00000010   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD000             BEQ      ??osThreadResume_1
   1619              EvrRtxThreadError(thread_id, osErrorISR);
   \                     ??osThreadResume_0: (+1)
   \   00000018   0x....             B.N      ?Subroutine4
   1620              return osErrorISR;
   1621            }
   1622            return __svcThreadResume(thread_id);
   \                     ??osThreadResume_1: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable46_5
   \   0000001C   0x4607             mov r7,R0
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBDB0             POP      {R4,R5,R7,PC}    ;; return
   1623          }
   1624          
   1625          /// Detach a thread (thread storage can be reclaimed when thread terminates).

   \                                 In section .text, align 4, keep-with-next
   1626          osStatus_t osThreadDetach (osThreadId_t thread_id) {
   \                     osThreadDetach: (+1)
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1627            EvrRtxThreadDetach(thread_id);
   \   00000004   0x.... 0x....      BL       EvrRtxThreadDetach
   1628            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000008   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE      ??osThreadDetach_0
   \   00000010   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD000             BEQ      ??osThreadDetach_1
   1629              EvrRtxThreadError(thread_id, osErrorISR);
   \                     ??osThreadDetach_0: (+1)
   \   00000018   0x....             B.N      ?Subroutine4
   1630              return osErrorISR;
   1631            }
   1632            return __svcThreadDetach(thread_id);
   \                     ??osThreadDetach_1: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable46_6
   \   0000001C   0x4607             mov r7,R0
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBDB0             POP      {R4,R5,R7,PC}    ;; return
   1633          }
   1634          
   1635          /// Wait for specified thread to terminate.

   \                                 In section .text, align 4, keep-with-next
   1636          osStatus_t osThreadJoin (osThreadId_t thread_id) {
   \                     osThreadJoin: (+1)
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1637            EvrRtxThreadJoin(thread_id);
   \   00000004   0x.... 0x....      BL       EvrRtxThreadJoin
   1638            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000008   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE      ??osThreadJoin_0
   \   00000010   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD000             BEQ      ??osThreadJoin_1
   1639              EvrRtxThreadError(thread_id, osErrorISR);
   \                     ??osThreadJoin_0: (+1)
   \   00000018   0x....             B.N      ?Subroutine4
   1640              return osErrorISR;
   1641            }
   1642            return __svcThreadJoin(thread_id);
   \                     ??osThreadJoin_1: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable46_7
   \   0000001C   0x4607             mov r7,R0
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBDB0             POP      {R4,R5,R7,PC}    ;; return
   1643          }
   1644          
   1645          /// Terminate execution of current running thread.

   \                                 In section .text, align 4, keep-with-next
   1646          __NO_RETURN void osThreadExit (void) {
   1647            EvrRtxThreadExit();
   \                     osThreadExit: (+1)
   \   00000000   0x.... 0x....      BL       EvrRtxThreadExit
   1648            __svcThreadExit();
   \   00000004   0x....             LDR      R0,??DataTable46_8
   \   00000006   0x4607             mov r7,R0
   \   00000008   0xDF00             SVC      0x0
   1649            EvrRtxThreadError(NULL, osError);
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      BL       EvrRtxThreadError
   1650            for (;;);
   \                     ??osThreadExit_0: (+1)
   \   00000014   0xE7FE             B        ??osThreadExit_0
   1651          }
   1652          
   1653          /// Terminate execution of a thread.

   \                                 In section .text, align 4, keep-with-next
   1654          osStatus_t osThreadTerminate (osThreadId_t thread_id) {
   \                     osThreadTerminate: (+1)
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1655            EvrRtxThreadTerminate(thread_id);
   \   00000004   0x.... 0x....      BL       EvrRtxThreadTerminate
   1656            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000008   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE      ??osThreadTerminate_0
   \   00000010   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD000             BEQ      ??osThreadTerminate_1
   1657              EvrRtxThreadError(thread_id, osErrorISR);
   \                     ??osThreadTerminate_0: (+1)
   \   00000018   0x....             B.N      ?Subroutine4
   1658              return osErrorISR;
   1659            }
   1660            return __svcThreadTerminate(thread_id);
   \                     ??osThreadTerminate_1: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable46_9
   \   0000001C   0x4607             mov r7,R0
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBDB0             POP      {R4,R5,R7,PC}    ;; return
   1661          }
   1662          
   1663          /// Get number of active threads.

   \                                 In section .text, align 4, keep-with-next
   1664          uint32_t osThreadGetCount (void) {
   \                     osThreadGetCount: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1665            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD103             BNE      ??osThreadGetCount_0
   \   0000000A   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ      ??osThreadGetCount_1
   1666              EvrRtxThreadGetCount(0U);
   \                     ??osThreadGetCount_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       EvrRtxThreadGetCount
   1667              return 0U;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD80             POP      {R7,PC}
   1668            }
   1669            return __svcThreadGetCount();
   \                     ??osThreadGetCount_1: (+1)
   \   0000001C   0x....             LDR      R0,??DataTable46_10
   \   0000001E   0x4607             mov r7,R0
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBD80             POP      {R7,PC}          ;; return
   1670          }
   1671          
   1672          /// Enumerate active threads.

   \                                 In section .text, align 4, keep-with-next
   1673          uint32_t osThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items) {
   \                     osThreadEnumerate: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1674            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8205      MRS      R2,IPSR
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD103             BNE      ??osThreadEnumerate_0
   \   0000000A   0xF3EF 0x8210      MRS      R2,PRIMASK
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD004             BEQ      ??osThreadEnumerate_1
   1675              EvrRtxThreadEnumerate(thread_array, array_items, 0U);
   \                     ??osThreadEnumerate_0: (+1)
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x.... 0x....      BL       EvrRtxThreadEnumerate
   1676              return 0U;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD80             POP      {R7,PC}
   1677            }
   1678            return __svcThreadEnumerate(thread_array, array_items);
   \                     ??osThreadEnumerate_1: (+1)
   \   0000001C   0x....             LDR      R2,??DataTable46_11
   \   0000001E   0x4617             mov r7,R2
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBD80             POP      {R7,PC}          ;; return
   1679          }
   1680          
   1681          /// Set the specified Thread Flags of a thread.

   \                                 In section .text, align 4, keep-with-next
   1682          uint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags) {
   \                     osThreadFlagsSet: (+1)
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1683            EvrRtxThreadFlagsSet(thread_id, flags);
   \   00000006   0x.... 0x....      BL       EvrRtxThreadFlagsSet
   1684            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   0000000A   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD103             BNE      ??osThreadFlagsSet_0
   \   00000012   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD026             BEQ      ??osThreadFlagsSet_1
   1685              return isrRtxThreadFlagsSet(thread_id, flags);
   \                     ??osThreadFlagsSet_0: (+1)
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD01C             BEQ      ??osThreadFlagsSet_2
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD119             BNE      ??osThreadFlagsSet_2
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD417             BMI      ??osThreadFlagsSet_2
   \   00000028   0x7860             LDRB     R0,[R4, #+1]
   \   0000002A   0x0001             MOVS     R1,R0
   \   0000002C   0xD012             BEQ      ??osThreadFlagsSet_3
   \   0000002E   0x2804             CMP      R0,#+4
   \   00000030   0xD010             BEQ      ??osThreadFlagsSet_3
   \   00000032   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000036   0xB672             CPSID    I
   \   00000038   0x6AA1             LDR      R1,[R4, #+40]
   \   0000003A   0x430D             ORRS     R5,R5,R1
   \   0000003C   0x62A5             STR      R5,[R4, #+40]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD100             BNE      ??osThreadFlagsSet_4
   \   00000042   0xB662             CPSIE    I
   \                     ??osThreadFlagsSet_4: (+1)
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       osRtxPostProcess
   \   0000004A   0x0029             MOVS     R1,R5
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       EvrRtxThreadFlagsSetDone
   \   00000052   0xE007             B        ??osThreadFlagsSet_5
   \                     ??osThreadFlagsSet_3: (+1)
   \   00000054   0x2502             MOVS     R5,#+2
   \   00000056   0xE000             B        ??osThreadFlagsSet_6
   \                     ??osThreadFlagsSet_2: (+1)
   \   00000058   0x2503             MOVS     R5,#+3
   \                     ??osThreadFlagsSet_6: (+1)
   \   0000005A   0x43ED             MVNS     R5,R5            ;; #-4
   \   0000005C   0x0029             MOVS     R1,R5
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       EvrRtxThreadError
   1686            } else {
   \                     ??osThreadFlagsSet_5: (+1)
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0xBDB0             POP      {R4,R5,R7,PC}
   1687              return  __svcThreadFlagsSet(thread_id, flags);
   \                     ??osThreadFlagsSet_1: (+1)
   \   00000068   0x....             LDR      R0,??DataTable46_12
   \   0000006A   0x4607             mov r7,R0
   \   0000006C   0x0029             MOVS     R1,R5
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0xDF00             SVC      0x0
   \   00000072   0xBDB0             POP      {R4,R5,R7,PC}    ;; return
   1688            }
   1689          }
   1690          
   1691          /// Clear the specified Thread Flags of current running thread.

   \                                 In section .text, align 4, keep-with-next
   1692          uint32_t osThreadFlagsClear (uint32_t flags) {
   \                     osThreadFlagsClear: (+1)
   \   00000000   0xB598             PUSH     {R3,R4,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1693            EvrRtxThreadFlagsClear(flags);
   \   00000004   0x.... 0x....      BL       EvrRtxThreadFlagsClear
   1694            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000008   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE      ??osThreadFlagsClear_0
   \   00000010   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD000             BEQ      ??osThreadFlagsClear_1
   1695              EvrRtxThreadError(NULL, osErrorISR);
   \                     ??osThreadFlagsClear_0: (+1)
   \   00000018   0x....             B.N      ?Subroutine3
   1696              return ((uint32_t)osErrorISR);
   1697            }
   1698            return __svcThreadFlagsClear(flags);
   \                     ??osThreadFlagsClear_1: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable46_13
   \   0000001C   0x4607             mov r7,R0
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBD92             POP      {R1,R4,R7,PC}    ;; return
   1699          }
   1700          
   1701          /// Get the current Thread Flags of current running thread.

   \                                 In section .text, align 4, keep-with-next
   1702          uint32_t osThreadFlagsGet (void) {
   \                     osThreadFlagsGet: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1703            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD103             BNE      ??osThreadFlagsGet_0
   \   0000000A   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ      ??osThreadFlagsGet_1
   1704              EvrRtxThreadFlagsGet(0U);
   \                     ??osThreadFlagsGet_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       EvrRtxThreadFlagsGet
   1705              return 0U;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD80             POP      {R7,PC}
   1706            }
   1707            return __svcThreadFlagsGet();
   \                     ??osThreadFlagsGet_1: (+1)
   \   0000001C   0x....             LDR      R0,??DataTable46_14
   \   0000001E   0x4607             mov r7,R0
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBD80             POP      {R7,PC}          ;; return
   1708          }
   1709          
   1710          /// Wait for one or more Thread Flags of the current running thread to become signaled.

   \                                 In section .text, align 4, keep-with-next
   1711          uint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout) {
   \                     osThreadFlagsWait: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0015             MOVS     R5,R2
   1712            EvrRtxThreadFlagsWait(flags, options, timeout);
   \   00000008   0x.... 0x....      BL       EvrRtxThreadFlagsWait
   1713            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   0000000C   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD103             BNE      ??osThreadFlagsWait_0
   \   00000014   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD007             BEQ      ??osThreadFlagsWait_1
   1714              EvrRtxThreadError(NULL, osErrorISR);
   \                     ??osThreadFlagsWait_0: (+1)
   \   0000001C   0x2405             MOVS     R4,#+5
   \   0000001E   0x43E4             MVNS     R4,R4            ;; #-6
   \   00000020   0x0021             MOVS     R1,R4
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      BL       EvrRtxThreadError
   1715              return ((uint32_t)osErrorISR);
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}
   1716            }
   1717            return __svcThreadFlagsWait(flags, options, timeout);
   \                     ??osThreadFlagsWait_1: (+1)
   \   0000002C   0x....             LDR      R0,??DataTable46_15
   \   0000002E   0x4607             mov r7,R0
   \   00000030   0x002A             MOVS     R2,R5
   \   00000032   0x0031             MOVS     R1,R6
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0xDF00             SVC      0x0
   \   00000038   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1718          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     osRtxInfo+0x1C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     osRtxInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     osEventObs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     osRtxInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     osRtxInfo+0x1C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     osRtxInfo+0x60

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     osRtxConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0xE25A2EA5         DC32     0xe25a2ea5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0xCCCCCCCC         DC32     0xcccccccc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     osThreadExit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     osRtxThreadPostProcess

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x........         DC32     osRtxInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     osEventObs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     osRtxInfo+0x74

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     osRtxInfo+0x34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x........         DC32     osRtxInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x........         DC32     osEventObs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     osRtxInfo+0x1C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   0x........         DC32     osRtxInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \   00000000   0x........         DC32     svcRtxThreadNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43:
   \   00000000   0x........         DC32     svcRtxThreadGetName

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44:
   \   00000000   0x........         DC32     svcRtxThreadGetId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45:
   \   00000000   0x........         DC32     svcRtxThreadGetState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_1:
   \   00000000   0x........         DC32     svcRtxThreadGetStackSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46:
   \   00000000   0x........         DC32     svcRtxThreadGetStackSpace

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_1:
   \   00000000   0x........         DC32     svcRtxThreadSetPriority

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_2:
   \   00000000   0x........         DC32     svcRtxThreadGetPriority

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_3:
   \   00000000   0x........         DC32     svcRtxThreadYield

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_4:
   \   00000000   0x........         DC32     svcRtxThreadSuspend

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_5:
   \   00000000   0x........         DC32     svcRtxThreadResume

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_6:
   \   00000000   0x........         DC32     svcRtxThreadDetach

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_7:
   \   00000000   0x........         DC32     svcRtxThreadJoin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_8:
   \   00000000   0x........         DC32     svcRtxThreadExit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_9:
   \   00000000   0x........         DC32     svcRtxThreadTerminate

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_10:
   \   00000000   0x........         DC32     svcRtxThreadGetCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_11:
   \   00000000   0x........         DC32     svcRtxThreadEnumerate

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_12:
   \   00000000   0x........         DC32     svcRtxThreadFlagsSet

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_13:
   \   00000000   0x........         DC32     svcRtxThreadFlagsClear

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_14:
   \   00000000   0x........         DC32     svcRtxThreadFlagsGet

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_15:
   \   00000000   0x........         DC32     svcRtxThreadFlagsWait

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ThreadFlagsCheck
       4   osRtxThreadBlock
      12   osRtxThreadDelayInsert
       4   osRtxThreadDelayRemove
      16   osRtxThreadDelayTick
        16   -> EvrRtxEventFlagsWaitTimeout
        16   -> EvrRtxMemoryPoolAllocTimeout
        16   -> EvrRtxMessageQueueGetTimeout
        16   -> EvrRtxMessageQueuePutTimeout
        16   -> EvrRtxMutexAcquireTimeout
        16   -> EvrRtxSemaphoreAcquireTimeout
        16   -> EvrRtxThreadDelayCompleted
        16   -> EvrRtxThreadFlagsWaitTimeout
        16   -> EvrRtxThreadUnblocked
        16   -> osRtxThreadListPut
      16   osRtxThreadDispatch
        16   -> EvrRtxThreadSwitch
        16   -> osRtxThreadBlock
        16   -> osRtxThreadListPut
        16   -> osRtxThreadListRemove
        16   -> osRtxThreadStackCheck
       8   osRtxThreadFree
         8   -> osRtxMemoryFree
         8   -> osRtxMemoryPoolFree
       0   osRtxThreadListGet
       4   osRtxThreadListPut
       0   osRtxThreadListRemove
       0   osRtxThreadListRoot
      16   osRtxThreadListSort
        16   -> osRtxThreadListPut
        16   -> osRtxThreadListRemove
       0   osRtxThreadListUnlink
      16   osRtxThreadPostProcess
        16   -> EvrRtxThreadFlagsWaitCompleted
        16   -> EvrRtxThreadUnblocked
        16   -> ThreadFlagsCheck
        16   -> osRtxThreadDelayRemove
        16   -> osRtxThreadListPut
       8   osRtxThreadReadyPut
         8   -> osRtxThreadListPut
       0   osRtxThreadRegPtr
       8   osRtxThreadStackCheck
         8   -> osRtxErrorNotify
       8   osRtxThreadSwitch
         8   -> EvrRtxThreadSwitch
         8   -> osRtxThreadStackCheck
      24   osRtxThreadWaitEnter
        24   -> EvrRtxThreadBlocked
        24   -> EvrRtxThreadSwitch
        24   -> osRtxThreadListGet
        24   -> osRtxThreadListRemove
        24   -> osRtxThreadStackCheck
      16   osRtxThreadWaitExit
        16   -> EvrRtxThreadUnblocked
        16   -> osRtxThreadDelayRemove
        16   -> osRtxThreadDispatch
        16   -> osRtxThreadListPut
      24   osThreadContextNew
        24   -> EvrRtxThreadError
        24   -> EvrRtxThreadNew
      16   osThreadDetach
        16   -> EvrRtxThreadDetach
        16   -> EvrRtxThreadError
       8   osThreadEnumerate
         8   -> EvrRtxThreadEnumerate
       0   osThreadExit
         0   -> EvrRtxThreadError
         0   -> EvrRtxThreadExit
      16   osThreadFlagsClear
        16   -> EvrRtxThreadError
        16   -> EvrRtxThreadFlagsClear
       8   osThreadFlagsGet
         8   -> EvrRtxThreadFlagsGet
      16   osThreadFlagsSet
        16   -> EvrRtxThreadError
        16   -> EvrRtxThreadFlagsSet
        16   -> EvrRtxThreadFlagsSetDone
        16   -> osRtxPostProcess
      24   osThreadFlagsWait
        24   -> EvrRtxThreadError
        24   -> EvrRtxThreadFlagsWait
       8   osThreadGetCount
         8   -> EvrRtxThreadGetCount
       8   osThreadGetId
         8   -> EvrRtxThreadGetId
       8   osThreadGetName
         8   -> EvrRtxThreadGetName
      16   osThreadGetPriority
        16   -> EvrRtxThreadGetPriority
       8   osThreadGetStackSize
         8   -> EvrRtxThreadGetStackSize
       8   osThreadGetStackSpace
         8   -> EvrRtxThreadGetStackSpace
      16   osThreadGetState
        16   -> EvrRtxThreadGetState
      16   osThreadJoin
        16   -> EvrRtxThreadError
        16   -> EvrRtxThreadJoin
       8   osThreadNew
         8   -> osThreadContextNew
      16   osThreadResume
        16   -> EvrRtxThreadError
        16   -> EvrRtxThreadResume
      16   osThreadSetPriority
        16   -> EvrRtxThreadError
        16   -> EvrRtxThreadSetPriority
      16   osThreadSuspend
        16   -> EvrRtxThreadError
        16   -> EvrRtxThreadSuspend
      16   osThreadTerminate
        16   -> EvrRtxThreadError
        16   -> EvrRtxThreadTerminate
      16   osThreadYield
        16   -> EvrRtxThreadError
        16   -> EvrRtxThreadYield
      16   svcRtxThreadDetach
        16   -> EvrRtxThreadDetached
        16   -> EvrRtxThreadError
        16   -> osRtxThreadFree
        16   -> osRtxThreadListUnlink
      16   svcRtxThreadEnumerate
        16   -> EvrRtxThreadEnumerate
      16   svcRtxThreadExit
        16   -> EvrRtxThreadDestroyed
        16   -> EvrRtxThreadJoined
        16   -> EvrRtxThreadSwitch
        16   -> EvrRtxThreadUnblocked
        16   -> osRtxMutexOwnerRelease
        16   -> osRtxThreadDelayRemove
        16   -> osRtxThreadFree
        16   -> osRtxThreadListGet
        16   -> osRtxThreadListPut
        16   -> osRtxThreadStackCheck
       8   svcRtxThreadFlagsClear
         8   -> EvrRtxThreadError
         8   -> EvrRtxThreadFlagsClearDone
       8   svcRtxThreadFlagsGet
         8   -> EvrRtxThreadFlagsGet
      24   svcRtxThreadFlagsSet
        24   -> EvrRtxThreadError
        24   -> EvrRtxThreadFlagsSetDone
        24   -> EvrRtxThreadFlagsWaitCompleted
        24   -> EvrRtxThreadUnblocked
        24   -> ThreadFlagsCheck
        24   -> osRtxThreadDelayRemove
        24   -> osRtxThreadDispatch
      24   svcRtxThreadFlagsWait
        24   -> EvrRtxThreadError
        24   -> EvrRtxThreadFlagsWaitCompleted
        24   -> EvrRtxThreadFlagsWaitNotCompleted
        24   -> EvrRtxThreadFlagsWaitPending
        24   -> ThreadFlagsCheck
        24   -> osRtxThreadWaitEnter
       8   svcRtxThreadGetCount
         8   -> EvrRtxThreadGetCount
       8   svcRtxThreadGetId
         8   -> EvrRtxThreadGetId
       8   svcRtxThreadGetName
         8   -> EvrRtxThreadGetName
      16   svcRtxThreadGetPriority
        16   -> EvrRtxThreadGetPriority
       8   svcRtxThreadGetStackSize
         8   -> EvrRtxThreadGetStackSize
       8   svcRtxThreadGetStackSpace
         8   -> EvrRtxThreadGetStackSpace
      16   svcRtxThreadGetState
        16   -> EvrRtxThreadGetState
      24   svcRtxThreadJoin
        24   -> EvrRtxThreadBlocked
        24   -> EvrRtxThreadError
        24   -> EvrRtxThreadJoinPending
        24   -> EvrRtxThreadJoined
        24   -> EvrRtxThreadSwitch
        24   -> osRtxThreadFree
        24   -> osRtxThreadListGet
        24   -> osRtxThreadListRemove
        24   -> osRtxThreadListUnlink
        24   -> osRtxThreadStackCheck
      48   svcRtxThreadNew
        48   -- Indirect call
        48   -> EvrRtxThreadCreated
        48   -> EvrRtxThreadError
        48   -> __aeabi_memclr4
        48   -> osRtxMemoryAlloc
        48   -> osRtxMemoryFree
        48   -> osRtxMemoryPoolAlloc
        48   -> osRtxMemoryPoolFree
        48   -> osRtxThreadDispatch
      16   svcRtxThreadResume
        16   -> EvrRtxThreadError
        16   -> EvrRtxThreadResumed
        16   -> osRtxThreadDelayRemove
        16   -> osRtxThreadDispatch
        16   -> osRtxThreadListRemove
       8   svcRtxThreadSetPriority
         8   -> EvrRtxThreadError
         8   -> osRtxThreadDispatch
         8   -> osRtxThreadListSort
      16   svcRtxThreadSuspend
        16   -> EvrRtxThreadError
        16   -> EvrRtxThreadSuspended
        16   -> EvrRtxThreadSwitch
        16   -> osRtxThreadDelayRemove
        16   -> osRtxThreadListGet
        16   -> osRtxThreadListRemove
        16   -> osRtxThreadStackCheck
      16   svcRtxThreadTerminate
        16   -- Indirect call
        16   -> EvrRtxThreadDestroyed
        16   -> EvrRtxThreadError
        16   -> EvrRtxThreadJoined
        16   -> EvrRtxThreadSwitch
        16   -> EvrRtxThreadUnblocked
        16   -> osRtxMutexOwnerRelease
        16   -> osRtxThreadDelayRemove
        16   -> osRtxThreadDispatch
        16   -> osRtxThreadFree
        16   -> osRtxThreadListGet
        16   -> osRtxThreadListPut
        16   -> osRtxThreadListRemove
        16   -> osRtxThreadStackCheck
      16   svcRtxThreadYield
        16   -> EvrRtxThreadSwitch
        16   -> osRtxThreadListPut
        16   -> osRtxThreadListRemove
        16   -> osRtxThreadStackCheck
       8   thread_switch_helper
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable22
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable35
       4  ??DataTable42
       4  ??DataTable43
       4  ??DataTable44
       4  ??DataTable45
       4  ??DataTable45_1
       4  ??DataTable46
       4  ??DataTable46_1
       4  ??DataTable46_10
       4  ??DataTable46_11
       4  ??DataTable46_12
       4  ??DataTable46_13
       4  ??DataTable46_14
       4  ??DataTable46_15
       4  ??DataTable46_2
       4  ??DataTable46_3
       4  ??DataTable46_4
       4  ??DataTable46_5
       4  ??DataTable46_6
       4  ??DataTable46_7
       4  ??DataTable46_8
       4  ??DataTable46_9
       4  ??DataTable6
       4  ??DataTable6_1
      14  ?Subroutine0
      14  ?Subroutine1
      14  ?Subroutine2
      16  ?Subroutine3
      16  ?Subroutine4
      80  ThreadFlagsCheck
      48  osRtxThreadBlock
      98  osRtxThreadDelayInsert
     102  osRtxThreadDelayRemove
     268  osRtxThreadDelayTick
     106  osRtxThreadDispatch
      68  osRtxThreadFree
      26  osRtxThreadListGet
      48  osRtxThreadListPut
      26  osRtxThreadListRemove
      16  osRtxThreadListRoot
      36  osRtxThreadListSort
      30  osRtxThreadListUnlink
      84  osRtxThreadPostProcess
      16  osRtxThreadReadyPut
       6  osRtxThreadRegPtr
      44  osRtxThreadStackCheck
      24  osRtxThreadSwitch
     166  osRtxThreadWaitEnter
      50  osRtxThreadWaitExit
      80  osThreadContextNew
      36  osThreadDetach
      36  osThreadEnumerate
      22  osThreadExit
      36  osThreadFlagsClear
      36  osThreadFlagsGet
     116  osThreadFlagsSet
      58  osThreadFlagsWait
      36  osThreadGetCount
      36  osThreadGetId
      36  osThreadGetName
      40  osThreadGetPriority
      36  osThreadGetStackSize
      36  osThreadGetStackSpace
      40  osThreadGetState
      36  osThreadJoin
      10  osThreadNew
      36  osThreadResume
      40  osThreadSetPriority
      36  osThreadSuspend
      36  osThreadTerminate
      32  osThreadYield
      84  svcRtxThreadDetach
     106  svcRtxThreadEnumerate
     160  svcRtxThreadExit
      94  svcRtxThreadFlagsClear
      40  svcRtxThreadFlagsGet
     148  svcRtxThreadFlagsSet
     124  svcRtxThreadFlagsWait
      52  svcRtxThreadGetCount
      16  svcRtxThreadGetId
      42  svcRtxThreadGetName
      54  svcRtxThreadGetPriority
      42  svcRtxThreadGetStackSize
      80  svcRtxThreadGetStackSpace
      46  svcRtxThreadGetState
     196  svcRtxThreadJoin
     518  svcRtxThreadNew
      58  svcRtxThreadResume
      78  svcRtxThreadSetPriority
     158  svcRtxThreadSuspend
     248  svcRtxThreadTerminate
      74  svcRtxThreadYield
      28  thread_switch_helper

 
 4 928 bytes in section .text
 
 4 884 bytes of CODE memory (+ 44 bytes shared)

Errors: none
Warnings: 1

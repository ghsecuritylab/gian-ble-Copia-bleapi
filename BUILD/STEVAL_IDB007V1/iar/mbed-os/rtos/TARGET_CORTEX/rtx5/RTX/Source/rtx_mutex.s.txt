###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:54
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_mutex.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_mutex.d
#        -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_mutex.s.txt
#        -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_mutex.o
#        .\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_mutex.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_mutex.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_mutex.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_mutex.c
      1          /*
      2           * Copyright (c) 2013-2017 ARM Limited. All rights reserved.
      3           *
      4           * SPDX-License-Identifier: Apache-2.0
      5           *
      6           * Licensed under the Apache License, Version 2.0 (the License); you may
      7           * not use this file except in compliance with the License.
      8           * You may obtain a copy of the License at
      9           *
     10           * www.apache.org/licenses/LICENSE-2.0
     11           *
     12           * Unless required by applicable law or agreed to in writing, software
     13           * distributed under the License is distributed on an AS IS BASIS, WITHOUT
     14           * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15           * See the License for the specific language governing permissions and
     16           * limitations under the License.
     17           *
     18           * -----------------------------------------------------------------------------
     19           *
     20           * Project:     CMSIS-RTOS RTX
     21           * Title:       Mutex functions
     22           *
     23           * -----------------------------------------------------------------------------
     24           */
     25          
     26          #include "rtx_lib.h"

  typedef uint8_t BOOL;  //already defined in "hal_type.h"
                  ^
"C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\TARGET_STEVAL_IDB007V1\device\system_BlueNRG1.h",240  Warning[Pe301]: typedef name has already been declared (with same type)
     27          
     28          
     29          //  ==== Library functions ====
     30          
     31          /// Release Mutex list when owner Thread terminates.
     32          /// \param[in]  mutex           mutex object.
     33          /// \return 1 - success, 0 - failure.

   \                                 In section .text, align 2, keep-with-next
     34          void osRtxMutexOwnerRelease (os_mutex_t *mutex_list) {
   \                     osRtxMutexOwnerRelease: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
     35            os_mutex_t  *mutex;
     36            os_thread_t *thread;
     37          
     38            mutex = mutex_list;
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x2700             MOVS     R7,#+0
   \   00000006   0x2E00             CMP      R6,#+0
   \   00000008   0xE01F             B        ??osRtxMutexOwnerRelease_0
     39            while (mutex) {
     40              mutex_list = mutex->owner_next;
   \                     ??osRtxMutexOwnerRelease_1: (+1)
   \   0000000A   0x6975             LDR      R5,[R6, #+20]
     41              // Check if Mutex is Robust
     42              if (mutex->attr & osMutexRobust) {
   \   0000000C   0x78F0             LDRB     R0,[R6, #+3]
   \   0000000E   0x0700             LSLS     R0,R0,#+28
   \   00000010   0xD51A             BPL      ??osRtxMutexOwnerRelease_2
     43                // Clear Lock counter
     44                mutex->lock = 0U;
   \   00000012   0x7637             STRB     R7,[R6, #+24]
     45                EvrRtxMutexReleased(mutex, 0U);
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x0030             MOVS     R0,R6
   \   00000018   0x.... 0x....      BL       EvrRtxMutexReleased
     46                // Check if Thread is waiting for a Mutex
     47                if (mutex->thread_list != NULL) {
   \   0000001C   0x68B0             LDR      R0,[R6, #+8]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD012             BEQ      ??osRtxMutexOwnerRelease_2
     48                  // Wakeup waiting Thread with highest Priority
     49                  thread = osRtxThreadListGet((os_object_t*)mutex);
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0x.... 0x....      BL       osRtxThreadListGet
   \   00000028   0x0004             MOVS     R4,R0
     50                  osRtxThreadWaitExit(thread, (uint32_t)osOK, false);
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x.... 0x....      BL       osRtxThreadWaitExit
     51                  // Thread is the new Mutex owner
     52                  mutex->owner_thread = thread;
   \   00000032   0x60F4             STR      R4,[R6, #+12]
     53                  mutex->owner_next   = thread->mutex_list;
   \   00000034   0x6AE0             LDR      R0,[R4, #+44]
   \   00000036   0x6170             STR      R0,[R6, #+20]
     54                  mutex->owner_prev   = NULL;
   \   00000038   0x6137             STR      R7,[R6, #+16]
     55                  thread->mutex_list  = mutex;
   \   0000003A   0x62E6             STR      R6,[R4, #+44]
     56                  mutex->lock = 1U;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x7630             STRB     R0,[R6, #+24]
     57                  EvrRtxMutexAcquired(mutex, 1U);
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x0030             MOVS     R0,R6
   \   00000044   0x.... 0x....      BL       EvrRtxMutexAcquired
     58                }
     59              }
     60              mutex = mutex_list;
   \                     ??osRtxMutexOwnerRelease_2: (+1)
   \   00000048   0x002E             MOVS     R6,R5
     61            }
   \                     ??osRtxMutexOwnerRelease_0: (+1)
   \   0000004A   0xD1DE             BNE      ??osRtxMutexOwnerRelease_1
     62          }
   \   0000004C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
     63          
     64          
     65          //  ==== Service Calls ====
     66          
     67          //  Service Calls definitions
     68          SVC0_1M(MutexNew,      osMutexId_t,  const osMutexAttr_t *)
     69          SVC0_1 (MutexGetName,  const char *, osMutexId_t)
     70          SVC0_2 (MutexAcquire,  osStatus_t,   osMutexId_t, uint32_t)
     71          SVC0_1 (MutexRelease,  osStatus_t,   osMutexId_t)
     72          SVC0_1 (MutexGetOwner, osThreadId_t, osMutexId_t)
     73          SVC0_1 (MutexDelete,   osStatus_t,   osMutexId_t)
     74          
     75          /// Create and Initialize a Mutex object.
     76          /// \note API identical to osMutexNew

   \                                 In section .text, align 2, keep-with-next
     77          osMutexId_t svcRtxMutexNew (const osMutexAttr_t *attr) {
   \                     svcRtxMutexNew: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
     78            os_mutex_t *mutex;
     79            uint32_t    attr_bits;
     80            uint8_t     flags;
     81            const char *name;
     82          
     83            // Process attributes
     84            if (attr != NULL) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD010             BEQ      ??svcRtxMutexNew_0
     85              name      = attr->name;
   \   00000006   0x6805             LDR      R5,[R0, #+0]
     86              attr_bits = attr->attr_bits;
   \   00000008   0x6844             LDR      R4,[R0, #+4]
     87              mutex     = attr->cb_mem;
   \   0000000A   0x6886             LDR      R6,[R0, #+8]
     88              if (mutex != NULL) {
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD006             BEQ      ??svcRtxMutexNew_1
     89                if (((uint32_t)mutex & 3U) || (attr->cb_size < sizeof(os_mutex_t))) {
   \   00000010   0x07B1             LSLS     R1,R6,#+30
   \   00000012   0xD107             BNE      ??svcRtxMutexNew_2
   \   00000014   0x68C0             LDR      R0,[R0, #+12]
   \   00000016   0x281C             CMP      R0,#+28
   \   00000018   0xD304             BCC      ??svcRtxMutexNew_2
     90                  EvrRtxMutexError(NULL, osRtxErrorInvalidControlBlock);
     91                  return NULL;
     92                }
     93              } else {
     94                if (attr->cb_size != 0U) {
     95                  EvrRtxMutexError(NULL, osRtxErrorInvalidControlBlock);
     96                  return NULL;
     97                }
     98              }
     99            } else {
    100              name      = NULL;
    101              attr_bits = 0U;
    102              mutex     = NULL;
    103            }
    104          
    105            // Allocate object memory if not provided
    106            if (mutex == NULL) {
    107              if (osRtxInfo.mpi.mutex != NULL) {
    108                mutex = osRtxMemoryPoolAlloc(osRtxInfo.mpi.mutex);
    109              } else {
    110                mutex = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_mutex_t), 1U);
    111              }
    112              if (mutex == NULL) {
    113                EvrRtxMutexError(NULL, osErrorNoMemory);
    114                return NULL;
    115              }
    116              flags = osRtxFlagSystemObject;
    117            } else {
    118              flags = 0U;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE01C             B        ??svcRtxMutexNew_3
    119            }
   \                     ??svcRtxMutexNew_1: (+1)
   \   0000001E   0x68C0             LDR      R0,[R0, #+12]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD003             BEQ      ??svcRtxMutexNew_4
   \                     ??svcRtxMutexNew_2: (+1)
   \   00000024   0x2108             MOVS     R1,#+8
   \   00000026   0xE010             B.N      ??svcRtxMutexNew_5
   \                     ??svcRtxMutexNew_0: (+1)
   \   00000028   0x2400             MOVS     R4,#+0
   \   0000002A   0x2500             MOVS     R5,#+0
   \                     ??svcRtxMutexNew_4: (+1)
   \   0000002C   0x....             LDR      R3,??DataTable2
   \   0000002E   0x6958             LDR      R0,[R3, #+20]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD002             BEQ      ??svcRtxMutexNew_6
   \   00000034   0x.... 0x....      BL       osRtxMemoryPoolAlloc
   \   00000038   0xE004             B        ??svcRtxMutexNew_7
   \                     ??svcRtxMutexNew_6: (+1)
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x211C             MOVS     R1,#+28
   \   0000003E   0x6818             LDR      R0,[R3, #+0]
   \   00000040   0x.... 0x....      BL       osRtxMemoryAlloc
   \                     ??svcRtxMutexNew_7: (+1)
   \   00000044   0x0006             MOVS     R6,R0
   \   00000046   0xD106             BNE      ??svcRtxMutexNew_8
   \   00000048   0x2104             MOVS     R1,#+4
   \                     ??svcRtxMutexNew_5: (+1)
   \   0000004A   0x43C9             MVNS     R1,R1            ;; #-5
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x.... 0x....      BL       EvrRtxMutexError
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xBD70             POP      {R4-R6,PC}
   \                     ??svcRtxMutexNew_8: (+1)
   \   00000056   0x2001             MOVS     R0,#+1
    120          
    121            // Initialize control block
    122            mutex->id           = osRtxIdMutex;
   \                     ??svcRtxMutexNew_3: (+1)
   \   00000058   0x2104             MOVS     R1,#+4
   \   0000005A   0x7031             STRB     R1,[R6, #+0]
    123            mutex->state        = osRtxObjectActive;
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x7071             STRB     R1,[R6, #+1]
    124            mutex->flags        = flags;
   \   00000060   0x70B0             STRB     R0,[R6, #+2]
    125            mutex->attr         = (uint8_t)attr_bits;
   \   00000062   0x70F4             STRB     R4,[R6, #+3]
    126            mutex->name         = name;
   \   00000064   0x6075             STR      R5,[R6, #+4]
    127            mutex->thread_list  = NULL;
   \   00000066   0x2400             MOVS     R4,#+0
   \   00000068   0x60B4             STR      R4,[R6, #+8]
    128            mutex->owner_thread = NULL;
   \   0000006A   0x60F4             STR      R4,[R6, #+12]
    129            mutex->owner_prev   = NULL;
   \   0000006C   0x6134             STR      R4,[R6, #+16]
    130            mutex->owner_next   = NULL;
   \   0000006E   0x6174             STR      R4,[R6, #+20]
    131            mutex->lock         = 0U;
   \   00000070   0x7634             STRB     R4,[R6, #+24]
    132          
    133            EvrRtxMutexCreated(mutex);
   \   00000072   0x0030             MOVS     R0,R6
   \   00000074   0x.... 0x....      BL       EvrRtxMutexCreated
    134          
    135            return mutex;
   \   00000078   0x0030             MOVS     R0,R6
   \   0000007A   0xBD70             POP      {R4-R6,PC}       ;; return
    136          }
    137          
    138          /// Get name of a Mutex object.
    139          /// \note API identical to osMutexGetName

   \                                 In section .text, align 2, keep-with-next
    140          const char *svcRtxMutexGetName (osMutexId_t mutex_id) {
   \                     svcRtxMutexGetName: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    141            os_mutex_t *mutex = (os_mutex_t *)mutex_id;
    142          
    143            // Check parameters
    144            if ((mutex == NULL) || (mutex->id != osRtxIdMutex)) {
   \   00000004   0xD005             BEQ      ??svcRtxMutexGetName_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD102             BNE      ??svcRtxMutexGetName_0
    145              EvrRtxMutexGetName(mutex, NULL);
    146              return NULL;
    147            }
    148          
    149            // Check object state
    150            if (mutex->state == osRtxObjectInactive) {
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE      ??svcRtxMutexGetName_1
    151              EvrRtxMutexGetName(mutex, NULL);
   \                     ??svcRtxMutexGetName_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       EvrRtxMutexGetName
    152              return NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}
    153            }
    154          
    155            EvrRtxMutexGetName(mutex, mutex->name);
   \                     ??svcRtxMutexGetName_1: (+1)
   \   0000001E   0x6861             LDR      R1,[R4, #+4]
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       EvrRtxMutexGetName
    156          
    157            return mutex->name;
   \   00000026   0x6860             LDR      R0,[R4, #+4]
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    158          }
    159          
    160          /// Acquire a Mutex or timeout if it is locked.
    161          /// \note API identical to osMutexAcquire

   \                                 In section .text, align 2, keep-with-next
    162          osStatus_t svcRtxMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
   \                     svcRtxMutexAcquire: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
    163            os_mutex_t  *mutex = (os_mutex_t *)mutex_id;
    164            os_thread_t *runnig_thread;
    165          
    166            runnig_thread = osRtxThreadGetRunning();
   \   00000006   0x....             LDR      R0,??DataTable4
   \   00000008   0x6945             LDR      R5,[R0, #+20]
    167            if (runnig_thread == NULL) {
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD106             BNE      ??svcRtxMutexAcquire_0
    168              EvrRtxMutexError(mutex, osRtxErrorKernelNotRunning);
   \   0000000E   0x2107             MOVS     R1,#+7
   \   00000010   0x43C9             MVNS     R1,R1            ;; #-8
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       EvrRtxMutexError
    169              return osError;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE054             B        ??svcRtxMutexAcquire_1
    170            }
    171          
    172            // Check parameters
    173            if ((mutex == NULL) || (mutex->id != osRtxIdMutex)) {
   \                     ??svcRtxMutexAcquire_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD002             BEQ      ??svcRtxMutexAcquire_2
   \   00000020   0x7820             LDRB     R0,[R4, #+0]
   \   00000022   0x2804             CMP      R0,#+4
   \   00000024   0xD001             BEQ      ??svcRtxMutexAcquire_3
    174              EvrRtxMutexError(mutex, osErrorParameter);
   \                     ??svcRtxMutexAcquire_2: (+1)
   \   00000026   0x2503             MOVS     R5,#+3
   \   00000028   0xE003             B.N      ??svcRtxMutexAcquire_4
    175              return osErrorParameter;
    176            }
    177          
    178            // Check object state
    179            if (mutex->state == osRtxObjectInactive) {
   \                     ??svcRtxMutexAcquire_3: (+1)
   \   0000002A   0x7860             LDRB     R0,[R4, #+1]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD101             BNE      ??svcRtxMutexAcquire_5
    180              EvrRtxMutexError(mutex, osErrorResource);
   \   00000030   0x2502             MOVS     R5,#+2
    181              return osErrorResource;
    182            }
   \                     ??svcRtxMutexAcquire_4: (+1)
   \   00000032   0x....             B.N      ?Subroutine0
    183          
    184            // Check if Mutex is not locked
    185            if (mutex->lock == 0U) {
   \                     ??svcRtxMutexAcquire_5: (+1)
   \   00000034   0x7E21             LDRB     R1,[R4, #+24]
   \   00000036   0x0008             MOVS     R0,R1
   \   00000038   0xD10D             BNE      ??svcRtxMutexAcquire_6
    186              // Acquire Mutex
    187              mutex->owner_thread = runnig_thread;
   \   0000003A   0x60E5             STR      R5,[R4, #+12]
    188              mutex->owner_next   = runnig_thread->mutex_list;
   \   0000003C   0x6AE8             LDR      R0,[R5, #+44]
   \   0000003E   0x6160             STR      R0,[R4, #+20]
    189              mutex->owner_prev   = NULL;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6120             STR      R0,[R4, #+16]
    190              if (runnig_thread->mutex_list != NULL) {
   \   00000044   0x6AE8             LDR      R0,[R5, #+44]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD000             BEQ      ??svcRtxMutexAcquire_7
    191                  runnig_thread->mutex_list->owner_prev = mutex;
   \   0000004A   0x6104             STR      R4,[R0, #+16]
    192              }
    193              runnig_thread->mutex_list = mutex;
   \                     ??svcRtxMutexAcquire_7: (+1)
   \   0000004C   0x62EC             STR      R4,[R5, #+44]
    194              mutex->lock = 1U;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x7620             STRB     R0,[R4, #+24]
    195              EvrRtxMutexAcquired(mutex, mutex->lock);
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0xE010             B.N      ??svcRtxMutexAcquire_8
    196              return osOK;
    197            }
    198          
    199            // Check if Mutex is recursive and running Thread is the owner
    200            if ((mutex->attr & osMutexRecursive) && (mutex->owner_thread == runnig_thread)) {
   \                     ??svcRtxMutexAcquire_6: (+1)
   \   00000056   0x78E0             LDRB     R0,[R4, #+3]
   \   00000058   0x07C2             LSLS     R2,R0,#+31
   \   0000005A   0xD512             BPL      ??svcRtxMutexAcquire_9
   \   0000005C   0x68E2             LDR      R2,[R4, #+12]
   \   0000005E   0x42AA             CMP      R2,R5
   \   00000060   0xD10F             BNE      ??svcRtxMutexAcquire_9
    201              // Increment lock counter
    202              if (mutex->lock == osRtxMutexLockLimit) {
   \   00000062   0x29FF             CMP      R1,#+255
   \   00000064   0xD105             BNE      ??svcRtxMutexAcquire_10
    203                EvrRtxMutexError(mutex, osRtxErrorMutexLockLimit);
   \   00000066   0x210F             MOVS     R1,#+15
   \   00000068   0x43C9             MVNS     R1,R1            ;; #-16
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       EvrRtxMutexError
    204                return osErrorResource;
   \   00000070   0xE028             B        ??svcRtxMutexAcquire_11
    205              }
    206              mutex->lock++;
   \                     ??svcRtxMutexAcquire_10: (+1)
   \   00000072   0x1C49             ADDS     R1,R1,#+1
   \   00000074   0x7621             STRB     R1,[R4, #+24]
    207              EvrRtxMutexAcquired(mutex, mutex->lock);
   \   00000076   0xB2C9             UXTB     R1,R1
   \                     ??svcRtxMutexAcquire_8: (+1)
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      BL       EvrRtxMutexAcquired
    208              return osOK;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xBD70             POP      {R4-R6,PC}
    209            }
    210          
    211            // Check if timeout is specified
    212            if (timeout != 0U) {
   \                     ??svcRtxMutexAcquire_9: (+1)
   \   00000082   0x2E00             CMP      R6,#+0
   \   00000084   0xD01B             BEQ      ??svcRtxMutexAcquire_12
    213              // Check if Priority inheritance protocol is enabled
    214              if (mutex->attr & osMutexPrioInherit) {
   \   00000086   0x0780             LSLS     R0,R0,#+30
   \   00000088   0xD50B             BPL      ??svcRtxMutexAcquire_13
    215                // Raise priority of owner Thread if lower than priority of running Thread
    216                if (mutex->owner_thread->priority < runnig_thread->priority) {
   \   0000008A   0x2020             MOVS     R0,#+32
   \   0000008C   0x5628             LDRSB    R0,[R5, R0]
   \   0000008E   0x68E1             LDR      R1,[R4, #+12]
   \   00000090   0x2220             MOVS     R2,#+32
   \   00000092   0x568A             LDRSB    R2,[R1, R2]
   \   00000094   0x4282             CMP      R2,R0
   \   00000096   0xDA04             BGE      ??svcRtxMutexAcquire_13
    217                  mutex->owner_thread->priority = runnig_thread->priority;
   \   00000098   0x2220             MOVS     R2,#+32
   \   0000009A   0x5488             STRB     R0,[R1, R2]
    218                  osRtxThreadListSort(mutex->owner_thread);
   \   0000009C   0x68E0             LDR      R0,[R4, #+12]
   \   0000009E   0x.... 0x....      BL       osRtxThreadListSort
    219                }
    220              }
    221              EvrRtxMutexAcquirePending(mutex, timeout);
   \                     ??svcRtxMutexAcquire_13: (+1)
   \   000000A2   0x0031             MOVS     R1,R6
   \   000000A4   0x0020             MOVS     R0,R4
   \   000000A6   0x.... 0x....      BL       EvrRtxMutexAcquirePending
    222              // Suspend current Thread
    223              osRtxThreadListPut((os_object_t*)mutex, runnig_thread);
   \   000000AA   0x0029             MOVS     R1,R5
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x.... 0x....      BL       osRtxThreadListPut
    224              osRtxThreadWaitEnter(osRtxThreadWaitingMutex, timeout);
   \   000000B2   0x0031             MOVS     R1,R6
   \   000000B4   0x2053             MOVS     R0,#+83
   \   000000B6   0x.... 0x....      BL       osRtxThreadWaitEnter
    225              return osErrorTimeout;
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0xE003             B        ??svcRtxMutexAcquire_1
    226            }
    227          
    228            // Mutex was not acquired
    229            EvrRtxMutexNotAcquired(mutex);
   \                     ??svcRtxMutexAcquire_12: (+1)
   \   000000BE   0x0020             MOVS     R0,R4
   \   000000C0   0x.... 0x....      BL       EvrRtxMutexNotAcquired
    230          
    231            return osErrorResource;
   \                     ??svcRtxMutexAcquire_11: (+1)
   \   000000C4   0x2002             MOVS     R0,#+2
   \                     ??svcRtxMutexAcquire_1: (+1)
   \   000000C6   0x43C0             MVNS     R0,R0            ;; #-3
   \   000000C8   0xBD70             POP      {R4-R6,PC}       ;; return
    232          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x43ED             MVNS     R5,R5            ;; #-3
   \   00000002   0x0029             MOVS     R1,R5
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       EvrRtxMutexError
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0xBD70             POP      {R4-R6,PC}
    233          
    234          /// Release a Mutex that was acquired by osMutexAcquire.
    235          /// \note API identical to osMutexRelease

   \                                 In section .text, align 2, keep-with-next
    236          osStatus_t svcRtxMutexRelease (osMutexId_t mutex_id) {
   \                     svcRtxMutexRelease: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    237            os_mutex_t  *mutex = (os_mutex_t *)mutex_id;
    238            os_mutex_t  *mutex0;
    239            os_thread_t *thread;
    240            os_thread_t *runnig_thread;
    241            int8_t       priority;
    242          
    243            runnig_thread = osRtxThreadGetRunning();
   \   00000004   0x....             LDR      R0,??DataTable4
   \   00000006   0x6945             LDR      R5,[R0, #+20]
    244            if (runnig_thread == NULL) {
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD106             BNE      ??svcRtxMutexRelease_0
    245              EvrRtxMutexError(mutex, osRtxErrorKernelNotRunning);
   \   0000000C   0x2107             MOVS     R1,#+7
   \   0000000E   0x43C9             MVNS     R1,R1            ;; #-8
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       EvrRtxMutexError
    246              return osError;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE019             B.N      ??svcRtxMutexRelease_1
    247            }
    248          
    249            // Check parameters
    250            if ((mutex == NULL) || (mutex->id != osRtxIdMutex)) {
   \                     ??svcRtxMutexRelease_0: (+1)
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD002             BEQ      ??svcRtxMutexRelease_2
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x2804             CMP      R0,#+4
   \   00000022   0xD001             BEQ      ??svcRtxMutexRelease_3
    251              EvrRtxMutexError(mutex, osErrorParameter);
   \                     ??svcRtxMutexRelease_2: (+1)
   \   00000024   0x2503             MOVS     R5,#+3
   \   00000026   0xE003             B.N      ??svcRtxMutexRelease_4
    252              return osErrorParameter;
    253            }
    254          
    255            // Check object state
    256            if (mutex->state == osRtxObjectInactive) {
   \                     ??svcRtxMutexRelease_3: (+1)
   \   00000028   0x7860             LDRB     R0,[R4, #+1]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD101             BNE      ??svcRtxMutexRelease_5
    257              EvrRtxMutexError(mutex, osErrorResource);
   \   0000002E   0x2502             MOVS     R5,#+2
    258              return osErrorResource;
    259            }
   \                     ??svcRtxMutexRelease_4: (+1)
   \   00000030   0x....             B.N      ?Subroutine0
    260          
    261            // Check if running Thread is not the owner
    262            if (mutex->owner_thread != runnig_thread) {
   \                     ??svcRtxMutexRelease_5: (+1)
   \   00000032   0x68E0             LDR      R0,[R4, #+12]
   \   00000034   0x42A8             CMP      R0,R5
   \   00000036   0xD001             BEQ      ??svcRtxMutexRelease_6
    263              EvrRtxMutexError(mutex, osRtxErrorMutexNotOwned);
   \   00000038   0x210D             MOVS     R1,#+13
   \   0000003A   0xE003             B.N      ??svcRtxMutexRelease_7
    264              return osErrorResource;
    265            }
    266          
    267            // Check if Mutex is not locked
    268            if (mutex->lock == 0U) {
   \                     ??svcRtxMutexRelease_6: (+1)
   \   0000003C   0x7E20             LDRB     R0,[R4, #+24]
   \   0000003E   0x0001             MOVS     R1,R0
   \   00000040   0xD107             BNE      ??svcRtxMutexRelease_8
    269              EvrRtxMutexError(mutex, osRtxErrorMutexNotLocked);
   \   00000042   0x210E             MOVS     R1,#+14
   \                     ??svcRtxMutexRelease_7: (+1)
   \   00000044   0x43C9             MVNS     R1,R1            ;; #-15
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       EvrRtxMutexError
    270              return osErrorResource;
   \   0000004C   0x2002             MOVS     R0,#+2
   \                     ??svcRtxMutexRelease_1: (+1)
   \   0000004E   0x43C0             MVNS     R0,R0            ;; #-3
   \   00000050   0xBD70             POP      {R4-R6,PC}
    271            }
    272          
    273            // Decrement Lock counter
    274            mutex->lock--;
   \                     ??svcRtxMutexRelease_8: (+1)
   \   00000052   0x1E41             SUBS     R1,R0,#+1
   \   00000054   0x7621             STRB     R1,[R4, #+24]
    275            EvrRtxMutexReleased(mutex, mutex->lock);
   \   00000056   0xB2C9             UXTB     R1,R1
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       EvrRtxMutexReleased
    276          
    277            // Check Lock counter
    278            if (mutex->lock != 0U) {
   \   0000005E   0x7E20             LDRB     R0,[R4, #+24]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD139             BNE      ??svcRtxMutexRelease_9
    279              return osOK;
    280            }
    281          
    282            // Remove Mutex from Thread owner list
    283            if (mutex->owner_next != NULL) {
   \   00000064   0x6960             LDR      R0,[R4, #+20]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD001             BEQ      ??svcRtxMutexRelease_10
    284              mutex->owner_next->owner_prev = mutex->owner_prev;
   \   0000006A   0x6921             LDR      R1,[R4, #+16]
   \   0000006C   0x6101             STR      R1,[R0, #+16]
    285            }
    286            if (mutex->owner_prev != NULL) {
   \                     ??svcRtxMutexRelease_10: (+1)
   \   0000006E   0x6920             LDR      R0,[R4, #+16]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD002             BEQ      ??svcRtxMutexRelease_11
    287              mutex->owner_prev->owner_next = mutex->owner_next;
   \   00000074   0x6961             LDR      R1,[R4, #+20]
   \   00000076   0x6141             STR      R1,[R0, #+20]
   \   00000078   0xE001             B        ??svcRtxMutexRelease_12
    288            } else {
    289              runnig_thread->mutex_list = mutex->owner_next;
   \                     ??svcRtxMutexRelease_11: (+1)
   \   0000007A   0x6960             LDR      R0,[R4, #+20]
   \   0000007C   0x62E8             STR      R0,[R5, #+44]
    290            }
    291          
    292            // Restore running Thread priority
    293            if (mutex->attr & osMutexPrioInherit) {
   \                     ??svcRtxMutexRelease_12: (+1)
   \   0000007E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000080   0x0780             LSLS     R0,R0,#+30
   \   00000082   0xD50F             BPL      ??svcRtxMutexRelease_13
    294              priority = runnig_thread->priority_base;
   \   00000084   0x2021             MOVS     R0,#+33
   \   00000086   0x5628             LDRSB    R0,[R5, R0]
    295              mutex0   = runnig_thread->mutex_list;
   \   00000088   0x6AE9             LDR      R1,[R5, #+44]
   \   0000008A   0x2620             MOVS     R6,#+32
   \   0000008C   0xE007             B        ??svcRtxMutexRelease_14
    296              while (mutex0) {
    297                // Mutexes owned by running Thread
    298                if ((mutex0->thread_list != NULL) && (mutex0->thread_list->priority > priority)) {
   \                     ??svcRtxMutexRelease_15: (+1)
   \   0000008E   0x688A             LDR      R2,[R1, #+8]
   \   00000090   0x2A00             CMP      R2,#+0
   \   00000092   0xD003             BEQ      ??svcRtxMutexRelease_16
   \   00000094   0x5792             LDRSB    R2,[R2, R6]
   \   00000096   0x4290             CMP      R0,R2
   \   00000098   0xDA00             BGE      ??svcRtxMutexRelease_16
   \   0000009A   0x0010             MOVS     R0,R2
    299                  // Higher priority Thread is waiting for Mutex
    300                  priority = mutex0->thread_list->priority;
    301                }
    302                mutex0 = mutex0->owner_next;
   \                     ??svcRtxMutexRelease_16: (+1)
   \   0000009C   0x6949             LDR      R1,[R1, #+20]
    303              }
   \                     ??svcRtxMutexRelease_14: (+1)
   \   0000009E   0x2900             CMP      R1,#+0
   \   000000A0   0xD1F5             BNE      ??svcRtxMutexRelease_15
    304              runnig_thread->priority = priority;
   \   000000A2   0x55A8             STRB     R0,[R5, R6]
    305            }
    306          
    307            // Check if Thread is waiting for a Mutex
    308            if (mutex->thread_list != NULL) {
   \                     ??svcRtxMutexRelease_13: (+1)
   \   000000A4   0x68A0             LDR      R0,[R4, #+8]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD013             BEQ      ??svcRtxMutexRelease_17
    309              // Wakeup waiting Thread with highest Priority
    310              thread = osRtxThreadListGet((os_object_t*)mutex);
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       osRtxThreadListGet
   \   000000B0   0x0005             MOVS     R5,R0
    311              osRtxThreadWaitExit(thread, (uint32_t)osOK, false);
   \   000000B2   0x2200             MOVS     R2,#+0
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0x.... 0x....      BL       osRtxThreadWaitExit
    312              // Thread is the new Mutex owner
    313              mutex->owner_thread = thread;
   \   000000BA   0x60E5             STR      R5,[R4, #+12]
    314              mutex->owner_next   = thread->mutex_list;
   \   000000BC   0x6AE8             LDR      R0,[R5, #+44]
   \   000000BE   0x6160             STR      R0,[R4, #+20]
    315              mutex->owner_prev   = NULL;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x6120             STR      R0,[R4, #+16]
    316              thread->mutex_list  = mutex;
   \   000000C4   0x62EC             STR      R4,[R5, #+44]
    317              mutex->lock = 1U;
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0x7620             STRB     R0,[R4, #+24]
    318              EvrRtxMutexAcquired(mutex, 1U);
   \   000000CA   0x2101             MOVS     R1,#+1
   \   000000CC   0x0020             MOVS     R0,R4
   \   000000CE   0x.... 0x....      BL       EvrRtxMutexAcquired
    319            }
    320          
    321            osRtxThreadDispatch(NULL);
   \                     ??svcRtxMutexRelease_17: (+1)
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x.... 0x....      BL       osRtxThreadDispatch
    322          
    323            return osOK;
   \                     ??svcRtxMutexRelease_9: (+1)
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xBD70             POP      {R4-R6,PC}       ;; return
    324          }
    325          
    326          /// Get Thread which owns a Mutex object.
    327          /// \note API identical to osMutexGetOwner

   \                                 In section .text, align 2, keep-with-next
    328          osThreadId_t svcRtxMutexGetOwner (osMutexId_t mutex_id) {
   \                     svcRtxMutexGetOwner: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    329            os_mutex_t *mutex = (os_mutex_t *)mutex_id;
    330          
    331            // Check parameters
    332            if ((mutex == NULL) || (mutex->id != osRtxIdMutex)) {
   \   00000004   0xD008             BEQ      ??svcRtxMutexGetOwner_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD105             BNE      ??svcRtxMutexGetOwner_0
    333              EvrRtxMutexGetOwner(mutex, NULL);
    334              return NULL;
    335            }
    336          
    337            // Check object state
    338            if (mutex->state == osRtxObjectInactive) {
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD002             BEQ      ??svcRtxMutexGetOwner_0
    339              EvrRtxMutexGetOwner(mutex, NULL);
    340              return NULL;
    341            }
    342          
    343            // Check if Mutex is not locked
    344            if (mutex->lock == 0U) {
   \   00000012   0x7E20             LDRB     R0,[R4, #+24]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD105             BNE      ??svcRtxMutexGetOwner_1
    345              EvrRtxMutexGetOwner(mutex, NULL);
   \                     ??svcRtxMutexGetOwner_0: (+1)
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       EvrRtxMutexGetOwner
    346              return NULL;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD10             POP      {R4,PC}
    347            }
    348          
    349            EvrRtxMutexGetOwner(mutex, mutex->owner_thread);
   \                     ??svcRtxMutexGetOwner_1: (+1)
   \   00000024   0x68E1             LDR      R1,[R4, #+12]
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       EvrRtxMutexGetOwner
    350          
    351            return mutex->owner_thread;
   \   0000002C   0x68E0             LDR      R0,[R4, #+12]
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    352          }
    353          
    354          /// Delete a Mutex object.
    355          /// \note API identical to osMutexDelete

   \                                 In section .text, align 2, keep-with-next
    356          osStatus_t svcRtxMutexDelete (osMutexId_t mutex_id) {
   \                     svcRtxMutexDelete: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    357            os_mutex_t  *mutex = (os_mutex_t *)mutex_id;
    358            os_mutex_t  *mutex0;
    359            os_thread_t *thread;
    360            int8_t       priority;
    361          
    362            // Check parameters
    363            if ((mutex == NULL) || (mutex->id != osRtxIdMutex)) {
   \   00000004   0xD002             BEQ      ??svcRtxMutexDelete_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD001             BEQ      ??svcRtxMutexDelete_1
    364              EvrRtxMutexError(mutex, osErrorParameter);
   \                     ??svcRtxMutexDelete_0: (+1)
   \   0000000C   0x2503             MOVS     R5,#+3
   \   0000000E   0xE003             B.N      ??svcRtxMutexDelete_2
    365              return osErrorParameter;
    366            }
    367          
    368            // Check object state
    369            if (mutex->state == osRtxObjectInactive) {
   \                     ??svcRtxMutexDelete_1: (+1)
   \   00000010   0x7860             LDRB     R0,[R4, #+1]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE      ??svcRtxMutexDelete_3
    370              EvrRtxMutexError(mutex, osErrorResource);
   \   00000016   0x2502             MOVS     R5,#+2
    371              return osErrorResource;
    372            }
   \                     ??svcRtxMutexDelete_2: (+1)
   \   00000018   0x....             B.N      ?Subroutine0
    373          
    374            // Mark object as inactive
    375            mutex->state = osRtxObjectInactive;
   \                     ??svcRtxMutexDelete_3: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x7060             STRB     R0,[R4, #+1]
    376          
    377            // Check if Mutex is locked
    378            if (mutex->lock != 0U) {
   \   0000001E   0x7E20             LDRB     R0,[R4, #+24]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD036             BEQ      ??svcRtxMutexDelete_4
    379          
    380              thread = mutex->owner_thread;
   \   00000024   0x68E0             LDR      R0,[R4, #+12]
    381          
    382              // Remove Mutex from Thread owner list
    383              if (mutex->owner_next != NULL) {
   \   00000026   0x6961             LDR      R1,[R4, #+20]
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD001             BEQ      ??svcRtxMutexDelete_5
    384                mutex->owner_next->owner_prev = mutex->owner_prev;
   \   0000002C   0x6922             LDR      R2,[R4, #+16]
   \   0000002E   0x610A             STR      R2,[R1, #+16]
    385              }
    386              if (mutex->owner_prev != NULL) {
   \                     ??svcRtxMutexDelete_5: (+1)
   \   00000030   0x6921             LDR      R1,[R4, #+16]
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD002             BEQ      ??svcRtxMutexDelete_6
    387                mutex->owner_prev->owner_next = mutex->owner_next;
   \   00000036   0x6962             LDR      R2,[R4, #+20]
   \   00000038   0x614A             STR      R2,[R1, #+20]
   \   0000003A   0xE001             B        ??svcRtxMutexDelete_7
    388              } else {
    389                thread->mutex_list = mutex->owner_next;
   \                     ??svcRtxMutexDelete_6: (+1)
   \   0000003C   0x6961             LDR      R1,[R4, #+20]
   \   0000003E   0x62C1             STR      R1,[R0, #+44]
    390              }
    391          
    392              // Restore owner Thread priority
    393              if (mutex->attr & osMutexPrioInherit) {
   \                     ??svcRtxMutexDelete_7: (+1)
   \   00000040   0x78E1             LDRB     R1,[R4, #+3]
   \   00000042   0x0789             LSLS     R1,R1,#+30
   \   00000044   0xD514             BPL      ??svcRtxMutexDelete_8
    394                priority = thread->priority_base;
   \   00000046   0x2121             MOVS     R1,#+33
   \   00000048   0x5641             LDRSB    R1,[R0, R1]
    395                mutex0   = thread->mutex_list;
   \   0000004A   0x6AC2             LDR      R2,[R0, #+44]
   \   0000004C   0x2620             MOVS     R6,#+32
   \   0000004E   0xE007             B        ??svcRtxMutexDelete_9
    396                while (mutex0) {
    397                  // Mutexes owned by running Thread
    398                  if ((mutex0->thread_list != NULL) && (mutex0->thread_list->priority > priority)) {
   \                     ??svcRtxMutexDelete_10: (+1)
   \   00000050   0x6893             LDR      R3,[R2, #+8]
   \   00000052   0x2B00             CMP      R3,#+0
   \   00000054   0xD003             BEQ      ??svcRtxMutexDelete_11
   \   00000056   0x579B             LDRSB    R3,[R3, R6]
   \   00000058   0x4299             CMP      R1,R3
   \   0000005A   0xDA00             BGE      ??svcRtxMutexDelete_11
   \   0000005C   0x0019             MOVS     R1,R3
    399                    // Higher priority Thread is waiting for Mutex
    400                    priority = mutex0->thread_list->priority;
    401                  }
    402                  mutex0 = mutex0->owner_next;
   \                     ??svcRtxMutexDelete_11: (+1)
   \   0000005E   0x6952             LDR      R2,[R2, #+20]
    403                }
   \                     ??svcRtxMutexDelete_9: (+1)
   \   00000060   0x2A00             CMP      R2,#+0
   \   00000062   0xD1F5             BNE      ??svcRtxMutexDelete_10
    404                if (thread->priority != priority) {
   \   00000064   0x5782             LDRSB    R2,[R0, R6]
   \   00000066   0x428A             CMP      R2,R1
   \   00000068   0xD002             BEQ      ??svcRtxMutexDelete_8
    405                  thread->priority = priority;
   \   0000006A   0x5581             STRB     R1,[R0, R6]
    406                  osRtxThreadListSort(thread);
   \   0000006C   0x.... 0x....      BL       osRtxThreadListSort
    407                }
    408              }
    409          
    410              // Unblock waiting threads
    411              if (mutex->thread_list != NULL) {
   \                     ??svcRtxMutexDelete_8: (+1)
   \   00000070   0x68A0             LDR      R0,[R4, #+8]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD00A             BEQ      ??svcRtxMutexDelete_12
    412                do {
    413                  thread = osRtxThreadListGet((os_object_t*)mutex);
   \                     ??svcRtxMutexDelete_13: (+1)
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       osRtxThreadListGet
    414                  osRtxThreadWaitExit(thread, (uint32_t)osErrorResource, false);
   \   0000007C   0x2200             MOVS     R2,#+0
   \   0000007E   0x2102             MOVS     R1,#+2
   \   00000080   0x43C9             MVNS     R1,R1            ;; #-3
   \   00000082   0x.... 0x....      BL       osRtxThreadWaitExit
    415                } while (mutex->thread_list != NULL);
   \   00000086   0x68A0             LDR      R0,[R4, #+8]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD1F4             BNE      ??svcRtxMutexDelete_13
    416              }
    417          
    418              osRtxThreadDispatch(NULL);
   \                     ??svcRtxMutexDelete_12: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x.... 0x....      BL       osRtxThreadDispatch
    419            }
    420          
    421            // Free object memory
    422            if (mutex->flags & osRtxFlagSystemObject) {
   \                     ??svcRtxMutexDelete_4: (+1)
   \   00000092   0x78A0             LDRB     R0,[R4, #+2]
   \   00000094   0x07C0             LSLS     R0,R0,#+31
   \   00000096   0xD50B             BPL      ??svcRtxMutexDelete_14
    423              if (osRtxInfo.mpi.mutex != NULL) {
   \   00000098   0x....             LDR      R2,??DataTable9
   \   0000009A   0x6950             LDR      R0,[R2, #+20]
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD003             BEQ      ??svcRtxMutexDelete_15
    424                osRtxMemoryPoolFree(osRtxInfo.mpi.mutex, mutex);
   \   000000A0   0x0021             MOVS     R1,R4
   \   000000A2   0x.... 0x....      BL       osRtxMemoryPoolFree
   \   000000A6   0xE003             B        ??svcRtxMutexDelete_14
    425              } else {
    426                osRtxMemoryFree(osRtxInfo.mem.common, mutex);
   \                     ??svcRtxMutexDelete_15: (+1)
   \   000000A8   0x0021             MOVS     R1,R4
   \   000000AA   0x6810             LDR      R0,[R2, #+0]
   \   000000AC   0x.... 0x....      BL       osRtxMemoryFree
    427              }
    428            }
    429          
    430            EvrRtxMutexDestroyed(mutex);
   \                     ??svcRtxMutexDelete_14: (+1)
   \   000000B0   0x0020             MOVS     R0,R4
   \   000000B2   0x.... 0x....      BL       EvrRtxMutexDestroyed
    431          
    432            return osOK;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xBD70             POP      {R4-R6,PC}       ;; return
    433          }
    434          
    435          
    436          //  ==== Public API ====
    437          
    438          /// Create and Initialize a Mutex object.

   \                                 In section .text, align 4, keep-with-next
    439          osMutexId_t osMutexNew (const osMutexAttr_t *attr) {
   \                     osMutexNew: (+1)
   \   00000000   0xB598             PUSH     {R3,R4,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    440            EvrRtxMutexNew(attr);
   \   00000004   0x.... 0x....      BL       EvrRtxMutexNew
    441            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000008   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE      ??osMutexNew_0
   \   00000010   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD006             BEQ      ??osMutexNew_1
    442              EvrRtxMutexError(NULL, osErrorISR);
   \                     ??osMutexNew_0: (+1)
   \   00000018   0x2105             MOVS     R1,#+5
   \   0000001A   0x43C9             MVNS     R1,R1            ;; #-6
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       EvrRtxMutexError
    443              return NULL;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD92             POP      {R1,R4,R7,PC}
    444            }
    445            return __svcMutexNew(attr);
   \                     ??osMutexNew_1: (+1)
   \   00000026   0xF3EF 0x8014      MRS      R0,CONTROL
   \   0000002A   0x0780             LSLS     R0,R0,#+30
   \   0000002C   0xD406             BMI      ??osMutexNew_2
   \   0000002E   0xF3EF 0x8008      MRS      R0,MSP
   \   00000032   0x3820             SUBS     R0,R0,#+32
   \   00000034   0x2107             MOVS     R1,#+7
   \   00000036   0x4388             BICS     R0,R0,R1
   \   00000038   0xF380 0x8809      MSR      PSP,R0
   \                     ??osMutexNew_2: (+1)
   \   0000003C   0x....             LDR      R0,??DataTable9_1
   \   0000003E   0x4607             mov r7,R0
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0xDF00             SVC      0x0
   \   00000044   0xBD92             POP      {R1,R4,R7,PC}    ;; return
    446          }
    447          
    448          /// Get name of a Mutex object.

   \                                 In section .text, align 4, keep-with-next
    449          const char *osMutexGetName (osMutexId_t mutex_id) {
   \                     osMutexGetName: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    450            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8105      MRS      R1,IPSR
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE      ??osMutexGetName_0
   \   0000000A   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD004             BEQ      ??osMutexGetName_1
    451              EvrRtxMutexGetName(mutex_id, NULL);
   \                     ??osMutexGetName_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x.... 0x....      BL       EvrRtxMutexGetName
    452              return NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD80             POP      {R7,PC}
    453            }
    454            return __svcMutexGetName(mutex_id);
   \                     ??osMutexGetName_1: (+1)
   \   0000001C   0x....             LDR      R1,??DataTable9_2
   \   0000001E   0x460F             mov r7,R1
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBD80             POP      {R7,PC}          ;; return
    455          }
    456          
    457          /// Acquire a Mutex or timeout if it is locked.

   \                                 In section .text, align 4, keep-with-next
    458          osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
   \                     osMutexAcquire: (+1)
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    459            EvrRtxMutexAcquire(mutex_id, timeout);
   \   00000006   0x.... 0x....      BL       EvrRtxMutexAcquire
    460            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   0000000A   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD103             BNE      ??osMutexAcquire_0
   \   00000012   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD000             BEQ      ??osMutexAcquire_1
    461              EvrRtxMutexError(mutex_id, osErrorISR);
   \                     ??osMutexAcquire_0: (+1)
   \   0000001A   0x....             B.N      ?Subroutine1
    462              return osErrorISR;
    463            }
    464            return __svcMutexAcquire(mutex_id, timeout);
   \                     ??osMutexAcquire_1: (+1)
   \   0000001C   0x....             LDR      R0,??DataTable9_3
   \   0000001E   0x4607             mov r7,R0
   \   00000020   0x0029             MOVS     R1,R5
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0xDF00             SVC      0x0
   \   00000026   0xBDB0             POP      {R4,R5,R7,PC}    ;; return
    465          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2505             MOVS     R5,#+5
   \   00000002   0x43ED             MVNS     R5,R5            ;; #-6
   \   00000004   0x0029             MOVS     R1,R5
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       EvrRtxMutexError
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xBDB0             POP      {R4,R5,R7,PC}
    466          
    467          /// Release a Mutex that was acquired by \ref osMutexAcquire.

   \                                 In section .text, align 4, keep-with-next
    468          osStatus_t osMutexRelease (osMutexId_t mutex_id) {
   \                     osMutexRelease: (+1)
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    469            EvrRtxMutexRelease(mutex_id);
   \   00000004   0x.... 0x....      BL       EvrRtxMutexRelease
    470            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000008   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE      ??osMutexRelease_0
   \   00000010   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD000             BEQ      ??osMutexRelease_1
    471              EvrRtxMutexError(mutex_id, osErrorISR);
   \                     ??osMutexRelease_0: (+1)
   \   00000018   0x....             B.N      ?Subroutine1
    472              return osErrorISR;
    473            }
    474            return __svcMutexRelease(mutex_id);
   \                     ??osMutexRelease_1: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable9_4
   \   0000001C   0x4607             mov r7,R0
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBDB0             POP      {R4,R5,R7,PC}    ;; return
    475          }
    476          
    477          /// Get Thread which owns a Mutex object.

   \                                 In section .text, align 4, keep-with-next
    478          osThreadId_t osMutexGetOwner (osMutexId_t mutex_id) {
   \                     osMutexGetOwner: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    479            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8105      MRS      R1,IPSR
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE      ??osMutexGetOwner_0
   \   0000000A   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD004             BEQ      ??osMutexGetOwner_1
    480              EvrRtxMutexGetOwner(mutex_id, NULL);
   \                     ??osMutexGetOwner_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x.... 0x....      BL       EvrRtxMutexGetOwner
    481              return NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD80             POP      {R7,PC}
    482            }
    483            return __svcMutexGetOwner(mutex_id);
   \                     ??osMutexGetOwner_1: (+1)
   \   0000001C   0x....             LDR      R1,??DataTable9_5
   \   0000001E   0x460F             mov r7,R1
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBD80             POP      {R7,PC}          ;; return
    484          }
    485          
    486          /// Delete a Mutex object.

   \                                 In section .text, align 4, keep-with-next
    487          osStatus_t osMutexDelete (osMutexId_t mutex_id) {
   \                     osMutexDelete: (+1)
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    488            EvrRtxMutexDelete(mutex_id);
   \   00000004   0x.... 0x....      BL       EvrRtxMutexDelete
    489            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000008   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE      ??osMutexDelete_0
   \   00000010   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD000             BEQ      ??osMutexDelete_1
    490              EvrRtxMutexError(mutex_id, osErrorISR);
   \                     ??osMutexDelete_0: (+1)
   \   00000018   0x....             B.N      ?Subroutine1
    491              return osErrorISR;
    492            }
    493            return __svcMutexDelete(mutex_id);
   \                     ??osMutexDelete_1: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable9_6
   \   0000001C   0x4607             mov r7,R0
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBDB0             POP      {R4,R5,R7,PC}    ;; return
    494          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     osRtxInfo+0x80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     osRtxInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     osRtxInfo+0x80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     svcRtxMutexNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     svcRtxMutexGetName

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     svcRtxMutexAcquire

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     svcRtxMutexRelease

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     svcRtxMutexGetOwner

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     svcRtxMutexDelete

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   osMutexAcquire
        16   -> EvrRtxMutexAcquire
        16   -> EvrRtxMutexError
      16   osMutexDelete
        16   -> EvrRtxMutexDelete
        16   -> EvrRtxMutexError
       8   osMutexGetName
         8   -> EvrRtxMutexGetName
       8   osMutexGetOwner
         8   -> EvrRtxMutexGetOwner
      16   osMutexNew
        16   -> EvrRtxMutexError
        16   -> EvrRtxMutexNew
      16   osMutexRelease
        16   -> EvrRtxMutexError
        16   -> EvrRtxMutexRelease
      24   osRtxMutexOwnerRelease
        24   -> EvrRtxMutexAcquired
        24   -> EvrRtxMutexReleased
        24   -> osRtxThreadListGet
        24   -> osRtxThreadWaitExit
      16   svcRtxMutexAcquire
        16   -> EvrRtxMutexAcquirePending
        16   -> EvrRtxMutexAcquired
        16   -> EvrRtxMutexError
        16   -> EvrRtxMutexNotAcquired
        16   -> osRtxThreadListPut
        16   -> osRtxThreadListSort
        16   -> osRtxThreadWaitEnter
      16   svcRtxMutexDelete
        16   -> EvrRtxMutexDestroyed
        16   -> EvrRtxMutexError
        16   -> osRtxMemoryFree
        16   -> osRtxMemoryPoolFree
        16   -> osRtxThreadDispatch
        16   -> osRtxThreadListGet
        16   -> osRtxThreadListSort
        16   -> osRtxThreadWaitExit
       8   svcRtxMutexGetName
         8   -> EvrRtxMutexGetName
       8   svcRtxMutexGetOwner
         8   -> EvrRtxMutexGetOwner
      16   svcRtxMutexNew
        16   -> EvrRtxMutexCreated
        16   -> EvrRtxMutexError
        16   -> osRtxMemoryAlloc
        16   -> osRtxMemoryPoolAlloc
      16   svcRtxMutexRelease
        16   -> EvrRtxMutexAcquired
        16   -> EvrRtxMutexError
        16   -> EvrRtxMutexReleased
        16   -> osRtxThreadDispatch
        16   -> osRtxThreadListGet
        16   -> osRtxThreadWaitExit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable4
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
      14  ?Subroutine0
      16  ?Subroutine1
      40  osMutexAcquire
      36  osMutexDelete
      36  osMutexGetName
      36  osMutexGetOwner
      70  osMutexNew
      36  osMutexRelease
      78  osRtxMutexOwnerRelease
     202  svcRtxMutexAcquire
     186  svcRtxMutexDelete
      42  svcRtxMutexGetName
      48  svcRtxMutexGetOwner
     124  svcRtxMutexNew
     220  svcRtxMutexRelease

 
 1 220 bytes in section .text
 
 1 220 bytes of CODE memory

Errors: none
Warnings: 1

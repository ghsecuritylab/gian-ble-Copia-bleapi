###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:53
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        .\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_msgqueue.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_msgqueue.d
#        -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_msgqueue.s.txt
#        -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_msgqueue.o
#        .\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_msgqueue.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_msgqueue.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_msgqueue.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_msgqueue.c
      1          /*
      2           * Copyright (c) 2013-2017 ARM Limited. All rights reserved.
      3           *
      4           * SPDX-License-Identifier: Apache-2.0
      5           *
      6           * Licensed under the Apache License, Version 2.0 (the License); you may
      7           * not use this file except in compliance with the License.
      8           * You may obtain a copy of the License at
      9           *
     10           * www.apache.org/licenses/LICENSE-2.0
     11           *
     12           * Unless required by applicable law or agreed to in writing, software
     13           * distributed under the License is distributed on an AS IS BASIS, WITHOUT
     14           * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15           * See the License for the specific language governing permissions and
     16           * limitations under the License.
     17           *
     18           * -----------------------------------------------------------------------------
     19           *
     20           * Project:     CMSIS-RTOS RTX
     21           * Title:       Message Queue functions
     22           *
     23           * -----------------------------------------------------------------------------
     24           */
     25          
     26          #include "rtx_lib.h"

  typedef uint8_t BOOL;  //already defined in "hal_type.h"
                  ^
"C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\TARGET_STEVAL_IDB007V1\device\system_BlueNRG1.h",240  Warning[Pe301]: typedef name has already been declared (with same type)
     27          
     28          
     29          //  ==== Helper functions ====
     30          
     31          /// Put a Message into Queue sorted by Priority (Highest at Head).
     32          /// \param[in]  mq              message queue object.
     33          /// \param[in]  msg             message object.

   \                                 In section .text, align 2, keep-with-next
     34          static void MessageQueuePut (os_message_queue_t *mq, os_message_t *msg) {
   \                     MessageQueuePut: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
     35          #if (__EXCLUSIVE_ACCESS == 0U)
     36            uint32_t      primask = __get_PRIMASK();
   \   00000002   0xF3EF 0x8210      MRS      R2,PRIMASK
     37          #endif
     38            os_message_t *prev, *next;
     39          
     40            if (mq->msg_last != NULL) {
   \   00000006   0x6B03             LDR      R3,[R0, #+48]
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD012             BEQ      ??MessageQueuePut_0
     41              prev = mq->msg_last;
     42              next = NULL;
   \   0000000E   0x78CD             LDRB     R5,[R1, #+3]
   \                     ??MessageQueuePut_1: (+1)
   \   00000010   0x78DE             LDRB     R6,[R3, #+3]
   \   00000012   0x42AE             CMP      R6,R5
   \   00000014   0xD203             BCS      ??MessageQueuePut_2
     43              while ((prev != NULL) && (prev->priority < msg->priority)) {
     44                next = prev;
   \   00000016   0x001C             MOVS     R4,R3
     45                prev = prev->prev;
   \   00000018   0x685B             LDR      R3,[R3, #+4]
     46              }
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD1F8             BNE      ??MessageQueuePut_1
     47              msg->prev = prev;
   \                     ??MessageQueuePut_2: (+1)
   \   0000001E   0x604B             STR      R3,[R1, #+4]
     48              msg->next = next;
   \   00000020   0x608C             STR      R4,[R1, #+8]
     49              if (prev != NULL) {
   \   00000022   0x2B00             CMP      R3,#+0
   \   00000024   0xD001             BEQ      ??MessageQueuePut_3
     50                prev->next = msg;
   \   00000026   0x6099             STR      R1,[R3, #+8]
   \   00000028   0xE000             B        ??MessageQueuePut_4
     51              } else {
     52                mq->msg_first = msg;
   \                     ??MessageQueuePut_3: (+1)
   \   0000002A   0x62C1             STR      R1,[R0, #+44]
     53              }
     54              if (next != NULL) {
   \                     ??MessageQueuePut_4: (+1)
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD004             BEQ      ??MessageQueuePut_5
     55                next->prev = msg;
   \   00000030   0x6061             STR      R1,[R4, #+4]
   \   00000032   0xE003             B        ??MessageQueuePut_6
     56              } else {
     57                mq->msg_last = msg;
     58              }
     59            } else {
     60              msg->prev = NULL;
   \                     ??MessageQueuePut_0: (+1)
   \   00000034   0x604C             STR      R4,[R1, #+4]
     61              msg->next = NULL;
   \   00000036   0x608C             STR      R4,[R1, #+8]
     62              mq->msg_first= msg;
   \   00000038   0x62C1             STR      R1,[R0, #+44]
     63              mq->msg_last = msg;
   \                     ??MessageQueuePut_5: (+1)
   \   0000003A   0x6301             STR      R1,[R0, #+48]
     64            }
     65          
     66          #if (__EXCLUSIVE_ACCESS == 0U)
     67            __disable_irq();
   \                     ??MessageQueuePut_6: (+1)
   \   0000003C   0xB672             CPSID    I
     68          
     69            mq->msg_count++;
   \   0000003E   0x6A81             LDR      R1,[R0, #+40]
   \   00000040   0x1C49             ADDS     R1,R1,#+1
   \   00000042   0x6281             STR      R1,[R0, #+40]
     70          
     71            if (primask == 0U) {
   \   00000044   0x2A00             CMP      R2,#+0
   \   00000046   0xD100             BNE      ??MessageQueuePut_7
     72              __enable_irq();
   \   00000048   0xB662             CPSIE    I
     73            }
     74          #else
     75            atomic_inc32(&mq->msg_count);
     76          #endif
     77          }
   \                     ??MessageQueuePut_7: (+1)
   \   0000004A   0xBC70             POP      {R4-R6}
   \   0000004C   0x4770             BX       LR               ;; return
     78          
     79          /// Get a Message from Queue with Highest Priority.
     80          /// \param[in]  mq              message queue object.
     81          /// \return message object or NULL.

   \                                 In section .text, align 2, keep-with-next
     82          static os_message_t *MessageQueueGet (os_message_queue_t *mq) {
     83          #if (__EXCLUSIVE_ACCESS == 0U)
     84            uint32_t      primask = __get_PRIMASK();
   \                     MessageQueueGet: (+1)
   \   00000000   0xF3EF 0x8110      MRS      R1,PRIMASK
     85          #endif
     86            os_message_t *msg;
     87            uint32_t      count;
     88            uint8_t       flags;
     89          
     90          #if (__EXCLUSIVE_ACCESS == 0U)
     91            __disable_irq();
   \   00000004   0xB672             CPSID    I
     92          
     93            count = mq->msg_count;
   \   00000006   0x6A82             LDR      R2,[R0, #+40]
   \   00000008   0x0013             MOVS     R3,R2
     94            if (count != 0U) {
   \   0000000A   0xD001             BEQ      ??MessageQueueGet_0
     95              mq->msg_count--;
   \   0000000C   0x1E52             SUBS     R2,R2,#+1
   \   0000000E   0x6282             STR      R2,[R0, #+40]
     96            }
     97          
     98            if (primask == 0U) {
   \                     ??MessageQueueGet_0: (+1)
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD100             BNE      ??MessageQueueGet_1
     99              __enable_irq();
   \   00000014   0xB662             CPSIE    I
    100            }
    101          #else
    102            count = atomic_dec32_nz(&mq->msg_count);
    103          #endif
    104          
    105            if (count == 0U) {
   \                     ??MessageQueueGet_1: (+1)
   \   00000016   0x2B00             CMP      R3,#+0
   \   00000018   0xD101             BNE      ??MessageQueueGet_2
    106              return NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR
    107            }
    108          
    109            msg = mq->msg_first;
   \                     ??MessageQueueGet_2: (+1)
   \   0000001E   0x6AC0             LDR      R0,[R0, #+44]
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0xE000             B        ??MessageQueueGet_3
    110          
    111            while (msg != NULL) {
    112          #if (__EXCLUSIVE_ACCESS == 0U)
    113              __disable_irq();
    114          
    115              flags = msg->flags;
    116              msg->flags = 1U;
    117          
    118              if (primask == 0U) {
    119                __enable_irq();
    120              }
    121          #else
    122              flags = atomic_wr8(&msg->flags, 1U);
    123          #endif
    124              if (flags == 0U) {
    125                break;
    126              }
    127              msg = msg->next;
   \                     ??MessageQueueGet_4: (+1)
   \   00000024   0x6880             LDR      R0,[R0, #+8]
   \                     ??MessageQueueGet_3: (+1)
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD007             BEQ      ??MessageQueueGet_5
   \   0000002A   0xB672             CPSID    I
   \   0000002C   0x7883             LDRB     R3,[R0, #+2]
   \   0000002E   0x7082             STRB     R2,[R0, #+2]
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD100             BNE      ??MessageQueueGet_6
   \   00000034   0xB662             CPSIE    I
   \                     ??MessageQueueGet_6: (+1)
   \   00000036   0x2B00             CMP      R3,#+0
   \   00000038   0xD1F4             BNE      ??MessageQueueGet_4
    128            }
    129          
    130            return msg;
   \                     ??MessageQueueGet_5: (+1)
   \   0000003A   0x4770             BX       LR               ;; return
    131          }
    132          
    133          /// Remove a Message from Queue
    134          /// \param[in]  mq              message queue object.
    135          /// \param[in]  msg             message object.

   \                                 In section .text, align 2, keep-with-next
    136          static void MessageQueueRemove (os_message_queue_t *mq, os_message_t *msg) {
    137          
    138            if (msg->prev != NULL) {
   \                     MessageQueueRemove: (+1)
   \   00000000   0x688A             LDR      R2,[R1, #+8]
   \   00000002   0x684B             LDR      R3,[R1, #+4]
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD001             BEQ      ??MessageQueueRemove_0
    139              msg->prev->next = msg->next;
   \   00000008   0x609A             STR      R2,[R3, #+8]
   \   0000000A   0xE000             B        ??MessageQueueRemove_1
    140            } else {
    141              mq->msg_first = msg->next;
   \                     ??MessageQueueRemove_0: (+1)
   \   0000000C   0x62C2             STR      R2,[R0, #+44]
    142            }
    143            if (msg->next != NULL) {
   \                     ??MessageQueueRemove_1: (+1)
   \   0000000E   0x684A             LDR      R2,[R1, #+4]
   \   00000010   0x6889             LDR      R1,[R1, #+8]
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD001             BEQ      ??MessageQueueRemove_2
    144              msg->next->prev = msg->prev;
   \   00000016   0x604A             STR      R2,[R1, #+4]
   \   00000018   0x4770             BX       LR
    145            } else {
    146              mq->msg_last = msg->prev;
   \                     ??MessageQueueRemove_2: (+1)
   \   0000001A   0x6302             STR      R2,[R0, #+48]
    147            }
    148          }
   \   0000001C   0x4770             BX       LR               ;; return
    149          
    150          
    151          //  ==== Library functions ====
    152          
    153          /// Message Queue post ISR processing.
    154          /// \param[in]  msg             message object.

   \                                 In section .text, align 2, keep-with-next
    155          void osRtxMessageQueuePostProcess (os_message_t *msg) {
   \                     osRtxMessageQueuePostProcess: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
    156            os_message_queue_t *mq;
    157            os_thread_t        *thread;
    158            uint32_t           *reg;
    159            void              **ptr;
    160          
    161            if (msg->state == osRtxObjectInactive) {
   \   00000004   0x7870             LDRB     R0,[R6, #+1]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD078             BEQ      ??osRtxMessageQueuePostProcess_0
    162              return;
    163            }
    164          
    165            if (msg->flags != 0U) {
   \   0000000A   0x78B0             LDRB     R0,[R6, #+2]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD03C             BEQ      ??osRtxMessageQueuePostProcess_1
    166              // Remove Message
    167              ptr = (void *)((uint8_t *)msg + sizeof(os_message_t));
    168              mq = *ptr;
   \   00000010   0x68F5             LDR      R5,[R6, #+12]
    169              if (mq->state == osRtxObjectInactive) {
   \   00000012   0x7868             LDRB     R0,[R5, #+1]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD071             BEQ      ??osRtxMessageQueuePostProcess_0
    170                return;
    171              }
    172              MessageQueueRemove(mq, msg);
   \   00000018   0x0031             MOVS     R1,R6
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0x.... 0x....      BL       MessageQueueRemove
    173              // Free memory
    174              msg->state = osRtxObjectInactive;
   \   00000020   0x2700             MOVS     R7,#+0
   \   00000022   0x7077             STRB     R7,[R6, #+1]
    175              osRtxMemoryPoolFree(&mq->mp_info, msg);
   \   00000024   0x0031             MOVS     R1,R6
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0x300C             ADDS     R0,R0,#+12
   \   0000002A   0x.... 0x....      BL       osRtxMemoryPoolFree
    176              // Check if Thread is waiting to send a Message
    177              if ((mq->thread_list != NULL) && (mq->thread_list->state == osRtxThreadWaitingMessagePut)) {
   \   0000002E   0x68A8             LDR      R0,[R5, #+8]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD063             BEQ      ??osRtxMessageQueuePostProcess_0
   \   00000034   0x7840             LDRB     R0,[R0, #+1]
   \   00000036   0x2893             CMP      R0,#+147
   \   00000038   0xD160             BNE      ??osRtxMessageQueuePostProcess_0
    178                // Try to allocate memory
    179                msg = osRtxMemoryPoolAlloc(&mq->mp_info);
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x300C             ADDS     R0,R0,#+12
   \   0000003E   0x.... 0x....      BL       osRtxMemoryPoolAlloc
   \   00000042   0x0006             MOVS     R6,R0
    180                if (msg != NULL) {
   \   00000044   0xD05A             BEQ      ??osRtxMessageQueuePostProcess_0
    181                  // Wakeup waiting Thread with highest Priority
    182                  thread = osRtxThreadListGet((os_object_t*)mq);
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0x.... 0x....      BL       osRtxThreadListGet
   \   0000004C   0x0004             MOVS     R4,R0
    183                  osRtxThreadWaitExit(thread, (uint32_t)osOK, false);
   \   0000004E   0x2200             MOVS     R2,#+0
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x.... 0x....      BL       osRtxThreadWaitExit
    184                  // Copy Message (R2: const void *msg_ptr, R3: uint8_t msg_prio)
    185                  reg = osRtxThreadRegPtr(thread);
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       osRtxThreadRegPtr
   \   0000005C   0x0004             MOVS     R4,R0
    186                  memcpy((uint8_t *)msg + sizeof(os_message_t), (void *)reg[2], mq->msg_size);
   \   0000005E   0x6A6A             LDR      R2,[R5, #+36]
   \   00000060   0x68A1             LDR      R1,[R4, #+8]
   \   00000062   0x0030             MOVS     R0,R6
   \   00000064   0x300C             ADDS     R0,R0,#+12
   \   00000066   0x.... 0x....      BL       __aeabi_memcpy
    187                  // Store Message into Queue
    188                  msg->id       = osRtxIdMessage;
   \   0000006A   0x2007             MOVS     R0,#+7
   \   0000006C   0x7030             STRB     R0,[R6, #+0]
    189                  msg->state    = osRtxObjectActive;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x7070             STRB     R0,[R6, #+1]
    190                  msg->flags    = 0U;
   \   00000072   0x70B7             STRB     R7,[R6, #+2]
    191                  msg->priority = (uint8_t)reg[3];
   \   00000074   0x68E0             LDR      R0,[R4, #+12]
   \   00000076   0x70F0             STRB     R0,[R6, #+3]
    192                  MessageQueuePut(mq, msg);
   \   00000078   0x0031             MOVS     R1,R6
   \   0000007A   0x0028             MOVS     R0,R5
   \   0000007C   0x.... 0x....      BL       MessageQueuePut
    193                  EvrRtxMessageQueueInserted(mq, (void *)reg[2]);
   \   00000080   0x68A1             LDR      R1,[R4, #+8]
   \   00000082   0x0028             MOVS     R0,R5
   \   00000084   0x.... 0x....      BL       EvrRtxMessageQueueInserted
   \   00000088   0xBDF1             POP      {R0,R4-R7,PC}
    194                }
    195              }
    196            } else {
    197              // New Message
    198              mq = (void *)msg->next;
   \                     ??osRtxMessageQueuePostProcess_1: (+1)
   \   0000008A   0x68B5             LDR      R5,[R6, #+8]
    199              if (mq->state == osRtxObjectInactive) {
   \   0000008C   0x7868             LDRB     R0,[R5, #+1]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD034             BEQ      ??osRtxMessageQueuePostProcess_0
    200                return;
    201              }
    202              // Check if Thread is waiting to receive a Message
    203              if ((mq->thread_list != NULL) && (mq->thread_list->state == osRtxThreadWaitingMessageGet)) {
   \   00000092   0x68A8             LDR      R0,[R5, #+8]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD029             BEQ      ??osRtxMessageQueuePostProcess_2
   \   00000098   0x7840             LDRB     R0,[R0, #+1]
   \   0000009A   0x2883             CMP      R0,#+131
   \   0000009C   0xD126             BNE      ??osRtxMessageQueuePostProcess_2
    204                EvrRtxMessageQueueInserted(mq, (void *)msg->prev);
   \   0000009E   0x6871             LDR      R1,[R6, #+4]
   \   000000A0   0x0028             MOVS     R0,R5
   \   000000A2   0x.... 0x....      BL       EvrRtxMessageQueueInserted
    205                // Wakeup waiting Thread with highest Priority
    206                thread = osRtxThreadListGet((os_object_t*)mq);
   \   000000A6   0x0028             MOVS     R0,R5
   \   000000A8   0x.... 0x....      BL       osRtxThreadListGet
   \   000000AC   0x0004             MOVS     R4,R0
    207                osRtxThreadWaitExit(thread, (uint32_t)osOK, false);
   \   000000AE   0x2200             MOVS     R2,#+0
   \   000000B0   0x2100             MOVS     R1,#+0
   \   000000B2   0x.... 0x....      BL       osRtxThreadWaitExit
    208                // Copy Message (R2: void *msg_ptr, R3: uint8_t *msg_prio)
    209                reg = osRtxThreadRegPtr(thread);
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       osRtxThreadRegPtr
   \   000000BC   0x0004             MOVS     R4,R0
    210                memcpy((void *)reg[2], (uint8_t *)msg + sizeof(os_message_t), mq->msg_size);
   \   000000BE   0x6A6A             LDR      R2,[R5, #+36]
   \   000000C0   0x0031             MOVS     R1,R6
   \   000000C2   0x310C             ADDS     R1,R1,#+12
   \   000000C4   0x68A0             LDR      R0,[R4, #+8]
   \   000000C6   0x.... 0x....      BL       __aeabi_memcpy
    211                if (reg[3] != 0U) {
   \   000000CA   0x68E0             LDR      R0,[R4, #+12]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD001             BEQ      ??osRtxMessageQueuePostProcess_3
    212                  *((uint8_t *)reg[3]) = msg->priority;
   \   000000D0   0x78F1             LDRB     R1,[R6, #+3]
   \   000000D2   0x7001             STRB     R1,[R0, #+0]
    213                }
    214                EvrRtxMessageQueueRetrieved(mq, (void *)reg[2]);
   \                     ??osRtxMessageQueuePostProcess_3: (+1)
   \   000000D4   0x68A1             LDR      R1,[R4, #+8]
   \   000000D6   0x0028             MOVS     R0,R5
   \   000000D8   0x.... 0x....      BL       EvrRtxMessageQueueRetrieved
    215                // Free memory
    216                msg->state = osRtxObjectInactive;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x7070             STRB     R0,[R6, #+1]
    217                osRtxMemoryPoolFree(&mq->mp_info, msg);
   \   000000E0   0x0031             MOVS     R1,R6
   \   000000E2   0x0028             MOVS     R0,R5
   \   000000E4   0x300C             ADDS     R0,R0,#+12
   \   000000E6   0x.... 0x....      BL       osRtxMemoryPoolFree
   \   000000EA   0xBDF1             POP      {R0,R4-R7,PC}
    218              } else {
    219                EvrRtxMessageQueueInserted(mq, (void *)msg->prev);
   \                     ??osRtxMessageQueuePostProcess_2: (+1)
   \   000000EC   0x6871             LDR      R1,[R6, #+4]
   \   000000EE   0x0028             MOVS     R0,R5
   \   000000F0   0x.... 0x....      BL       EvrRtxMessageQueueInserted
    220                MessageQueuePut(mq, msg);
   \   000000F4   0x0031             MOVS     R1,R6
   \   000000F6   0x0028             MOVS     R0,R5
   \   000000F8   0x.... 0x....      BL       MessageQueuePut
    221              }
    222            }
    223          }
   \                     ??osRtxMessageQueuePostProcess_0: (+1)
   \   000000FC   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    224          
    225          
    226          //  ==== Service Calls ====
    227          
    228          SVC0_3M(MessageQueueNew,         osMessageQueueId_t, uint32_t, uint32_t, const osMessageQueueAttr_t *)
    229          SVC0_1 (MessageQueueGetName,     const char *,       osMessageQueueId_t)
    230          SVC0_4 (MessageQueuePut,         osStatus_t,         osMessageQueueId_t, const void *, uint8_t,   uint32_t)
    231          SVC0_4 (MessageQueueGet,         osStatus_t,         osMessageQueueId_t,       void *, uint8_t *, uint32_t)
    232          SVC0_1 (MessageQueueGetCapacity, uint32_t,           osMessageQueueId_t)
    233          SVC0_1 (MessageQueueGetMsgSize,  uint32_t,           osMessageQueueId_t)
    234          SVC0_1 (MessageQueueGetCount,    uint32_t,           osMessageQueueId_t)
    235          SVC0_1 (MessageQueueGetSpace,    uint32_t,           osMessageQueueId_t)
    236          SVC0_1 (MessageQueueReset,       osStatus_t,         osMessageQueueId_t)
    237          SVC0_1 (MessageQueueDelete,      osStatus_t,         osMessageQueueId_t)
    238          
    239          /// Create and Initialize a Message Queue object.
    240          /// \note API identical to osMessageQueueNew

   \                                 In section .text, align 2, keep-with-next
    241          osMessageQueueId_t svcRtxMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
   \                     svcRtxMessageQueueNew: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    242            os_message_queue_t *mq;
    243            void               *mq_mem;
    244            uint32_t            mq_size;
    245            uint32_t            block_size;
    246            uint32_t            size;
    247            uint8_t             flags;
    248            const char         *name;
    249          
    250            // Check parameters
    251            if ((msg_count == 0U) || (msg_size  == 0U)) {
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD022             BEQ      ??svcRtxMessageQueueNew_0
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD020             BEQ      ??svcRtxMessageQueueNew_0
    252              EvrRtxMessageQueueError(NULL, osErrorParameter);
    253              return NULL;
    254            }
    255            block_size = ((msg_size + 3U) & ~3UL) + sizeof(os_message_t);
   \   0000000C   0x1CC8             ADDS     R0,R1,#+3
   \   0000000E   0x2103             MOVS     R1,#+3
   \   00000010   0x4388             BICS     R0,R0,R1
   \   00000012   0x300C             ADDS     R0,R0,#+12
   \   00000014   0x9001             STR      R0,[SP, #+4]
    256            if ((__CLZ(msg_count) + __CLZ(block_size)) < 32) {
   \   00000016   0x2700             MOVS     R7,#+0
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x0609             LSLS     R1,R1,#+24       ;; #-2147483648
   \   0000001E   0x000B             MOVS     R3,R1
   \   00000020   0xE001             B        ??svcRtxMessageQueueNew_1
   \                     ??svcRtxMessageQueueNew_2: (+1)
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0x085B             LSRS     R3,R3,#+1
   \                     ??svcRtxMessageQueueNew_1: (+1)
   \   00000026   0x9C05             LDR      R4,[SP, #+20]
   \   00000028   0x401C             ANDS     R4,R4,R3
   \   0000002A   0xD0FA             BEQ      ??svcRtxMessageQueueNew_2
   \   0000002C   0x9B01             LDR      R3,[SP, #+4]
   \   0000002E   0x2B00             CMP      R3,#+0
   \   00000030   0xD101             BNE      ??svcRtxMessageQueueNew_3
   \   00000032   0x2320             MOVS     R3,#+32
   \   00000034   0xE006             B        ??svcRtxMessageQueueNew_4
   \                     ??svcRtxMessageQueueNew_3: (+1)
   \   00000036   0x2300             MOVS     R3,#+0
   \   00000038   0xE001             B        ??svcRtxMessageQueueNew_5
   \                     ??svcRtxMessageQueueNew_6: (+1)
   \   0000003A   0x1C5B             ADDS     R3,R3,#+1
   \   0000003C   0x0849             LSRS     R1,R1,#+1
   \                     ??svcRtxMessageQueueNew_5: (+1)
   \   0000003E   0x9C01             LDR      R4,[SP, #+4]
   \   00000040   0x400C             ANDS     R4,R4,R1
   \   00000042   0xD0FA             BEQ      ??svcRtxMessageQueueNew_6
   \                     ??svcRtxMessageQueueNew_4: (+1)
   \   00000044   0xB2C0             UXTB     R0,R0
   \   00000046   0xB2DB             UXTB     R3,R3
   \   00000048   0x18C0             ADDS     R0,R0,R3
   \   0000004A   0x2820             CMP      R0,#+32
   \   0000004C   0xDA06             BGE      ??svcRtxMessageQueueNew_7
    257              EvrRtxMessageQueueError(NULL, osErrorParameter);
   \                     ??svcRtxMessageQueueNew_0: (+1)
   \   0000004E   0x2103             MOVS     R1,#+3
   \   00000050   0x43C9             MVNS     R1,R1            ;; #-4
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      BL       EvrRtxMessageQueueError
    258              return NULL;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE086             B        ??svcRtxMessageQueueNew_8
    259            }
    260          
    261            size = msg_count * block_size;
   \                     ??svcRtxMessageQueueNew_7: (+1)
   \   0000005C   0x9805             LDR      R0,[SP, #+20]
   \   0000005E   0x9901             LDR      R1,[SP, #+4]
   \   00000060   0x4348             MULS     R0,R1,R0
   \   00000062   0x9002             STR      R0,[SP, #+8]
    262          
    263            // Process attributes
    264            if (attr != NULL) {
   \   00000064   0x2A00             CMP      R2,#+0
   \   00000066   0xD02E             BEQ      ??svcRtxMessageQueueNew_9
    265              name    = attr->name;
   \   00000068   0x6810             LDR      R0,[R2, #+0]
   \   0000006A   0x9003             STR      R0,[SP, #+12]
    266              mq      = attr->cb_mem;
   \   0000006C   0x6894             LDR      R4,[R2, #+8]
    267              mq_mem  = attr->mq_mem;
   \   0000006E   0x6910             LDR      R0,[R2, #+16]
   \   00000070   0x9000             STR      R0,[SP, #+0]
    268              mq_size = attr->mq_size;
   \   00000072   0x6950             LDR      R0,[R2, #+20]
    269              if (mq != NULL) {
   \   00000074   0x2C00             CMP      R4,#+0
   \   00000076   0xD015             BEQ      ??svcRtxMessageQueueNew_10
    270                if (((uint32_t)mq & 3U) || (attr->cb_size < sizeof(os_message_queue_t))) {
   \   00000078   0x07A1             LSLS     R1,R4,#+30
   \   0000007A   0xD116             BNE      ??svcRtxMessageQueueNew_11
   \   0000007C   0x68D1             LDR      R1,[R2, #+12]
   \   0000007E   0x2934             CMP      R1,#+52
   \   00000080   0xD313             BCC      ??svcRtxMessageQueueNew_11
    271                  EvrRtxMessageQueueError(NULL, osRtxErrorInvalidControlBlock);
    272                  return NULL;
    273                }
    274              } else {
    275                if (attr->cb_size != 0U) {
    276                  EvrRtxMessageQueueError(NULL, osRtxErrorInvalidControlBlock);
    277                  return NULL;
    278                }
    279              }
    280              if (mq_mem != NULL) {
   \                     ??svcRtxMessageQueueNew_12: (+1)
   \   00000082   0x9900             LDR      R1,[SP, #+0]
   \   00000084   0x2900             CMP      R1,#+0
   \   00000086   0xD016             BEQ      ??svcRtxMessageQueueNew_13
    281                if (((uint32_t)mq_mem & 3U) || (mq_size < size)) {
   \   00000088   0x0789             LSLS     R1,R1,#+30
   \   0000008A   0xD116             BNE      ??svcRtxMessageQueueNew_14
   \   0000008C   0x9902             LDR      R1,[SP, #+8]
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xD313             BCC      ??svcRtxMessageQueueNew_14
    282                  EvrRtxMessageQueueError(NULL, osRtxErrorInvalidDataMemory);
    283                  return NULL;
    284                }
    285              } else {
    286                if (mq_size != 0U) {
    287                  EvrRtxMessageQueueError(NULL, osRtxErrorInvalidDataMemory);
    288                  return NULL;
    289                }
    290              }
    291            } else {
    292              name   = NULL;
    293              mq     = NULL;
    294              mq_mem = NULL;
    295            }
    296          
    297            // Allocate object memory if not provided
    298            if (mq == NULL) {
   \                     ??svcRtxMessageQueueNew_15: (+1)
   \   00000092   0x2C00             CMP      R4,#+0
   \   00000094   0xD129             BNE      ??svcRtxMessageQueueNew_16
    299              if (osRtxInfo.mpi.message_queue != NULL) {
   \                     ??svcRtxMessageQueueNew_17: (+1)
   \   00000096   0x....             LDR      R5,??DataTable2
   \   00000098   0x6B28             LDR      R0,[R5, #+48]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD016             BEQ      ??svcRtxMessageQueueNew_18
    300                mq = osRtxMemoryPoolAlloc(osRtxInfo.mpi.message_queue);
   \   0000009E   0x.... 0x....      BL       osRtxMemoryPoolAlloc
   \   000000A2   0xE018             B        ??svcRtxMessageQueueNew_19
    301              } else {
   \                     ??svcRtxMessageQueueNew_10: (+1)
   \   000000A4   0x68D1             LDR      R1,[R2, #+12]
   \   000000A6   0x2900             CMP      R1,#+0
   \   000000A8   0xD0EB             BEQ      ??svcRtxMessageQueueNew_12
   \                     ??svcRtxMessageQueueNew_11: (+1)
   \   000000AA   0x2108             MOVS     R1,#+8
   \   000000AC   0x43C9             MVNS     R1,R1            ;; #-9
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x.... 0x....      BL       EvrRtxMessageQueueError
   \   000000B4   0xE037             B.N      ??svcRtxMessageQueueNew_20
   \                     ??svcRtxMessageQueueNew_13: (+1)
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD0EB             BEQ      ??svcRtxMessageQueueNew_15
   \                     ??svcRtxMessageQueueNew_14: (+1)
   \   000000BA   0x2109             MOVS     R1,#+9
   \   000000BC   0x43C9             MVNS     R1,R1            ;; #-10
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x.... 0x....      BL       EvrRtxMessageQueueError
   \   000000C4   0xE02F             B.N      ??svcRtxMessageQueueNew_20
   \                     ??svcRtxMessageQueueNew_9: (+1)
   \   000000C6   0x9703             STR      R7,[SP, #+12]
   \   000000C8   0x9700             STR      R7,[SP, #+0]
   \   000000CA   0xE7E4             B        ??svcRtxMessageQueueNew_17
    302                mq = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_message_queue_t), 1U);
   \                     ??svcRtxMessageQueueNew_18: (+1)
   \   000000CC   0x2201             MOVS     R2,#+1
   \   000000CE   0x2134             MOVS     R1,#+52
   \   000000D0   0x6928             LDR      R0,[R5, #+16]
   \   000000D2   0x.... 0x....      BL       osRtxMemoryAlloc
   \                     ??svcRtxMessageQueueNew_19: (+1)
   \   000000D6   0x0004             MOVS     R4,R0
    303              }
    304              if (mq == NULL) {
   \   000000D8   0xD105             BNE      ??svcRtxMessageQueueNew_21
    305                EvrRtxMessageQueueError(NULL, osErrorNoMemory);
   \   000000DA   0x2104             MOVS     R1,#+4
   \   000000DC   0x43C9             MVNS     R1,R1            ;; #-5
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x.... 0x....      BL       EvrRtxMessageQueueError
    306                return NULL;
   \   000000E4   0xE01F             B.N      ??svcRtxMessageQueueNew_20
    307              }
    308              flags = osRtxFlagSystemObject;
   \                     ??svcRtxMessageQueueNew_21: (+1)
   \   000000E6   0x2601             MOVS     R6,#+1
   \   000000E8   0xE000             B        ??svcRtxMessageQueueNew_22
    309            } else {
    310              flags = 0U;
   \                     ??svcRtxMessageQueueNew_16: (+1)
   \   000000EA   0x2600             MOVS     R6,#+0
    311            }
    312          
    313            // Allocate data memory if not provided
    314            if (mq_mem == NULL) {
   \                     ??svcRtxMessageQueueNew_22: (+1)
   \   000000EC   0x....             LDR      R5,??DataTable2
   \   000000EE   0x9800             LDR      R0,[SP, #+0]
   \   000000F0   0x2800             CMP      R0,#+0
   \   000000F2   0xD120             BNE      ??svcRtxMessageQueueNew_23
    315              mq_mem = osRtxMemoryAlloc(osRtxInfo.mem.mq_data, size, 0U);
   \   000000F4   0x2200             MOVS     R2,#+0
   \   000000F6   0x9902             LDR      R1,[SP, #+8]
   \   000000F8   0x68E8             LDR      R0,[R5, #+12]
   \   000000FA   0x.... 0x....      BL       osRtxMemoryAlloc
   \   000000FE   0x9000             STR      R0,[SP, #+0]
    316              if (mq_mem == NULL) {
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD112             BNE      ??svcRtxMessageQueueNew_24
    317                EvrRtxMessageQueueError(NULL, osErrorNoMemory);
   \   00000104   0x2104             MOVS     R1,#+4
   \   00000106   0x43C9             MVNS     R1,R1            ;; #-5
   \   00000108   0x.... 0x....      BL       EvrRtxMessageQueueError
    318                if (flags & osRtxFlagSystemObject) {
   \   0000010C   0x2E00             CMP      R6,#+0
   \   0000010E   0xD00A             BEQ      ??svcRtxMessageQueueNew_20
    319                  if (osRtxInfo.mpi.message_queue != NULL) {
   \   00000110   0x6B28             LDR      R0,[R5, #+48]
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD003             BEQ      ??svcRtxMessageQueueNew_25
    320                    osRtxMemoryPoolFree(osRtxInfo.mpi.message_queue, mq);
   \   00000116   0x0021             MOVS     R1,R4
   \   00000118   0x.... 0x....      BL       osRtxMemoryPoolFree
   \   0000011C   0xE003             B        ??svcRtxMessageQueueNew_20
    321                  } else {
    322                    osRtxMemoryFree(osRtxInfo.mem.common, mq);
   \                     ??svcRtxMessageQueueNew_25: (+1)
   \   0000011E   0x0021             MOVS     R1,R4
   \   00000120   0x6928             LDR      R0,[R5, #+16]
   \   00000122   0x.... 0x....      BL       osRtxMemoryFree
    323                  }
    324                }
    325                return NULL;
   \                     ??svcRtxMessageQueueNew_20: (+1)
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0xE01F             B        ??svcRtxMessageQueueNew_8
    326              }
    327              memset(mq_mem, 0, size);
   \                     ??svcRtxMessageQueueNew_24: (+1)
   \   0000012A   0x9902             LDR      R1,[SP, #+8]
   \   0000012C   0x.... 0x....      BL       __aeabi_memclr
    328              flags |= osRtxFlagSystemMemory;
   \   00000130   0x0030             MOVS     R0,R6
   \   00000132   0x2602             MOVS     R6,#+2
   \   00000134   0x4306             ORRS     R6,R6,R0
    329            }
    330          
    331            // Initialize control block
    332            mq->id          = osRtxIdMessageQueue;
   \                     ??svcRtxMessageQueueNew_23: (+1)
   \   00000136   0x2008             MOVS     R0,#+8
   \   00000138   0x7020             STRB     R0,[R4, #+0]
    333            mq->state       = osRtxObjectActive;
   \   0000013A   0x2001             MOVS     R0,#+1
   \   0000013C   0x7060             STRB     R0,[R4, #+1]
    334            mq->flags       = flags;
   \   0000013E   0x70A6             STRB     R6,[R4, #+2]
    335            mq->name        = name;
   \   00000140   0x9803             LDR      R0,[SP, #+12]
   \   00000142   0x6060             STR      R0,[R4, #+4]
    336            mq->thread_list = NULL;
   \   00000144   0x60A7             STR      R7,[R4, #+8]
    337            mq->msg_size    = msg_size;
   \   00000146   0x9806             LDR      R0,[SP, #+24]
   \   00000148   0x6260             STR      R0,[R4, #+36]
    338            mq->msg_count   = 0U;
   \   0000014A   0x62A7             STR      R7,[R4, #+40]
    339            mq->msg_first   = NULL;
   \   0000014C   0x62E7             STR      R7,[R4, #+44]
    340            mq->msg_last    = NULL;
   \   0000014E   0x6327             STR      R7,[R4, #+48]
    341            osRtxMemoryPoolInit(&mq->mp_info, msg_count, block_size, mq_mem);
   \   00000150   0x9B00             LDR      R3,[SP, #+0]
   \   00000152   0x9A01             LDR      R2,[SP, #+4]
   \   00000154   0x9905             LDR      R1,[SP, #+20]
   \   00000156   0x0020             MOVS     R0,R4
   \   00000158   0x300C             ADDS     R0,R0,#+12
   \   0000015A   0x.... 0x....      BL       osRtxMemoryPoolInit
    342          
    343            // Register post ISR processing function
    344            osRtxInfo.post_process.message_queue = osRtxMessageQueuePostProcess;
   \   0000015E   0x....             LDR      R0,??DataTable2_1
   \   00000160   0x6028             STR      R0,[R5, #+0]
    345          
    346            EvrRtxMessageQueueCreated(mq);
   \   00000162   0x0020             MOVS     R0,R4
   \   00000164   0x.... 0x....      BL       EvrRtxMessageQueueCreated
    347          
    348            return mq;
   \   00000168   0x0020             MOVS     R0,R4
   \                     ??svcRtxMessageQueueNew_8: (+1)
   \   0000016A   0xB007             ADD      SP,SP,#+28
   \   0000016C   0xBDF0             POP      {R4-R7,PC}       ;; return
    349          }
    350          
    351          /// Get name of a Message Queue object.
    352          /// \note API identical to osMessageQueueGetName

   \                                 In section .text, align 2, keep-with-next
    353          const char *svcRtxMessageQueueGetName (osMessageQueueId_t mq_id) {
   \                     svcRtxMessageQueueGetName: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    354            os_message_queue_t *mq = (os_message_queue_t *)mq_id;
    355          
    356            // Check parameters
    357            if ((mq == NULL) || (mq->id != osRtxIdMessageQueue)) {
   \   00000004   0xD005             BEQ      ??svcRtxMessageQueueGetName_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2808             CMP      R0,#+8
   \   0000000A   0xD102             BNE      ??svcRtxMessageQueueGetName_0
    358              EvrRtxMessageQueueGetName(mq, NULL);
    359              return NULL;
    360            }
    361          
    362            // Check object state
    363            if (mq->state == osRtxObjectInactive) {
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE      ??svcRtxMessageQueueGetName_1
    364              EvrRtxMessageQueueGetName(mq, NULL);
   \                     ??svcRtxMessageQueueGetName_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       EvrRtxMessageQueueGetName
    365              return NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}
    366            }
    367          
    368            EvrRtxMessageQueueGetName(mq, mq->name);
   \                     ??svcRtxMessageQueueGetName_1: (+1)
   \   0000001E   0x6861             LDR      R1,[R4, #+4]
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       EvrRtxMessageQueueGetName
    369          
    370            return mq->name;
   \   00000026   0x6860             LDR      R0,[R4, #+4]
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    371          }
    372          
    373          /// Put a Message into a Queue or timeout if Queue is full.
    374          /// \note API identical to osMessageQueuePut

   \                                 In section .text, align 2, keep-with-next
    375          osStatus_t svcRtxMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
   \                     svcRtxMessageQueuePut: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0015             MOVS     R5,R2
    376            os_message_queue_t *mq = (os_message_queue_t *)mq_id;
    377            os_message_t       *msg;
    378            os_thread_t        *thread;
    379            uint32_t           *reg;
    380          
    381            // Check parameters
    382            if ((mq == NULL) || (mq->id != osRtxIdMessageQueue) || (msg_ptr == NULL)) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD004             BEQ      ??svcRtxMessageQueuePut_0
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xD101             BNE      ??svcRtxMessageQueuePut_0
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD101             BNE      ??svcRtxMessageQueuePut_1
    383              EvrRtxMessageQueueError(mq, osErrorParameter);
   \                     ??svcRtxMessageQueuePut_0: (+1)
   \   00000016   0x2503             MOVS     R5,#+3
   \   00000018   0xE003             B.N      ??svcRtxMessageQueuePut_2
    384              return osErrorParameter;
    385            }
    386          
    387            // Check object state
    388            if (mq->state == osRtxObjectInactive) {
   \                     ??svcRtxMessageQueuePut_1: (+1)
   \   0000001A   0x7860             LDRB     R0,[R4, #+1]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD107             BNE      ??svcRtxMessageQueuePut_3
    389              EvrRtxMessageQueueError(mq, osErrorResource);
   \   00000020   0x2502             MOVS     R5,#+2
   \                     ??svcRtxMessageQueuePut_2: (+1)
   \   00000022   0x43ED             MVNS     R5,R5            ;; #-3
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       EvrRtxMessageQueueError
    390              return osErrorResource;
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0xBDF2             POP      {R1,R4-R7,PC}
    391            }
    392          
    393            // Check if Thread is waiting to receive a Message
    394            if ((mq->thread_list != NULL) && (mq->thread_list->state == osRtxThreadWaitingMessageGet)) {
   \                     ??svcRtxMessageQueuePut_3: (+1)
   \   00000030   0x68A0             LDR      R0,[R4, #+8]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD01F             BEQ      ??svcRtxMessageQueuePut_4
   \   00000036   0x7840             LDRB     R0,[R0, #+1]
   \   00000038   0x2883             CMP      R0,#+131
   \   0000003A   0xD11C             BNE      ??svcRtxMessageQueuePut_4
    395              EvrRtxMessageQueueInserted(mq, msg_ptr);
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       EvrRtxMessageQueueInserted
    396              // Wakeup waiting Thread with highest Priority
    397              thread = osRtxThreadListGet((os_object_t*)mq);
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       osRtxThreadListGet
   \   00000048   0x0007             MOVS     R7,R0
    398              osRtxThreadWaitExit(thread, (uint32_t)osOK, true);
   \   0000004A   0x2201             MOVS     R2,#+1
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x.... 0x....      BL       osRtxThreadWaitExit
    399              // Copy Message (R2: void *msg_ptr, R3: uint8_t *msg_prio)
    400              reg = osRtxThreadRegPtr(thread);
   \   00000052   0x0038             MOVS     R0,R7
   \   00000054   0x.... 0x....      BL       osRtxThreadRegPtr
   \   00000058   0x0007             MOVS     R7,R0
    401              memcpy((void *)reg[2], msg_ptr, mq->msg_size);
   \   0000005A   0x6A62             LDR      R2,[R4, #+36]
   \   0000005C   0x0031             MOVS     R1,R6
   \   0000005E   0x68B8             LDR      R0,[R7, #+8]
   \   00000060   0x.... 0x....      BL       __aeabi_memcpy
    402              if (reg[3] != 0U) {
   \   00000064   0x68F8             LDR      R0,[R7, #+12]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD000             BEQ      ??svcRtxMessageQueuePut_5
    403                *((uint8_t *)reg[3]) = msg_prio;
   \   0000006A   0x7005             STRB     R5,[R0, #+0]
    404              }
    405              EvrRtxMessageQueueRetrieved(mq, (void *)reg[2]);
   \                     ??svcRtxMessageQueuePut_5: (+1)
   \   0000006C   0x68B9             LDR      R1,[R7, #+8]
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       EvrRtxMessageQueueRetrieved
    406              return osOK;
   \   00000074   0xE019             B.N      ??svcRtxMessageQueuePut_6
    407            }
    408          
    409            // Try to allocate memory
    410            msg = osRtxMemoryPoolAlloc(&mq->mp_info);
   \                     ??svcRtxMessageQueuePut_4: (+1)
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x300C             ADDS     R0,R0,#+12
   \   0000007A   0x.... 0x....      BL       osRtxMemoryPoolAlloc
   \   0000007E   0x0007             MOVS     R7,R0
    411            if (msg != NULL) {
   \   00000080   0xD015             BEQ      ??svcRtxMessageQueuePut_7
    412              // Copy Message
    413              memcpy((uint8_t *)msg + sizeof(os_message_t), msg_ptr, mq->msg_size);
   \   00000082   0x6A62             LDR      R2,[R4, #+36]
   \   00000084   0x0031             MOVS     R1,R6
   \   00000086   0x300C             ADDS     R0,R0,#+12
   \   00000088   0x.... 0x....      BL       __aeabi_memcpy
    414              // Put Message into Queue
    415              msg->id       = osRtxIdMessage;
   \   0000008C   0x2007             MOVS     R0,#+7
   \   0000008E   0x7038             STRB     R0,[R7, #+0]
    416              msg->state    = osRtxObjectActive;
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0x7078             STRB     R0,[R7, #+1]
    417              msg->flags    = 0U;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x70B8             STRB     R0,[R7, #+2]
    418              msg->priority = msg_prio;
   \   00000098   0x70FD             STRB     R5,[R7, #+3]
    419              MessageQueuePut(mq, msg);
   \   0000009A   0x0039             MOVS     R1,R7
   \   0000009C   0x0020             MOVS     R0,R4
   \   0000009E   0x.... 0x....      BL       MessageQueuePut
    420            } else {
    421              // No memory available
    422              if (timeout != 0U) {
    423                EvrRtxMessageQueuePutPending(mq, msg_ptr, timeout);
    424                // Suspend current Thread
    425                osRtxThreadListPut((os_object_t*)mq, osRtxThreadGetRunning());
    426                osRtxThreadWaitEnter(osRtxThreadWaitingMessagePut, timeout);
    427                // Save arguments (R2: const void *msg_ptr, R3: uint8_t msg_prio)
    428                reg = (uint32_t *)(__get_PSP());
    429                reg[2] = (uint32_t)msg_ptr;
    430                reg[3] = (uint32_t)msg_prio;
    431                return osErrorTimeout;
    432              } else {
    433                EvrRtxMessageQueueNotInserted(mq, msg_ptr);
    434                return osErrorResource;
    435              }
    436            }
    437          
    438            EvrRtxMessageQueueInserted(mq, msg_ptr);
   \   000000A2   0x0031             MOVS     R1,R6
   \   000000A4   0x0020             MOVS     R0,R4
   \   000000A6   0x.... 0x....      BL       EvrRtxMessageQueueInserted
    439          
    440            return osOK;
   \                     ??svcRtxMessageQueuePut_6: (+1)
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??svcRtxMessageQueuePut_7: (+1)
   \   000000AE   0x9800             LDR      R0,[SP, #+0]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD013             BEQ      ??svcRtxMessageQueuePut_8
   \   000000B4   0x4602             MOV      R2,R0
   \   000000B6   0x0031             MOVS     R1,R6
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       EvrRtxMessageQueuePutPending
   \   000000BE   0x....             LDR      R0,??DataTable2_2
   \   000000C0   0x6941             LDR      R1,[R0, #+20]
   \   000000C2   0x0020             MOVS     R0,R4
   \   000000C4   0x.... 0x....      BL       osRtxThreadListPut
   \   000000C8   0x9900             LDR      R1,[SP, #+0]
   \   000000CA   0x2093             MOVS     R0,#+147
   \   000000CC   0x.... 0x....      BL       osRtxThreadWaitEnter
   \   000000D0   0xF3EF 0x8709      MRS      R7,PSP
   \   000000D4   0x60BE             STR      R6,[R7, #+8]
   \   000000D6   0x60FD             STR      R5,[R7, #+12]
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0xE004             B        ??svcRtxMessageQueuePut_9
   \                     ??svcRtxMessageQueuePut_8: (+1)
   \   000000DC   0x0031             MOVS     R1,R6
   \   000000DE   0x0020             MOVS     R0,R4
   \   000000E0   0x.... 0x....      BL       EvrRtxMessageQueueNotInserted
   \   000000E4   0x2002             MOVS     R0,#+2
   \                     ??svcRtxMessageQueuePut_9: (+1)
   \   000000E6   0x43C0             MVNS     R0,R0            ;; #-3
   \   000000E8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    441          }
    442          
    443          /// Get a Message from a Queue or timeout if Queue is empty.
    444          /// \note API identical to osMessageQueueGet

   \                                 In section .text, align 2, keep-with-next
    445          osStatus_t svcRtxMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
   \                     svcRtxMessageQueueGet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0017             MOVS     R7,R2
    446            os_message_queue_t *mq = (os_message_queue_t *)mq_id;
    447            os_message_t       *msg;
    448            os_thread_t        *thread;
    449            uint32_t           *reg;
    450          
    451            // Check parameters
    452            if ((mq == NULL) || (mq->id != osRtxIdMessageQueue) || (msg_ptr == NULL)) {
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD004             BEQ      ??svcRtxMessageQueueGet_0
   \   0000000C   0x7828             LDRB     R0,[R5, #+0]
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xD101             BNE      ??svcRtxMessageQueueGet_0
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD101             BNE      ??svcRtxMessageQueueGet_1
    453              EvrRtxMessageQueueError(mq, osErrorParameter);
   \                     ??svcRtxMessageQueueGet_0: (+1)
   \   00000016   0x2403             MOVS     R4,#+3
   \   00000018   0xE003             B.N      ??svcRtxMessageQueueGet_2
    454              return osErrorParameter;
    455            }
    456          
    457            // Check object state
    458            if (mq->state == osRtxObjectInactive) {
   \                     ??svcRtxMessageQueueGet_1: (+1)
   \   0000001A   0x7868             LDRB     R0,[R5, #+1]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD107             BNE      ??svcRtxMessageQueueGet_3
    459              EvrRtxMessageQueueError(mq, osErrorResource);
   \   00000020   0x2402             MOVS     R4,#+2
   \                     ??svcRtxMessageQueueGet_2: (+1)
   \   00000022   0x43E4             MVNS     R4,R4            ;; #-3
   \   00000024   0x0021             MOVS     R1,R4
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0x.... 0x....      BL       EvrRtxMessageQueueError
    460              return osErrorResource;
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0xBDF2             POP      {R1,R4-R7,PC}
    461            }
    462          
    463            // Get Message from Queue
    464            msg = MessageQueueGet(mq);
   \                     ??svcRtxMessageQueueGet_3: (+1)
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x.... 0x....      BL       MessageQueueGet
   \   00000036   0x0004             MOVS     R4,R0
    465            if (msg != NULL) {
   \   00000038   0xD047             BEQ      ??svcRtxMessageQueueGet_4
    466              MessageQueueRemove(mq, msg);
   \   0000003A   0x0021             MOVS     R1,R4
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x.... 0x....      BL       MessageQueueRemove
    467              // Copy Message
    468              memcpy(msg_ptr, (uint8_t *)msg + sizeof(os_message_t), mq->msg_size);
   \   00000042   0x6A6A             LDR      R2,[R5, #+36]
   \   00000044   0x0021             MOVS     R1,R4
   \   00000046   0x310C             ADDS     R1,R1,#+12
   \   00000048   0x0030             MOVS     R0,R6
   \   0000004A   0x.... 0x....      BL       __aeabi_memcpy
    469              if (msg_prio != NULL) {
   \   0000004E   0x2F00             CMP      R7,#+0
   \   00000050   0xD001             BEQ      ??svcRtxMessageQueueGet_5
    470                *msg_prio = msg->priority;
   \   00000052   0x78E0             LDRB     R0,[R4, #+3]
   \   00000054   0x7038             STRB     R0,[R7, #+0]
    471              }
    472              EvrRtxMessageQueueRetrieved(mq, msg_ptr);
   \                     ??svcRtxMessageQueueGet_5: (+1)
   \   00000056   0x0031             MOVS     R1,R6
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0x.... 0x....      BL       EvrRtxMessageQueueRetrieved
    473              // Free memory
    474              msg->state = osRtxObjectInactive;
   \   0000005E   0x2700             MOVS     R7,#+0
   \   00000060   0x7067             STRB     R7,[R4, #+1]
    475              osRtxMemoryPoolFree(&mq->mp_info, msg);
   \   00000062   0x0021             MOVS     R1,R4
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0x300C             ADDS     R0,R0,#+12
   \   00000068   0x.... 0x....      BL       osRtxMemoryPoolFree
    476            } else {
    477              // No Message available
    478              if (timeout != 0U) {
    479                EvrRtxMessageQueueGetPending(mq, msg_ptr, timeout);
    480                // Suspend current Thread
    481                osRtxThreadListPut((os_object_t*)mq, osRtxThreadGetRunning());
    482                osRtxThreadWaitEnter(osRtxThreadWaitingMessageGet, timeout);
    483                // Save arguments (R2: void *msg_ptr, R3: uint8_t *msg_prio)
    484                reg = (uint32_t *)(__get_PSP());
    485                reg[2] = (uint32_t)msg_ptr;
    486                reg[3] = (uint32_t)msg_prio;
    487                return osErrorTimeout;
    488              } else {
    489                EvrRtxMessageQueueNotRetrieved(mq, msg_ptr);
    490                return osErrorResource;
    491              }
    492            }
    493          
    494            // Check if Thread is waiting to send a Message
    495            if ((mq->thread_list != NULL) && (mq->thread_list->state == osRtxThreadWaitingMessagePut)) {
   \   0000006C   0x68A8             LDR      R0,[R5, #+8]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD029             BEQ      ??svcRtxMessageQueueGet_6
   \   00000072   0x7840             LDRB     R0,[R0, #+1]
   \   00000074   0x2893             CMP      R0,#+147
   \   00000076   0xD126             BNE      ??svcRtxMessageQueueGet_6
    496              // Try to allocate memory
    497              msg = osRtxMemoryPoolAlloc(&mq->mp_info);
   \   00000078   0x0028             MOVS     R0,R5
   \   0000007A   0x300C             ADDS     R0,R0,#+12
   \   0000007C   0x.... 0x....      BL       osRtxMemoryPoolAlloc
   \   00000080   0x0006             MOVS     R6,R0
    498              if (msg != NULL) {
   \   00000082   0xD020             BEQ      ??svcRtxMessageQueueGet_6
    499                // Wakeup waiting Thread with highest Priority
    500                thread = osRtxThreadListGet((os_object_t*)mq);
   \   00000084   0x0028             MOVS     R0,R5
   \   00000086   0x.... 0x....      BL       osRtxThreadListGet
   \   0000008A   0x0004             MOVS     R4,R0
    501                osRtxThreadWaitExit(thread, (uint32_t)osOK, true);
   \   0000008C   0x2201             MOVS     R2,#+1
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x.... 0x....      BL       osRtxThreadWaitExit
    502                // Copy Message (R2: const void *msg_ptr, R3: uint8_t msg_prio)
    503                reg = osRtxThreadRegPtr(thread);
   \   00000094   0x0020             MOVS     R0,R4
   \   00000096   0x.... 0x....      BL       osRtxThreadRegPtr
   \   0000009A   0x0004             MOVS     R4,R0
    504                memcpy((uint8_t *)msg + sizeof(os_message_t), (void *)reg[2], mq->msg_size);
   \   0000009C   0x6A6A             LDR      R2,[R5, #+36]
   \   0000009E   0x68A1             LDR      R1,[R4, #+8]
   \   000000A0   0x0030             MOVS     R0,R6
   \   000000A2   0x300C             ADDS     R0,R0,#+12
   \   000000A4   0x.... 0x....      BL       __aeabi_memcpy
    505                // Store Message into Queue
    506                msg->id       = osRtxIdMessage;
   \   000000A8   0x2007             MOVS     R0,#+7
   \   000000AA   0x7030             STRB     R0,[R6, #+0]
    507                msg->state    = osRtxObjectActive;
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x7070             STRB     R0,[R6, #+1]
    508                msg->flags    = 0U;
   \   000000B0   0x70B7             STRB     R7,[R6, #+2]
    509                msg->priority = (uint8_t)reg[3];
   \   000000B2   0x68E0             LDR      R0,[R4, #+12]
   \   000000B4   0x70F0             STRB     R0,[R6, #+3]
    510                MessageQueuePut(mq, msg);
   \   000000B6   0x0031             MOVS     R1,R6
   \   000000B8   0x0028             MOVS     R0,R5
   \   000000BA   0x.... 0x....      BL       MessageQueuePut
    511                EvrRtxMessageQueueInserted(mq, (void *)reg[2]);
   \   000000BE   0x68A1             LDR      R1,[R4, #+8]
   \   000000C0   0x0028             MOVS     R0,R5
   \   000000C2   0x.... 0x....      BL       EvrRtxMessageQueueInserted
    512              }
    513            }
    514          
    515            return osOK;
   \                     ??svcRtxMessageQueueGet_6: (+1)
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??svcRtxMessageQueueGet_4: (+1)
   \   000000CA   0x9800             LDR      R0,[SP, #+0]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD014             BEQ      ??svcRtxMessageQueueGet_7
   \   000000D0   0x4602             MOV      R2,R0
   \   000000D2   0x0031             MOVS     R1,R6
   \   000000D4   0x0028             MOVS     R0,R5
   \   000000D6   0x.... 0x....      BL       EvrRtxMessageQueueGetPending
   \   000000DA   0x....             LDR      R0,??DataTable2_2
   \   000000DC   0x6941             LDR      R1,[R0, #+20]
   \   000000DE   0x0028             MOVS     R0,R5
   \   000000E0   0x.... 0x....      BL       osRtxThreadListPut
   \   000000E4   0x9900             LDR      R1,[SP, #+0]
   \   000000E6   0x2083             MOVS     R0,#+131
   \   000000E8   0x.... 0x....      BL       osRtxThreadWaitEnter
   \   000000EC   0xF3EF 0x8409      MRS      R4,PSP
   \   000000F0   0x60A6             STR      R6,[R4, #+8]
   \   000000F2   0x60E7             STR      R7,[R4, #+12]
   \   000000F4   0x2001             MOVS     R0,#+1
   \                     ??svcRtxMessageQueueGet_8: (+1)
   \   000000F6   0x43C0             MVNS     R0,R0            ;; #-2
   \   000000F8   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??svcRtxMessageQueueGet_7: (+1)
   \   000000FA   0x0031             MOVS     R1,R6
   \   000000FC   0x0028             MOVS     R0,R5
   \   000000FE   0x.... 0x....      BL       EvrRtxMessageQueueNotRetrieved
   \   00000102   0x2002             MOVS     R0,#+2
   \   00000104   0xE7F7             B.N      ??svcRtxMessageQueueGet_8
    516          }
    517          
    518          /// Get maximum number of messages in a Message Queue.
    519          /// \note API identical to osMessageGetCapacity

   \                                 In section .text, align 2, keep-with-next
    520          uint32_t svcRtxMessageQueueGetCapacity (osMessageQueueId_t mq_id) {
   \                     svcRtxMessageQueueGetCapacity: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    521            os_message_queue_t *mq = (os_message_queue_t *)mq_id;
    522          
    523            // Check parameters
    524            if ((mq == NULL) || (mq->id != osRtxIdMessageQueue)) {
   \   00000004   0xD005             BEQ      ??svcRtxMessageQueueGetCapacity_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2808             CMP      R0,#+8
   \   0000000A   0xD102             BNE      ??svcRtxMessageQueueGetCapacity_0
    525              EvrRtxMessageQueueGetCapacity(mq, 0U);
    526              return 0U;
    527            }
    528          
    529            // Check object state
    530            if (mq->state == osRtxObjectInactive) {
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE      ??svcRtxMessageQueueGetCapacity_1
    531              EvrRtxMessageQueueGetCapacity(mq, 0U);
   \                     ??svcRtxMessageQueueGetCapacity_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       EvrRtxMessageQueueGetCapacity
    532              return 0U;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}
    533            }
    534          
    535            EvrRtxMessageQueueGetCapacity(mq, mq->mp_info.max_blocks);
   \                     ??svcRtxMessageQueueGetCapacity_1: (+1)
   \   0000001E   0x68E1             LDR      R1,[R4, #+12]
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       EvrRtxMessageQueueGetCapacity
    536          
    537            return mq->mp_info.max_blocks;
   \   00000026   0x68E0             LDR      R0,[R4, #+12]
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    538          }
    539          
    540          /// Get maximum message size in a Memory Pool.
    541          /// \note API identical to osMessageGetMsgSize

   \                                 In section .text, align 2, keep-with-next
    542          uint32_t svcRtxMessageQueueGetMsgSize (osMessageQueueId_t mq_id) {
   \                     svcRtxMessageQueueGetMsgSize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    543            os_message_queue_t *mq = (os_message_queue_t *)mq_id;
    544          
    545            // Check parameters
    546            if ((mq == NULL) || (mq->id != osRtxIdMessageQueue)) {
   \   00000004   0xD005             BEQ      ??svcRtxMessageQueueGetMsgSize_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2808             CMP      R0,#+8
   \   0000000A   0xD102             BNE      ??svcRtxMessageQueueGetMsgSize_0
    547              EvrRtxMessageQueueGetMsgSize(mq, 0U);
    548              return 0U;
    549            }
    550          
    551            // Check object state
    552            if (mq->state == osRtxObjectInactive) {
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE      ??svcRtxMessageQueueGetMsgSize_1
    553              EvrRtxMessageQueueGetMsgSize(mq, 0U);
   \                     ??svcRtxMessageQueueGetMsgSize_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       EvrRtxMessageQueueGetMsgSize
    554              return 0U;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}
    555            }
    556          
    557            EvrRtxMessageQueueGetMsgSize(mq, mq->msg_size);
   \                     ??svcRtxMessageQueueGetMsgSize_1: (+1)
   \   0000001E   0x6A61             LDR      R1,[R4, #+36]
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       EvrRtxMessageQueueGetMsgSize
    558          
    559            return mq->msg_size;
   \   00000026   0x6A60             LDR      R0,[R4, #+36]
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    560          }
    561          
    562          /// Get number of queued messages in a Message Queue.
    563          /// \note API identical to osMessageGetCount

   \                                 In section .text, align 2, keep-with-next
    564          uint32_t svcRtxMessageQueueGetCount (osMessageQueueId_t mq_id) {
   \                     svcRtxMessageQueueGetCount: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    565            os_message_queue_t *mq = (os_message_queue_t *)mq_id;
    566          
    567            // Check parameters
    568            if ((mq == NULL) || (mq->id != osRtxIdMessageQueue)) {
   \   00000004   0xD005             BEQ      ??svcRtxMessageQueueGetCount_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2808             CMP      R0,#+8
   \   0000000A   0xD102             BNE      ??svcRtxMessageQueueGetCount_0
    569              EvrRtxMessageQueueGetCount(mq, 0U);
    570              return 0U;
    571            }
    572          
    573            // Check object state
    574            if (mq->state == osRtxObjectInactive) {
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE      ??svcRtxMessageQueueGetCount_1
    575              EvrRtxMessageQueueGetCount(mq, 0U);
   \                     ??svcRtxMessageQueueGetCount_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       EvrRtxMessageQueueGetCount
    576              return 0U;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}
    577            }
    578          
    579            EvrRtxMessageQueueGetCount(mq, mq->msg_count);
   \                     ??svcRtxMessageQueueGetCount_1: (+1)
   \   0000001E   0x6AA1             LDR      R1,[R4, #+40]
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       EvrRtxMessageQueueGetCount
    580          
    581            return mq->msg_count;
   \   00000026   0x6AA0             LDR      R0,[R4, #+40]
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    582          }
    583          
    584          /// Get number of available slots for messages in a Message Queue.
    585          /// \note API identical to osMessageGetSpace

   \                                 In section .text, align 2, keep-with-next
    586          uint32_t svcRtxMessageQueueGetSpace (osMessageQueueId_t mq_id) {
   \                     svcRtxMessageQueueGetSpace: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    587            os_message_queue_t *mq = (os_message_queue_t *)mq_id;
    588          
    589            // Check parameters
    590            if ((mq == NULL) || (mq->id != osRtxIdMessageQueue)) {
   \   00000004   0xD005             BEQ      ??svcRtxMessageQueueGetSpace_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2808             CMP      R0,#+8
   \   0000000A   0xD102             BNE      ??svcRtxMessageQueueGetSpace_0
    591              EvrRtxMessageQueueGetSpace(mq, 0U);
    592              return 0U;
    593            }
    594          
    595            // Check object state
    596            if (mq->state == osRtxObjectInactive) {
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE      ??svcRtxMessageQueueGetSpace_1
    597              EvrRtxMessageQueueGetSpace(mq, 0U);
   \                     ??svcRtxMessageQueueGetSpace_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       EvrRtxMessageQueueGetSpace
    598              return 0U;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}
    599            }
    600          
    601            EvrRtxMessageQueueGetSpace(mq, mq->mp_info.max_blocks - mq->msg_count);
   \                     ??svcRtxMessageQueueGetSpace_1: (+1)
   \   0000001E   0x68E0             LDR      R0,[R4, #+12]
   \   00000020   0x6AA1             LDR      R1,[R4, #+40]
   \   00000022   0x1A41             SUBS     R1,R0,R1
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       EvrRtxMessageQueueGetSpace
    602          
    603            return (mq->mp_info.max_blocks - mq->msg_count);
   \   0000002A   0x68E0             LDR      R0,[R4, #+12]
   \   0000002C   0x6AA1             LDR      R1,[R4, #+40]
   \   0000002E   0x1A40             SUBS     R0,R0,R1
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    604          }
    605          
    606          /// Reset a Message Queue to initial empty state.
    607          /// \note API identical to osMessageQueueReset

   \                                 In section .text, align 2, keep-with-next
    608          osStatus_t svcRtxMessageQueueReset (osMessageQueueId_t mq_id) {
   \                     svcRtxMessageQueueReset: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    609            os_message_queue_t *mq = (os_message_queue_t *)mq_id;
    610            os_message_t       *msg;
    611            os_thread_t        *thread;
    612            uint32_t           *reg;
    613          
    614            // Check parameters
    615            if ((mq == NULL) || (mq->id != osRtxIdMessageQueue)) {
   \   00000004   0xD002             BEQ      ??svcRtxMessageQueueReset_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2808             CMP      R0,#+8
   \   0000000A   0xD001             BEQ      ??svcRtxMessageQueueReset_1
    616              EvrRtxMessageQueueError(mq, osErrorParameter);
   \                     ??svcRtxMessageQueueReset_0: (+1)
   \   0000000C   0x2503             MOVS     R5,#+3
   \   0000000E   0xE003             B.N      ??svcRtxMessageQueueReset_2
    617              return osErrorParameter;
    618            }
    619          
    620            // Check object state
    621            if (mq->state == osRtxObjectInactive) {
   \                     ??svcRtxMessageQueueReset_1: (+1)
   \   00000010   0x7860             LDRB     R0,[R4, #+1]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD113             BNE      ??svcRtxMessageQueueReset_3
    622              EvrRtxMessageQueueError(mq, osErrorResource);
   \   00000016   0x2502             MOVS     R5,#+2
   \                     ??svcRtxMessageQueueReset_2: (+1)
   \   00000018   0x43ED             MVNS     R5,R5            ;; #-3
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       EvrRtxMessageQueueError
    623              return osErrorResource;
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xBD70             POP      {R4-R6,PC}
    624            }
    625          
    626            // Remove Messages from Queue
    627            for (;;) {
   \                     ??svcRtxMessageQueueReset_4: (+1)
   \   00000026   0x6320             STR      R0,[R4, #+48]
    628              // Get Message from Queue
    629              msg = MessageQueueGet(mq);
    630              if (msg == NULL) {
    631                break;
    632              }
    633              MessageQueueRemove(mq, msg);
    634              EvrRtxMessageQueueRetrieved(mq, NULL);
   \                     ??svcRtxMessageQueueReset_5: (+1)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       EvrRtxMessageQueueRetrieved
    635              // Free memory
    636              msg->state = osRtxObjectInactive;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x7068             STRB     R0,[R5, #+1]
    637              osRtxMemoryPoolFree(&mq->mp_info, msg);
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x300C             ADDS     R0,R0,#+12
   \   0000003A   0x.... 0x....      BL       osRtxMemoryPoolFree
   \                     ??svcRtxMessageQueueReset_3: (+1)
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       MessageQueueGet
   \   00000044   0x0005             MOVS     R5,R0
   \   00000046   0xD138             BNE      ??svcRtxMessageQueueReset_6
    638            }
    639          
    640            // Check if Threads are waiting to send Messages
    641            if ((mq->thread_list != NULL) && (mq->thread_list->state == osRtxThreadWaitingMessagePut)) {
   \   00000048   0x68A0             LDR      R0,[R4, #+8]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD030             BEQ      ??svcRtxMessageQueueReset_7
   \   0000004E   0x7840             LDRB     R0,[R0, #+1]
   \   00000050   0x2893             CMP      R0,#+147
   \   00000052   0xD12D             BNE      ??svcRtxMessageQueueReset_7
    642              do {
    643                // Try to allocate memory
    644                msg = osRtxMemoryPoolAlloc(&mq->mp_info);
   \                     ??svcRtxMessageQueueReset_8: (+1)
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x300C             ADDS     R0,R0,#+12
   \   00000058   0x.... 0x....      BL       osRtxMemoryPoolAlloc
   \   0000005C   0x0006             MOVS     R6,R0
    645                if (msg != NULL) {
   \   0000005E   0xD024             BEQ      ??svcRtxMessageQueueReset_9
    646                  // Wakeup waiting Thread with highest Priority
    647                  thread = osRtxThreadListGet((os_object_t*)mq);
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       osRtxThreadListGet
   \   00000066   0x0005             MOVS     R5,R0
    648                  osRtxThreadWaitExit(thread, (uint32_t)osOK, false);
   \   00000068   0x2200             MOVS     R2,#+0
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x.... 0x....      BL       osRtxThreadWaitExit
    649                  // Copy Message (R2: const void *msg_ptr, R3: uint8_t msg_prio)
    650                  reg = osRtxThreadRegPtr(thread);
   \   00000070   0x0028             MOVS     R0,R5
   \   00000072   0x.... 0x....      BL       osRtxThreadRegPtr
   \   00000076   0x0005             MOVS     R5,R0
    651                  memcpy((uint8_t *)msg + sizeof(os_message_t), (void *)reg[2], mq->msg_size);
   \   00000078   0x6A62             LDR      R2,[R4, #+36]
   \   0000007A   0x68A9             LDR      R1,[R5, #+8]
   \   0000007C   0x0030             MOVS     R0,R6
   \   0000007E   0x300C             ADDS     R0,R0,#+12
   \   00000080   0x.... 0x....      BL       __aeabi_memcpy
    652                  // Store Message into Queue
    653                  msg->id       = osRtxIdMessage;
   \   00000084   0x2007             MOVS     R0,#+7
   \   00000086   0x7030             STRB     R0,[R6, #+0]
    654                  msg->state    = osRtxObjectActive;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x7070             STRB     R0,[R6, #+1]
    655                  msg->flags    = 0U;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x70B0             STRB     R0,[R6, #+2]
    656                  msg->priority = (uint8_t)reg[3];
   \   00000090   0x68E8             LDR      R0,[R5, #+12]
   \   00000092   0x70F0             STRB     R0,[R6, #+3]
    657                  MessageQueuePut(mq, msg);
   \   00000094   0x0031             MOVS     R1,R6
   \   00000096   0x0020             MOVS     R0,R4
   \   00000098   0x.... 0x....      BL       MessageQueuePut
    658                  EvrRtxMessageQueueInserted(mq, (void *)reg[2]);
   \   0000009C   0x68A9             LDR      R1,[R5, #+8]
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x.... 0x....      BL       EvrRtxMessageQueueInserted
   \   000000A4   0x68A0             LDR      R0,[R4, #+8]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD1D4             BNE      ??svcRtxMessageQueueReset_8
    659                }
    660              } while ((msg != NULL) && (mq->thread_list != NULL));
    661              osRtxThreadDispatch(NULL);
   \                     ??svcRtxMessageQueueReset_9: (+1)
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x.... 0x....      BL       osRtxThreadDispatch
    662            }
    663          
    664            EvrRtxMessageQueueResetDone(mq);
   \                     ??svcRtxMessageQueueReset_7: (+1)
   \   000000B0   0x0020             MOVS     R0,R4
   \   000000B2   0x.... 0x....      BL       EvrRtxMessageQueueResetDone
    665          
    666            return osOK;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??svcRtxMessageQueueReset_6: (+1)
   \   000000BA   0x68A8             LDR      R0,[R5, #+8]
   \   000000BC   0x6869             LDR      R1,[R5, #+4]
   \   000000BE   0x2900             CMP      R1,#+0
   \   000000C0   0xD001             BEQ      ??svcRtxMessageQueueReset_10
   \   000000C2   0x6088             STR      R0,[R1, #+8]
   \   000000C4   0xE000             B        ??svcRtxMessageQueueReset_11
   \                     ??svcRtxMessageQueueReset_10: (+1)
   \   000000C6   0x62E0             STR      R0,[R4, #+44]
   \                     ??svcRtxMessageQueueReset_11: (+1)
   \   000000C8   0x6868             LDR      R0,[R5, #+4]
   \   000000CA   0x68A9             LDR      R1,[R5, #+8]
   \   000000CC   0x2900             CMP      R1,#+0
   \   000000CE   0xD0AA             BEQ      ??svcRtxMessageQueueReset_4
   \   000000D0   0x6048             STR      R0,[R1, #+4]
   \   000000D2   0xE7A9             B        ??svcRtxMessageQueueReset_5
    667          }
    668          
    669          /// Delete a Message Queue object.
    670          /// \note API identical to osMessageQueueDelete

   \                                 In section .text, align 2, keep-with-next
    671          osStatus_t svcRtxMessageQueueDelete (osMessageQueueId_t mq_id) {
   \                     svcRtxMessageQueueDelete: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    672            os_message_queue_t *mq = (os_message_queue_t *)mq_id;
    673            os_thread_t        *thread;
    674          
    675            // Check parameters
    676            if ((mq == NULL) || (mq->id != osRtxIdMessageQueue)) {
   \   00000004   0xD002             BEQ      ??svcRtxMessageQueueDelete_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2808             CMP      R0,#+8
   \   0000000A   0xD001             BEQ      ??svcRtxMessageQueueDelete_1
    677              EvrRtxMessageQueueError(mq, osErrorParameter);
   \                     ??svcRtxMessageQueueDelete_0: (+1)
   \   0000000C   0x2503             MOVS     R5,#+3
   \   0000000E   0xE003             B.N      ??svcRtxMessageQueueDelete_2
    678              return osErrorParameter;
    679            }
    680          
    681            // Check object state
    682            if (mq->state == osRtxObjectInactive) {
   \                     ??svcRtxMessageQueueDelete_1: (+1)
   \   00000010   0x7860             LDRB     R0,[R4, #+1]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD107             BNE      ??svcRtxMessageQueueDelete_3
    683              EvrRtxMessageQueueError(mq, osErrorResource);
   \   00000016   0x2502             MOVS     R5,#+2
   \                     ??svcRtxMessageQueueDelete_2: (+1)
   \   00000018   0x43ED             MVNS     R5,R5            ;; #-3
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       EvrRtxMessageQueueError
    684              return osErrorResource;
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}
    685            }
    686          
    687            // Mark object as inactive
    688            mq->state = osRtxObjectInactive;
   \                     ??svcRtxMessageQueueDelete_3: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x7060             STRB     R0,[R4, #+1]
    689          
    690            // Unblock waiting threads
    691            if (mq->thread_list != NULL) {
   \   0000002A   0x68A0             LDR      R0,[R4, #+8]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD00C             BEQ      ??svcRtxMessageQueueDelete_4
    692              do {
    693                thread = osRtxThreadListGet((os_object_t*)mq);
   \                     ??svcRtxMessageQueueDelete_5: (+1)
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       osRtxThreadListGet
    694                osRtxThreadWaitExit(thread, (uint32_t)osErrorResource, false);
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x2102             MOVS     R1,#+2
   \   0000003A   0x43C9             MVNS     R1,R1            ;; #-3
   \   0000003C   0x.... 0x....      BL       osRtxThreadWaitExit
    695              } while (mq->thread_list != NULL);
   \   00000040   0x68A0             LDR      R0,[R4, #+8]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD1F4             BNE      ??svcRtxMessageQueueDelete_5
    696              osRtxThreadDispatch(NULL);
   \   00000046   0x.... 0x....      BL       osRtxThreadDispatch
    697            }
    698          
    699            // Free data memory
    700            if (mq->flags & osRtxFlagSystemMemory) {
   \                     ??svcRtxMessageQueueDelete_4: (+1)
   \   0000004A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000004C   0x0780             LSLS     R0,R0,#+30
   \   0000004E   0xD504             BPL      ??svcRtxMessageQueueDelete_6
    701              osRtxMemoryFree(osRtxInfo.mem.mq_data, mq->mp_info.block_base);
   \   00000050   0x69A1             LDR      R1,[R4, #+24]
   \   00000052   0x....             LDR      R0,??DataTable13
   \   00000054   0x6FC0             LDR      R0,[R0, #+124]
   \   00000056   0x.... 0x....      BL       osRtxMemoryFree
    702            }
    703          
    704            // Free object memory
    705            if (mq->flags & osRtxFlagSystemObject) {
   \                     ??svcRtxMessageQueueDelete_6: (+1)
   \   0000005A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000005C   0x07C0             LSLS     R0,R0,#+31
   \   0000005E   0xD50B             BPL      ??svcRtxMessageQueueDelete_7
    706              if (osRtxInfo.mpi.message_queue != NULL) {
   \   00000060   0x....             LDR      R2,??DataTable13_1
   \   00000062   0x6A50             LDR      R0,[R2, #+36]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD003             BEQ      ??svcRtxMessageQueueDelete_8
    707                osRtxMemoryPoolFree(osRtxInfo.mpi.message_queue, mq);
   \   00000068   0x0021             MOVS     R1,R4
   \   0000006A   0x.... 0x....      BL       osRtxMemoryPoolFree
   \   0000006E   0xE003             B        ??svcRtxMessageQueueDelete_7
    708              } else {
    709                osRtxMemoryFree(osRtxInfo.mem.common, mq);
   \                     ??svcRtxMessageQueueDelete_8: (+1)
   \   00000070   0x0021             MOVS     R1,R4
   \   00000072   0x6850             LDR      R0,[R2, #+4]
   \   00000074   0x.... 0x....      BL       osRtxMemoryFree
    710              }
    711            }
    712          
    713            EvrRtxMessageQueueDestroyed(mq);
   \                     ??svcRtxMessageQueueDelete_7: (+1)
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      BL       EvrRtxMessageQueueDestroyed
    714          
    715            return osOK;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    716          }
    717          
    718          
    719          //  ==== ISR Calls ====
    720          
    721          /// Put a Message into a Queue or timeout if Queue is full.
    722          /// \note API identical to osMessageQueuePut
    723          __STATIC_INLINE
    724          osStatus_t isrRtxMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
    725            os_message_queue_t *mq = (os_message_queue_t *)mq_id;
    726            os_message_t       *msg;
    727            const void        **ptr;
    728          
    729            // Check parameters
    730            if ((mq == NULL) || (mq->id != osRtxIdMessageQueue) || (msg_ptr == NULL) || (timeout != 0U)) {
    731              EvrRtxMessageQueueError(mq, osErrorParameter);
    732              return osErrorParameter;
    733            }
    734          
    735            // Check object state
    736            if (mq->state == osRtxObjectInactive) {
    737              EvrRtxMessageQueueError(mq, osErrorResource);
    738              return osErrorResource;
    739            }
    740          
    741            // Try to allocate memory
    742            msg = osRtxMemoryPoolAlloc(&mq->mp_info);
    743            if (msg != NULL) {
    744              // Copy Message
    745              memcpy((uint8_t *)msg + sizeof(os_message_t), msg_ptr, mq->msg_size);
    746              msg->id       = osRtxIdMessage;
    747              msg->state    = osRtxObjectActive;
    748              msg->flags    = 0U;
    749              msg->priority = msg_prio;
    750              // Register post ISR processing
    751               ptr = (void *)&msg->prev;
    752              *ptr = msg_ptr;
    753               ptr = (void *)&msg->next;
    754              *ptr = mq;
    755              osRtxPostProcess((os_object_t *)msg);
    756            } else {
    757              // No memory available
    758              EvrRtxMessageQueueNotInserted(mq, msg_ptr);
    759              return osErrorResource;
    760            }
    761          
    762            EvrRtxMessageQueueInsertPending(mq, msg_ptr);
    763          
    764            return osOK;
    765          }
    766          
    767          /// Get a Message from a Queue or timeout if Queue is empty.
    768          /// \note API identical to osMessageQueueGet
    769          __STATIC_INLINE
    770          osStatus_t isrRtxMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
    771            os_message_queue_t *mq = (os_message_queue_t *)mq_id;
    772            os_message_t       *msg;
    773            void              **ptr;
    774          
    775            // Check parameters
    776            if ((mq == NULL) || (mq->id != osRtxIdMessageQueue) || (msg_ptr == NULL) || (timeout != 0U)) {
    777              EvrRtxMessageQueueError(mq, osErrorParameter);
    778              return osErrorParameter;
    779            }
    780          
    781            // Check object state
    782            if (mq->state == osRtxObjectInactive) {
    783              EvrRtxMessageQueueError(mq, osErrorResource);
    784              return osErrorResource;
    785            }
    786          
    787            // Get Message from Queue
    788            msg = MessageQueueGet(mq);
    789            if (msg != NULL) {
    790              // Copy Message
    791              memcpy(msg_ptr, (uint8_t *)msg + sizeof(os_message_t), mq->msg_size);
    792              if (msg_prio != NULL) {
    793                *msg_prio = msg->priority;
    794              }
    795              EvrRtxMessageQueueRetrieved(mq, msg_ptr);
    796              // Register post ISR processing
    797               ptr = (void *)((uint8_t *)msg + sizeof(os_message_t));
    798              *ptr = mq;
    799              osRtxPostProcess((os_object_t *)msg);
    800            } else {
    801              // No Message available
    802              EvrRtxMessageQueueNotRetrieved(mq, msg_ptr);
    803              return osErrorResource;
    804            }
    805          
    806            return osOK;
    807          }
    808          
    809          
    810          //  ==== Public API ====
    811          
    812          /// Create and Initialize a Message Queue object.

   \                                 In section .text, align 4, keep-with-next
    813          osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
   \                     osMessageQueueNew: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0015             MOVS     R5,R2
    814            EvrRtxMessageQueueNew(msg_count, msg_size, attr);
   \   00000008   0x.... 0x....      BL       EvrRtxMessageQueueNew
    815            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   0000000C   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD103             BNE      ??osMessageQueueNew_0
   \   00000014   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD006             BEQ      ??osMessageQueueNew_1
    816              EvrRtxMessageQueueError(NULL, osErrorISR);
   \                     ??osMessageQueueNew_0: (+1)
   \   0000001C   0x2105             MOVS     R1,#+5
   \   0000001E   0x43C9             MVNS     R1,R1            ;; #-6
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      BL       EvrRtxMessageQueueError
    817              return NULL;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBDF2             POP      {R1,R4-R7,PC}
    818            }
    819            return __svcMessageQueueNew(msg_count, msg_size, attr);
   \                     ??osMessageQueueNew_1: (+1)
   \   0000002A   0xF3EF 0x8014      MRS      R0,CONTROL
   \   0000002E   0x0780             LSLS     R0,R0,#+30
   \   00000030   0xD406             BMI      ??osMessageQueueNew_2
   \   00000032   0xF3EF 0x8008      MRS      R0,MSP
   \   00000036   0x3820             SUBS     R0,R0,#+32
   \   00000038   0x2107             MOVS     R1,#+7
   \   0000003A   0x4388             BICS     R0,R0,R1
   \   0000003C   0xF380 0x8809      MSR      PSP,R0
   \                     ??osMessageQueueNew_2: (+1)
   \   00000040   0x....             LDR      R0,??DataTable13_2
   \   00000042   0x4607             mov r7,R0
   \   00000044   0x002A             MOVS     R2,R5
   \   00000046   0x0031             MOVS     R1,R6
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0xDF00             SVC      0x0
   \   0000004C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    820          }
    821          
    822          /// Get name of a Message Queue object.

   \                                 In section .text, align 4, keep-with-next
    823          const char *osMessageQueueGetName (osMessageQueueId_t mq_id) {
   \                     osMessageQueueGetName: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    824            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8105      MRS      R1,IPSR
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE      ??osMessageQueueGetName_0
   \   0000000A   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD004             BEQ      ??osMessageQueueGetName_1
    825              EvrRtxMessageQueueGetName(mq_id, NULL);
   \                     ??osMessageQueueGetName_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x.... 0x....      BL       EvrRtxMessageQueueGetName
    826              return NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD80             POP      {R7,PC}
    827            }
    828            return __svcMessageQueueGetName(mq_id);
   \                     ??osMessageQueueGetName_1: (+1)
   \   0000001C   0x....             LDR      R1,??DataTable13_3
   \   0000001E   0x460F             mov r7,R1
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBD80             POP      {R7,PC}          ;; return
    829          }
    830          
    831          /// Put a Message into a Queue or timeout if Queue is full.

   \                                 In section .text, align 4, keep-with-next
    832          osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
   \                     osMessageQueuePut: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0015             MOVS     R5,R2
    833            EvrRtxMessageQueuePut(mq_id, msg_ptr, msg_prio, timeout);
   \   00000008   0x.... 0x....      BL       EvrRtxMessageQueuePut
    834            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   0000000C   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD103             BNE      ??osMessageQueuePut_0
   \   00000014   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD03A             BEQ      ??osMessageQueuePut_1
    835              return isrRtxMessageQueuePut(mq_id, msg_ptr, msg_prio, timeout);
   \                     ??osMessageQueuePut_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD030             BEQ      ??osMessageQueuePut_2
   \   00000020   0x7820             LDRB     R0,[R4, #+0]
   \   00000022   0x2808             CMP      R0,#+8
   \   00000024   0xD12D             BNE      ??osMessageQueuePut_2
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD02B             BEQ      ??osMessageQueuePut_2
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD128             BNE      ??osMessageQueuePut_2
   \   00000030   0x7860             LDRB     R0,[R4, #+1]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD101             BNE      ??osMessageQueuePut_3
   \   00000036   0x2502             MOVS     R5,#+2
   \   00000038   0xE024             B        ??osMessageQueuePut_4
   \                     ??osMessageQueuePut_3: (+1)
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x300C             ADDS     R0,R0,#+12
   \   0000003E   0x.... 0x....      BL       osRtxMemoryPoolAlloc
   \   00000042   0x0007             MOVS     R7,R0
   \   00000044   0xD016             BEQ      ??osMessageQueuePut_5
   \   00000046   0x6A62             LDR      R2,[R4, #+36]
   \   00000048   0x0031             MOVS     R1,R6
   \   0000004A   0x300C             ADDS     R0,R0,#+12
   \   0000004C   0x.... 0x....      BL       __aeabi_memcpy
   \   00000050   0x2007             MOVS     R0,#+7
   \   00000052   0x7038             STRB     R0,[R7, #+0]
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0x7078             STRB     R0,[R7, #+1]
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x70B8             STRB     R0,[R7, #+2]
   \   0000005C   0x70FD             STRB     R5,[R7, #+3]
   \   0000005E   0x607E             STR      R6,[R7, #+4]
   \   00000060   0x60BC             STR      R4,[R7, #+8]
   \   00000062   0x0038             MOVS     R0,R7
   \   00000064   0x.... 0x....      BL       osRtxPostProcess
   \   00000068   0x0031             MOVS     R1,R6
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       EvrRtxMessageQueueInsertPending
   \   00000070   0x2500             MOVS     R5,#+0
   \   00000072   0xE00C             B        ??osMessageQueuePut_6
   \                     ??osMessageQueuePut_5: (+1)
   \   00000074   0x0031             MOVS     R1,R6
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       EvrRtxMessageQueueNotInserted
   \   0000007C   0x2502             MOVS     R5,#+2
   \   0000007E   0x43ED             MVNS     R5,R5            ;; #-3
   \   00000080   0xE005             B        ??osMessageQueuePut_6
   \                     ??osMessageQueuePut_2: (+1)
   \   00000082   0x2503             MOVS     R5,#+3
   \                     ??osMessageQueuePut_4: (+1)
   \   00000084   0x43ED             MVNS     R5,R5            ;; #-4
   \   00000086   0x0029             MOVS     R1,R5
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       EvrRtxMessageQueueError
    836            } else {
   \                     ??osMessageQueuePut_6: (+1)
   \   0000008E   0x0028             MOVS     R0,R5
   \   00000090   0xBDF2             POP      {R1,R4-R7,PC}
    837              return  __svcMessageQueuePut(mq_id, msg_ptr, msg_prio, timeout);
   \                     ??osMessageQueuePut_1: (+1)
   \   00000092   0x....             LDR      R0,??DataTable13_4
   \   00000094   0x4607             mov r7,R0
   \   00000096   0x9B00             LDR      R3,[SP, #+0]
   \   00000098   0x002A             MOVS     R2,R5
   \   0000009A   0x0031             MOVS     R1,R6
   \   0000009C   0x0020             MOVS     R0,R4
   \   0000009E   0xDF00             SVC      0x0
   \   000000A0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    838            }
    839          }
    840          
    841          /// Get a Message from a Queue or timeout if Queue is empty.

   \                                 In section .text, align 4, keep-with-next
    842          osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
   \                     osMessageQueueGet: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x001E             MOVS     R6,R3
    843            EvrRtxMessageQueueGet(mq_id, msg_ptr, msg_prio, timeout);
   \   00000008   0x.... 0x....      BL       EvrRtxMessageQueueGet
    844            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   0000000C   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD103             BNE      ??osMessageQueueGet_0
   \   00000014   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD037             BEQ      ??osMessageQueueGet_1
    845              return isrRtxMessageQueueGet(mq_id, msg_ptr, msg_prio, timeout);
   \                     ??osMessageQueueGet_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD02D             BEQ      ??osMessageQueueGet_2
   \   00000020   0x7820             LDRB     R0,[R4, #+0]
   \   00000022   0x2808             CMP      R0,#+8
   \   00000024   0xD12A             BNE      ??osMessageQueueGet_2
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD028             BEQ      ??osMessageQueueGet_2
   \   0000002A   0x2E00             CMP      R6,#+0
   \   0000002C   0xD126             BNE      ??osMessageQueueGet_2
   \   0000002E   0x7860             LDRB     R0,[R4, #+1]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD101             BNE      ??osMessageQueueGet_3
   \   00000034   0x2502             MOVS     R5,#+2
   \   00000036   0xE022             B        ??osMessageQueueGet_4
   \                     ??osMessageQueueGet_3: (+1)
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       MessageQueueGet
   \   0000003E   0x0006             MOVS     R6,R0
   \   00000040   0xD015             BEQ      ??osMessageQueueGet_5
   \   00000042   0x6A62             LDR      R2,[R4, #+36]
   \   00000044   0x0031             MOVS     R1,R6
   \   00000046   0x310C             ADDS     R1,R1,#+12
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       __aeabi_memcpy
   \   0000004E   0x9800             LDR      R0,[SP, #+0]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD002             BEQ      ??osMessageQueueGet_6
   \   00000054   0x78F0             LDRB     R0,[R6, #+3]
   \   00000056   0x9900             LDR      R1,[SP, #+0]
   \   00000058   0x7008             STRB     R0,[R1, #+0]
   \                     ??osMessageQueueGet_6: (+1)
   \   0000005A   0x0029             MOVS     R1,R5
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       EvrRtxMessageQueueRetrieved
   \   00000062   0x60F4             STR      R4,[R6, #+12]
   \   00000064   0x0030             MOVS     R0,R6
   \   00000066   0x.... 0x....      BL       osRtxPostProcess
   \   0000006A   0x2500             MOVS     R5,#+0
   \   0000006C   0xE00C             B        ??osMessageQueueGet_7
   \                     ??osMessageQueueGet_5: (+1)
   \   0000006E   0x0029             MOVS     R1,R5
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       EvrRtxMessageQueueNotRetrieved
   \   00000076   0x2502             MOVS     R5,#+2
   \   00000078   0x43ED             MVNS     R5,R5            ;; #-3
   \   0000007A   0xE005             B        ??osMessageQueueGet_7
   \                     ??osMessageQueueGet_2: (+1)
   \   0000007C   0x2503             MOVS     R5,#+3
   \                     ??osMessageQueueGet_4: (+1)
   \   0000007E   0x43ED             MVNS     R5,R5            ;; #-4
   \   00000080   0x0029             MOVS     R1,R5
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x.... 0x....      BL       EvrRtxMessageQueueError
    846            } else {
   \                     ??osMessageQueueGet_7: (+1)
   \   00000088   0x0028             MOVS     R0,R5
   \   0000008A   0xBDF2             POP      {R1,R4-R7,PC}
    847              return  __svcMessageQueueGet(mq_id, msg_ptr, msg_prio, timeout);
   \                     ??osMessageQueueGet_1: (+1)
   \   0000008C   0x....             LDR      R0,??DataTable13_5
   \   0000008E   0x4607             mov r7,R0
   \   00000090   0x0033             MOVS     R3,R6
   \   00000092   0x9A00             LDR      R2,[SP, #+0]
   \   00000094   0x0029             MOVS     R1,R5
   \   00000096   0x0020             MOVS     R0,R4
   \   00000098   0xDF00             SVC      0x0
   \   0000009A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    848            }
    849          }
    850          
    851          /// Get maximum number of messages in a Message Queue.

   \                                 In section .text, align 4, keep-with-next
    852          uint32_t osMessageQueueGetCapacity (osMessageQueueId_t mq_id) {
   \                     osMessageQueueGetCapacity: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    853            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8105      MRS      R1,IPSR
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE      ??osMessageQueueGetCapacity_0
   \   0000000A   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD002             BEQ      ??osMessageQueueGetCapacity_1
    854              return svcRtxMessageQueueGetCapacity(mq_id);
   \                     ??osMessageQueueGetCapacity_0: (+1)
   \   00000012   0x.... 0x....      BL       svcRtxMessageQueueGetCapacity
   \   00000016   0xBD80             POP      {R7,PC}
    855            } else {
    856              return  __svcMessageQueueGetCapacity(mq_id);
   \                     ??osMessageQueueGetCapacity_1: (+1)
   \   00000018   0x....             LDR      R1,??DataTable13_6
   \   0000001A   0x460F             mov r7,R1
   \   0000001C   0xDF00             SVC      0x0
   \   0000001E   0xBD80             POP      {R7,PC}          ;; return
    857            }
    858          }
    859          
    860          /// Get maximum message size in a Memory Pool.

   \                                 In section .text, align 4, keep-with-next
    861          uint32_t osMessageQueueGetMsgSize (osMessageQueueId_t mq_id) {
   \                     osMessageQueueGetMsgSize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    862            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8105      MRS      R1,IPSR
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE      ??osMessageQueueGetMsgSize_0
   \   0000000A   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD002             BEQ      ??osMessageQueueGetMsgSize_1
    863              return svcRtxMessageQueueGetMsgSize(mq_id);
   \                     ??osMessageQueueGetMsgSize_0: (+1)
   \   00000012   0x.... 0x....      BL       svcRtxMessageQueueGetMsgSize
   \   00000016   0xBD80             POP      {R7,PC}
    864            } else {
    865              return  __svcMessageQueueGetMsgSize(mq_id);
   \                     ??osMessageQueueGetMsgSize_1: (+1)
   \   00000018   0x....             LDR      R1,??DataTable13_7
   \   0000001A   0x460F             mov r7,R1
   \   0000001C   0xDF00             SVC      0x0
   \   0000001E   0xBD80             POP      {R7,PC}          ;; return
    866            }
    867          }
    868          
    869          /// Get number of queued messages in a Message Queue.

   \                                 In section .text, align 4, keep-with-next
    870          uint32_t osMessageQueueGetCount (osMessageQueueId_t mq_id) {
   \                     osMessageQueueGetCount: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    871            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8105      MRS      R1,IPSR
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE      ??osMessageQueueGetCount_0
   \   0000000A   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD002             BEQ      ??osMessageQueueGetCount_1
    872              return svcRtxMessageQueueGetCount(mq_id);
   \                     ??osMessageQueueGetCount_0: (+1)
   \   00000012   0x.... 0x....      BL       svcRtxMessageQueueGetCount
   \   00000016   0xBD80             POP      {R7,PC}
    873            } else {
    874              return  __svcMessageQueueGetCount(mq_id);
   \                     ??osMessageQueueGetCount_1: (+1)
   \   00000018   0x....             LDR      R1,??DataTable13_8
   \   0000001A   0x460F             mov r7,R1
   \   0000001C   0xDF00             SVC      0x0
   \   0000001E   0xBD80             POP      {R7,PC}          ;; return
    875            }
    876          }
    877          
    878          /// Get number of available slots for messages in a Message Queue.

   \                                 In section .text, align 4, keep-with-next
    879          uint32_t osMessageQueueGetSpace (osMessageQueueId_t mq_id) {
   \                     osMessageQueueGetSpace: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    880            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8105      MRS      R1,IPSR
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE      ??osMessageQueueGetSpace_0
   \   0000000A   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD002             BEQ      ??osMessageQueueGetSpace_1
    881              return svcRtxMessageQueueGetSpace(mq_id);
   \                     ??osMessageQueueGetSpace_0: (+1)
   \   00000012   0x.... 0x....      BL       svcRtxMessageQueueGetSpace
   \   00000016   0xBD80             POP      {R7,PC}
    882            } else {
    883              return  __svcMessageQueueGetSpace(mq_id);
   \                     ??osMessageQueueGetSpace_1: (+1)
   \   00000018   0x....             LDR      R1,??DataTable13_9
   \   0000001A   0x460F             mov r7,R1
   \   0000001C   0xDF00             SVC      0x0
   \   0000001E   0xBD80             POP      {R7,PC}          ;; return
    884            }
    885          }
    886          
    887          /// Reset a Message Queue to initial empty state.

   \                                 In section .text, align 4, keep-with-next
    888          osStatus_t osMessageQueueReset (osMessageQueueId_t mq_id) {
   \                     osMessageQueueReset: (+1)
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    889            EvrRtxMessageQueueReset(mq_id);
   \   00000004   0x.... 0x....      BL       EvrRtxMessageQueueReset
    890            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000008   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE      ??osMessageQueueReset_0
   \   00000010   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD000             BEQ      ??osMessageQueueReset_1
    891              EvrRtxMessageQueueError(mq_id, osErrorISR);
   \                     ??osMessageQueueReset_0: (+1)
   \   00000018   0x....             B.N      ?Subroutine0
    892              return osErrorISR;
    893            }
    894            return __svcMessageQueueReset(mq_id);
   \                     ??osMessageQueueReset_1: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable13_10
   \   0000001C   0x4607             mov r7,R0
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBDB0             POP      {R4,R5,R7,PC}    ;; return
    895          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2505             MOVS     R5,#+5
   \   00000002   0x43ED             MVNS     R5,R5            ;; #-6
   \   00000004   0x0029             MOVS     R1,R5
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       EvrRtxMessageQueueError
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xBDB0             POP      {R4,R5,R7,PC}
    896          
    897          /// Delete a Message Queue object.

   \                                 In section .text, align 4, keep-with-next
    898          osStatus_t osMessageQueueDelete (osMessageQueueId_t mq_id) {
   \                     osMessageQueueDelete: (+1)
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    899            EvrRtxMessageQueueDelete(mq_id);
   \   00000004   0x.... 0x....      BL       EvrRtxMessageQueueDelete
    900            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000008   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE      ??osMessageQueueDelete_0
   \   00000010   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD000             BEQ      ??osMessageQueueDelete_1
    901              EvrRtxMessageQueueError(mq_id, osErrorISR);
   \                     ??osMessageQueueDelete_0: (+1)
   \   00000018   0x....             B.N      ?Subroutine0
    902              return osErrorISR;
    903            }
    904            return __svcMessageQueueDelete(mq_id);
   \                     ??osMessageQueueDelete_1: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable13_11
   \   0000001C   0x4607             mov r7,R0
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBDB0             POP      {R4,R5,R7,PC}    ;; return
    905          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     osRtxInfo+0x70

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     osRtxMessageQueuePostProcess

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     osRtxInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     osRtxInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     osRtxInfo+0x7C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     svcRtxMessageQueueNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     svcRtxMessageQueueGetName

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     svcRtxMessageQueuePut

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x........         DC32     svcRtxMessageQueueGet

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x........         DC32     svcRtxMessageQueueGetCapacity

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x........         DC32     svcRtxMessageQueueGetMsgSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x........         DC32     svcRtxMessageQueueGetCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x........         DC32     svcRtxMessageQueueGetSpace

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x........         DC32     svcRtxMessageQueueReset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x........         DC32     svcRtxMessageQueueDelete

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   MessageQueueGet
      12   MessageQueuePut
       0   MessageQueueRemove
      16   osMessageQueueDelete
        16   -> EvrRtxMessageQueueDelete
        16   -> EvrRtxMessageQueueError
      24   osMessageQueueGet
        24   -> EvrRtxMessageQueueError
        24   -> EvrRtxMessageQueueGet
        24   -> EvrRtxMessageQueueNotRetrieved
        24   -> EvrRtxMessageQueueRetrieved
        24   -> MessageQueueGet
        24   -> __aeabi_memcpy
        24   -> osRtxPostProcess
       8   osMessageQueueGetCapacity
         8   -> svcRtxMessageQueueGetCapacity
       8   osMessageQueueGetCount
         8   -> svcRtxMessageQueueGetCount
       8   osMessageQueueGetMsgSize
         8   -> svcRtxMessageQueueGetMsgSize
       8   osMessageQueueGetName
         8   -> EvrRtxMessageQueueGetName
       8   osMessageQueueGetSpace
         8   -> svcRtxMessageQueueGetSpace
      24   osMessageQueueNew
        24   -> EvrRtxMessageQueueError
        24   -> EvrRtxMessageQueueNew
      24   osMessageQueuePut
        24   -> EvrRtxMessageQueueError
        24   -> EvrRtxMessageQueueInsertPending
        24   -> EvrRtxMessageQueueNotInserted
        24   -> EvrRtxMessageQueuePut
        24   -> __aeabi_memcpy
        24   -> osRtxMemoryPoolAlloc
        24   -> osRtxPostProcess
      16   osMessageQueueReset
        16   -> EvrRtxMessageQueueError
        16   -> EvrRtxMessageQueueReset
      24   osRtxMessageQueuePostProcess
        24   -> EvrRtxMessageQueueInserted
        24   -> EvrRtxMessageQueueRetrieved
        24   -> MessageQueuePut
        24   -> MessageQueueRemove
        24   -> __aeabi_memcpy
        24   -> osRtxMemoryPoolAlloc
        24   -> osRtxMemoryPoolFree
        24   -> osRtxThreadListGet
        24   -> osRtxThreadRegPtr
        24   -> osRtxThreadWaitExit
      16   svcRtxMessageQueueDelete
        16   -> EvrRtxMessageQueueDestroyed
        16   -> EvrRtxMessageQueueError
        16   -> osRtxMemoryFree
        16   -> osRtxMemoryPoolFree
        16   -> osRtxThreadDispatch
        16   -> osRtxThreadListGet
        16   -> osRtxThreadWaitExit
      24   svcRtxMessageQueueGet
        24   -> EvrRtxMessageQueueError
        24   -> EvrRtxMessageQueueGetPending
        24   -> EvrRtxMessageQueueInserted
        24   -> EvrRtxMessageQueueNotRetrieved
        24   -> EvrRtxMessageQueueRetrieved
        24   -> MessageQueueGet
        24   -> MessageQueuePut
        24   -> MessageQueueRemove
        24   -> __aeabi_memcpy
        24   -> osRtxMemoryPoolAlloc
        24   -> osRtxMemoryPoolFree
        24   -> osRtxThreadListGet
        24   -> osRtxThreadListPut
        24   -> osRtxThreadRegPtr
        24   -> osRtxThreadWaitEnter
        24   -> osRtxThreadWaitExit
       8   svcRtxMessageQueueGetCapacity
         8   -> EvrRtxMessageQueueGetCapacity
       8   svcRtxMessageQueueGetCount
         8   -> EvrRtxMessageQueueGetCount
       8   svcRtxMessageQueueGetMsgSize
         8   -> EvrRtxMessageQueueGetMsgSize
       8   svcRtxMessageQueueGetName
         8   -> EvrRtxMessageQueueGetName
       8   svcRtxMessageQueueGetSpace
         8   -> EvrRtxMessageQueueGetSpace
      48   svcRtxMessageQueueNew
        48   -> EvrRtxMessageQueueCreated
        48   -> EvrRtxMessageQueueError
        48   -> __aeabi_memclr
        48   -> osRtxMemoryAlloc
        48   -> osRtxMemoryFree
        48   -> osRtxMemoryPoolAlloc
        48   -> osRtxMemoryPoolFree
        48   -> osRtxMemoryPoolInit
      24   svcRtxMessageQueuePut
        24   -> EvrRtxMessageQueueError
        24   -> EvrRtxMessageQueueInserted
        24   -> EvrRtxMessageQueueNotInserted
        24   -> EvrRtxMessageQueuePutPending
        24   -> EvrRtxMessageQueueRetrieved
        24   -> MessageQueuePut
        24   -> __aeabi_memcpy
        24   -> osRtxMemoryPoolAlloc
        24   -> osRtxThreadListGet
        24   -> osRtxThreadListPut
        24   -> osRtxThreadRegPtr
        24   -> osRtxThreadWaitEnter
        24   -> osRtxThreadWaitExit
      16   svcRtxMessageQueueReset
        16   -> EvrRtxMessageQueueError
        16   -> EvrRtxMessageQueueInserted
        16   -> EvrRtxMessageQueueResetDone
        16   -> EvrRtxMessageQueueRetrieved
        16   -> MessageQueueGet
        16   -> MessageQueuePut
        16   -> __aeabi_memcpy
        16   -> osRtxMemoryPoolAlloc
        16   -> osRtxMemoryPoolFree
        16   -> osRtxThreadDispatch
        16   -> osRtxThreadListGet
        16   -> osRtxThreadRegPtr
        16   -> osRtxThreadWaitExit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
      16  ?Subroutine0
      60  MessageQueueGet
      78  MessageQueuePut
      30  MessageQueueRemove
      36  osMessageQueueDelete
     156  osMessageQueueGet
      32  osMessageQueueGetCapacity
      32  osMessageQueueGetCount
      32  osMessageQueueGetMsgSize
      36  osMessageQueueGetName
      32  osMessageQueueGetSpace
      78  osMessageQueueNew
     162  osMessageQueuePut
      36  osMessageQueueReset
     254  osRtxMessageQueuePostProcess
     130  svcRtxMessageQueueDelete
     262  svcRtxMessageQueueGet
      42  svcRtxMessageQueueGetCapacity
      42  svcRtxMessageQueueGetCount
      42  svcRtxMessageQueueGetMsgSize
      42  svcRtxMessageQueueGetName
      50  svcRtxMessageQueueGetSpace
     366  svcRtxMessageQueueNew
     234  svcRtxMessageQueuePut
     212  svcRtxMessageQueueReset

 
 2 552 bytes in section .text
 
 2 552 bytes of CODE memory

Errors: none
Warnings: 1

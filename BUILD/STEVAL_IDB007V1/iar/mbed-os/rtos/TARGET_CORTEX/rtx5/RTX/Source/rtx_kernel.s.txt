###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:53
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_kernel.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_kernel.d
#        -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_kernel.s.txt
#        -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_kernel.o
#        .\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_kernel.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_kernel.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_kernel.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_kernel.c
      1          /*
      2           * Copyright (c) 2013-2017 ARM Limited. All rights reserved.
      3           *
      4           * SPDX-License-Identifier: Apache-2.0
      5           *
      6           * Licensed under the Apache License, Version 2.0 (the License); you may
      7           * not use this file except in compliance with the License.
      8           * You may obtain a copy of the License at
      9           *
     10           * www.apache.org/licenses/LICENSE-2.0
     11           *
     12           * Unless required by applicable law or agreed to in writing, software
     13           * distributed under the License is distributed on an AS IS BASIS, WITHOUT
     14           * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15           * See the License for the specific language governing permissions and
     16           * limitations under the License.
     17           *
     18           * -----------------------------------------------------------------------------
     19           *
     20           * Project:     CMSIS-RTOS RTX
     21           * Title:       Kernel functions
     22           *
     23           * -----------------------------------------------------------------------------
     24           */
     25          
     26          #include "rtx_lib.h"

  typedef uint8_t BOOL;  //already defined in "hal_type.h"
                  ^
"C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\TARGET_STEVAL_IDB007V1\device\system_BlueNRG1.h",240  Warning[Pe301]: typedef name has already been declared (with same type)
     27          #include "rt_OsEventObserver.h"
     28          
     29          
     30          //  OS Runtime Information

   \                                 In section .data.os, align 4
     31          osRtxInfo_t osRtxInfo __attribute__((section(".data.os"))) =
   \                     osRtxInfo:
   \   00000000   0x........         DC32 ?_0, 50020002
   \              0x02FB3EA2   
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000038   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000048   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000058   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000068   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000078   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000088   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000098   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     32          { .os_id = osRtxKernelId, .version = osRtxVersionKernel, .kernel.state = osRtxKernelInactive };
     33          
     34          
     35          //  ==== Helper functions ====
     36          
     37          /// Block Kernel (disable: thread switching, time tick, post ISR processing).
     38          static void KernelBlock (void) {
     39          
     40            OS_Tick_Disable();
     41          
     42            osRtxInfo.kernel.blocked = 1U;
     43            __DSB();
     44          
     45            if (GetPendSV() != 0U) {
     46              ClrPendSV();
     47              osRtxInfo.kernel.pendSV = 1U;
     48            }
     49          }
     50          
     51          /// Unblock Kernel
     52          static void KernelUnblock (void) {
     53          
     54            osRtxInfo.kernel.blocked = 0U;
     55            __DSB();
     56          
     57            if (osRtxInfo.kernel.pendSV != 0U) {
     58              osRtxInfo.kernel.pendSV = 0U;
     59              SetPendSV();
     60            }
     61          
     62            OS_Tick_Enable();
     63          }
     64          
     65          
     66          //  ==== Service Calls ====
     67          
     68          //  Service Calls definitions
     69          SVC0_0M(KernelInitialize,       osStatus_t)
     70          SVC0_3 (KernelGetInfo,          osStatus_t, osVersion_t *, char *, uint32_t)
     71          SVC0_0M(KernelStart,            osStatus_t)
     72          SVC0_0 (KernelLock,             int32_t)
     73          SVC0_0 (KernelUnlock,           int32_t)
     74          SVC0_1 (KernelRestoreLock,      int32_t, int32_t)
     75          SVC0_0 (KernelSuspend,          uint32_t)
     76          SVC0_1N(KernelResume,           void, uint32_t)
     77          SVC0_0 (KernelGetState,         osKernelState_t)
     78          SVC0_0 (KernelGetTickCount,     uint32_t)
     79          SVC0_0 (KernelGetTickFreq,      uint32_t)
     80          SVC0_0 (KernelGetSysTimerCount, uint32_t)
     81          SVC0_0 (KernelGetSysTimerFreq,  uint32_t)
     82          
     83          /// Initialize the RTOS Kernel.
     84          /// \note API identical to osKernelInitialize

   \                                 In section .text, align 2, keep-with-next
     85          osStatus_t svcRtxKernelInitialize (void) {
   \                     svcRtxKernelInitialize: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
     86          
     87            if (osRtxInfo.kernel.state == osRtxKernelReady) {
   \   00000002   0x....             LDR      R5,??DataTable5
   \   00000004   0x002F             MOVS     R7,R5
   \   00000006   0x3708             ADDS     R7,R7,#+8
   \   00000008   0x7838             LDRB     R0,[R7, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD100             BNE      .+4
   \   0000000E   0xE0B0             B        ??svcRtxKernelInitialize_0
     88              EvrRtxKernelInitializeCompleted();
     89              return osOK;
     90            }
     91            if (osRtxInfo.kernel.state != osKernelInactive) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD114             BNE      ??svcRtxKernelInitialize_1
     92              EvrRtxKernelError(osError);
     93              return osError;
     94            }
     95          
     96            // Initialize osRtxInfo
     97            memset(&osRtxInfo.kernel, 0, sizeof(osRtxInfo) - offsetof(osRtxInfo_t, kernel));
   \   00000014   0x219C             MOVS     R1,#+156
   \   00000016   0x0038             MOVS     R0,R7
   \   00000018   0x.... 0x....      BL       __aeabi_memclr4
     98          
     99            if (osRtxConfig.thread_stack_size < (64U + 8U)) {
   \   0000001C   0x....             LDR      R4,??DataTable5_1
   \   0000001E   0x6D60             LDR      R0,[R4, #+84]
   \   00000020   0x2848             CMP      R0,#+72
   \   00000022   0xD206             BCS      ??svcRtxKernelInitialize_2
    100              EvrRtxKernelError(osRtxErrorInvalidThreadStack);
   \   00000024   0x200A             MOVS     R0,#+10
   \   00000026   0x43C0             MVNS     R0,R0            ;; #-11
   \   00000028   0x.... 0x....      BL       EvrRtxKernelError
    101              return osError;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000030   0xBDF2             POP      {R1,R4-R7,PC}
    102            }
    103          
    104            if ((osRtxConfig.isr_queue.data == NULL) || (osRtxConfig.isr_queue.max == 0U)) {
   \                     ??svcRtxKernelInitialize_2: (+1)
   \   00000032   0x68E0             LDR      R0,[R4, #+12]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD002             BEQ      ??svcRtxKernelInitialize_1
   \   00000038   0x8A21             LDRH     R1,[R4, #+16]
   \   0000003A   0x000A             MOVS     R2,R1
   \   0000003C   0xD101             BNE      ??svcRtxKernelInitialize_3
    105              EvrRtxKernelError(osError);
   \                     ??svcRtxKernelInitialize_1: (+1)
   \   0000003E   0x2400             MOVS     R4,#+0
   \   00000040   0x....             B.N      ?Subroutine0
    106              return osError;
    107            }
    108            osRtxInfo.isr_queue.data = osRtxConfig.isr_queue.data;
   \                     ??svcRtxKernelInitialize_3: (+1)
   \   00000042   0x002E             MOVS     R6,R5
   \   00000044   0x3654             ADDS     R6,R6,#+84
   \   00000046   0x60B0             STR      R0,[R6, #+8]
    109            osRtxInfo.isr_queue.max  = osRtxConfig.isr_queue.max;
   \   00000048   0x8031             STRH     R1,[R6, #+0]
    110          
    111            osRtxInfo.thread.robin.timeout = osRtxConfig.robin_timeout;
   \   0000004A   0x68A0             LDR      R0,[R4, #+8]
   \   0000004C   0x63B8             STR      R0,[R7, #+56]
    112          
    113            // Initialize Memory Pools (Variable Block Size)
    114            if (osRtxMemoryInit(osRtxConfig.mem.common_addr, osRtxConfig.mem.common_size) != 0U) {
   \   0000004E   0x6AE5             LDR      R5,[R4, #+44]
   \   00000050   0x6B21             LDR      R1,[R4, #+48]
   \   00000052   0x0028             MOVS     R0,R5
   \   00000054   0x.... 0x....      BL       osRtxMemoryInit
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD000             BEQ      ??svcRtxKernelInitialize_4
    115              osRtxInfo.mem.common = osRtxConfig.mem.common_addr;
   \   0000005C   0x62F5             STR      R5,[R6, #+44]
    116            }
    117            if (osRtxMemoryInit(osRtxConfig.mem.stack_addr, osRtxConfig.mem.stack_size) != 0U) {
   \                     ??svcRtxKernelInitialize_4: (+1)
   \   0000005E   0x6965             LDR      R5,[R4, #+20]
   \   00000060   0x69A1             LDR      R1,[R4, #+24]
   \   00000062   0x0028             MOVS     R0,R5
   \   00000064   0x.... 0x....      BL       osRtxMemoryInit
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD100             BNE      ??svcRtxKernelInitialize_5
    118              osRtxInfo.mem.stack = osRtxConfig.mem.stack_addr;
    119            } else {
    120              osRtxInfo.mem.stack = osRtxInfo.mem.common;
   \   0000006C   0x6AF5             LDR      R5,[R6, #+44]
   \                     ??svcRtxKernelInitialize_5: (+1)
   \   0000006E   0x6235             STR      R5,[R6, #+32]
    121            }
    122            if (osRtxMemoryInit(osRtxConfig.mem.mp_data_addr, osRtxConfig.mem.mp_data_size) != 0U) {
   \   00000070   0x69E5             LDR      R5,[R4, #+28]
   \   00000072   0x6A21             LDR      R1,[R4, #+32]
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0x.... 0x....      BL       osRtxMemoryInit
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD100             BNE      ??svcRtxKernelInitialize_6
    123              osRtxInfo.mem.mp_data = osRtxConfig.mem.mp_data_addr;
    124            } else {
    125              osRtxInfo.mem.mp_data = osRtxInfo.mem.common;
   \   0000007E   0x6AF5             LDR      R5,[R6, #+44]
   \                     ??svcRtxKernelInitialize_6: (+1)
   \   00000080   0x6275             STR      R5,[R6, #+36]
    126            }
    127            if (osRtxMemoryInit(osRtxConfig.mem.mq_data_addr, osRtxConfig.mem.mq_data_size) != 0U) {
   \   00000082   0x6A65             LDR      R5,[R4, #+36]
   \   00000084   0x6AA1             LDR      R1,[R4, #+40]
   \   00000086   0x0028             MOVS     R0,R5
   \   00000088   0x.... 0x....      BL       osRtxMemoryInit
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD100             BNE      ??svcRtxKernelInitialize_7
    128              osRtxInfo.mem.mq_data = osRtxConfig.mem.mq_data_addr;
    129            } else {
    130              osRtxInfo.mem.mq_data = osRtxInfo.mem.common;
   \   00000090   0x6AF5             LDR      R5,[R6, #+44]
   \                     ??svcRtxKernelInitialize_7: (+1)
   \   00000092   0x62B5             STR      R5,[R6, #+40]
    131            }
    132          
    133            // Initialize Memory Pools (Fixed Block Size)
    134            if ((osRtxConfig.mpi.stack != NULL) &&
    135                (osRtxMemoryPoolInit(osRtxConfig.mpi.stack,
    136                                     osRtxConfig.mpi.stack->max_blocks,
    137                                     osRtxConfig.mpi.stack->block_size,
    138                                     osRtxConfig.mpi.stack->block_base) != 0U)) {
   \   00000094   0x6B65             LDR      R5,[R4, #+52]
   \   00000096   0x2D00             CMP      R5,#+0
   \   00000098   0xD008             BEQ      ??svcRtxKernelInitialize_8
   \   0000009A   0x68EB             LDR      R3,[R5, #+12]
   \   0000009C   0x68AA             LDR      R2,[R5, #+8]
   \   0000009E   0x6829             LDR      R1,[R5, #+0]
   \   000000A0   0x0028             MOVS     R0,R5
   \   000000A2   0x.... 0x....      BL       osRtxMemoryPoolInit
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD000             BEQ      ??svcRtxKernelInitialize_8
    139              osRtxInfo.mpi.stack = osRtxConfig.mpi.stack;
   \   000000AA   0x6335             STR      R5,[R6, #+48]
    140            }
    141            if ((osRtxConfig.mpi.thread != NULL) &&
    142                (osRtxMemoryPoolInit(osRtxConfig.mpi.thread,
    143                                     osRtxConfig.mpi.thread->max_blocks,
    144                                     osRtxConfig.mpi.thread->block_size,
    145                                     osRtxConfig.mpi.thread->block_base) != 0U)) {
   \                     ??svcRtxKernelInitialize_8: (+1)
   \   000000AC   0x6BA5             LDR      R5,[R4, #+56]
   \   000000AE   0x2D00             CMP      R5,#+0
   \   000000B0   0xD008             BEQ      ??svcRtxKernelInitialize_9
   \   000000B2   0x68EB             LDR      R3,[R5, #+12]
   \   000000B4   0x68AA             LDR      R2,[R5, #+8]
   \   000000B6   0x6829             LDR      R1,[R5, #+0]
   \   000000B8   0x0028             MOVS     R0,R5
   \   000000BA   0x.... 0x....      BL       osRtxMemoryPoolInit
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD000             BEQ      ??svcRtxKernelInitialize_9
    146              osRtxInfo.mpi.thread = osRtxConfig.mpi.thread;
   \   000000C2   0x6375             STR      R5,[R6, #+52]
    147            }
    148            if ((osRtxConfig.mpi.timer != NULL) &&
    149                (osRtxMemoryPoolInit(osRtxConfig.mpi.timer,
    150                                     osRtxConfig.mpi.timer->max_blocks,
    151                                     osRtxConfig.mpi.timer->block_size,
    152                                     osRtxConfig.mpi.timer->block_base) != 0U)) {
   \                     ??svcRtxKernelInitialize_9: (+1)
   \   000000C4   0x6BE5             LDR      R5,[R4, #+60]
   \   000000C6   0x2D00             CMP      R5,#+0
   \   000000C8   0xD008             BEQ      ??svcRtxKernelInitialize_10
   \   000000CA   0x68EB             LDR      R3,[R5, #+12]
   \   000000CC   0x68AA             LDR      R2,[R5, #+8]
   \   000000CE   0x6829             LDR      R1,[R5, #+0]
   \   000000D0   0x0028             MOVS     R0,R5
   \   000000D2   0x.... 0x....      BL       osRtxMemoryPoolInit
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD000             BEQ      ??svcRtxKernelInitialize_10
    153              osRtxInfo.mpi.timer = osRtxConfig.mpi.timer;
   \   000000DA   0x63B5             STR      R5,[R6, #+56]
    154            }
    155            if ((osRtxConfig.mpi.event_flags != NULL) &&
    156                (osRtxMemoryPoolInit(osRtxConfig.mpi.event_flags,
    157                                     osRtxConfig.mpi.event_flags->max_blocks,
    158                                     osRtxConfig.mpi.event_flags->block_size,
    159                                     osRtxConfig.mpi.event_flags->block_base) != 0U)) {
   \                     ??svcRtxKernelInitialize_10: (+1)
   \   000000DC   0x6C25             LDR      R5,[R4, #+64]
   \   000000DE   0x2D00             CMP      R5,#+0
   \   000000E0   0xD008             BEQ      ??svcRtxKernelInitialize_11
   \   000000E2   0x68EB             LDR      R3,[R5, #+12]
   \   000000E4   0x68AA             LDR      R2,[R5, #+8]
   \   000000E6   0x6829             LDR      R1,[R5, #+0]
   \   000000E8   0x0028             MOVS     R0,R5
   \   000000EA   0x.... 0x....      BL       osRtxMemoryPoolInit
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD000             BEQ      ??svcRtxKernelInitialize_11
    160              osRtxInfo.mpi.event_flags = osRtxConfig.mpi.event_flags;
   \   000000F2   0x63F5             STR      R5,[R6, #+60]
    161            }
    162            if ((osRtxConfig.mpi.mutex != NULL) &&
    163                (osRtxMemoryPoolInit(osRtxConfig.mpi.mutex,
    164                                     osRtxConfig.mpi.mutex->max_blocks,
    165                                     osRtxConfig.mpi.mutex->block_size,
    166                                     osRtxConfig.mpi.mutex->block_base) != 0U)) {
   \                     ??svcRtxKernelInitialize_11: (+1)
   \   000000F4   0x6C65             LDR      R5,[R4, #+68]
   \   000000F6   0x2D00             CMP      R5,#+0
   \   000000F8   0xD008             BEQ      ??svcRtxKernelInitialize_12
   \   000000FA   0x68EB             LDR      R3,[R5, #+12]
   \   000000FC   0x68AA             LDR      R2,[R5, #+8]
   \   000000FE   0x6829             LDR      R1,[R5, #+0]
   \   00000100   0x0028             MOVS     R0,R5
   \   00000102   0x.... 0x....      BL       osRtxMemoryPoolInit
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD000             BEQ      ??svcRtxKernelInitialize_12
    167              osRtxInfo.mpi.mutex = osRtxConfig.mpi.mutex;
   \   0000010A   0x6435             STR      R5,[R6, #+64]
    168            }
    169            if ((osRtxConfig.mpi.semaphore != NULL) &&
    170                (osRtxMemoryPoolInit(osRtxConfig.mpi.semaphore,
    171                                     osRtxConfig.mpi.semaphore->max_blocks,
    172                                     osRtxConfig.mpi.semaphore->block_size,
    173                                     osRtxConfig.mpi.semaphore->block_base) != 0U)) {
   \                     ??svcRtxKernelInitialize_12: (+1)
   \   0000010C   0x6CA5             LDR      R5,[R4, #+72]
   \   0000010E   0x2D00             CMP      R5,#+0
   \   00000110   0xD008             BEQ      ??svcRtxKernelInitialize_13
   \   00000112   0x68EB             LDR      R3,[R5, #+12]
   \   00000114   0x68AA             LDR      R2,[R5, #+8]
   \   00000116   0x6829             LDR      R1,[R5, #+0]
   \   00000118   0x0028             MOVS     R0,R5
   \   0000011A   0x.... 0x....      BL       osRtxMemoryPoolInit
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD000             BEQ      ??svcRtxKernelInitialize_13
    174              osRtxInfo.mpi.semaphore = osRtxConfig.mpi.semaphore;
   \   00000122   0x6475             STR      R5,[R6, #+68]
    175            }
    176            if ((osRtxConfig.mpi.memory_pool != NULL) &&
    177                (osRtxMemoryPoolInit(osRtxConfig.mpi.memory_pool,
    178                                     osRtxConfig.mpi.memory_pool->max_blocks,
    179                                     osRtxConfig.mpi.memory_pool->block_size,
    180                                     osRtxConfig.mpi.memory_pool->block_base) != 0U)) {
   \                     ??svcRtxKernelInitialize_13: (+1)
   \   00000124   0x6CE5             LDR      R5,[R4, #+76]
   \   00000126   0x2D00             CMP      R5,#+0
   \   00000128   0xD008             BEQ      ??svcRtxKernelInitialize_14
   \   0000012A   0x68EB             LDR      R3,[R5, #+12]
   \   0000012C   0x68AA             LDR      R2,[R5, #+8]
   \   0000012E   0x6829             LDR      R1,[R5, #+0]
   \   00000130   0x0028             MOVS     R0,R5
   \   00000132   0x.... 0x....      BL       osRtxMemoryPoolInit
   \   00000136   0x2800             CMP      R0,#+0
   \   00000138   0xD000             BEQ      ??svcRtxKernelInitialize_14
    181              osRtxInfo.mpi.memory_pool = osRtxConfig.mpi.memory_pool;
   \   0000013A   0x64B5             STR      R5,[R6, #+72]
    182            }
    183            if ((osRtxConfig.mpi.message_queue != NULL) &&
    184                (osRtxMemoryPoolInit(osRtxConfig.mpi.message_queue,
    185                                     osRtxConfig.mpi.message_queue->max_blocks,
    186                                     osRtxConfig.mpi.message_queue->block_size,
    187                                     osRtxConfig.mpi.message_queue->block_base) != 0U)) {
   \                     ??svcRtxKernelInitialize_14: (+1)
   \   0000013C   0x6D24             LDR      R4,[R4, #+80]
   \   0000013E   0x2C00             CMP      R4,#+0
   \   00000140   0xD008             BEQ      ??svcRtxKernelInitialize_15
   \   00000142   0x68E3             LDR      R3,[R4, #+12]
   \   00000144   0x68A2             LDR      R2,[R4, #+8]
   \   00000146   0x6821             LDR      R1,[R4, #+0]
   \   00000148   0x0020             MOVS     R0,R4
   \   0000014A   0x.... 0x....      BL       osRtxMemoryPoolInit
   \   0000014E   0x2800             CMP      R0,#+0
   \   00000150   0xD000             BEQ      ??svcRtxKernelInitialize_15
    188              osRtxInfo.mpi.message_queue = osRtxConfig.mpi.message_queue;
   \   00000152   0x64F4             STR      R4,[R6, #+76]
    189            }
    190          
    191          #if (__DOMAIN_NS == 1U)
    192            // Initialize Secure Process Stack
    193            if (TZ_InitContextSystem_S() == 0U) {
    194              EvrRtxKernelError(osRtxErrorTZ_InitContext_S);
    195              return osError;
    196            }
    197          #endif
    198          
    199            // Initialize SVC and PendSV System Service Calls
    200            SVC_Initialize();
   \                     ??svcRtxKernelInitialize_15: (+1)
   \   00000154   0x....             LDR      R0,??DataTable10  ;; 0xe000ed1c
   \   00000156   0x6841             LDR      R1,[R0, #+4]
   \   00000158   0x22FF             MOVS     R2,#+255
   \   0000015A   0x0412             LSLS     R2,R2,#+16       ;; #+16711680
   \   0000015C   0x430A             ORRS     R2,R2,R1
   \   0000015E   0x6042             STR      R2,[R0, #+4]
   \   00000160   0x6841             LDR      R1,[R0, #+4]
   \   00000162   0x6802             LDR      R2,[R0, #+0]
   \   00000164   0x0249             LSLS     R1,R1,#+9
   \   00000166   0x0E89             LSRS     R1,R1,#+26
   \   00000168   0x0689             LSLS     R1,R1,#+26
   \   0000016A   0x4311             ORRS     R1,R1,R2
   \   0000016C   0x6001             STR      R1,[R0, #+0]
    201          
    202            osRtxInfo.kernel.state = osRtxKernelReady;
   \   0000016E   0x2001             MOVS     R0,#+1
   \   00000170   0x7038             STRB     R0,[R7, #+0]
    203          
    204            EvrRtxKernelInitializeCompleted();
   \                     ??svcRtxKernelInitialize_0: (+1)
   \   00000172   0x.... 0x....      BL       EvrRtxKernelInitializeCompleted
    205          
    206            return osOK;
   \   00000176   0x2000             MOVS     R0,#+0
   \   00000178   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    207          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x43E4             MVNS     R4,R4            ;; #-1
   \   00000002   0x0020             MOVS     R0,R4
   \   00000004   0x.... 0x....      BL       EvrRtxKernelError
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xBDF2             POP      {R1,R4-R7,PC}
    208          
    209          ///  Get RTOS Kernel Information.
    210          /// \note API identical to osKernelGetInfo

   \                                 In section .text, align 4, keep-with-next
    211          osStatus_t svcRtxKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size) {
   \                     svcRtxKernelGetInfo: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    212          
    213            if (version != NULL) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD003             BEQ      ??svcRtxKernelGetInfo_0
    214              version->api    = osRtxVersionAPI;
   \   0000000A   0x....             LDR      R0,??DataTable10_1  ;; 0x1315411
   \   0000000C   0x6020             STR      R0,[R4, #+0]
    215              version->kernel = osRtxVersionKernel;
   \   0000000E   0x....             LDR      R0,??DataTable11  ;; 0x2fb3ea2
   \   00000010   0x6060             STR      R0,[R4, #+4]
    216            }
    217          
    218            if ((id_buf != NULL) && (id_size != 0U)) {
   \                     ??svcRtxKernelGetInfo_0: (+1)
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD008             BEQ      ??svcRtxKernelGetInfo_1
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD006             BEQ      ??svcRtxKernelGetInfo_1
    219              if (id_size > sizeof(osRtxKernelId)) {
   \   0000001A   0x2A0C             CMP      R2,#+12
   \   0000001C   0xD300             BCC      ??svcRtxKernelGetInfo_2
    220                id_size = sizeof(osRtxKernelId);
   \   0000001E   0x220B             MOVS     R2,#+11
    221              }
    222              memcpy(id_buf, osRtxKernelId, id_size);
   \                     ??svcRtxKernelGetInfo_2: (+1)
   \   00000020   0x....             ADR.N    R1,?_0
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0x.... 0x....      BL       __aeabi_memcpy
    223            }
    224          
    225            EvrRtxKernelInfoRetrieved(version, id_buf);
   \                     ??svcRtxKernelGetInfo_1: (+1)
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       EvrRtxKernelInfoRetrieved
    226          
    227            return osOK;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    228          }
    229          
    230          /// Get the current RTOS Kernel state.
    231          /// \note API identical to osKernelGetState

   \                                 In section .text, align 2, keep-with-next
    232          osKernelState_t svcRtxKernelGetState (void) {
   \                     svcRtxKernelGetState: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    233            EvrRtxKernelGetState((osKernelState_t)(osRtxInfo.kernel.state));
   \   00000002   0x....             LDR      R4,??DataTable5
   \   00000004   0x7A20             LDRB     R0,[R4, #+8]
   \   00000006   0x.... 0x....      BL       EvrRtxKernelGetState
    234            return ((osKernelState_t)(osRtxInfo.kernel.state));
   \   0000000A   0x7A20             LDRB     R0,[R4, #+8]
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    235          }
    236          
    237          /// Start the RTOS Kernel scheduler.
    238          /// \note API identical to osKernelStart

   \                                 In section .text, align 2, keep-with-next
    239          osStatus_t svcRtxKernelStart (void) {
   \                     svcRtxKernelStart: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    240            os_thread_t *thread;
    241          
    242            if (osRtxInfo.kernel.state != osRtxKernelReady) {
   \   00000002   0x....             LDR      R4,??DataTable5
   \   00000004   0x7A20             LDRB     R0,[R4, #+8]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD004             BEQ      ??svcRtxKernelStart_0
    243              EvrRtxKernelError(osRtxErrorKernelNotReady);
   \   0000000A   0x2006             MOVS     R0,#+6
   \   0000000C   0x43C0             MVNS     R0,R0            ;; #-7
   \   0000000E   0x.... 0x....      BL       EvrRtxKernelError
    244              return osError;
   \   00000012   0xE028             B.N      ??svcRtxKernelStart_1
    245            }
    246          
    247            // Create Idle Thread
    248            if (osRtxInfo.thread.idle == NULL) {
   \                     ??svcRtxKernelStart_0: (+1)
   \   00000014   0x....             LDR      R5,??DataTable5_1
   \   00000016   0x6AA0             LDR      R0,[R4, #+40]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD108             BNE      ??svcRtxKernelStart_2
    249              osRtxInfo.thread.idle = svcRtxThreadNew(osRtxIdleThread, NULL, osRtxConfig.idle_thread_attr, NULL);
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x6DAA             LDR      R2,[R5, #+88]
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x....             LDR      R0,??DataTable12
   \   00000024   0x.... 0x....      BL       svcRtxThreadNew
   \   00000028   0x62A0             STR      R0,[R4, #+40]
    250              if (osRtxInfo.thread.idle == NULL) {
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD024             BEQ      ??svcRtxKernelStart_3
    251                EvrRtxKernelError(osError);
    252                return osError;
    253              }
    254            }
    255          
    256            // Create Timer Thread
    257            if (osRtxConfig.timer_mq_mcnt != 0U) {
   \                     ??svcRtxKernelStart_2: (+1)
   \   0000002E   0x6E68             LDR      R0,[R5, #+100]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD00B             BEQ      ??svcRtxKernelStart_4
    258              if (osRtxInfo.timer.thread == NULL) {
   \   00000034   0x6CA0             LDR      R0,[R4, #+72]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD108             BNE      ??svcRtxKernelStart_4
    259                osRtxInfo.timer.thread = svcRtxThreadNew(osRtxTimerThread, NULL, osRtxConfig.timer_thread_attr, NULL);
   \   0000003A   0x2300             MOVS     R3,#+0
   \   0000003C   0x6DEA             LDR      R2,[R5, #+92]
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x....             LDR      R0,??DataTable13
   \   00000042   0x.... 0x....      BL       svcRtxThreadNew
   \   00000046   0x64A0             STR      R0,[R4, #+72]
    260                if (osRtxInfo.timer.thread == NULL) {
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD015             BEQ      ??svcRtxKernelStart_3
    261                  EvrRtxKernelError(osError);
    262                  return osError;
    263                }
    264              }
    265            }
    266          
    267            // Setup RTOS Tick
    268            if (OS_Tick_Setup(osRtxConfig.tick_freq, OS_TICK_HANDLER) != 0U) {
   \                     ??svcRtxKernelStart_4: (+1)
   \   0000004C   0x....             LDR      R1,??DataTable13_1
   \   0000004E   0x6868             LDR      R0,[R5, #+4]
   \   00000050   0x.... 0x....      BL       OS_Tick_Setup
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD106             BNE      ??svcRtxKernelStart_1
    269              return osError;
    270            }
    271            osRtxInfo.tick_irqn = OS_Tick_GetIRQn();
   \   00000058   0x.... 0x....      BL       OS_Tick_GetIRQn
   \   0000005C   0x6120             STR      R0,[R4, #+16]
    272          
    273            // Enable RTOS Tick
    274            if (OS_Tick_Enable() != 0U) {
   \   0000005E   0x.... 0x....      BL       OS_Tick_Enable
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD002             BEQ      ??svcRtxKernelStart_5
    275              return osError;
   \                     ??svcRtxKernelStart_1: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}
    276            }
    277          
    278            // Switch to Ready Thread with highest Priority
    279            thread = osRtxThreadListGet(&osRtxInfo.thread.ready);
   \                     ??svcRtxKernelStart_5: (+1)
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x301C             ADDS     R0,R0,#+28
   \   00000070   0x.... 0x....      BL       osRtxThreadListGet
    280            if (thread == NULL) {
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD106             BNE      ??svcRtxKernelStart_6
    281              EvrRtxKernelError(osError);
   \                     ??svcRtxKernelStart_3: (+1)
   \   00000078   0x2400             MOVS     R4,#+0
   \   0000007A   0x43E4             MVNS     R4,R4            ;; #-1
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       EvrRtxKernelError
    282              return osError;
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0xBD32             POP      {R1,R4,R5,PC}
    283            }
    284            osRtxThreadSwitch(thread);
   \                     ??svcRtxKernelStart_6: (+1)
   \   00000086   0x.... 0x....      BL       osRtxThreadSwitch
    285          
    286            if ((osRtxConfig.flags & osRtxConfigPrivilegedMode) != 0U) {
   \   0000008A   0x7828             LDRB     R0,[R5, #+0]
   \   0000008C   0x07C0             LSLS     R0,R0,#+31
   \   0000008E   0xD501             BPL      ??svcRtxKernelStart_7
    287              // Privileged Thread mode & PSP
    288              __set_CONTROL(0x02U);
   \   00000090   0x2002             MOVS     R0,#+2
   \   00000092   0xE000             B        ??svcRtxKernelStart_8
    289            } else {
    290              // Unprivileged Thread mode & PSP
    291              __set_CONTROL(0x03U);
   \                     ??svcRtxKernelStart_7: (+1)
   \   00000094   0x2003             MOVS     R0,#+3
   \                     ??svcRtxKernelStart_8: (+1)
   \   00000096   0xF380 0x8814      MSR      CONTROL,R0
    292            }
    293          
    294            osRtxInfo.kernel.state = osRtxKernelRunning;
   \   0000009A   0x2002             MOVS     R0,#+2
   \   0000009C   0x7220             STRB     R0,[R4, #+8]
    295          
    296            EvrRtxKernelStarted();
   \   0000009E   0x.... 0x....      BL       EvrRtxKernelStarted
    297          
    298            return osOK;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    299          }
    300          
    301          /// Lock the RTOS Kernel scheduler.
    302          /// \note API identical to osKernelLock

   \                                 In section .text, align 2, keep-with-next
    303          int32_t svcRtxKernelLock (void) {
   \                     svcRtxKernelLock: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    304          
    305            if (osRtxInfo.kernel.state == osRtxKernelLocked) {
   \   00000002   0x....             LDR      R0,??DataTable5
   \   00000004   0x7A01             LDRB     R1,[R0, #+8]
   \   00000006   0x2903             CMP      R1,#+3
   \   00000008   0xD104             BNE      ??svcRtxKernelLock_0
    306              EvrRtxKernelLocked(1);
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       EvrRtxKernelLocked
    307              return 1;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xBD10             POP      {R4,PC}
    308            }
    309            if (osRtxInfo.kernel.state == osRtxKernelRunning) {
   \                     ??svcRtxKernelLock_0: (+1)
   \   00000014   0x2902             CMP      R1,#+2
   \   00000016   0xD106             BNE      ??svcRtxKernelLock_1
    310              osRtxInfo.kernel.state = osRtxKernelLocked;
   \   00000018   0x2103             MOVS     R1,#+3
   \   0000001A   0x7201             STRB     R1,[R0, #+8]
    311              EvrRtxKernelLocked(0);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       EvrRtxKernelLocked
    312              return 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD10             POP      {R4,PC}
    313            }
    314          
    315            EvrRtxKernelError(osError);
   \                     ??svcRtxKernelLock_1: (+1)
   \   00000026   0x....             B.N      ?Subroutine1
    316            return osError;
    317          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2400             MOVS     R4,#+0
   \   00000002   0x43E4             MVNS     R4,R4            ;; #-1
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       EvrRtxKernelError
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    318           
    319          /// Unlock the RTOS Kernel scheduler.
    320          /// \note API identical to osKernelUnlock

   \                                 In section .text, align 2, keep-with-next
    321          int32_t svcRtxKernelUnlock (void) {
   \                     svcRtxKernelUnlock: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    322          
    323            if (osRtxInfo.kernel.state == osRtxKernelLocked) {
   \   00000002   0x....             LDR      R0,??DataTable15
   \   00000004   0x7A01             LDRB     R1,[R0, #+8]
   \   00000006   0x2903             CMP      R1,#+3
   \   00000008   0xD106             BNE      ??svcRtxKernelUnlock_0
    324              osRtxInfo.kernel.state = osRtxKernelRunning;
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x7201             STRB     R1,[R0, #+8]
    325              EvrRtxKernelUnlocked(1);
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       EvrRtxKernelUnlocked
    326              return 1;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xBD10             POP      {R4,PC}
    327            }
    328            if (osRtxInfo.kernel.state == osRtxKernelRunning) {
   \                     ??svcRtxKernelUnlock_0: (+1)
   \   00000018   0x2902             CMP      R1,#+2
   \   0000001A   0xD104             BNE      ??svcRtxKernelUnlock_1
    329              EvrRtxKernelUnlocked(0);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       EvrRtxKernelUnlocked
    330              return 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD10             POP      {R4,PC}
    331            }
    332          
    333            EvrRtxKernelError(osError);
   \                     ??svcRtxKernelUnlock_1: (+1)
   \   00000026                      REQUIRE ?Subroutine1
   \   00000026                      ;; // Fall through to label ?Subroutine1
    334            return osError;
    335          }
    336          
    337          /// Restore the RTOS Kernel scheduler lock state.
    338          /// \note API identical to osKernelRestoreLock

   \                                 In section .text, align 2, keep-with-next
    339          int32_t svcRtxKernelRestoreLock (int32_t lock) {
   \                     svcRtxKernelRestoreLock: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    340          
    341            if ((osRtxInfo.kernel.state == osRtxKernelRunning) || 
    342                (osRtxInfo.kernel.state == osRtxKernelLocked)) {
   \   00000002   0x....             LDR      R1,??DataTable15
   \   00000004   0x7A0A             LDRB     R2,[R1, #+8]
   \   00000006   0x2A02             CMP      R2,#+2
   \   00000008   0xD001             BEQ      ??svcRtxKernelRestoreLock_0
   \   0000000A   0x2A03             CMP      R2,#+3
   \   0000000C   0xD111             BNE      ??svcRtxKernelRestoreLock_1
    343              switch (lock) {
   \                     ??svcRtxKernelRestoreLock_0: (+1)
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD008             BEQ      ??svcRtxKernelRestoreLock_2
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD10D             BNE      ??svcRtxKernelRestoreLock_1
    344                case 1:
    345                  osRtxInfo.kernel.state = osRtxKernelLocked;
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0x7208             STRB     R0,[R1, #+8]
    346                  EvrRtxKernelLockRestored(1);
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x.... 0x....      BL       EvrRtxKernelLockRestored
    347                  return 1;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xBD10             POP      {R4,PC}
    348                case 0:
    349                  osRtxInfo.kernel.state = osRtxKernelRunning;
   \                     ??svcRtxKernelRestoreLock_2: (+1)
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x7208             STRB     R0,[R1, #+8]
    350                  EvrRtxKernelLockRestored(0);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      BL       EvrRtxKernelLockRestored
    351                  return 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD10             POP      {R4,PC}
    352                default:
    353                  break;
    354              }
    355            }
    356          
    357            EvrRtxKernelError(osError);
   \                     ??svcRtxKernelRestoreLock_1: (+1)
   \   00000032   0x....             B.N      ?Subroutine1
    358            return osError;
    359          }
    360          
    361          /// Suspend the RTOS Kernel scheduler.
    362          /// \note API identical to osKernelSuspend

   \                                 In section .text, align 2, keep-with-next
    363          uint32_t svcRtxKernelSuspend (void) {
   \                     svcRtxKernelSuspend: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    364            os_thread_t *thread;
    365            os_timer_t  *timer;
    366            uint32_t     delay;
    367          
    368            if (osRtxInfo.kernel.state != osRtxKernelRunning) {
   \   00000002   0x....             LDR      R4,??DataTable15
   \   00000004   0x7A20             LDRB     R0,[R4, #+8]
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD005             BEQ      ??svcRtxKernelSuspend_0
    369              EvrRtxKernelError(osRtxErrorKernelNotRunning);
   \   0000000A   0x2007             MOVS     R0,#+7
   \   0000000C   0x43C0             MVNS     R0,R0            ;; #-8
   \   0000000E   0x.... 0x....      BL       EvrRtxKernelError
    370              return 0U;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD32             POP      {R1,R4,R5,PC}
    371            }
    372          
    373            KernelBlock();
   \                     ??svcRtxKernelSuspend_0: (+1)
   \   00000016   0x.... 0x....      BL       OS_Tick_Disable
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x7260             STRB     R0,[R4, #+9]
   \   0000001E   0xF3BF 0x8F4F      DSB      
   \   00000022   0x....             LDR      R1,??DataTable18  ;; 0xe000ed04
   \   00000024   0x680A             LDR      R2,[R1, #+0]
   \   00000026   0x0E12             LSRS     R2,R2,#+24
   \   00000028   0x06D2             LSLS     R2,R2,#+27
   \   0000002A   0xD502             BPL      ??svcRtxKernelSuspend_1
   \   0000002C   0x06C2             LSLS     R2,R0,#+27
   \   0000002E   0x600A             STR      R2,[R1, #+0]
   \   00000030   0x72A0             STRB     R0,[R4, #+10]
    374          
    375            delay = osWaitForever;
   \                     ??svcRtxKernelSuspend_1: (+1)
   \   00000032   0x2500             MOVS     R5,#+0
   \   00000034   0x43ED             MVNS     R5,R5            ;; #-1
    376          
    377            // Check Thread Delay list
    378            thread = osRtxInfo.thread.delay_list;
   \   00000036   0x6AE0             LDR      R0,[R4, #+44]
    379            if (thread != NULL) {
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD000             BEQ      ??svcRtxKernelSuspend_2
    380              delay = thread->delay;
   \   0000003C   0x69C5             LDR      R5,[R0, #+28]
    381            }
    382          
    383            // Check Active Timer list
    384            timer = osRtxInfo.timer.list;
   \                     ??svcRtxKernelSuspend_2: (+1)
   \   0000003E   0x6C60             LDR      R0,[R4, #+68]
    385            if (timer != NULL) {
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD003             BEQ      ??svcRtxKernelSuspend_3
    386              if (timer->tick < delay) {
   \   00000044   0x6901             LDR      R1,[R0, #+16]
   \   00000046   0x42A9             CMP      R1,R5
   \   00000048   0xD800             BHI      ??svcRtxKernelSuspend_3
   \   0000004A   0x000D             MOVS     R5,R1
    387                delay = timer->tick;
    388              }
    389            }
    390          
    391            osRtxInfo.kernel.state = osRtxKernelSuspended;
   \                     ??svcRtxKernelSuspend_3: (+1)
   \   0000004C   0x2004             MOVS     R0,#+4
   \   0000004E   0x7220             STRB     R0,[R4, #+8]
    392          
    393            EvrRtxKernelSuspended(delay);
   \   00000050   0x0028             MOVS     R0,R5
   \   00000052   0x.... 0x....      BL       EvrRtxKernelSuspended
    394          
    395            return delay;
   \   00000056   0x0028             MOVS     R0,R5
   \   00000058   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    396          }
    397          
    398          /// Resume the RTOS Kernel scheduler.
    399          /// \note API identical to osKernelResume

   \                                 In section .text, align 2, keep-with-next
    400          void svcRtxKernelResume (uint32_t sleep_ticks) {
   \                     svcRtxKernelResume: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    401            os_thread_t *thread;
    402            os_timer_t  *timer;
    403            uint32_t     delay;
    404          
    405            if (osRtxInfo.kernel.state != osRtxKernelSuspended) {
   \   00000004   0x....             LDR      R5,??DataTable15
   \   00000006   0x7A28             LDRB     R0,[R5, #+8]
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD143             BNE      ??svcRtxKernelResume_0
    406              EvrRtxKernelResumed();
    407              return;
    408            }
    409          
    410            // Process Thread Delay list
    411            thread = osRtxInfo.thread.delay_list;
   \   0000000C   0x6AE8             LDR      R0,[R5, #+44]
    412            if (thread != NULL) {
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD016             BEQ      ??svcRtxKernelResume_1
    413              delay = sleep_ticks;
    414              if (delay >= thread->delay) {
   \   00000012   0x69C1             LDR      R1,[R0, #+28]
   \   00000014   0x428C             CMP      R4,R1
   \   00000016   0xD311             BCC      ??svcRtxKernelResume_2
    415                  delay -= thread->delay;
   \   00000018   0x1A66             SUBS     R6,R4,R1
    416                osRtxInfo.kernel.tick += thread->delay;
   \   0000001A   0x68EA             LDR      R2,[R5, #+12]
   \   0000001C   0x1851             ADDS     R1,R2,R1
   \   0000001E   0x60E9             STR      R1,[R5, #+12]
    417                thread->delay = 1U;
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x61C1             STR      R1,[R0, #+28]
    418                do {
    419                  osRtxThreadDelayTick();
   \                     ??svcRtxKernelResume_3: (+1)
   \   00000024   0x.... 0x....      BL       osRtxThreadDelayTick
    420                  if (delay == 0U) { 
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD00C             BEQ      ??svcRtxKernelResume_4
    421                    break;
    422                  }
    423                  delay--;
   \   0000002C   0x1E76             SUBS     R6,R6,#+1
    424                  osRtxInfo.kernel.tick++;
   \   0000002E   0x68E8             LDR      R0,[R5, #+12]
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0x60E8             STR      R0,[R5, #+12]
    425                } while (osRtxInfo.thread.delay_list != NULL);
   \   00000034   0x6AE8             LDR      R0,[R5, #+44]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD1F4             BNE      ??svcRtxKernelResume_3
   \   0000003A   0xE004             B        ??svcRtxKernelResume_4
    426              } else {
    427                thread->delay -= delay;
   \                     ??svcRtxKernelResume_2: (+1)
   \   0000003C   0x1B09             SUBS     R1,R1,R4
   \   0000003E   0x61C1             STR      R1,[R0, #+28]
    428                osRtxInfo.kernel.tick += delay;
    429              }
    430            } else {
    431              osRtxInfo.kernel.tick += sleep_ticks;
   \                     ??svcRtxKernelResume_1: (+1)
   \   00000040   0x68E8             LDR      R0,[R5, #+12]
   \   00000042   0x1900             ADDS     R0,R0,R4
   \   00000044   0x60E8             STR      R0,[R5, #+12]
    432            }
    433          
    434            // Process Active Timer list
    435            timer = osRtxInfo.timer.list;
   \                     ??svcRtxKernelResume_4: (+1)
   \   00000046   0x6C68             LDR      R0,[R5, #+68]
    436            if (timer != NULL) {
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD010             BEQ      ??svcRtxKernelResume_5
    437              if (sleep_ticks >= timer->tick) {
   \   0000004C   0x6901             LDR      R1,[R0, #+16]
   \   0000004E   0x428C             CMP      R4,R1
   \   00000050   0xD30B             BCC      ??svcRtxKernelResume_6
    438                  sleep_ticks -= timer->tick;
   \   00000052   0x1A64             SUBS     R4,R4,R1
    439                timer->tick = 1U;
   \   00000054   0x2101             MOVS     R1,#+1
   \   00000056   0x6101             STR      R1,[R0, #+16]
    440                do {
    441                  osRtxInfo.timer.tick();
   \                     ??svcRtxKernelResume_7: (+1)
   \   00000058   0x6D28             LDR      R0,[R5, #+80]
   \   0000005A   0x4780             BLX      R0
    442                  if (sleep_ticks == 0U) {
   \   0000005C   0x2C00             CMP      R4,#+0
   \   0000005E   0xD006             BEQ      ??svcRtxKernelResume_5
    443                    break;
    444                  }
    445                  sleep_ticks--;
   \   00000060   0x1E64             SUBS     R4,R4,#+1
    446                } while (osRtxInfo.timer.list != NULL);
   \   00000062   0x6C68             LDR      R0,[R5, #+68]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD1F7             BNE      ??svcRtxKernelResume_7
   \   00000068   0xE001             B        ??svcRtxKernelResume_5
    447              } else {
    448                timer->tick -= sleep_ticks;
   \                     ??svcRtxKernelResume_6: (+1)
   \   0000006A   0x1B09             SUBS     R1,R1,R4
   \   0000006C   0x6101             STR      R1,[R0, #+16]
    449              }
    450            }
    451          
    452            osRtxInfo.kernel.state = osRtxKernelRunning;
   \                     ??svcRtxKernelResume_5: (+1)
   \   0000006E   0x2002             MOVS     R0,#+2
   \   00000070   0x7228             STRB     R0,[R5, #+8]
    453          
    454            osRtxThreadDispatch(NULL);
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x.... 0x....      BL       osRtxThreadDispatch
    455          
    456            KernelUnblock();
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x7268             STRB     R0,[R5, #+9]
   \   0000007C   0xF3BF 0x8F4F      DSB      
   \   00000080   0x7AA9             LDRB     R1,[R5, #+10]
   \   00000082   0x2900             CMP      R1,#+0
   \   00000084   0xD004             BEQ      ??svcRtxKernelResume_8
   \   00000086   0x72A8             STRB     R0,[R5, #+10]
   \   00000088   0x2080             MOVS     R0,#+128
   \   0000008A   0x0540             LSLS     R0,R0,#+21       ;; #+268435456
   \   0000008C   0x....             LDR      R1,??DataTable18  ;; 0xe000ed04
   \   0000008E   0x6008             STR      R0,[R1, #+0]
   \                     ??svcRtxKernelResume_8: (+1)
   \   00000090   0x.... 0x....      BL       OS_Tick_Enable
    457          
    458            EvrRtxKernelResumed();
   \                     ??svcRtxKernelResume_0: (+1)
   \   00000094   0x.... 0x....      BL       EvrRtxKernelResumed
    459          }
   \   00000098   0xBD70             POP      {R4-R6,PC}       ;; return
    460          
    461          /// Get the RTOS kernel tick count.
    462          /// \note API identical to osKernelGetTickCount

   \                                 In section .text, align 2, keep-with-next
    463          uint32_t svcRtxKernelGetTickCount (void) {
   \                     svcRtxKernelGetTickCount: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    464            EvrRtxKernelGetTickCount(osRtxInfo.kernel.tick);
   \   00000002   0x....             LDR      R4,??DataTable15
   \   00000004   0x68E0             LDR      R0,[R4, #+12]
   \   00000006   0x.... 0x....      BL       EvrRtxKernelGetTickCount
    465            return osRtxInfo.kernel.tick;
   \   0000000A   0x68E0             LDR      R0,[R4, #+12]
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    466          }
    467          
    468          /// Get the RTOS kernel tick frequency.
    469          /// \note API identical to osKernelGetTickFreq

   \                                 In section .text, align 2, keep-with-next
    470          uint32_t svcRtxKernelGetTickFreq (void) {
   \                     svcRtxKernelGetTickFreq: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x....             LDR      R0,??DataTable24
   \   00000004   0x6844             LDR      R4,[R0, #+4]
   \   00000006   0x0020             MOVS     R0,R4
    471            EvrRtxKernelGetTickFreq(osRtxConfig.tick_freq);
   \   00000008   0x.... 0x....      BL       EvrRtxKernelGetTickFreq
    472            return osRtxConfig.tick_freq;
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    473          }
    474          
    475          /// Get the RTOS kernel system timer count.
    476          /// \note API identical to osKernelGetSysTimerCount

   \                                 In section .text, align 2, keep-with-next
    477          uint32_t svcRtxKernelGetSysTimerCount (void) {
   \                     svcRtxKernelGetSysTimerCount: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    478            uint32_t tick;
    479            uint32_t count;
    480          
    481            tick  = (uint32_t)osRtxInfo.kernel.tick;
   \   00000002   0x....             LDR      R0,??DataTable24_1
   \   00000004   0x68C4             LDR      R4,[R0, #+12]
    482            count = OS_Tick_GetCount();
   \   00000006   0x.... 0x....      BL       OS_Tick_GetCount
   \   0000000A   0x0005             MOVS     R5,R0
    483            if (OS_Tick_GetOverflow()) {
   \   0000000C   0x.... 0x....      BL       OS_Tick_GetOverflow
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ      ??svcRtxKernelGetSysTimerCount_0
    484              count = OS_Tick_GetCount();
   \   00000014   0x.... 0x....      BL       OS_Tick_GetCount
   \   00000018   0x0005             MOVS     R5,R0
    485              tick++;
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
    486            }
    487            count += tick * OS_Tick_GetInterval();
   \                     ??svcRtxKernelGetSysTimerCount_0: (+1)
   \   0000001C   0x.... 0x....      BL       OS_Tick_GetInterval
   \   00000020   0x4344             MULS     R4,R0,R4
   \   00000022   0x192C             ADDS     R4,R5,R4
    488            EvrRtxKernelGetSysTimerCount(count);
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       EvrRtxKernelGetSysTimerCount
    489            return count;
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    490          }
    491          
    492          /// Get the RTOS kernel system timer frequency.
    493          /// \note API identical to osKernelGetSysTimerFreq

   \                                 In section .text, align 2, keep-with-next
    494          uint32_t svcRtxKernelGetSysTimerFreq (void) {
   \                     svcRtxKernelGetSysTimerFreq: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    495            uint32_t freq = OS_Tick_GetClock();
   \   00000002   0x.... 0x....      BL       OS_Tick_GetClock
   \   00000006   0x0004             MOVS     R4,R0
    496            EvrRtxKernelGetSysTimerFreq(freq);
   \   00000008   0x.... 0x....      BL       EvrRtxKernelGetSysTimerFreq
    497            return freq;
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    498          }
    499          
    500          
    501          //  ==== Public API ====
    502          
    503          /// Initialize the RTOS Kernel.

   \                                 In section .text, align 4, keep-with-next
    504          osStatus_t osKernelInitialize (void) {
   \                     osKernelInitialize: (+1)
   \   00000000   0xB598             PUSH     {R3,R4,R7,LR}
    505            EvrRtxKernelInitialize();
   \   00000002   0x.... 0x....      BL       EvrRtxKernelInitialize
    506            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000006   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD103             BNE      ??osKernelInitialize_0
   \   0000000E   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD000             BEQ      ??osKernelInitialize_1
    507              EvrRtxKernelError(osErrorISR);
   \                     ??osKernelInitialize_0: (+1)
   \   00000016   0x....             B.N      ?Subroutine2
    508              return osErrorISR;
    509            }
    510            return __svcKernelInitialize();
   \                     ??osKernelInitialize_1: (+1)
   \   00000018   0xF3EF 0x8014      MRS      R0,CONTROL
   \   0000001C   0x0780             LSLS     R0,R0,#+30
   \   0000001E   0xD406             BMI      ??osKernelInitialize_2
   \   00000020   0xF3EF 0x8008      MRS      R0,MSP
   \   00000024   0x3820             SUBS     R0,R0,#+32
   \   00000026   0x2107             MOVS     R1,#+7
   \   00000028   0x4388             BICS     R0,R0,R1
   \   0000002A   0xF380 0x8809      MSR      PSP,R0
   \                     ??osKernelInitialize_2: (+1)
   \   0000002E   0x....             LDR      R0,??DataTable24_2
   \   00000030   0x4607             mov r7,R0
   \   00000032   0xDF00             SVC      0x0
   \   00000034   0xBD92             POP      {R1,R4,R7,PC}    ;; return
    511          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x2405             MOVS     R4,#+5
   \   00000002   0x43E4             MVNS     R4,R4            ;; #-6
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       EvrRtxKernelError
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xBD92             POP      {R1,R4,R7,PC}
    512          
    513          ///  Get RTOS Kernel Information.

   \                                 In section .text, align 4, keep-with-next
    514          osStatus_t osKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size) {
   \                     osKernelGetInfo: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0015             MOVS     R5,R2
    515            EvrRtxKernelGetInfo(version, id_buf, id_size);
   \   00000008   0x.... 0x....      BL       EvrRtxKernelGetInfo
    516            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   0000000C   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD103             BNE      ??osKernelGetInfo_0
   \   00000014   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ      ??osKernelGetInfo_1
    517              EvrRtxKernelError(osErrorISR);
   \                     ??osKernelGetInfo_0: (+1)
   \   0000001C   0x2405             MOVS     R4,#+5
   \   0000001E   0x....             B.N      ?Subroutine0
    518              return osErrorISR;
    519            }
    520            if (IS_PRIVILEGED()) {
   \                     ??osKernelGetInfo_1: (+1)
   \   00000020   0xF3EF 0x8014      MRS      R0,CONTROL
   \   00000024   0x07C0             LSLS     R0,R0,#+31
   \   00000026   0xD405             BMI      ??osKernelGetInfo_2
    521              return svcRtxKernelGetInfo(version, id_buf, id_size);
   \   00000028   0x002A             MOVS     R2,R5
   \   0000002A   0x0031             MOVS     R1,R6
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       svcRtxKernelGetInfo
   \   00000032   0xBDF2             POP      {R1,R4-R7,PC}
    522            } else {
    523              return  __svcKernelGetInfo(version, id_buf, id_size);
   \                     ??osKernelGetInfo_2: (+1)
   \   00000034   0x....             LDR      R0,??DataTable24_3
   \   00000036   0x4607             mov r7,R0
   \   00000038   0x002A             MOVS     R2,R5
   \   0000003A   0x0031             MOVS     R1,R6
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0xDF00             SVC      0x0
   \   00000040   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    524            }
    525          }
    526          
    527          /// Get the current RTOS Kernel state.

   \                                 In section .text, align 4, keep-with-next
    528          osKernelState_t osKernelGetState (void) {
   \                     osKernelGetState: (+1)
   \   00000000   0xB598             PUSH     {R3,R4,R7,LR}
    529            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD103             BNE      ??osKernelGetState_0
   \   0000000A   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD006             BEQ      ??osKernelGetState_1
    530              EvrRtxKernelGetState(osKernelError);
   \                     ??osKernelGetState_0: (+1)
   \   00000012   0x2400             MOVS     R4,#+0
   \   00000014   0x43E4             MVNS     R4,R4            ;; #-1
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       EvrRtxKernelGetState
    531              return osKernelError;
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xBD92             POP      {R1,R4,R7,PC}
    532            }
    533            if (IS_PRIVILEGED()) {
   \                     ??osKernelGetState_1: (+1)
   \   00000020   0xF3EF 0x8014      MRS      R0,CONTROL
   \   00000024   0x07C0             LSLS     R0,R0,#+31
   \   00000026   0xD405             BMI      ??osKernelGetState_2
    534              return svcRtxKernelGetState();
   \   00000028   0x....             LDR      R4,??DataTable15
   \   0000002A   0x7A20             LDRB     R0,[R4, #+8]
   \   0000002C   0x.... 0x....      BL       EvrRtxKernelGetState
    535            } else {
   \   00000030   0x7A20             LDRB     R0,[R4, #+8]
   \   00000032   0xBD92             POP      {R1,R4,R7,PC}
    536              return  __svcKernelGetState();
   \                     ??osKernelGetState_2: (+1)
   \   00000034   0x....             LDR      R0,??DataTable24_4
   \   00000036   0x4607             mov r7,R0
   \   00000038   0xDF00             SVC      0x0
   \   0000003A   0xBD92             POP      {R1,R4,R7,PC}    ;; return
    537            }
    538          }
    539          
    540          /// Start the RTOS Kernel scheduler.

   \                                 In section .text, align 4, keep-with-next
    541          osStatus_t osKernelStart (void) {
   \                     osKernelStart: (+1)
   \   00000000   0xB598             PUSH     {R3,R4,R7,LR}
    542            EvrRtxKernelStart();
   \   00000002   0x.... 0x....      BL       EvrRtxKernelStart
    543            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000006   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD103             BNE      ??osKernelStart_0
   \   0000000E   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD000             BEQ      ??osKernelStart_1
    544              EvrRtxKernelError(osErrorISR);
   \                     ??osKernelStart_0: (+1)
   \   00000016   0x....             B.N      ?Subroutine2
    545              return osErrorISR;
    546            }
    547          
    548            /* Call the pre-start event (from unprivileged mode) if the handler exists
    549             * and the kernel is not running. */
    550            /* FIXME osEventObs needs to be readable but not writable from unprivileged
    551             * code. */
    552            if (osKernelGetState() != osKernelRunning && osEventObs && osEventObs->pre_start) {
   \                     ??osKernelStart_1: (+1)
   \   00000018   0x.... 0x....      BL       osKernelGetState
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD007             BEQ      ??osKernelStart_2
   \   00000020   0x....             LDR      R0,??DataTable24_5
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD003             BEQ      ??osKernelStart_2
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0x0001             MOVS     R1,R0
   \   0000002C   0xD000             BEQ      ??osKernelStart_2
    553              osEventObs->pre_start();
   \   0000002E   0x4780             BLX      R0
    554            }
    555          
    556            return __svcKernelStart();
   \                     ??osKernelStart_2: (+1)
   \   00000030   0xF3EF 0x8014      MRS      R0,CONTROL
   \   00000034   0x0780             LSLS     R0,R0,#+30
   \   00000036   0xD406             BMI      ??osKernelStart_3
   \   00000038   0xF3EF 0x8008      MRS      R0,MSP
   \   0000003C   0x3820             SUBS     R0,R0,#+32
   \   0000003E   0x2107             MOVS     R1,#+7
   \   00000040   0x4388             BICS     R0,R0,R1
   \   00000042   0xF380 0x8809      MSR      PSP,R0
   \                     ??osKernelStart_3: (+1)
   \   00000046   0x....             LDR      R0,??DataTable24_6
   \   00000048   0x4607             mov r7,R0
   \   0000004A   0xDF00             SVC      0x0
   \   0000004C   0xBD92             POP      {R1,R4,R7,PC}    ;; return
    557          }
    558          
    559          /// Lock the RTOS Kernel scheduler.

   \                                 In section .text, align 4, keep-with-next
    560          int32_t osKernelLock (void) {
   \                     osKernelLock: (+1)
   \   00000000   0xB598             PUSH     {R3,R4,R7,LR}
    561            EvrRtxKernelLock();
   \   00000002   0x.... 0x....      BL       EvrRtxKernelLock
    562            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000006   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD103             BNE      ??osKernelLock_0
   \   0000000E   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD000             BEQ      ??osKernelLock_1
    563              EvrRtxKernelError(osErrorISR);
   \                     ??osKernelLock_0: (+1)
   \   00000016   0x....             B.N      ?Subroutine2
    564              return osErrorISR;
    565            }
    566            return __svcKernelLock();
   \                     ??osKernelLock_1: (+1)
   \   00000018   0x....             LDR      R0,??DataTable24_7
   \   0000001A   0x4607             mov r7,R0
   \   0000001C   0xDF00             SVC      0x0
   \   0000001E   0xBD92             POP      {R1,R4,R7,PC}    ;; return
    567          }
    568           
    569          /// Unlock the RTOS Kernel scheduler.

   \                                 In section .text, align 4, keep-with-next
    570          int32_t osKernelUnlock (void) {
   \                     osKernelUnlock: (+1)
   \   00000000   0xB598             PUSH     {R3,R4,R7,LR}
    571            EvrRtxKernelUnlock();
   \   00000002   0x.... 0x....      BL       EvrRtxKernelUnlock
    572            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000006   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD103             BNE      ??osKernelUnlock_0
   \   0000000E   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD000             BEQ      ??osKernelUnlock_1
    573              EvrRtxKernelError(osErrorISR);
   \                     ??osKernelUnlock_0: (+1)
   \   00000016   0x....             B.N      ?Subroutine2
    574              return osErrorISR;
    575            }
    576            return __svcKernelUnlock();
   \                     ??osKernelUnlock_1: (+1)
   \   00000018   0x....             LDR      R0,??DataTable24_8
   \   0000001A   0x4607             mov r7,R0
   \   0000001C   0xDF00             SVC      0x0
   \   0000001E   0xBD92             POP      {R1,R4,R7,PC}    ;; return
    577          }
    578          
    579          /// Restore the RTOS Kernel scheduler lock state.

   \                                 In section .text, align 4, keep-with-next
    580          int32_t osKernelRestoreLock (int32_t lock) {
   \                     osKernelRestoreLock: (+1)
   \   00000000   0xB598             PUSH     {R3,R4,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    581            EvrRtxKernelRestoreLock(lock);
   \   00000004   0x.... 0x....      BL       EvrRtxKernelRestoreLock
    582            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000008   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE      ??osKernelRestoreLock_0
   \   00000010   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD000             BEQ      ??osKernelRestoreLock_1
    583              EvrRtxKernelError(osErrorISR);
   \                     ??osKernelRestoreLock_0: (+1)
   \   00000018   0x....             B.N      ?Subroutine2
    584              return osErrorISR;
    585            }
    586            return __svcKernelRestoreLock(lock);
   \                     ??osKernelRestoreLock_1: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable24_9
   \   0000001C   0x4607             mov r7,R0
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBD92             POP      {R1,R4,R7,PC}    ;; return
    587          }
    588          
    589          /// Suspend the RTOS Kernel scheduler.

   \                                 In section .text, align 4, keep-with-next
    590          uint32_t osKernelSuspend (void) {
   \                     osKernelSuspend: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    591            EvrRtxKernelSuspend();
   \   00000002   0x.... 0x....      BL       EvrRtxKernelSuspend
    592            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000006   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD103             BNE      ??osKernelSuspend_0
   \   0000000E   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD005             BEQ      ??osKernelSuspend_1
    593              EvrRtxKernelError(osErrorISR);
   \                     ??osKernelSuspend_0: (+1)
   \   00000016   0x2005             MOVS     R0,#+5
   \   00000018   0x43C0             MVNS     R0,R0            ;; #-6
   \   0000001A   0x.... 0x....      BL       EvrRtxKernelError
    594              return 0U;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD80             POP      {R7,PC}
    595            }
    596            return __svcKernelSuspend();
   \                     ??osKernelSuspend_1: (+1)
   \   00000022   0x....             LDR      R0,??DataTable24_10
   \   00000024   0x4607             mov r7,R0
   \   00000026   0xDF00             SVC      0x0
   \   00000028   0xBD80             POP      {R7,PC}          ;; return
    597          }
    598          
    599          /// Resume the RTOS Kernel scheduler.

   \                                 In section .text, align 4, keep-with-next
    600          void osKernelResume (uint32_t sleep_ticks) {
   \                     osKernelResume: (+1)
   \   00000000   0xB598             PUSH     {R3,R4,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    601            EvrRtxKernelResume(sleep_ticks);
   \   00000004   0x.... 0x....      BL       EvrRtxKernelResume
    602            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000008   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE      ??osKernelResume_0
   \   00000010   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ      ??osKernelResume_1
    603              EvrRtxKernelError(osErrorISR);
   \                     ??osKernelResume_0: (+1)
   \   00000018   0x2005             MOVS     R0,#+5
   \   0000001A   0x43C0             MVNS     R0,R0            ;; #-6
   \   0000001C   0x.... 0x....      BL       EvrRtxKernelError
    604              return;
   \   00000020   0xBD91             POP      {R0,R4,R7,PC}
    605            }
    606            __svcKernelResume(sleep_ticks);
   \                     ??osKernelResume_1: (+1)
   \   00000022   0x....             LDR      R0,??DataTable24_11
   \   00000024   0x4607             mov r7,R0
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0xDF00             SVC      0x0
    607          }
   \   0000002A   0xBD91             POP      {R0,R4,R7,PC}    ;; return
    608          
    609          /// Get the RTOS kernel tick count.

   \                                 In section .text, align 4, keep-with-next
    610          uint32_t osKernelGetTickCount (void) {
   \                     osKernelGetTickCount: (+1)
   \   00000000   0xB598             PUSH     {R3,R4,R7,LR}
    611            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD103             BNE      ??osKernelGetTickCount_0
   \   0000000A   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD005             BEQ      ??osKernelGetTickCount_1
    612              return svcRtxKernelGetTickCount();
   \                     ??osKernelGetTickCount_0: (+1)
   \   00000012   0x....             LDR      R4,??DataTable24_1
   \   00000014   0x68E0             LDR      R0,[R4, #+12]
   \   00000016   0x.... 0x....      BL       EvrRtxKernelGetTickCount
    613            } else {
   \   0000001A   0x68E0             LDR      R0,[R4, #+12]
   \   0000001C   0xBD92             POP      {R1,R4,R7,PC}
    614              return  __svcKernelGetTickCount();
   \                     ??osKernelGetTickCount_1: (+1)
   \   0000001E   0x....             LDR      R0,??DataTable24_12
   \   00000020   0x4607             mov r7,R0
   \   00000022   0xDF00             SVC      0x0
   \   00000024   0xBD92             POP      {R1,R4,R7,PC}    ;; return
    615            }
    616          }
    617          
    618          /// Get the RTOS kernel tick frequency.

   \                                 In section .text, align 4, keep-with-next
    619          uint32_t osKernelGetTickFreq (void) {
   \                     osKernelGetTickFreq: (+1)
   \   00000000   0xB598             PUSH     {R3,R4,R7,LR}
    620            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD103             BNE      ??osKernelGetTickFreq_0
   \   0000000A   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD006             BEQ      ??osKernelGetTickFreq_1
   \                     ??osKernelGetTickFreq_0: (+1)
   \   00000012   0x....             LDR      R0,??DataTable24
   \   00000014   0x6844             LDR      R4,[R0, #+4]
   \   00000016   0x0020             MOVS     R0,R4
    621              return svcRtxKernelGetTickFreq();
   \   00000018   0x.... 0x....      BL       EvrRtxKernelGetTickFreq
    622            } else {
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xBD92             POP      {R1,R4,R7,PC}
    623              return  __svcKernelGetTickFreq();
   \                     ??osKernelGetTickFreq_1: (+1)
   \   00000020   0x....             LDR      R0,??DataTable24_13
   \   00000022   0x4607             mov r7,R0
   \   00000024   0xDF00             SVC      0x0
   \   00000026   0xBD92             POP      {R1,R4,R7,PC}    ;; return
    624            }
    625          }
    626          
    627          /// Get the RTOS kernel system timer count.

   \                                 In section .text, align 4, keep-with-next
    628          uint32_t osKernelGetSysTimerCount (void) {
   \                     osKernelGetSysTimerCount: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    629            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD103             BNE      ??osKernelGetSysTimerCount_0
   \   0000000A   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD002             BEQ      ??osKernelGetSysTimerCount_1
    630              return svcRtxKernelGetSysTimerCount();
   \                     ??osKernelGetSysTimerCount_0: (+1)
   \   00000012   0x.... 0x....      BL       svcRtxKernelGetSysTimerCount
   \   00000016   0xBD80             POP      {R7,PC}
    631            } else {
    632              return  __svcKernelGetSysTimerCount();
   \                     ??osKernelGetSysTimerCount_1: (+1)
   \   00000018   0x....             LDR      R0,??DataTable24_14
   \   0000001A   0x4607             mov r7,R0
   \   0000001C   0xDF00             SVC      0x0
   \   0000001E   0xBD80             POP      {R7,PC}          ;; return
    633            }
    634          }
    635          
    636          /// Get the RTOS kernel system timer frequency.

   \                                 In section .text, align 4, keep-with-next
    637          uint32_t osKernelGetSysTimerFreq (void) {
   \                     osKernelGetSysTimerFreq: (+1)
   \   00000000   0xB598             PUSH     {R3,R4,R7,LR}
    638            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD103             BNE      ??osKernelGetSysTimerFreq_0
   \   0000000A   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD006             BEQ      ??osKernelGetSysTimerFreq_1
    639              return svcRtxKernelGetSysTimerFreq();
   \                     ??osKernelGetSysTimerFreq_0: (+1)
   \   00000012   0x.... 0x....      BL       OS_Tick_GetClock
   \   00000016   0x0004             MOVS     R4,R0
   \   00000018   0x.... 0x....      BL       EvrRtxKernelGetSysTimerFreq
    640            } else {
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xBD92             POP      {R1,R4,R7,PC}
    641              return  __svcKernelGetSysTimerFreq();
   \                     ??osKernelGetSysTimerFreq_1: (+1)
   \   00000020   0x....             LDR      R0,??DataTable24_15
   \   00000022   0x4607             mov r7,R0
   \   00000024   0xDF00             SVC      0x0
   \   00000026   0xBD92             POP      {R1,R4,R7,PC}    ;; return
    642            }
    643          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x52 0x54          DC8 "RTX V5.2.2"
   \              0x58 0x20    
   \              0x56 0x35    
   \              0x2E 0x32    
   \              0x2E 0x32    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     osRtxInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     osRtxConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xE000ED1C         DC32     0xe000ed1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x01315411         DC32     0x1315411

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x02FB3EA2         DC32     0x2fb3ea2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     osRtxIdleThread

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     osRtxTimerThread

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     SysTick_Handler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     osRtxInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x........         DC32     osRtxConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x........         DC32     osRtxInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0x........         DC32     svcRtxKernelInitialize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   0x........         DC32     svcRtxKernelGetInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \   00000000   0x........         DC32     svcRtxKernelGetState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_5:
   \   00000000   0x........         DC32     osEventObs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_6:
   \   00000000   0x........         DC32     svcRtxKernelStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_7:
   \   00000000   0x........         DC32     svcRtxKernelLock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_8:
   \   00000000   0x........         DC32     svcRtxKernelUnlock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_9:
   \   00000000   0x........         DC32     svcRtxKernelRestoreLock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_10:
   \   00000000   0x........         DC32     svcRtxKernelSuspend

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_11:
   \   00000000   0x........         DC32     svcRtxKernelResume

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_12:
   \   00000000   0x........         DC32     svcRtxKernelGetTickCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_13:
   \   00000000   0x........         DC32     svcRtxKernelGetTickFreq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_14:
   \   00000000   0x........         DC32     svcRtxKernelGetSysTimerCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_15:
   \   00000000   0x........         DC32     svcRtxKernelGetSysTimerFreq

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   osKernelGetInfo
        24   -> EvrRtxKernelError
        24   -> EvrRtxKernelGetInfo
        24   -> svcRtxKernelGetInfo
      16   osKernelGetState
        16   -> EvrRtxKernelGetState
       8   osKernelGetSysTimerCount
         8   -> svcRtxKernelGetSysTimerCount
      16   osKernelGetSysTimerFreq
        16   -> EvrRtxKernelGetSysTimerFreq
        16   -> OS_Tick_GetClock
      16   osKernelGetTickCount
        16   -> EvrRtxKernelGetTickCount
      16   osKernelGetTickFreq
        16   -> EvrRtxKernelGetTickFreq
      16   osKernelInitialize
        16   -> EvrRtxKernelError
        16   -> EvrRtxKernelInitialize
      16   osKernelLock
        16   -> EvrRtxKernelError
        16   -> EvrRtxKernelLock
      16   osKernelRestoreLock
        16   -> EvrRtxKernelError
        16   -> EvrRtxKernelRestoreLock
      16   osKernelResume
        16   -> EvrRtxKernelError
        16   -> EvrRtxKernelResume
      16   osKernelStart
        16   -- Indirect call
        16   -> EvrRtxKernelError
        16   -> EvrRtxKernelStart
        16   -> osKernelGetState
       8   osKernelSuspend
         8   -> EvrRtxKernelError
         8   -> EvrRtxKernelSuspend
      16   osKernelUnlock
        16   -> EvrRtxKernelError
        16   -> EvrRtxKernelUnlock
      16   svcRtxKernelGetInfo
        16   -> EvrRtxKernelInfoRetrieved
        16   -> __aeabi_memcpy
       8   svcRtxKernelGetState
         8   -> EvrRtxKernelGetState
      16   svcRtxKernelGetSysTimerCount
        16   -> EvrRtxKernelGetSysTimerCount
        16   -> OS_Tick_GetCount
        16   -> OS_Tick_GetInterval
        16   -> OS_Tick_GetOverflow
       8   svcRtxKernelGetSysTimerFreq
         8   -> EvrRtxKernelGetSysTimerFreq
         8   -> OS_Tick_GetClock
       8   svcRtxKernelGetTickCount
         8   -> EvrRtxKernelGetTickCount
       8   svcRtxKernelGetTickFreq
         8   -> EvrRtxKernelGetTickFreq
      24   svcRtxKernelInitialize
        24   -> EvrRtxKernelError
        24   -> EvrRtxKernelInitializeCompleted
        24   -> __aeabi_memclr4
        24   -> osRtxMemoryInit
        24   -> osRtxMemoryPoolInit
       8   svcRtxKernelLock
         8   -> EvrRtxKernelError
         8   -> EvrRtxKernelLocked
       8   svcRtxKernelRestoreLock
         8   -> EvrRtxKernelError
         8   -> EvrRtxKernelLockRestored
      16   svcRtxKernelResume
        16   -- Indirect call
        16   -> EvrRtxKernelResumed
        16   -> OS_Tick_Enable
        16   -> osRtxThreadDelayTick
        16   -> osRtxThreadDispatch
      16   svcRtxKernelStart
        16   -> EvrRtxKernelError
        16   -> EvrRtxKernelStarted
        16   -> OS_Tick_Enable
        16   -> OS_Tick_GetIRQn
        16   -> OS_Tick_Setup
        16   -> osRtxThreadListGet
        16   -> osRtxThreadSwitch
        16   -> svcRtxThreadNew
      16   svcRtxKernelSuspend
        16   -> EvrRtxKernelError
        16   -> EvrRtxKernelSuspended
        16   -> OS_Tick_Disable
       8   svcRtxKernelUnlock
         8   -> EvrRtxKernelError
         8   -> EvrRtxKernelUnlocked


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable11
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable15
       4  ??DataTable18
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_10
       4  ??DataTable24_11
       4  ??DataTable24_12
       4  ??DataTable24_13
       4  ??DataTable24_14
       4  ??DataTable24_15
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable24_9
       4  ??DataTable5
       4  ??DataTable5_1
      12  ?Subroutine0
      14  ?Subroutine1
      14  ?Subroutine2
      12  ?_0
      66  osKernelGetInfo
      60  osKernelGetState
      32  osKernelGetSysTimerCount
      40  osKernelGetSysTimerFreq
      38  osKernelGetTickCount
      40  osKernelGetTickFreq
      54  osKernelInitialize
      32  osKernelLock
      36  osKernelRestoreLock
      44  osKernelResume
      78  osKernelStart
      42  osKernelSuspend
      32  osKernelUnlock
     164  osRtxInfo
      52  svcRtxKernelGetInfo
      14  svcRtxKernelGetState
      46  svcRtxKernelGetSysTimerCount
      16  svcRtxKernelGetSysTimerFreq
      14  svcRtxKernelGetTickCount
      16  svcRtxKernelGetTickFreq
     378  svcRtxKernelInitialize
      40  svcRtxKernelLock
      52  svcRtxKernelRestoreLock
     154  svcRtxKernelResume
     166  svcRtxKernelStart
      90  svcRtxKernelSuspend
      38  svcRtxKernelUnlock

 
   164 bytes in section .data.os
 1 826 bytes in section .text
 
 1 826 bytes of CODE memory
   164 bytes of DATA memory

Errors: none
Warnings: 1

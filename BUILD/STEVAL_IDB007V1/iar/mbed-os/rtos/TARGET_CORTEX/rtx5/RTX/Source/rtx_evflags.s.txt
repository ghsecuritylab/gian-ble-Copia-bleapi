###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:52
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_evflags.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_evflags.d
#        -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_evflags.s.txt
#        -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_evflags.o
#        .\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_evflags.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_evflags.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_evflags.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\rtos\TARGET_CORTEX\rtx5\RTX\Source\rtx_evflags.c
      1          /*
      2           * Copyright (c) 2013-2017 ARM Limited. All rights reserved.
      3           *
      4           * SPDX-License-Identifier: Apache-2.0
      5           *
      6           * Licensed under the Apache License, Version 2.0 (the License); you may
      7           * not use this file except in compliance with the License.
      8           * You may obtain a copy of the License at
      9           *
     10           * www.apache.org/licenses/LICENSE-2.0
     11           *
     12           * Unless required by applicable law or agreed to in writing, software
     13           * distributed under the License is distributed on an AS IS BASIS, WITHOUT
     14           * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15           * See the License for the specific language governing permissions and
     16           * limitations under the License.
     17           *
     18           * -----------------------------------------------------------------------------
     19           *
     20           * Project:     CMSIS-RTOS RTX
     21           * Title:       Event Flags functions
     22           *
     23           * -----------------------------------------------------------------------------
     24           */
     25          
     26          #include "rtx_lib.h"

  typedef uint8_t BOOL;  //already defined in "hal_type.h"
                  ^
"C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\TARGET_STEVAL_IDB007V1\device\system_BlueNRG1.h",240  Warning[Pe301]: typedef name has already been declared (with same type)
     27          
     28          
     29          //  ==== Helper functions ====
     30          
     31          /// Set Event Flags.
     32          /// \param[in]  ef              event flags object.
     33          /// \param[in]  flags           specifies the flags to set.
     34          /// \return event flags after setting.
     35          static uint32_t EventFlagsSet (os_event_flags_t *ef, uint32_t flags) {
     36          #if (__EXCLUSIVE_ACCESS == 0U)
     37            uint32_t primask = __get_PRIMASK();
     38          #endif
     39            uint32_t event_flags;
     40          
     41          #if (__EXCLUSIVE_ACCESS == 0U)
     42            __disable_irq();
     43          
     44            ef->event_flags |= flags;
     45            event_flags = ef->event_flags;
     46          
     47            if (primask == 0U) {
     48              __enable_irq();
     49            }
     50          #else
     51            event_flags = atomic_set32(&ef->event_flags, flags);
     52          #endif
     53          
     54            return event_flags;
     55          }
     56          
     57          /// Clear Event Flags.
     58          /// \param[in]  ef              event flags object.
     59          /// \param[in]  flags           specifies the flags to clear.
     60          /// \return event flags before clearing.
     61          static uint32_t EventFlagsClear (os_event_flags_t *ef, uint32_t flags) {
     62          #if (__EXCLUSIVE_ACCESS == 0U)
     63            uint32_t primask = __get_PRIMASK();
     64          #endif
     65            uint32_t event_flags;
     66          
     67          #if (__EXCLUSIVE_ACCESS == 0U)
     68            __disable_irq();
     69          
     70            event_flags = ef->event_flags;
     71            ef->event_flags &= ~flags;
     72          
     73            if (primask == 0U) {
     74              __enable_irq();
     75            }
     76          #else
     77            event_flags = atomic_clr32(&ef->event_flags, flags);
     78          #endif
     79          
     80            return event_flags;
     81          }
     82          
     83          /// Check Event Flags.
     84          /// \param[in]  ef              event flags object.
     85          /// \param[in]  flags           specifies the flags to check.
     86          /// \param[in]  options         specifies flags options (osFlagsXxxx).
     87          /// \return event flags before clearing or 0 if specified flags have not been set.

   \                                 In section .text, align 2, keep-with-next
     88          static uint32_t EventFlagsCheck (os_event_flags_t *ef, uint32_t flags, uint32_t options) {
   \                     EventFlagsCheck: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0013             MOVS     R3,R2
     89          #if (__EXCLUSIVE_ACCESS == 0U)
     90            uint32_t primask;
     91          #endif
     92            uint32_t event_flags;
     93          
     94            if ((options & osFlagsNoClear) == 0U) {
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x079A             LSLS     R2,R3,#+30
   \   00000008   0xD414             BMI      ??EventFlagsCheck_0
     95          #if (__EXCLUSIVE_ACCESS == 0U)
     96              primask = __get_PRIMASK();
   \   0000000A   0xF3EF 0x8510      MRS      R5,PRIMASK
     97              __disable_irq();
   \   0000000E   0xB672             CPSID    I
     98          
     99              event_flags = ef->event_flags;
   \   00000010   0x68C6             LDR      R6,[R0, #+12]
   \   00000012   0x0032             MOVS     R2,R6
    100              if ((((options & osFlagsWaitAll) != 0U) && ((event_flags & flags) != flags)) ||
    101                  (((options & osFlagsWaitAll) == 0U) && ((event_flags & flags) == 0U))) {
   \   00000014   0x000F             MOVS     R7,R1
   \   00000016   0x4017             ANDS     R7,R7,R2
   \   00000018   0x401C             ANDS     R4,R4,R3
   \   0000001A   0xD007             BEQ      ??EventFlagsCheck_1
   \   0000001C   0x428F             CMP      R7,R1
   \   0000001E   0xD107             BNE      ??EventFlagsCheck_2
    102                event_flags = 0U;
    103              } else {
    104                ef->event_flags &= ~flags;
   \                     ??EventFlagsCheck_3: (+1)
   \   00000020   0x438E             BICS     R6,R6,R1
   \   00000022   0x60C6             STR      R6,[R0, #+12]
    105              }
    106          
    107              if (primask == 0U) {
   \                     ??EventFlagsCheck_4: (+1)
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD110             BNE      ??EventFlagsCheck_5
    108                __enable_irq();
   \   00000028   0xB662             CPSIE    I
   \   0000002A   0xE00E             B        ??EventFlagsCheck_5
    109              }
   \                     ??EventFlagsCheck_1: (+1)
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD1F7             BNE      ??EventFlagsCheck_3
   \                     ??EventFlagsCheck_2: (+1)
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0xE7F7             B        ??EventFlagsCheck_4
    110          #else
    111              if ((options & osFlagsWaitAll) != 0U) {
    112                event_flags = atomic_chk32_all(&ef->event_flags, flags);
    113              } else {
    114                event_flags = atomic_chk32_any(&ef->event_flags, flags);
    115              }
    116          #endif
    117            } else {
    118              event_flags = ef->event_flags;
   \                     ??EventFlagsCheck_0: (+1)
   \   00000034   0x68C2             LDR      R2,[R0, #+12]
    119              if ((((options & osFlagsWaitAll) != 0U) && ((event_flags & flags) != flags)) ||
    120                  (((options & osFlagsWaitAll) == 0U) && ((event_flags & flags) == 0U))) {
   \   00000036   0x0008             MOVS     R0,R1
   \   00000038   0x4010             ANDS     R0,R0,R2
   \   0000003A   0x401C             ANDS     R4,R4,R3
   \   0000003C   0xD002             BEQ      ??EventFlagsCheck_6
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD102             BNE      ??EventFlagsCheck_7
   \   00000042   0xE002             B        ??EventFlagsCheck_5
   \                     ??EventFlagsCheck_6: (+1)
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD100             BNE      ??EventFlagsCheck_5
    121                event_flags = 0U;
   \                     ??EventFlagsCheck_7: (+1)
   \   00000048   0x2200             MOVS     R2,#+0
    122              }
    123            }
    124          
    125            return event_flags;
   \                     ??EventFlagsCheck_5: (+1)
   \   0000004A   0x0010             MOVS     R0,R2
   \   0000004C   0xBCF0             POP      {R4-R7}
   \   0000004E   0x4770             BX       LR               ;; return
    126          }
    127          
    128          
    129          //  ==== Library functions ====
    130          
    131          /// Event Flags post ISR processing.
    132          /// \param[in]  ef              event flags object.

   \                                 In section .text, align 2, keep-with-next
    133          void osRtxEventFlagsPostProcess (os_event_flags_t *ef) {
   \                     osRtxEventFlagsPostProcess: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
    134            os_thread_t *thread;
    135            os_thread_t *thread_next;
    136            uint32_t     event_flags;
    137          
    138            if (ef->state == osRtxObjectInactive) {
   \   00000002   0x7840             LDRB     R0,[R0, #+1]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD01D             BEQ      ??osRtxEventFlagsPostProcess_0
    139              return;
    140            }
    141          
    142            // Check if Threads are waiting for Event Flags
    143            thread = ef->thread_list;
   \   00000008   0x9800             LDR      R0,[SP, #+0]
   \   0000000A   0x6884             LDR      R4,[R0, #+8]
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xE018             B        ??osRtxEventFlagsPostProcess_1
    144            while (thread != NULL) {
    145              thread_next = thread->thread_next;
   \                     ??osRtxEventFlagsPostProcess_2: (+1)
   \   00000010   0x0026             MOVS     R6,R4
   \   00000012   0x3608             ADDS     R6,R6,#+8
   \   00000014   0x6837             LDR      R7,[R6, #+0]
    146              event_flags = EventFlagsCheck(ef, thread->wait_flags, thread->flags_options);
   \   00000016   0x7EF2             LDRB     R2,[R6, #+27]
   \   00000018   0x69F1             LDR      R1,[R6, #+28]
   \   0000001A   0x9800             LDR      R0,[SP, #+0]
   \   0000001C   0x.... 0x....      BL       EventFlagsCheck
   \   00000020   0x0005             MOVS     R5,R0
    147              if (event_flags != 0U) {
   \   00000022   0xD00D             BEQ      ??osRtxEventFlagsPostProcess_3
    148                osRtxThreadListRemove(thread);
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       osRtxThreadListRemove
    149                osRtxThreadWaitExit(thread, event_flags, false);
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x0029             MOVS     R1,R5
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       osRtxThreadWaitExit
    150                EvrRtxEventFlagsWaitCompleted(ef, thread->wait_flags, thread->flags_options, event_flags);
   \   00000034   0x002B             MOVS     R3,R5
   \   00000036   0x7EF2             LDRB     R2,[R6, #+27]
   \   00000038   0x69F1             LDR      R1,[R6, #+28]
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
   \   0000003C   0x.... 0x....      BL       EvrRtxEventFlagsWaitCompleted
    151              }
    152              thread = thread_next;
   \                     ??osRtxEventFlagsPostProcess_3: (+1)
   \   00000040   0x003C             MOVS     R4,R7
    153            }
   \                     ??osRtxEventFlagsPostProcess_1: (+1)
   \   00000042   0xD1E5             BNE      ??osRtxEventFlagsPostProcess_2
    154          }
   \                     ??osRtxEventFlagsPostProcess_0: (+1)
   \   00000044   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    155          
    156          
    157          //  ==== Service Calls ====
    158          
    159          //  Service Calls definitions
    160          SVC0_1M(EventFlagsNew,     osEventFlagsId_t, const osEventFlagsAttr_t *)
    161          SVC0_1 (EventFlagsGetName, const char *,     osEventFlagsId_t)
    162          SVC0_2 (EventFlagsSet,     uint32_t,         osEventFlagsId_t, uint32_t)
    163          SVC0_2 (EventFlagsClear,   uint32_t,         osEventFlagsId_t, uint32_t)
    164          SVC0_1 (EventFlagsGet,     uint32_t,         osEventFlagsId_t)
    165          SVC0_4 (EventFlagsWait,    uint32_t,         osEventFlagsId_t, uint32_t, uint32_t, uint32_t)
    166          SVC0_1 (EventFlagsDelete,  osStatus_t,       osEventFlagsId_t)
    167          
    168          /// Create and Initialize an Event Flags object.
    169          /// \note API identical to osEventFlagsNew

   \                                 In section .text, align 2, keep-with-next
    170          osEventFlagsId_t svcRtxEventFlagsNew (const osEventFlagsAttr_t *attr) {
   \                     svcRtxEventFlagsNew: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    171            os_event_flags_t *ef;
    172            uint8_t           flags;
    173            const char       *name;
    174          
    175            // Process attributes
    176            if (attr != NULL) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD024             BEQ      ??svcRtxEventFlagsNew_0
    177              name = attr->name;
   \   00000006   0x6804             LDR      R4,[R0, #+0]
    178              ef   = attr->cb_mem;
   \   00000008   0x6885             LDR      R5,[R0, #+8]
    179              if (ef != NULL) {
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD016             BEQ      ??svcRtxEventFlagsNew_1
    180                if (((uint32_t)ef & 3U) || (attr->cb_size < sizeof(os_event_flags_t))) {
   \   0000000E   0x07A9             LSLS     R1,R5,#+30
   \   00000010   0xD117             BNE      ??svcRtxEventFlagsNew_2
   \   00000012   0x68C0             LDR      R0,[R0, #+12]
   \   00000014   0x2810             CMP      R0,#+16
   \   00000016   0xD314             BCC      ??svcRtxEventFlagsNew_2
    181                  EvrRtxEventFlagsError(NULL, osRtxErrorInvalidControlBlock);
    182                  return NULL;
    183                }
    184              } else {
    185                if (attr->cb_size != 0U) {
    186                  EvrRtxEventFlagsError(NULL, osRtxErrorInvalidControlBlock);
    187                  return NULL;
    188                }
    189              }
    190            } else {
    191              name = NULL;
    192              ef   = NULL;
    193            }
    194          
    195            // Allocate object memory if not provided
    196            if (ef == NULL) {
    197              if (osRtxInfo.mpi.event_flags != NULL) {
    198                ef = osRtxMemoryPoolAlloc(osRtxInfo.mpi.event_flags);
    199              } else {
    200                ef = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_event_flags_t), 1U);
    201              }
    202              if (ef == NULL) {
    203                EvrRtxEventFlagsError(NULL, osErrorNoMemory);
    204                return NULL;
    205              }
    206              flags = osRtxFlagSystemObject;
    207            } else {
    208              flags = 0U;
   \   00000018   0x2000             MOVS     R0,#+0
    209            }
    210          
    211            // Initialize control block
    212            ef->id          = osRtxIdEventFlags;
   \                     ??svcRtxEventFlagsNew_3: (+1)
   \   0000001A   0x2103             MOVS     R1,#+3
   \   0000001C   0x7029             STRB     R1,[R5, #+0]
    213            ef->state       = osRtxObjectActive;
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x7069             STRB     R1,[R5, #+1]
    214            ef->flags       = flags;
   \   00000022   0x70A8             STRB     R0,[R5, #+2]
    215            ef->name        = name;
   \   00000024   0x606C             STR      R4,[R5, #+4]
    216            ef->thread_list = NULL;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x60A8             STR      R0,[R5, #+8]
    217            ef->event_flags = 0U;
   \   0000002A   0x60E8             STR      R0,[R5, #+12]
    218          
    219            // Register post ISR processing function
    220            osRtxInfo.post_process.event_flags = osRtxEventFlagsPostProcess;
   \   0000002C   0x....             LDR      R0,??DataTable3
   \   0000002E   0x....             LDR      R1,??DataTable3_1
   \   00000030   0x6648             STR      R0,[R1, #+100]
    221          
    222            EvrRtxEventFlagsCreated(ef);
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       EvrRtxEventFlagsCreated
    223          
    224            return ef;
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??svcRtxEventFlagsNew_1: (+1)
   \   0000003C   0x68C0             LDR      R0,[R0, #+12]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD007             BEQ      ??svcRtxEventFlagsNew_4
   \                     ??svcRtxEventFlagsNew_2: (+1)
   \   00000042   0x2108             MOVS     R1,#+8
   \                     ??svcRtxEventFlagsNew_5: (+1)
   \   00000044   0x43C9             MVNS     R1,R1            ;; #-9
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x.... 0x....      BL       EvrRtxEventFlagsError
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??svcRtxEventFlagsNew_0: (+1)
   \   00000050   0x2400             MOVS     R4,#+0
   \                     ??svcRtxEventFlagsNew_4: (+1)
   \   00000052   0x....             LDR      R3,??DataTable4
   \   00000054   0x6AD8             LDR      R0,[R3, #+44]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD002             BEQ      ??svcRtxEventFlagsNew_6
   \   0000005A   0x.... 0x....      BL       osRtxMemoryPoolAlloc
   \   0000005E   0xE004             B        ??svcRtxEventFlagsNew_7
   \                     ??svcRtxEventFlagsNew_6: (+1)
   \   00000060   0x2201             MOVS     R2,#+1
   \   00000062   0x2110             MOVS     R1,#+16
   \   00000064   0x69D8             LDR      R0,[R3, #+28]
   \   00000066   0x.... 0x....      BL       osRtxMemoryAlloc
   \                     ??svcRtxEventFlagsNew_7: (+1)
   \   0000006A   0x0005             MOVS     R5,R0
   \   0000006C   0xD101             BNE      ??svcRtxEventFlagsNew_8
   \   0000006E   0x2104             MOVS     R1,#+4
   \   00000070   0xE7E8             B.N      ??svcRtxEventFlagsNew_5
   \                     ??svcRtxEventFlagsNew_8: (+1)
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xE7D1             B        ??svcRtxEventFlagsNew_3
    225          }
    226          
    227          /// Get name of an Event Flags object.
    228          /// \note API identical to osEventFlagsGetName

   \                                 In section .text, align 2, keep-with-next
    229          const char *svcRtxEventFlagsGetName (osEventFlagsId_t ef_id) {
   \                     svcRtxEventFlagsGetName: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    230            os_event_flags_t *ef = (os_event_flags_t *)ef_id;
    231          
    232            // Check parameters
    233            if ((ef == NULL) || (ef->id != osRtxIdEventFlags)) {
   \   00000004   0xD005             BEQ      ??svcRtxEventFlagsGetName_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2803             CMP      R0,#+3
   \   0000000A   0xD102             BNE      ??svcRtxEventFlagsGetName_0
    234              EvrRtxEventFlagsGetName(ef, NULL);
    235              return NULL;
    236            }
    237          
    238            // Check object state
    239            if (ef->state == osRtxObjectInactive) {
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE      ??svcRtxEventFlagsGetName_1
    240              EvrRtxEventFlagsGetName(ef, NULL);
   \                     ??svcRtxEventFlagsGetName_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       EvrRtxEventFlagsGetName
    241              return NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}
    242            }
    243          
    244            EvrRtxEventFlagsGetName(ef, ef->name);
   \                     ??svcRtxEventFlagsGetName_1: (+1)
   \   0000001E   0x6861             LDR      R1,[R4, #+4]
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       EvrRtxEventFlagsGetName
    245          
    246            return ef->name;
   \   00000026   0x6860             LDR      R0,[R4, #+4]
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    247          }
    248          
    249          /// Set the specified Event Flags.
    250          /// \note API identical to osEventFlagsSet

   \                                 In section .text, align 2, keep-with-next
    251          uint32_t svcRtxEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags) {
   \                     svcRtxEventFlagsSet: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0007             MOVS     R7,R0
    252            os_event_flags_t *ef = (os_event_flags_t *)ef_id;
    253            os_thread_t      *thread;
    254            os_thread_t      *thread_next;
    255            uint32_t          event_flags;
    256            uint32_t          event_flags0;
    257          
    258            // Check parameters
    259            if ((ef == NULL) || (ef->id != osRtxIdEventFlags) ||
    260                (flags & ~((1U << osRtxEventFlagsLimit) - 1U))) {
   \   00000006   0xD004             BEQ      ??svcRtxEventFlagsSet_0
   \   00000008   0x7838             LDRB     R0,[R7, #+0]
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xD101             BNE      ??svcRtxEventFlagsSet_0
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD501             BPL      ??svcRtxEventFlagsSet_1
    261              EvrRtxEventFlagsError(ef, osErrorParameter);
   \                     ??svcRtxEventFlagsSet_0: (+1)
   \   00000012   0x2403             MOVS     R4,#+3
   \   00000014   0xE003             B.N      ??svcRtxEventFlagsSet_2
    262              return ((uint32_t)osErrorParameter);
    263            }
    264          
    265            // Check object state
    266            if (ef->state == osRtxObjectInactive) {
   \                     ??svcRtxEventFlagsSet_1: (+1)
   \   00000016   0x7878             LDRB     R0,[R7, #+1]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD107             BNE      ??svcRtxEventFlagsSet_3
    267              EvrRtxEventFlagsError(ef, osErrorResource);
   \   0000001C   0x2402             MOVS     R4,#+2
   \                     ??svcRtxEventFlagsSet_2: (+1)
   \   0000001E   0x43E4             MVNS     R4,R4            ;; #-3
   \   00000020   0x0021             MOVS     R1,R4
   \   00000022   0x0038             MOVS     R0,R7
   \   00000024   0x.... 0x....      BL       EvrRtxEventFlagsError
    268              return ((uint32_t)osErrorResource);
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xE038             B        ??svcRtxEventFlagsSet_4
    269            }
    270          
    271            // Set Event Flags
    272            event_flags = EventFlagsSet(ef, flags);
   \                     ??svcRtxEventFlagsSet_3: (+1)
   \   0000002C   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000030   0xB672             CPSID    I
   \   00000032   0x68FA             LDR      R2,[R7, #+12]
   \   00000034   0x4311             ORRS     R1,R1,R2
   \   00000036   0x60F9             STR      R1,[R7, #+12]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD100             BNE      ??svcRtxEventFlagsSet_5
   \   0000003C   0xB662             CPSIE    I
   \                     ??svcRtxEventFlagsSet_5: (+1)
   \   0000003E   0x9100             STR      R1,[SP, #+0]
    273          
    274            // Check if Threads are waiting for Event Flags
    275            thread = ef->thread_list;
   \   00000040   0x68BC             LDR      R4,[R7, #+8]
   \   00000042   0xE00F             B        ??svcRtxEventFlagsSet_6
    276            while (thread != NULL) {
    277              thread_next = thread->thread_next;
    278              event_flags0 = EventFlagsCheck(ef, thread->wait_flags, thread->flags_options);
    279              if (event_flags0 != 0U) {
    280                if ((thread->flags_options & osFlagsNoClear) == 0U) {
    281                  event_flags = event_flags0 & ~thread->wait_flags;
    282                } else {
    283                  event_flags = event_flags0;
   \                     ??svcRtxEventFlagsSet_7: (+1)
   \   00000044   0x9500             STR      R5,[SP, #+0]
    284                }
    285                osRtxThreadListRemove(thread);
   \                     ??svcRtxEventFlagsSet_8: (+1)
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       osRtxThreadListRemove
    286                osRtxThreadWaitExit(thread, event_flags0, false);
   \   0000004C   0x2200             MOVS     R2,#+0
   \   0000004E   0x0029             MOVS     R1,R5
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       osRtxThreadWaitExit
    287                EvrRtxEventFlagsWaitCompleted(ef, thread->wait_flags, thread->flags_options, event_flags0);
   \   00000056   0x002B             MOVS     R3,R5
   \   00000058   0x7EF2             LDRB     R2,[R6, #+27]
   \   0000005A   0x69F1             LDR      R1,[R6, #+28]
   \   0000005C   0x0038             MOVS     R0,R7
   \   0000005E   0x.... 0x....      BL       EvrRtxEventFlagsWaitCompleted
    288              }
    289              thread = thread_next;
   \                     ??svcRtxEventFlagsSet_9: (+1)
   \   00000062   0x9C01             LDR      R4,[SP, #+4]
   \                     ??svcRtxEventFlagsSet_6: (+1)
   \   00000064   0x2C00             CMP      R4,#+0
   \   00000066   0xD012             BEQ      ??svcRtxEventFlagsSet_10
   \   00000068   0x0026             MOVS     R6,R4
   \   0000006A   0x3608             ADDS     R6,R6,#+8
   \   0000006C   0x6830             LDR      R0,[R6, #+0]
   \   0000006E   0x9001             STR      R0,[SP, #+4]
   \   00000070   0x7EF2             LDRB     R2,[R6, #+27]
   \   00000072   0x69F1             LDR      R1,[R6, #+28]
   \   00000074   0x0038             MOVS     R0,R7
   \   00000076   0x.... 0x....      BL       EventFlagsCheck
   \   0000007A   0x0005             MOVS     R5,R0
   \   0000007C   0xD0F1             BEQ      ??svcRtxEventFlagsSet_9
   \   0000007E   0x7EF0             LDRB     R0,[R6, #+27]
   \   00000080   0x0780             LSLS     R0,R0,#+30
   \   00000082   0xD4DF             BMI      ??svcRtxEventFlagsSet_7
   \   00000084   0x69F0             LDR      R0,[R6, #+28]
   \   00000086   0x43C1             MVNS     R1,R0
   \   00000088   0x4029             ANDS     R1,R1,R5
   \   0000008A   0x9100             STR      R1,[SP, #+0]
   \   0000008C   0xE7DB             B        ??svcRtxEventFlagsSet_8
    290            }
    291            osRtxThreadDispatch(NULL);
   \                     ??svcRtxEventFlagsSet_10: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x.... 0x....      BL       osRtxThreadDispatch
    292          
    293            EvrRtxEventFlagsSetDone(ef, event_flags);
   \   00000094   0x9900             LDR      R1,[SP, #+0]
   \   00000096   0x0038             MOVS     R0,R7
   \   00000098   0x.... 0x....      BL       EvrRtxEventFlagsSetDone
    294          
    295            return event_flags;
   \   0000009C   0x9800             LDR      R0,[SP, #+0]
   \                     ??svcRtxEventFlagsSet_4: (+1)
   \   0000009E   0xB003             ADD      SP,SP,#+12
   \   000000A0   0xBDF0             POP      {R4-R7,PC}       ;; return
    296          }
    297          
    298          /// Clear the specified Event Flags.
    299          /// \note API identical to osEventFlagsClear

   \                                 In section .text, align 2, keep-with-next
    300          uint32_t svcRtxEventFlagsClear (osEventFlagsId_t ef_id, uint32_t flags) {
   \                     svcRtxEventFlagsClear: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    301            os_event_flags_t *ef = (os_event_flags_t *)ef_id;
    302            uint32_t          event_flags;
    303          
    304            // Check parameters
    305            if ((ef == NULL) || (ef->id != osRtxIdEventFlags) ||
    306                (flags & ~((1U << osRtxEventFlagsLimit) - 1U))) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD004             BEQ      ??svcRtxEventFlagsClear_0
   \   00000006   0x7802             LDRB     R2,[R0, #+0]
   \   00000008   0x2A03             CMP      R2,#+3
   \   0000000A   0xD101             BNE      ??svcRtxEventFlagsClear_0
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD505             BPL      ??svcRtxEventFlagsClear_1
    307              EvrRtxEventFlagsError(ef, osErrorParameter);
   \                     ??svcRtxEventFlagsClear_0: (+1)
   \   00000010   0x2403             MOVS     R4,#+3
   \   00000012   0x43E4             MVNS     R4,R4            ;; #-4
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0x.... 0x....      BL       EvrRtxEventFlagsError
    308              return ((uint32_t)osErrorParameter);
   \   0000001A   0xE015             B        ??svcRtxEventFlagsClear_2
    309            }
    310          
    311            // Check object state
    312            if (ef->state == osRtxObjectInactive) {
   \                     ??svcRtxEventFlagsClear_1: (+1)
   \   0000001C   0x7842             LDRB     R2,[R0, #+1]
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD105             BNE      ??svcRtxEventFlagsClear_3
    313              EvrRtxEventFlagsError(ef, osErrorResource);
   \   00000022   0x2402             MOVS     R4,#+2
   \   00000024   0x43E4             MVNS     R4,R4            ;; #-3
   \   00000026   0x0021             MOVS     R1,R4
   \   00000028   0x.... 0x....      BL       EvrRtxEventFlagsError
    314              return ((uint32_t)osErrorResource);
   \   0000002C   0xE00C             B        ??svcRtxEventFlagsClear_2
    315            }
    316          
    317            // Clear Event Flags
    318            event_flags = EventFlagsClear(ef, flags);
   \                     ??svcRtxEventFlagsClear_3: (+1)
   \   0000002E   0xF3EF 0x8210      MRS      R2,PRIMASK
   \   00000032   0xB672             CPSID    I
   \   00000034   0x68C3             LDR      R3,[R0, #+12]
   \   00000036   0x001C             MOVS     R4,R3
   \   00000038   0x438B             BICS     R3,R3,R1
   \   0000003A   0x60C3             STR      R3,[R0, #+12]
   \   0000003C   0x2A00             CMP      R2,#+0
   \   0000003E   0xD100             BNE      ??svcRtxEventFlagsClear_4
   \   00000040   0xB662             CPSIE    I
    319          
    320            EvrRtxEventFlagsClearDone(ef, event_flags);
   \                     ??svcRtxEventFlagsClear_4: (+1)
   \   00000042   0x0021             MOVS     R1,R4
   \   00000044   0x.... 0x....      BL       EvrRtxEventFlagsClearDone
    321            
    322            return event_flags;
   \                     ??svcRtxEventFlagsClear_2: (+1)
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
    323          }
    324          
    325          /// Get the current Event Flags.
    326          /// \note API identical to osEventFlagsGet

   \                                 In section .text, align 2, keep-with-next
    327          uint32_t svcRtxEventFlagsGet (osEventFlagsId_t ef_id) {
   \                     svcRtxEventFlagsGet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    328            os_event_flags_t *ef = (os_event_flags_t *)ef_id;
    329          
    330            // Check parameters
    331            if ((ef == NULL) || (ef->id != osRtxIdEventFlags)) {
   \   00000004   0xD005             BEQ      ??svcRtxEventFlagsGet_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2803             CMP      R0,#+3
   \   0000000A   0xD102             BNE      ??svcRtxEventFlagsGet_0
    332              EvrRtxEventFlagsGet(ef, 0U);
    333              return 0U;
    334            }
    335          
    336            // Check object state
    337            if (ef->state == osRtxObjectInactive) {
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE      ??svcRtxEventFlagsGet_1
    338              EvrRtxEventFlagsGet(ef, 0U);
   \                     ??svcRtxEventFlagsGet_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       EvrRtxEventFlagsGet
    339              return 0U;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}
    340            }
    341          
    342            EvrRtxEventFlagsGet(ef, ef->event_flags);
   \                     ??svcRtxEventFlagsGet_1: (+1)
   \   0000001E   0x68E1             LDR      R1,[R4, #+12]
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       EvrRtxEventFlagsGet
    343          
    344            return ef->event_flags;
   \   00000026   0x68E0             LDR      R0,[R4, #+12]
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    345          }
    346          
    347          /// Wait for one or more Event Flags to become signaled.
    348          /// \note API identical to osEventFlagsWait

   \                                 In section .text, align 2, keep-with-next
    349          uint32_t svcRtxEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout) {
   \                     svcRtxEventFlagsWait: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    350            os_event_flags_t *ef = (os_event_flags_t *)ef_id;
    351            os_thread_t      *running_thread;
    352            uint32_t          event_flags;
    353          
    354            running_thread = osRtxThreadGetRunning();
   \   0000000A   0x....             LDR      R0,??DataTable3_1
   \   0000000C   0x6940             LDR      R0,[R0, #+20]
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    355            if (running_thread == NULL) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD106             BNE      ??svcRtxEventFlagsWait_0
    356              EvrRtxEventFlagsError(ef, osRtxErrorKernelNotRunning);
   \   00000014   0x2107             MOVS     R1,#+7
   \   00000016   0x43C9             MVNS     R1,R1            ;; #-8
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       EvrRtxEventFlagsError
    357              return ((uint32_t)osError);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE03E             B        ??svcRtxEventFlagsWait_1
    358            }
    359          
    360            // Check parameters
    361            if ((ef == NULL) || (ef->id != osRtxIdEventFlags) ||
    362                (flags & ~((1U << osRtxEventFlagsLimit) - 1U))) {
   \                     ??svcRtxEventFlagsWait_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD004             BEQ      ??svcRtxEventFlagsWait_2
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0x2803             CMP      R0,#+3
   \   0000002A   0xD101             BNE      ??svcRtxEventFlagsWait_2
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD501             BPL      ??svcRtxEventFlagsWait_3
    363              EvrRtxEventFlagsError(ef, osErrorParameter);
   \                     ??svcRtxEventFlagsWait_2: (+1)
   \   00000030   0x2503             MOVS     R5,#+3
   \   00000032   0xE003             B.N      ??svcRtxEventFlagsWait_4
    364              return ((uint32_t)osErrorParameter);
    365            }
    366          
    367            // Check object state
    368            if (ef->state == osRtxObjectInactive) {
   \                     ??svcRtxEventFlagsWait_3: (+1)
   \   00000034   0x7860             LDRB     R0,[R4, #+1]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD107             BNE      ??svcRtxEventFlagsWait_5
    369              EvrRtxEventFlagsError(ef, osErrorResource);
   \   0000003A   0x2502             MOVS     R5,#+2
   \                     ??svcRtxEventFlagsWait_4: (+1)
   \   0000003C   0x43ED             MVNS     R5,R5            ;; #-3
   \   0000003E   0x0029             MOVS     R1,R5
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       EvrRtxEventFlagsError
    370              return ((uint32_t)osErrorResource);
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0xE02B             B        ??svcRtxEventFlagsWait_6
    371            }
    372          
    373            // Check Event Flags
    374            event_flags = EventFlagsCheck(ef, flags, options);
   \                     ??svcRtxEventFlagsWait_5: (+1)
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       EventFlagsCheck
   \   00000050   0x0007             MOVS     R7,R0
    375            if (event_flags != 0U) {
   \   00000052   0xD007             BEQ      ??svcRtxEventFlagsWait_7
    376              EvrRtxEventFlagsWaitCompleted(ef, flags, options, event_flags);
   \   00000054   0x003B             MOVS     R3,R7
   \   00000056   0x0032             MOVS     R2,R6
   \   00000058   0x0029             MOVS     R1,R5
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       EvrRtxEventFlagsWaitCompleted
    377              return event_flags;
   \   00000060   0x0038             MOVS     R0,R7
   \   00000062   0xE01E             B        ??svcRtxEventFlagsWait_6
    378            }
    379          
    380            // Check if timeout is specified
    381            if (timeout != 0U) {
   \                     ??svcRtxEventFlagsWait_7: (+1)
   \   00000064   0x9802             LDR      R0,[SP, #+8]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD014             BEQ      ??svcRtxEventFlagsWait_8
    382              EvrRtxEventFlagsWaitPending(ef, flags, options, timeout);
   \   0000006A   0x4603             MOV      R3,R0
   \   0000006C   0x0032             MOVS     R2,R6
   \   0000006E   0x0029             MOVS     R1,R5
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       EvrRtxEventFlagsWaitPending
    383              // Store waiting flags and options
    384              running_thread->wait_flags = flags;
   \   00000076   0x9800             LDR      R0,[SP, #+0]
   \   00000078   0x6245             STR      R5,[R0, #+36]
    385              running_thread->flags_options = (uint8_t)options;
   \   0000007A   0x9800             LDR      R0,[SP, #+0]
   \   0000007C   0x2123             MOVS     R1,#+35
   \   0000007E   0x5446             STRB     R6,[R0, R1]
    386              // Suspend current Thread
    387              osRtxThreadListPut((os_object_t*)ef, running_thread);
   \   00000080   0x9900             LDR      R1,[SP, #+0]
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x.... 0x....      BL       osRtxThreadListPut
    388              osRtxThreadWaitEnter(osRtxThreadWaitingEventFlags, timeout);
   \   00000088   0x9902             LDR      R1,[SP, #+8]
   \   0000008A   0x2043             MOVS     R0,#+67
   \   0000008C   0x.... 0x....      BL       osRtxThreadWaitEnter
    389              return ((uint32_t)osErrorTimeout);
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0xE005             B        ??svcRtxEventFlagsWait_1
    390            }
    391          
    392            EvrRtxEventFlagsWaitNotCompleted(ef, flags, options);
   \                     ??svcRtxEventFlagsWait_8: (+1)
   \   00000094   0x0032             MOVS     R2,R6
   \   00000096   0x0029             MOVS     R1,R5
   \   00000098   0x0020             MOVS     R0,R4
   \   0000009A   0x.... 0x....      BL       EvrRtxEventFlagsWaitNotCompleted
    393          
    394            return ((uint32_t)osErrorResource);
   \   0000009E   0x2002             MOVS     R0,#+2
   \                     ??svcRtxEventFlagsWait_1: (+1)
   \   000000A0   0x43C0             MVNS     R0,R0            ;; #-3
   \                     ??svcRtxEventFlagsWait_6: (+1)
   \   000000A2   0xB003             ADD      SP,SP,#+12
   \   000000A4   0xBDF0             POP      {R4-R7,PC}       ;; return
    395          }
    396          
    397          /// Delete an Event Flags object.
    398          /// \note API identical to osEventFlagsDelete

   \                                 In section .text, align 2, keep-with-next
    399          osStatus_t svcRtxEventFlagsDelete (osEventFlagsId_t ef_id) {
   \                     svcRtxEventFlagsDelete: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    400            os_event_flags_t *ef = (os_event_flags_t *)ef_id;
    401            os_thread_t      *thread;
    402          
    403            // Check parameters
    404            if ((ef == NULL) || (ef->id != osRtxIdEventFlags)) {
   \   00000004   0xD002             BEQ      ??svcRtxEventFlagsDelete_0
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2803             CMP      R0,#+3
   \   0000000A   0xD001             BEQ      ??svcRtxEventFlagsDelete_1
    405              EvrRtxEventFlagsError(ef, osErrorParameter);
   \                     ??svcRtxEventFlagsDelete_0: (+1)
   \   0000000C   0x2503             MOVS     R5,#+3
   \   0000000E   0xE003             B.N      ??svcRtxEventFlagsDelete_2
    406              return osErrorParameter;
    407            }
    408          
    409            // Check object state
    410            if (ef->state == osRtxObjectInactive) {
   \                     ??svcRtxEventFlagsDelete_1: (+1)
   \   00000010   0x7860             LDRB     R0,[R4, #+1]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD107             BNE      ??svcRtxEventFlagsDelete_3
    411              EvrRtxEventFlagsError(ef, osErrorResource);
   \   00000016   0x2502             MOVS     R5,#+2
   \                     ??svcRtxEventFlagsDelete_2: (+1)
   \   00000018   0x43ED             MVNS     R5,R5            ;; #-3
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       EvrRtxEventFlagsError
    412              return osErrorResource;
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}
    413            }
    414          
    415            // Mark object as inactive
    416            ef->state = osRtxObjectInactive;
   \                     ??svcRtxEventFlagsDelete_3: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x7060             STRB     R0,[R4, #+1]
    417          
    418            // Unblock waiting threads
    419            if (ef->thread_list != NULL) {
   \   0000002A   0x68A0             LDR      R0,[R4, #+8]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD00C             BEQ      ??svcRtxEventFlagsDelete_4
    420              do {
    421                thread = osRtxThreadListGet((os_object_t*)ef);
   \                     ??svcRtxEventFlagsDelete_5: (+1)
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       osRtxThreadListGet
    422                osRtxThreadWaitExit(thread, (uint32_t)osErrorResource, false);
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x2102             MOVS     R1,#+2
   \   0000003A   0x43C9             MVNS     R1,R1            ;; #-3
   \   0000003C   0x.... 0x....      BL       osRtxThreadWaitExit
    423              } while (ef->thread_list != NULL);
   \   00000040   0x68A0             LDR      R0,[R4, #+8]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD1F4             BNE      ??svcRtxEventFlagsDelete_5
    424              osRtxThreadDispatch(NULL);
   \   00000046   0x.... 0x....      BL       osRtxThreadDispatch
    425            }
    426          
    427            // Free object memory
    428            if (ef->flags & osRtxFlagSystemObject) {
   \                     ??svcRtxEventFlagsDelete_4: (+1)
   \   0000004A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000004C   0x07C0             LSLS     R0,R0,#+31
   \   0000004E   0xD50B             BPL      ??svcRtxEventFlagsDelete_6
    429              if (osRtxInfo.mpi.event_flags != NULL) {
   \   00000050   0x....             LDR      R2,??DataTable9
   \   00000052   0x6910             LDR      R0,[R2, #+16]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD003             BEQ      ??svcRtxEventFlagsDelete_7
    430                osRtxMemoryPoolFree(osRtxInfo.mpi.event_flags, ef);
   \   00000058   0x0021             MOVS     R1,R4
   \   0000005A   0x.... 0x....      BL       osRtxMemoryPoolFree
   \   0000005E   0xE003             B        ??svcRtxEventFlagsDelete_6
    431              } else {
    432                osRtxMemoryFree(osRtxInfo.mem.common, ef);
   \                     ??svcRtxEventFlagsDelete_7: (+1)
   \   00000060   0x0021             MOVS     R1,R4
   \   00000062   0x6810             LDR      R0,[R2, #+0]
   \   00000064   0x.... 0x....      BL       osRtxMemoryFree
    433              }
    434            }
    435          
    436            EvrRtxEventFlagsDestroyed(ef);
   \                     ??svcRtxEventFlagsDelete_6: (+1)
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       EvrRtxEventFlagsDestroyed
    437          
    438            return osOK;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    439          }
    440          
    441          
    442          //  ==== ISR Calls ====
    443          
    444          /// Set the specified Event Flags.
    445          /// \note API identical to osEventFlagsSet
    446          __STATIC_INLINE
    447          uint32_t isrRtxEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags) {
    448            os_event_flags_t *ef = (os_event_flags_t *)ef_id;
    449            uint32_t          event_flags;
    450          
    451            // Check parameters
    452            if ((ef == NULL) || (ef->id != osRtxIdEventFlags) ||
    453                (flags & ~((1U << osRtxEventFlagsLimit) - 1U))) {
    454              EvrRtxEventFlagsError(ef, osErrorParameter);
    455              return ((uint32_t)osErrorParameter);
    456            }
    457          
    458            // Check object state
    459            if (ef->state == osRtxObjectInactive) {
    460              EvrRtxEventFlagsError(ef, osErrorResource);
    461              return ((uint32_t)osErrorResource);
    462            }
    463          
    464            // Set Event Flags
    465            event_flags = EventFlagsSet(ef, flags);
    466          
    467            // Register post ISR processing
    468            osRtxPostProcess((os_object_t *)ef);
    469          
    470            EvrRtxEventFlagsSetDone(ef, event_flags);
    471          
    472            return event_flags;
    473          }
    474          
    475          /// Wait for one or more Event Flags to become signaled.
    476          /// \note API identical to osEventFlagsWait
    477          __STATIC_INLINE
    478          uint32_t isrRtxEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout) {
    479            os_event_flags_t *ef = (os_event_flags_t *)ef_id;
    480            uint32_t          event_flags;
    481          
    482            // Check parameters
    483            if ((ef == NULL) || (ef->id != osRtxIdEventFlags) || (timeout != 0U) ||
    484                (flags & ~((1U << osRtxEventFlagsLimit) - 1U))) {
    485              EvrRtxEventFlagsError(ef, osErrorParameter);
    486              return ((uint32_t)osErrorParameter);
    487            }
    488          
    489            // Check object state
    490            if (ef->state == osRtxObjectInactive) {
    491              EvrRtxEventFlagsError(ef, osErrorResource);
    492              return ((uint32_t)osErrorResource);
    493            }
    494          
    495            // Check Event Flags
    496            event_flags = EventFlagsCheck(ef, flags, options);
    497            if (event_flags != 0U) {
    498              EvrRtxEventFlagsWaitCompleted(ef, flags, options, event_flags);
    499              return ((uint32_t)event_flags);
    500            }
    501          
    502            EvrRtxEventFlagsWaitNotCompleted(ef, flags, options);
    503          
    504            return ((uint32_t)osErrorResource);
    505          }
    506          
    507          
    508          //  ==== Public API ====
    509          
    510          /// Create and Initialize an Event Flags object.

   \                                 In section .text, align 4, keep-with-next
    511          osEventFlagsId_t osEventFlagsNew (const osEventFlagsAttr_t *attr) {
   \                     osEventFlagsNew: (+1)
   \   00000000   0xB598             PUSH     {R3,R4,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    512            EvrRtxEventFlagsNew(attr);
   \   00000004   0x.... 0x....      BL       EvrRtxEventFlagsNew
    513            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000008   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE      ??osEventFlagsNew_0
   \   00000010   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD006             BEQ      ??osEventFlagsNew_1
    514              EvrRtxEventFlagsError(NULL, osErrorISR);
   \                     ??osEventFlagsNew_0: (+1)
   \   00000018   0x2105             MOVS     R1,#+5
   \   0000001A   0x43C9             MVNS     R1,R1            ;; #-6
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       EvrRtxEventFlagsError
    515              return NULL;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD92             POP      {R1,R4,R7,PC}
    516            }
    517            return __svcEventFlagsNew(attr);
   \                     ??osEventFlagsNew_1: (+1)
   \   00000026   0xF3EF 0x8014      MRS      R0,CONTROL
   \   0000002A   0x0780             LSLS     R0,R0,#+30
   \   0000002C   0xD406             BMI      ??osEventFlagsNew_2
   \   0000002E   0xF3EF 0x8008      MRS      R0,MSP
   \   00000032   0x3820             SUBS     R0,R0,#+32
   \   00000034   0x2107             MOVS     R1,#+7
   \   00000036   0x4388             BICS     R0,R0,R1
   \   00000038   0xF380 0x8809      MSR      PSP,R0
   \                     ??osEventFlagsNew_2: (+1)
   \   0000003C   0x....             LDR      R0,??DataTable9_1
   \   0000003E   0x4607             mov r7,R0
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0xDF00             SVC      0x0
   \   00000044   0xBD92             POP      {R1,R4,R7,PC}    ;; return
    518          }
    519          
    520          /// Get name of an Event Flags object.

   \                                 In section .text, align 4, keep-with-next
    521          const char *osEventFlagsGetName (osEventFlagsId_t ef_id) {
   \                     osEventFlagsGetName: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    522            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8105      MRS      R1,IPSR
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE      ??osEventFlagsGetName_0
   \   0000000A   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD004             BEQ      ??osEventFlagsGetName_1
    523              EvrRtxEventFlagsGetName(ef_id, NULL);
   \                     ??osEventFlagsGetName_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x.... 0x....      BL       EvrRtxEventFlagsGetName
    524              return NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD80             POP      {R7,PC}
    525            }
    526            return __svcEventFlagsGetName(ef_id);
   \                     ??osEventFlagsGetName_1: (+1)
   \   0000001C   0x....             LDR      R1,??DataTable9_2
   \   0000001E   0x460F             mov r7,R1
   \   00000020   0xDF00             SVC      0x0
   \   00000022   0xBD80             POP      {R7,PC}          ;; return
    527          }
    528          
    529          /// Set the specified Event Flags.

   \                                 In section .text, align 4, keep-with-next
    530          uint32_t osEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags) {
   \                     osEventFlagsSet: (+1)
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    531            EvrRtxEventFlagsSet(ef_id, flags);
   \   00000006   0x.... 0x....      BL       EvrRtxEventFlagsSet
    532            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   0000000A   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD103             BNE      ??osEventFlagsSet_0
   \   00000012   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD024             BEQ      ??osEventFlagsSet_1
    533              return isrRtxEventFlagsSet(ef_id, flags);
   \                     ??osEventFlagsSet_0: (+1)
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD01A             BEQ      ??osEventFlagsSet_2
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x2803             CMP      R0,#+3
   \   00000022   0xD117             BNE      ??osEventFlagsSet_2
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD415             BMI      ??osEventFlagsSet_2
   \   00000028   0x7860             LDRB     R0,[R4, #+1]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD101             BNE      ??osEventFlagsSet_3
   \   0000002E   0x2502             MOVS     R5,#+2
   \   00000030   0xE011             B        ??osEventFlagsSet_4
   \                     ??osEventFlagsSet_3: (+1)
   \   00000032   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000036   0xB672             CPSID    I
   \   00000038   0x68E1             LDR      R1,[R4, #+12]
   \   0000003A   0x430D             ORRS     R5,R5,R1
   \   0000003C   0x60E5             STR      R5,[R4, #+12]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD100             BNE      ??osEventFlagsSet_5
   \   00000042   0xB662             CPSIE    I
   \                     ??osEventFlagsSet_5: (+1)
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       osRtxPostProcess
   \   0000004A   0x0029             MOVS     R1,R5
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       EvrRtxEventFlagsSetDone
   \   00000052   0xE005             B        ??osEventFlagsSet_6
   \                     ??osEventFlagsSet_2: (+1)
   \   00000054   0x2503             MOVS     R5,#+3
   \                     ??osEventFlagsSet_4: (+1)
   \   00000056   0x43ED             MVNS     R5,R5            ;; #-4
   \   00000058   0x0029             MOVS     R1,R5
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       EvrRtxEventFlagsError
    534            } else {
   \                     ??osEventFlagsSet_6: (+1)
   \   00000060   0x0028             MOVS     R0,R5
   \   00000062   0xBDB0             POP      {R4,R5,R7,PC}
    535              return  __svcEventFlagsSet(ef_id, flags);
   \                     ??osEventFlagsSet_1: (+1)
   \   00000064   0x....             LDR      R0,??DataTable9_3
   \   00000066   0x4607             mov r7,R0
   \   00000068   0x0029             MOVS     R1,R5
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0xDF00             SVC      0x0
   \   0000006E   0xBDB0             POP      {R4,R5,R7,PC}    ;; return
    536            }
    537          }
    538          
    539          /// Clear the specified Event Flags.

   \                                 In section .text, align 4, keep-with-next
    540          uint32_t osEventFlagsClear (osEventFlagsId_t ef_id, uint32_t flags) {
   \                     osEventFlagsClear: (+1)
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    541            EvrRtxEventFlagsClear(ef_id, flags);
   \   00000006   0x.... 0x....      BL       EvrRtxEventFlagsClear
    542            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   0000000A   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD103             BNE      ??osEventFlagsClear_0
   \   00000012   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ      ??osEventFlagsClear_1
    543              return svcRtxEventFlagsClear(ef_id, flags);
   \                     ??osEventFlagsClear_0: (+1)
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       svcRtxEventFlagsClear
   \   00000022   0xBDB0             POP      {R4,R5,R7,PC}
    544            } else {
    545              return  __svcEventFlagsClear(ef_id, flags);
   \                     ??osEventFlagsClear_1: (+1)
   \   00000024   0x....             LDR      R0,??DataTable9_4
   \   00000026   0x4607             mov r7,R0
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0xDF00             SVC      0x0
   \   0000002E   0xBDB0             POP      {R4,R5,R7,PC}    ;; return
    546            }
    547          }
    548          
    549          /// Get the current Event Flags.

   \                                 In section .text, align 4, keep-with-next
    550          uint32_t osEventFlagsGet (osEventFlagsId_t ef_id) {
   \                     osEventFlagsGet: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    551            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000002   0xF3EF 0x8105      MRS      R1,IPSR
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE      ??osEventFlagsGet_0
   \   0000000A   0xF3EF 0x8110      MRS      R1,PRIMASK
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD002             BEQ      ??osEventFlagsGet_1
    552              return svcRtxEventFlagsGet(ef_id);
   \                     ??osEventFlagsGet_0: (+1)
   \   00000012   0x.... 0x....      BL       svcRtxEventFlagsGet
   \   00000016   0xBD80             POP      {R7,PC}
    553            } else {
    554              return  __svcEventFlagsGet(ef_id);
   \                     ??osEventFlagsGet_1: (+1)
   \   00000018   0x....             LDR      R1,??DataTable9_5
   \   0000001A   0x460F             mov r7,R1
   \   0000001C   0xDF00             SVC      0x0
   \   0000001E   0xBD80             POP      {R7,PC}          ;; return
    555            }
    556          }
    557          
    558          /// Wait for one or more Event Flags to become signaled.

   \                                 In section .text, align 4, keep-with-next
    559          uint32_t osEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout) {
   \                     osEventFlagsWait: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x001D             MOVS     R5,R3
    560            EvrRtxEventFlagsWait(ef_id, flags, options, timeout);
   \   00000008   0x.... 0x....      BL       EvrRtxEventFlagsWait
    561            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   0000000C   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD103             BNE      ??osEventFlagsWait_0
   \   00000014   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD02B             BEQ      ??osEventFlagsWait_1
    562              return isrRtxEventFlagsWait(ef_id, flags, options, timeout);
   \                     ??osEventFlagsWait_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD021             BEQ      ??osEventFlagsWait_2
   \   00000020   0x7820             LDRB     R0,[R4, #+0]
   \   00000022   0x2803             CMP      R0,#+3
   \   00000024   0xD11E             BNE      ??osEventFlagsWait_2
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD11C             BNE      ??osEventFlagsWait_2
   \   0000002A   0x2E00             CMP      R6,#+0
   \   0000002C   0xD41A             BMI      ??osEventFlagsWait_2
   \   0000002E   0x7860             LDRB     R0,[R4, #+1]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD101             BNE      ??osEventFlagsWait_3
   \   00000034   0x2502             MOVS     R5,#+2
   \   00000036   0xE016             B        ??osEventFlagsWait_4
   \                     ??osEventFlagsWait_3: (+1)
   \   00000038   0x9A00             LDR      R2,[SP, #+0]
   \   0000003A   0x0031             MOVS     R1,R6
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       EventFlagsCheck
   \   00000042   0x0005             MOVS     R5,R0
   \   00000044   0xD006             BEQ      ??osEventFlagsWait_5
   \   00000046   0x002B             MOVS     R3,R5
   \   00000048   0x9A00             LDR      R2,[SP, #+0]
   \   0000004A   0x0031             MOVS     R1,R6
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       EvrRtxEventFlagsWaitCompleted
   \   00000052   0xE00D             B        ??osEventFlagsWait_6
   \                     ??osEventFlagsWait_5: (+1)
   \   00000054   0x9A00             LDR      R2,[SP, #+0]
   \   00000056   0x0031             MOVS     R1,R6
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       EvrRtxEventFlagsWaitNotCompleted
   \   0000005E   0x2502             MOVS     R5,#+2
   \   00000060   0x43ED             MVNS     R5,R5            ;; #-3
   \   00000062   0xE005             B        ??osEventFlagsWait_6
   \                     ??osEventFlagsWait_2: (+1)
   \   00000064   0x2503             MOVS     R5,#+3
   \                     ??osEventFlagsWait_4: (+1)
   \   00000066   0x43ED             MVNS     R5,R5            ;; #-4
   \   00000068   0x0029             MOVS     R1,R5
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       EvrRtxEventFlagsError
    563            } else {
   \                     ??osEventFlagsWait_6: (+1)
   \   00000070   0x0028             MOVS     R0,R5
   \   00000072   0xBDF2             POP      {R1,R4-R7,PC}
    564              return  __svcEventFlagsWait(ef_id, flags, options, timeout);
   \                     ??osEventFlagsWait_1: (+1)
   \   00000074   0x....             LDR      R0,??DataTable9_6
   \   00000076   0x4607             mov r7,R0
   \   00000078   0x002B             MOVS     R3,R5
   \   0000007A   0x9A00             LDR      R2,[SP, #+0]
   \   0000007C   0x0031             MOVS     R1,R6
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0xDF00             SVC      0x0
   \   00000082   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    565            }
    566          }
    567          
    568          /// Delete an Event Flags object.

   \                                 In section .text, align 4, keep-with-next
    569          osStatus_t osEventFlagsDelete (osEventFlagsId_t ef_id) {
   \                     osEventFlagsDelete: (+1)
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    570            EvrRtxEventFlagsDelete(ef_id);
   \   00000004   0x.... 0x....      BL       EvrRtxEventFlagsDelete
    571            if (IS_IRQ_MODE() || IS_IRQ_MASKED()) {
   \   00000008   0xF3EF 0x8005      MRS      R0,IPSR
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE      ??osEventFlagsDelete_0
   \   00000010   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD007             BEQ      ??osEventFlagsDelete_1
    572              EvrRtxEventFlagsError(ef_id, osErrorISR);
   \                     ??osEventFlagsDelete_0: (+1)
   \   00000018   0x2505             MOVS     R5,#+5
   \   0000001A   0x43ED             MVNS     R5,R5            ;; #-6
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       EvrRtxEventFlagsError
    573              return osErrorISR;
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0xBDB0             POP      {R4,R5,R7,PC}
    574            }
    575            return __svcEventFlagsDelete(ef_id);
   \                     ??osEventFlagsDelete_1: (+1)
   \   00000028   0x....             LDR      R0,??DataTable9_7
   \   0000002A   0x4607             mov r7,R0
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0xDF00             SVC      0x0
   \   00000030   0xBDB0             POP      {R4,R5,R7,PC}    ;; return
    576          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     osRtxEventFlagsPostProcess

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     osRtxInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     osRtxInfo+0x64

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     osRtxInfo+0x80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     svcRtxEventFlagsNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     svcRtxEventFlagsGetName

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     svcRtxEventFlagsSet

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     svcRtxEventFlagsClear

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     svcRtxEventFlagsGet

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     svcRtxEventFlagsWait

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     svcRtxEventFlagsDelete

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   EventFlagsCheck
      16   osEventFlagsClear
        16   -> EvrRtxEventFlagsClear
        16   -> svcRtxEventFlagsClear
      16   osEventFlagsDelete
        16   -> EvrRtxEventFlagsDelete
        16   -> EvrRtxEventFlagsError
       8   osEventFlagsGet
         8   -> svcRtxEventFlagsGet
       8   osEventFlagsGetName
         8   -> EvrRtxEventFlagsGetName
      16   osEventFlagsNew
        16   -> EvrRtxEventFlagsError
        16   -> EvrRtxEventFlagsNew
      16   osEventFlagsSet
        16   -> EvrRtxEventFlagsError
        16   -> EvrRtxEventFlagsSet
        16   -> EvrRtxEventFlagsSetDone
        16   -> osRtxPostProcess
      24   osEventFlagsWait
        24   -> EventFlagsCheck
        24   -> EvrRtxEventFlagsError
        24   -> EvrRtxEventFlagsWait
        24   -> EvrRtxEventFlagsWaitCompleted
        24   -> EvrRtxEventFlagsWaitNotCompleted
      24   osRtxEventFlagsPostProcess
        24   -> EventFlagsCheck
        24   -> EvrRtxEventFlagsWaitCompleted
        24   -> osRtxThreadListRemove
        24   -> osRtxThreadWaitExit
       8   svcRtxEventFlagsClear
         8   -> EvrRtxEventFlagsClearDone
         8   -> EvrRtxEventFlagsError
      16   svcRtxEventFlagsDelete
        16   -> EvrRtxEventFlagsDestroyed
        16   -> EvrRtxEventFlagsError
        16   -> osRtxMemoryFree
        16   -> osRtxMemoryPoolFree
        16   -> osRtxThreadDispatch
        16   -> osRtxThreadListGet
        16   -> osRtxThreadWaitExit
       8   svcRtxEventFlagsGet
         8   -> EvrRtxEventFlagsGet
       8   svcRtxEventFlagsGetName
         8   -> EvrRtxEventFlagsGetName
      16   svcRtxEventFlagsNew
        16   -> EvrRtxEventFlagsCreated
        16   -> EvrRtxEventFlagsError
        16   -> osRtxMemoryAlloc
        16   -> osRtxMemoryPoolAlloc
      32   svcRtxEventFlagsSet
        32   -> EventFlagsCheck
        32   -> EvrRtxEventFlagsError
        32   -> EvrRtxEventFlagsSetDone
        32   -> EvrRtxEventFlagsWaitCompleted
        32   -> osRtxThreadDispatch
        32   -> osRtxThreadListRemove
        32   -> osRtxThreadWaitExit
      32   svcRtxEventFlagsWait
        32   -> EventFlagsCheck
        32   -> EvrRtxEventFlagsError
        32   -> EvrRtxEventFlagsWaitCompleted
        32   -> EvrRtxEventFlagsWaitNotCompleted
        32   -> EvrRtxEventFlagsWaitPending
        32   -> osRtxThreadListPut
        32   -> osRtxThreadWaitEnter


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable4
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
      80  EventFlagsCheck
      48  osEventFlagsClear
      50  osEventFlagsDelete
      32  osEventFlagsGet
      36  osEventFlagsGetName
      70  osEventFlagsNew
     112  osEventFlagsSet
     132  osEventFlagsWait
      70  osRtxEventFlagsPostProcess
      76  svcRtxEventFlagsClear
     114  svcRtxEventFlagsDelete
      42  svcRtxEventFlagsGet
      42  svcRtxEventFlagsGetName
     118  svcRtxEventFlagsNew
     162  svcRtxEventFlagsSet
     166  svcRtxEventFlagsWait

 
 1 394 bytes in section .text
 
 1 394 bytes of CODE memory

Errors: none
Warnings: 1

###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:51
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\rtos\TARGET_CORTEX\rtx4\cmsis_os1.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx4\cmsis_os1.d
#        -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx4\cmsis_os1.s.txt
#        -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx4\cmsis_os1.o
#        .\mbed-os\rtos\TARGET_CORTEX\rtx4\cmsis_os1.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx4\cmsis_os1.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\rtos\TARGET_CORTEX\rtx4\cmsis_os1.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\rtos\TARGET_CORTEX\rtx4\cmsis_os1.c
      1          /*
      2           * Copyright (c) 2013-2017 ARM Limited. All rights reserved.
      3           *
      4           * SPDX-License-Identifier: Apache-2.0
      5           *
      6           * Licensed under the Apache License, Version 2.0 (the License); you may
      7           * not use this file except in compliance with the License.
      8           * You may obtain a copy of the License at
      9           *
     10           * www.apache.org/licenses/LICENSE-2.0
     11           *
     12           * Unless required by applicable law or agreed to in writing, software
     13           * distributed under the License is distributed on an AS IS BASIS, WITHOUT
     14           * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15           * See the License for the specific language governing permissions and
     16           * limitations under the License.
     17           *
     18           * ----------------------------------------------------------------------
     19           *
     20           * $Date:        10. January 2017
     21           * $Revision:    V1.2
     22           *
     23           * Project:      CMSIS-RTOS API V1
     24           * Title:        cmsis_os_v1.c V1 module file
     25           *---------------------------------------------------------------------------*/
     26          
     27          #include <string.h>
     28          #include "cmsis_os.h"
     29          
     30          #if (osCMSIS >= 0x20000U) && !defined(os1_Disable)
     31          
     32          
     33          // Thread
     34          #if !defined(os1_Disable_Thread)

   \                                 In section .text, align 2, keep-with-next
     35          osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument) {
     36          
     37            if (thread_def == NULL) {
   \                     osThreadCreate: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD100             BNE      ??osThreadCreate_0
   \   00000004   0x4770             BX       LR
     38              return NULL;
     39            }
     40            return osThreadNew((osThreadFunc_t)thread_def->pthread, argument, &thread_def->attr);
   \                     ??osThreadCreate_0: (+1)
   \   00000006   0xB580             PUSH     {R7,LR}
   \   00000008   0x1D02             ADDS     R2,R0,#+4
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x.... 0x....      BL       osThreadNew
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
     41          }
     42          #endif
     43          
     44          
     45          // Signals
     46          
     47          #if !defined(os1_Disable_Signal)
     48          
     49          #define SignalMask ((1U<<osFeature_Signals)-1U)
     50          

   \                                 In section .text, align 2, keep-with-next
     51          int32_t osSignalSet (osThreadId thread_id, int32_t signals) {
   \                     osSignalSet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
     52            uint32_t flags;
     53          
     54            flags = osThreadFlagsSet(thread_id, (uint32_t)signals);
   \   00000004   0x.... 0x....      BL       osThreadFlagsSet
     55            if ((flags & 0x80000000U) != 0U) {
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD502             BPL      ??osSignalSet_0
     56              return ((int32_t)0x80000000U);
   \   0000000C   0x2080             MOVS     R0,#+128
   \   0000000E   0x0600             LSLS     R0,R0,#+24       ;; #-2147483648
   \   00000010   0xBD10             POP      {R4,PC}
     57            }
     58            return ((int32_t)(flags & ~((uint32_t)signals)));
   \                     ??osSignalSet_0: (+1)
   \   00000012   0x43A0             BICS     R0,R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
     59          }
     60          

   \                                 In section .text, align 2, keep-with-next
     61          int32_t osSignalClear (osThreadId thread_id, int32_t signals) {
   \                     osSignalClear: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
     62            uint32_t flags;
     63          
     64            if (thread_id != osThreadGetId()) {
   \   00000006   0x.... 0x....      BL       osThreadGetId
   \   0000000A   0x4285             CMP      R5,R0
   \   0000000C   0xD104             BNE      ??osSignalClear_0
     65              return ((int32_t)0x80000000U);
     66            }
     67            flags = osThreadFlagsClear((uint32_t)signals);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       osThreadFlagsClear
     68            if ((flags & 0x80000000U) != 0U) {
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD501             BPL      ??osSignalClear_1
     69              return ((int32_t)0x80000000U);
   \                     ??osSignalClear_0: (+1)
   \   00000018   0x2080             MOVS     R0,#+128
   \   0000001A   0x0600             LSLS     R0,R0,#+24       ;; #-2147483648
     70            }
     71            return ((int32_t)flags);
   \                     ??osSignalClear_1: (+1)
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     72          }
     73          

   \                                 In section .text, align 2, keep-with-next
     74          os_InRegs osEvent osSignalWait (int32_t signals, uint32_t millisec) {
   \                     osSignalWait: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0008             MOVS     R0,R1
     75            osEvent  event;
     76            uint32_t flags;
     77          
     78            if (signals != 0) {
   \   00000008   0xD001             BEQ      ??osSignalWait_0
     79              flags = osThreadFlagsWait((uint32_t)signals, osFlagsWaitAll, millisec);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0xE001             B        ??osSignalWait_1
     80            } else {
     81              flags = osThreadFlagsWait(SignalMask,        osFlagsWaitAny, millisec);
   \                     ??osSignalWait_0: (+1)
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x....             LDR      R0,??DataTable0  ;; 0x7fffffff
   \                     ??osSignalWait_1: (+1)
   \   00000012   0x.... 0x....      BL       osThreadFlagsWait
     82            }
     83            if ((flags > 0U) && (flags < 0x80000000U)) {
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD016             BEQ      ??osSignalWait_2
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x0609             LSLS     R1,R1,#+24       ;; #-2147483648
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD203             BCS      ??osSignalWait_3
     84              event.status = osEventSignal;
   \   00000022   0x2108             MOVS     R1,#+8
   \   00000024   0x9100             STR      R1,[SP, #+0]
     85              event.value.signals = (int32_t)flags;
   \   00000026   0x9001             STR      R0,[SP, #+4]
   \   00000028   0xE00F             B        ??osSignalWait_4
     86            } else {
     87              switch ((int32_t)flags) {
   \                     ??osSignalWait_3: (+1)
   \   0000002A   0x2203             MOVS     R2,#+3
   \   0000002C   0x43D2             MVNS     R2,R2            ;; #-4
   \   0000002E   0x1A81             SUBS     R1,R0,R2
   \   00000030   0xD008             BEQ      ??osSignalWait_5
   \   00000032   0x1E49             SUBS     R1,R1,#+1
   \   00000034   0xD002             BEQ      ??osSignalWait_6
   \   00000036   0x1E49             SUBS     R1,R1,#+1
   \   00000038   0xD002             BEQ      ??osSignalWait_7
   \   0000003A   0xE005             B        ??osSignalWait_2
     88                case osErrorResource:
     89                  event.status = osOK;
   \                     ??osSignalWait_6: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE003             B        ??osSignalWait_2
     90                  break;
     91                case osErrorTimeout:
     92                  event.status = osEventTimeout;
   \                     ??osSignalWait_7: (+1)
   \   00000040   0x2040             MOVS     R0,#+64
   \   00000042   0xE001             B        ??osSignalWait_2
     93                  break;
     94                case osErrorParameter:
     95                  event.status = osErrorValue;
   \                     ??osSignalWait_5: (+1)
   \   00000044   0x207E             MOVS     R0,#+126
   \   00000046   0x43C0             MVNS     R0,R0            ;; #-127
     96                  break;
     97                default:
     98                  event.status = (osStatus)flags;
   \                     ??osSignalWait_2: (+1)
   \   00000048   0x9000             STR      R0,[SP, #+0]
     99                  break;
    100              }
    101            }
    102            return event;
   \                     ??osSignalWait_4: (+1)
   \   0000004A   0x4668             MOV      R0,SP
   \   0000004C   0x....             B.N      ??Subroutine0_0
    103          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xA801             ADD      R0,SP,#+4
   \                     ??Subroutine0_0: (+1)
   \   00000002   0xC80E             LDM      R0!,{R1-R3}
   \   00000004   0xC40E             STM      R4!,{R1-R3}
   \   00000006   0xB004             ADD      SP,SP,#+16
   \   00000008   0xBD10             POP      {R4,PC}          ;; return
    104          
    105          #endif  // Signal
    106          
    107          
    108          // Timer
    109          #if !defined(os1_Disable_Timer)

   \                                 In section .text, align 2, keep-with-next
    110          osTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument) {
    111          
    112            if (timer_def == NULL) {
   \                     osTimerCreate: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD100             BNE      ??osTimerCreate_0
   \   00000004   0x4770             BX       LR
    113              return NULL;
    114            }
    115            return osTimerNew((osTimerFunc_t)timer_def->ptimer, type, argument, &timer_def->attr);
   \                     ??osTimerCreate_0: (+1)
   \   00000006   0xB580             PUSH     {R7,LR}
   \   00000008   0x1D03             ADDS     R3,R0,#+4
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x.... 0x....      BL       osTimerNew
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    116          }
    117          #endif
    118          
    119          
    120          // Mutex
    121          #if !defined(os1_Disable_Mutex)

   \                                 In section .text, align 2, keep-with-next
    122          osMutexId osMutexCreate (const osMutexDef_t *mutex_def) {
    123          
    124            if (mutex_def == NULL) {
   \                     osMutexCreate: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD100             BNE      ??osMutexCreate_0
   \   00000004   0x4770             BX       LR
    125              return NULL;
    126            }
    127            return osMutexNew(mutex_def);
   \                     ??osMutexCreate_0: (+1)
   \   00000006   0xB580             PUSH     {R7,LR}
   \   00000008   0x.... 0x....      BL       osMutexNew
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    128          }
    129          #endif
    130          
    131          
    132          // Semaphore
    133          
    134          #if (defined (osFeature_Semaphore) && (osFeature_Semaphore != 0U)) && !defined(os1_Disable_Semaphore)
    135          

   \                                 In section .text, align 2, keep-with-next
    136          osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count) {
    137          
    138            if (semaphore_def == NULL) {
   \                     osSemaphoreCreate: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD100             BNE      ??osSemaphoreCreate_0
   \   00000004   0x4770             BX       LR
    139              return NULL;
    140            }
    141            return osSemaphoreNew((uint32_t)count, (uint32_t)count, semaphore_def);
   \                     ??osSemaphoreCreate_0: (+1)
   \   00000006   0xB580             PUSH     {R7,LR}
   \   00000008   0x0002             MOVS     R2,R0
   \   0000000A   0x0008             MOVS     R0,R1
   \   0000000C   0x.... 0x....      BL       osSemaphoreNew
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    142          }
    143          

   \                                 In section .text, align 2, keep-with-next
    144          int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec) {
   \                     osSemaphoreWait: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    145            osStatus_t status;
    146            uint32_t   count;
    147          
    148            status = osSemaphoreAcquire(semaphore_id, millisec);
    149            switch (status) {
   \   00000004   0x.... 0x....      BL       osSemaphoreAcquire
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD005             BEQ      ??osSemaphoreWait_0
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0x43C9             MVNS     R1,R1            ;; #-3
   \   00000010   0x1A40             SUBS     R0,R0,R1
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD905             BLS      ??osSemaphoreWait_1
   \   00000016   0xE006             B        ??osSemaphoreWait_2
    150              case osOK:
    151                count = osSemaphoreGetCount(semaphore_id);
    152                return ((int32_t)count + 1);
   \                     ??osSemaphoreWait_0: (+1)
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       osSemaphoreGetCount
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0xBD10             POP      {R4,PC}
    153              case osErrorResource:
    154              case osErrorTimeout:
    155                return 0;
   \                     ??osSemaphoreWait_1: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD10             POP      {R4,PC}
    156              default:
    157                break;
    158            }
    159            return -1;
   \                     ??osSemaphoreWait_2: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    160          }
    161          
    162          #endif  // Semaphore
    163          
    164          
    165          // Memory Pool
    166          
    167          #if (defined(osFeature_Pool) && (osFeature_Pool != 0))&& !defined(os1_Disable_Pool)
    168          

   \                                 In section .text, align 2, keep-with-next
    169          osPoolId osPoolCreate (const osPoolDef_t *pool_def) {
    170          
    171            if (pool_def == NULL) {
   \                     osPoolCreate: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD100             BNE      ??osPoolCreate_0
   \   00000004   0x4770             BX       LR
    172              return NULL;
    173            }
    174            return osMemoryPoolNew(pool_def->pool_sz, pool_def->item_sz, &pool_def->attr);
   \                     ??osPoolCreate_0: (+1)
   \   00000006   0xB580             PUSH     {R7,LR}
   \   00000008   0x0002             MOVS     R2,R0
   \   0000000A   0x3208             ADDS     R2,R2,#+8
   \   0000000C   0x6841             LDR      R1,[R0, #+4]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x.... 0x....      BL       osMemoryPoolNew
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    175          }
    176          

   \                                 In section .text, align 2, keep-with-next
    177          void *osPoolAlloc (osPoolId pool_id) {
   \                     osPoolAlloc: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    178            return osMemoryPoolAlloc(pool_id, 0U);
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      BL       osMemoryPoolAlloc
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    179          }
    180          

   \                                 In section .text, align 2, keep-with-next
    181          void *osPoolCAlloc (osPoolId pool_id) {
   \                     osPoolCAlloc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    182            void    *block;
    183            uint32_t block_size;
    184          
    185            block_size = osMemoryPoolGetBlockSize((osMemoryPoolId_t)pool_id);
   \   00000004   0x.... 0x....      BL       osMemoryPoolGetBlockSize
   \   00000008   0x0004             MOVS     R4,R0
    186            if (block_size == 0U) {
   \   0000000A   0xD101             BNE      ??osPoolCAlloc_0
    187              return NULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    188            }
    189            block = osMemoryPoolAlloc(pool_id, 0U);
   \                     ??osPoolCAlloc_0: (+1)
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       osMemoryPoolAlloc
   \   00000018   0x0005             MOVS     R5,R0
    190            if (block != NULL) {
   \   0000001A   0xD002             BEQ      ??osPoolCAlloc_1
    191              memset(block, 0, block_size);
   \   0000001C   0x0021             MOVS     R1,R4
   \   0000001E   0x.... 0x....      BL       __aeabi_memclr
    192            }
    193            return block;
   \                     ??osPoolCAlloc_1: (+1)
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    194          }
    195          

   \                                 In section .text, align 2, keep-with-next
    196          osStatus osPoolFree (osPoolId pool_id, void *block) {
   \                     osPoolFree: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    197            return osMemoryPoolFree(pool_id, block);
   \   00000002   0x.... 0x....      BL       osMemoryPoolFree
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    198          }
    199          
    200          #endif  // Memory Pool
    201          
    202          
    203          // Message Queue
    204          
    205          #if (defined(osFeature_MessageQ) && (osFeature_MessageQ != 0)) && !defined(os1_Disable_MessageQ)
    206          

   \                                 In section .text, align 2, keep-with-next
    207          osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id) {
    208            (void)thread_id;
    209          
    210            if (queue_def == NULL) {
   \                     osMessageCreate: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD100             BNE      ??osMessageCreate_0
   \   00000004   0x4770             BX       LR
    211              return NULL;
    212            }
    213            return osMessageQueueNew(queue_def->queue_sz, sizeof(uint32_t), &queue_def->attr);
   \                     ??osMessageCreate_0: (+1)
   \   00000006   0xB580             PUSH     {R7,LR}
   \   00000008   0x1D02             ADDS     R2,R0,#+4
   \   0000000A   0x2104             MOVS     R1,#+4
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       osMessageQueueNew
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
    214          }
    215          

   \                                 In section .text, align 2, keep-with-next
    216          osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec) {
   \                     osMessagePut: (+1)
   \   00000000   0xB502             PUSH     {R1,LR}
    217            return osMessageQueuePut(queue_id, &info, 0U, millisec);
   \   00000002   0x0013             MOVS     R3,R2
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x.... 0x....      BL       osMessageQueuePut
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    218          }
    219          

   \                                 In section .text, align 2, keep-with-next
    220          os_InRegs osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec) {
   \                     osMessageGet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0008             MOVS     R0,R1
    221            osStatus_t status;
    222            osEvent    event;
    223            uint32_t   message;
    224          
    225            status = osMessageQueueGet(queue_id, &message, NULL, millisec);
   \   00000008   0x0013             MOVS     R3,R2
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x.... 0x....      BL       osMessageQueueGet
    226            switch (status) {
   \   00000012   0x0001             MOVS     R1,R0
   \   00000014   0xD006             BEQ      ??osMessageGet_0
   \   00000016   0x2202             MOVS     R2,#+2
   \   00000018   0x43D2             MVNS     R2,R2            ;; #-3
   \   0000001A   0x1A81             SUBS     R1,R0,R2
   \   0000001C   0xD007             BEQ      ??osMessageGet_1
   \   0000001E   0x1E49             SUBS     R1,R1,#+1
   \   00000020   0xD007             BEQ      ??osMessageGet_2
   \   00000022   0xE007             B        ??osMessageGet_3
    227              case osOK:
    228                event.status = osEventMessage;
   \                     ??osMessageGet_0: (+1)
   \   00000024   0x2010             MOVS     R0,#+16
   \   00000026   0x9001             STR      R0,[SP, #+4]
    229                event.value.v = message;
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x9002             STR      R0,[SP, #+8]
    230                break;
   \   0000002C   0xE003             B        ??osMessageGet_4
    231              case osErrorResource:
    232                event.status = osOK;
   \                     ??osMessageGet_1: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE000             B        ??osMessageGet_3
    233                break;
    234              case osErrorTimeout:
    235                event.status = osEventTimeout;
   \                     ??osMessageGet_2: (+1)
   \   00000032   0x2040             MOVS     R0,#+64
    236                break;
    237              default:
    238                event.status = status;
   \                     ??osMessageGet_3: (+1)
   \   00000034   0x9001             STR      R0,[SP, #+4]
    239                break;
    240            }
    241            return event;
   \                     ??osMessageGet_4: (+1)
   \   00000036   0x....             B.N      ?Subroutine0
    242          }
    243          
    244          #endif  // Message Queue
    245          
    246          
    247          // Mail Queue
    248          
    249          #if (defined(osFeature_MailQ) && (osFeature_MailQ != 0)) && !defined(os1_Disable_MailQ)
    250          
    251          typedef struct os_mail_queue_s {
    252            osMemoryPoolId_t   mp_id;
    253            osMessageQueueId_t mq_id;
    254          } os_mail_queue_t;
    255          

   \                                 In section .text, align 2, keep-with-next
    256          osMailQId osMailCreate (const osMailQDef_t *queue_def, osThreadId thread_id) {
   \                     osMailCreate: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    257            os_mail_queue_t *ptr;
    258            (void)thread_id;
    259          
    260            if (queue_def == NULL) {
   \   00000004   0xD01D             BEQ      ??osMailCreate_0
    261              return NULL;
    262            }
    263          
    264            ptr = queue_def->mail;
   \   00000006   0x68AC             LDR      R4,[R5, #+8]
    265            if (ptr == NULL) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD01A             BEQ      ??osMailCreate_0
    266              return NULL;
    267            }
    268          
    269            ptr->mp_id = osMemoryPoolNew  (queue_def->queue_sz, queue_def->item_sz, &queue_def->mp_attr);
   \   0000000C   0x002A             MOVS     R2,R5
   \   0000000E   0x320C             ADDS     R2,R2,#+12
   \   00000010   0x6869             LDR      R1,[R5, #+4]
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x.... 0x....      BL       osMemoryPoolNew
   \   00000018   0x6020             STR      R0,[R4, #+0]
    270            ptr->mq_id = osMessageQueueNew(queue_def->queue_sz, sizeof(void *), &queue_def->mq_attr);
   \   0000001A   0x002A             MOVS     R2,R5
   \   0000001C   0x3224             ADDS     R2,R2,#+36
   \   0000001E   0x2104             MOVS     R1,#+4
   \   00000020   0x6828             LDR      R0,[R5, #+0]
   \   00000022   0x.... 0x....      BL       osMessageQueueNew
   \   00000026   0x6060             STR      R0,[R4, #+4]
    271            if ((ptr->mp_id == NULL) || (ptr->mq_id == NULL)) {
   \   00000028   0x6821             LDR      R1,[R4, #+0]
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD004             BEQ      ??osMailCreate_1
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD109             BNE      ??osMailCreate_2
    272              if (ptr->mp_id != NULL) {
    273                osMemoryPoolDelete(ptr->mp_id);
   \   00000032   0x0008             MOVS     R0,R1
   \   00000034   0x.... 0x....      BL       osMemoryPoolDelete
    274              }
    275              if (ptr->mq_id != NULL) {
   \                     ??osMailCreate_1: (+1)
   \   00000038   0x6860             LDR      R0,[R4, #+4]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD001             BEQ      ??osMailCreate_0
    276                osMessageQueueDelete(ptr->mq_id);
   \   0000003E   0x.... 0x....      BL       osMessageQueueDelete
    277              }
    278              return NULL;
   \                     ??osMailCreate_0: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}
    279            }
    280          
    281            return ptr;
   \                     ??osMailCreate_2: (+1)
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    282          }
    283          

   \                                 In section .text, align 2, keep-with-next
    284          void *osMailAlloc (osMailQId queue_id, uint32_t millisec) {
    285            os_mail_queue_t *ptr = (os_mail_queue_t *)queue_id;
    286          
    287            if (ptr == NULL) {
   \                     osMailAlloc: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD100             BNE      ??osMailAlloc_0
   \   00000004   0x4770             BX       LR
    288              return NULL;
    289            }
    290            return osMemoryPoolAlloc(ptr->mp_id, millisec);
   \                     ??osMailAlloc_0: (+1)
   \   00000006   0xB580             PUSH     {R7,LR}
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x.... 0x....      BL       osMemoryPoolAlloc
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
    291          }
    292          

   \                                 In section .text, align 2, keep-with-next
    293          void *osMailCAlloc (osMailQId queue_id, uint32_t millisec) {
   \                     osMailCAlloc: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
    294            os_mail_queue_t *ptr = (os_mail_queue_t *)queue_id;
    295            void            *block;
    296            uint32_t         block_size;
    297          
    298            if (ptr == NULL) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD004             BEQ      ??osMailCAlloc_0
    299              return NULL;
    300            }
    301            block_size = osMemoryPoolGetBlockSize(ptr->mp_id);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       osMemoryPoolGetBlockSize
   \   00000010   0x0005             MOVS     R5,R0
    302            if (block_size == 0U) {
   \   00000012   0xD101             BNE      ??osMailCAlloc_1
    303              return NULL;
   \                     ??osMailCAlloc_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD70             POP      {R4-R6,PC}
    304            }
    305            block = osMemoryPoolAlloc(ptr->mp_id, millisec);
   \                     ??osMailCAlloc_1: (+1)
   \   00000018   0x0031             MOVS     R1,R6
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x.... 0x....      BL       osMemoryPoolAlloc
   \   00000020   0x0004             MOVS     R4,R0
    306            if (block != NULL) {
   \   00000022   0xD002             BEQ      ??osMailCAlloc_2
    307              memset(block, 0, block_size);
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x.... 0x....      BL       __aeabi_memclr
    308            }
    309          
    310            return block;
   \                     ??osMailCAlloc_2: (+1)
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
    311          
    312          }
    313          

   \                                 In section .text, align 2, keep-with-next
    314          osStatus osMailPut (osMailQId queue_id, const void *mail) {
   \                     osMailPut: (+1)
   \   00000000   0xB502             PUSH     {R1,LR}
    315            os_mail_queue_t *ptr = (os_mail_queue_t *)queue_id;
    316          
    317            if (ptr == NULL) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD101             BNE      ??osMailPut_0
    318              return osErrorParameter;
   \   00000006   0x2003             MOVS     R0,#+3
   \   00000008   0xE002             B.N      ??osMailPut_1
    319            }
    320            if (mail == NULL) {
   \                     ??osMailPut_0: (+1)
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD102             BNE      ??osMailPut_2
    321              return osErrorValue;
   \   0000000E   0x207E             MOVS     R0,#+126
   \                     ??osMailPut_1: (+1)
   \   00000010   0x43C0             MVNS     R0,R0            ;; #-127
   \   00000012   0xBD02             POP      {R1,PC}
    322            }
    323            return osMessageQueuePut(ptr->mq_id, &mail, 0U, 0U);
   \                     ??osMailPut_2: (+1)
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x6840             LDR      R0,[R0, #+4]
   \   0000001C   0x.... 0x....      BL       osMessageQueuePut
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
    324          }
    325          

   \                                 In section .text, align 2, keep-with-next
    326          os_InRegs osEvent osMailGet (osMailQId queue_id, uint32_t millisec) {
   \                     osMailGet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0008             MOVS     R0,R1
    327            os_mail_queue_t *ptr = (os_mail_queue_t *)queue_id;
    328            osStatus_t       status;
    329            osEvent          event;
    330            void            *mail;
    331          
    332            if (ptr == NULL) {
   \   00000008   0xD103             BNE      ??osMailGet_0
    333              event.status = osErrorParameter;
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0x43C0             MVNS     R0,R0            ;; #-4
   \   0000000E   0x9001             STR      R0,[SP, #+4]
    334              return event;
   \   00000010   0xE017             B        ??osMailGet_1
    335            }
    336          
    337            status = osMessageQueueGet(ptr->mq_id, &mail, NULL, millisec);
   \                     ??osMailGet_0: (+1)
   \   00000012   0x0013             MOVS     R3,R2
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x6840             LDR      R0,[R0, #+4]
   \   0000001A   0x.... 0x....      BL       osMessageQueueGet
    338            switch (status) {
   \   0000001E   0x0001             MOVS     R1,R0
   \   00000020   0xD006             BEQ      ??osMailGet_2
   \   00000022   0x2202             MOVS     R2,#+2
   \   00000024   0x43D2             MVNS     R2,R2            ;; #-3
   \   00000026   0x1A81             SUBS     R1,R0,R2
   \   00000028   0xD007             BEQ      ??osMailGet_3
   \   0000002A   0x1E49             SUBS     R1,R1,#+1
   \   0000002C   0xD007             BEQ      ??osMailGet_4
   \   0000002E   0xE007             B        ??osMailGet_5
    339              case osOK:
    340                event.status = osEventMail;
   \                     ??osMailGet_2: (+1)
   \   00000030   0x2020             MOVS     R0,#+32
   \   00000032   0x9001             STR      R0,[SP, #+4]
    341                event.value.p = mail;
   \   00000034   0x9800             LDR      R0,[SP, #+0]
   \   00000036   0x9002             STR      R0,[SP, #+8]
    342                break;
   \   00000038   0xE003             B        ??osMailGet_1
    343              case osErrorResource:
    344                event.status = osOK;
   \                     ??osMailGet_3: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE000             B        ??osMailGet_5
    345                break;
    346              case osErrorTimeout:
    347                event.status = osEventTimeout;
   \                     ??osMailGet_4: (+1)
   \   0000003E   0x2040             MOVS     R0,#+64
    348                break;
    349              default:
    350                event.status = status;
   \                     ??osMailGet_5: (+1)
   \   00000040   0x9001             STR      R0,[SP, #+4]
    351                break;
    352            }
    353            return event;
   \                     ??osMailGet_1: (+1)
   \   00000042                      REQUIRE ?Subroutine0
   \   00000042                      ;; // Fall through to label ?Subroutine0
    354          }
    355          

   \                                 In section .text, align 2, keep-with-next
    356          osStatus osMailFree (osMailQId queue_id, void *mail) {
   \                     osMailFree: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    357            os_mail_queue_t *ptr = (os_mail_queue_t *)queue_id;
    358          
    359            if (ptr == NULL) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD101             BNE      ??osMailFree_0
    360              return osErrorParameter;
   \   00000006   0x2003             MOVS     R0,#+3
   \   00000008   0xE002             B.N      ??osMailFree_1
    361            }
    362            if (mail == NULL) {
   \                     ??osMailFree_0: (+1)
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD102             BNE      ??osMailFree_2
    363              return osErrorValue;
   \   0000000E   0x207E             MOVS     R0,#+126
   \                     ??osMailFree_1: (+1)
   \   00000010   0x43C0             MVNS     R0,R0            ;; #-127
   \   00000012   0xBD02             POP      {R1,PC}
    364            }
    365            return osMemoryPoolFree(ptr->mp_id, mail);
   \                     ??osMailFree_2: (+1)
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       osMemoryPoolFree
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return
    366          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x7FFFFFFF         DC32     0x7fffffff
    367          
    368          #endif  // Mail Queue
    369          
    370          
    371          #endif  // osCMSIS

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   osMailAlloc
         8   -> osMemoryPoolAlloc
      16   osMailCAlloc
        16   -> __aeabi_memclr
        16   -> osMemoryPoolAlloc
        16   -> osMemoryPoolGetBlockSize
      16   osMailCreate
        16   -> osMemoryPoolDelete
        16   -> osMemoryPoolNew
        16   -> osMessageQueueDelete
        16   -> osMessageQueueNew
       8   osMailFree
         8   -> osMemoryPoolFree
      24   osMailGet
        24   -> osMessageQueueGet
       8   osMailPut
         8   -> osMessageQueuePut
       8   osMessageCreate
         8   -> osMessageQueueNew
      24   osMessageGet
        24   -> osMessageQueueGet
       8   osMessagePut
         8   -> osMessageQueuePut
       8   osMutexCreate
         8   -> osMutexNew
       8   osPoolAlloc
         8   -> osMemoryPoolAlloc
      16   osPoolCAlloc
        16   -> __aeabi_memclr
        16   -> osMemoryPoolAlloc
        16   -> osMemoryPoolGetBlockSize
       8   osPoolCreate
         8   -> osMemoryPoolNew
       8   osPoolFree
         8   -> osMemoryPoolFree
       8   osSemaphoreCreate
         8   -> osSemaphoreNew
       8   osSemaphoreWait
         8   -> osSemaphoreAcquire
         8   -> osSemaphoreGetCount
      16   osSignalClear
        16   -> osThreadFlagsClear
        16   -> osThreadGetId
       8   osSignalSet
         8   -> osThreadFlagsSet
      24   osSignalWait
        24   -> osThreadFlagsWait
       8   osThreadCreate
         8   -> osThreadNew
       8   osTimerCreate
         8   -> osTimerNew


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
      10  ?Subroutine0
      16  osMailAlloc
      46  osMailCAlloc
      74  osMailCreate
      28  osMailFree
      66  osMailGet
      34  osMailPut
      20  osMessageCreate
      56  osMessageGet
      14  osMessagePut
      14  osMutexCreate
      10  osPoolAlloc
      38  osPoolCAlloc
      22  osPoolCreate
       8  osPoolFree
      18  osSemaphoreCreate
      44  osSemaphoreWait
      30  osSignalClear
      22  osSignalSet
      78  osSignalWait
      18  osThreadCreate
      18  osTimerCreate

 
 688 bytes in section .text
 
 688 bytes of CODE memory

Errors: none
Warnings: none

###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:46
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\platform\mbed_retarget.cpp
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --c++ --no_rtti --no_exceptions --guard_calls
#        --no_static_destruction -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\platform\mbed_retarget.d -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\platform\mbed_retarget.s.txt -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\platform\mbed_retarget.o
#        .\mbed-os\platform\mbed_retarget.cpp
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\platform\mbed_retarget.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\platform\mbed_retarget.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\platform\mbed_retarget.cpp
      1          /* mbed Microcontroller Library
      2           * Copyright (c) 2006-2015 ARM Limited
      3           *
      4           * Licensed under the Apache License, Version 2.0 (the "License");
      5           * you may not use this file except in compliance with the License.
      6           * You may obtain a copy of the License at
      7           *
      8           *     http://www.apache.org/licenses/LICENSE-2.0
      9           *
     10           * Unless required by applicable law or agreed to in writing, software
     11           * distributed under the License is distributed on an "AS IS" BASIS,
     12           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13           * See the License for the specific language governing permissions and
     14           * limitations under the License.
     15           */
     16          #include <time.h>
     17          #include "platform/platform.h"
     18          #include "platform/FilePath.h"

   \                                 In section .text, align 4
   \   __interwork __softfp rtos::Mutex *SingletonPtr<rtos::Mutex>::operator->()
   \                     _ZN12SingletonPtrIN4rtos5MutexEEptEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD110             BNE      `??operator->_0`
   \   0000000A   0x4D0E             LDR      R5,`??operator->_1`
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0x.... 0x....      BL       osMutexAcquire
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD104             BNE      `??operator->_2`
   \   0000001C   0x1D20             ADDS     R0,R4,#+4
   \   0000001E   0xD001             BEQ      `??operator->_3`
   \   00000020   0x.... 0x....      BL       _ZN4rtos5MutexC1Ev
   \                     `??operator->_3`: (+1)
   \   00000024   0x6020             STR      R0,[R4, #+0]
   \                     `??operator->_2`: (+1)
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x.... 0x....      BL       osMutexRelease
   \                     `??operator->_0`: (+1)
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x1D21             ADDS     R1,R4,#+4
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD004             BEQ      `??operator->_4`
   \   00000034   0x225D             MOVS     R2,#+93
   \   00000036   0x4904             LDR      R1,`??operator->_1`+0x4
   \   00000038   0x4804             LDR      R0,`??operator->_1`+0x8
   \   0000003A   0x.... 0x....      BL       mbed_assert_internal
   \                     `??operator->_4`: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \   00000042   0xBF00             Nop      
   \                     `??operator->_1`:
   \   00000044   0x........         DC32     singleton_mutex_id
   \   00000048   0x........         DC32     _ZZN12SingletonPtrIN4rtos5MutexEE3getEvEs_0
   \   0000004C   0x........         DC32     _ZZN12SingletonPtrIN4rtos5MutexEE3getEvEs
     19          #include "hal/serial_api.h"
     20          #include "hal/us_ticker_api.h"
     21          #include "platform/mbed_toolchain.h"
     22          #include "platform/mbed_semihost_api.h"
     23          #include "platform/mbed_interface.h"
     24          #include "platform/SingletonPtr.h"
     25          #include "platform/PlatformMutex.h"
     26          #include "platform/mbed_error.h"
     27          #include "platform/mbed_stats.h"
     28          #include "platform/mbed_critical.h"
     29          #include "platform/PlatformMutex.h"
     30          #include "us_ticker_api.h"
     31          #include "lp_ticker_api.h"
     32          #include <stdlib.h>
     33          #include <string.h>
     34          #include <limits.h>
     35          #if DEVICE_STDIO_MESSAGES
     36          #include <stdio.h>
     37          #endif
     38          #include <errno.h>
     39          #include "platform/mbed_retarget.h"
     40          

   \                                 In section .bss, align 4
     41          static SingletonPtr<PlatformMutex> _mutex;
   \                     _mutex:
   \   00000000                      DS8 40
     42          
     43          #if defined(__ARMCC_VERSION)
     44          #   if __ARMCC_VERSION >= 6010050
     45          #      include <arm_compat.h>
     46          #   endif
     47          #   include <rt_sys.h>
     48          #   include <rt_misc.h>
     49          #   include <stdint.h>
     50          #   define PREFIX(x)    _sys##x
     51          #   define OPEN_MAX     _SYS_OPEN
     52          #   ifdef __MICROLIB
     53          #       pragma import(__use_full_stdio)
     54          #   endif
     55          
     56          #elif defined(__ICCARM__)
     57          #   include <yfuns.h>
     58          #   define PREFIX(x)        _##x
     59          #   define OPEN_MAX         16
     60          
     61          #   define STDIN_FILENO     0
     62          #   define STDOUT_FILENO    1
     63          #   define STDERR_FILENO    2
     64          
     65          #else
     66          #   include <sys/syslimits.h>
     67          #   define PREFIX(x)    x
     68          #endif
     69          
     70          #define FILE_HANDLE_RESERVED    0xFFFFFFFF
     71          
     72          using namespace mbed;
     73          
     74          #if defined(__MICROLIB) && (__ARMCC_VERSION>5030000)
     75          // Before version 5.03, we were using a patched version of microlib with proper names
     76          extern const char __stdin_name[]  = ":tt";
     77          extern const char __stdout_name[] = ":tt";
     78          extern const char __stderr_name[] = ":tt";
     79          
     80          #else

   \                                 In section .text, align 4, keep-with-next
     81          extern const char __stdin_name[]  = "/stdin";
   \                     __stdin_name:
   \   00000000   0x2F 0x73          DC8 "/stdin"
   \              0x74 0x64    
   \              0x69 0x6E    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
     82          extern const char __stdout_name[] = "/stdout";
   \                     __stdout_name:
   \   00000000   0x2F 0x73          DC8 "/stdout"
   \              0x74 0x64    
   \              0x6F 0x75    
   \              0x74 0x00    

   \                                 In section .text, align 4, keep-with-next
     83          extern const char __stderr_name[] = "/stderr";
   \                     __stderr_name:
   \   00000000   0x2F 0x73          DC8 "/stderr"
   \              0x74 0x64    
   \              0x65 0x72    
   \              0x72 0x00    
     84          #endif
     85          

   \                                 In section .bss, align 4
     86          unsigned char *mbed_heap_start = 0;
   \                     mbed_heap_start:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     87          uint32_t mbed_heap_size = 0;
   \                     mbed_heap_size:
   \   00000000                      DS8 4
     88          
     89          /* newlib has the filehandle field in the FILE struct as a short, so
     90           * we can't just return a Filehandle* from _open and instead have to
     91           * put it in a filehandles array and return the index into that array
     92           * (or rather index+3, as filehandles 0-2 are stdin/out/err).
     93           */

   \                                 In section .bss, align 4
     94          static FileHandle *filehandles[OPEN_MAX];
   \                     filehandles:
   \   00000000                      DS8 64
   \   00000040                      DS8 40
     95          static SingletonPtr<PlatformMutex> filehandle_mutex;
     96          
     97          namespace mbed {

   \                                 In section .text, align 2, keep-with-next
     98          void remove_filehandle(FileHandle *file) {
   \                     _ZN4mbed17remove_filehandleEPNS_10FileHandleE: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     99              filehandle_mutex->lock();
   \   00000004   0x....             LDR      R5,??DataTable10
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x3040             ADDS     R0,R0,#+64
   \   0000000A   0x.... 0x....      BL       _ZN12SingletonPtrIN4rtos5MutexEEptEv
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000012   0x.... 0x....      BL       _ZN4rtos5Mutex4lockEj
    100              /* Remove all open filehandles for this */
    101              for (unsigned int fh_i = 0; fh_i < sizeof(filehandles)/sizeof(*filehandles); fh_i++) {
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x0029             MOVS     R1,R5
    102                  if (filehandles[fh_i] == file) {
   \                     ??remove_filehandle_0: (+1)
   \   0000001C   0x680B             LDR      R3,[R1, #+0]
   \   0000001E   0x42A3             CMP      R3,R4
   \   00000020   0xD100             BNE      ??remove_filehandle_1
    103                      filehandles[fh_i] = NULL;
   \   00000022   0x6008             STR      R0,[R1, #+0]
   \                     ??remove_filehandle_1: (+1)
   \   00000024   0x1C52             ADDS     R2,R2,#+1
   \   00000026   0x684B             LDR      R3,[R1, #+4]
   \   00000028   0x42A3             CMP      R3,R4
   \   0000002A   0xD100             BNE      ??remove_filehandle_2
   \   0000002C   0x6048             STR      R0,[R1, #+4]
   \                     ??remove_filehandle_2: (+1)
   \   0000002E   0x1C52             ADDS     R2,R2,#+1
   \   00000030   0x688B             LDR      R3,[R1, #+8]
   \   00000032   0x42A3             CMP      R3,R4
   \   00000034   0xD100             BNE      ??remove_filehandle_3
   \   00000036   0x6088             STR      R0,[R1, #+8]
   \                     ??remove_filehandle_3: (+1)
   \   00000038   0x1C52             ADDS     R2,R2,#+1
   \   0000003A   0x68CB             LDR      R3,[R1, #+12]
   \   0000003C   0x42A3             CMP      R3,R4
   \   0000003E   0xD100             BNE      ??remove_filehandle_4
   \   00000040   0x60C8             STR      R0,[R1, #+12]
    104                  }
    105              }
   \                     ??remove_filehandle_4: (+1)
   \   00000042   0x1C52             ADDS     R2,R2,#+1
   \   00000044   0x3110             ADDS     R1,R1,#+16
   \   00000046   0x2A10             CMP      R2,#+16
   \   00000048   0xD3E8             BCC      ??remove_filehandle_0
    106              filehandle_mutex->unlock();
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0x3040             ADDS     R0,R0,#+64
   \   0000004E   0x.... 0x....      BL       _ZN12SingletonPtrIN4rtos5MutexEEptEv
   \   00000052   0x.... 0x....      BL       _ZN4rtos5Mutex6unlockEv
    107          }
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    108          }
    109          
    110          #if DEVICE_SERIAL
    111          extern int stdio_uart_inited;
    112          extern serial_t stdio_uart;
    113          #if MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES
    114          static char stdio_in_prev;
    115          static char stdio_out_prev;
    116          #endif
    117          #endif
    118          
    119          static void init_serial() {
    120          #if DEVICE_SERIAL
    121              if (stdio_uart_inited) return;
    122              serial_init(&stdio_uart, STDIO_UART_TX, STDIO_UART_RX);
    123          #if MBED_CONF_PLATFORM_STDIO_BAUD_RATE
    124              serial_baud(&stdio_uart, MBED_CONF_PLATFORM_STDIO_BAUD_RATE);
    125          #endif
    126          #endif
    127          }
    128          
    129          /**
    130           * Sets errno when file opening fails.
    131           * Wipes out the filehandle too.
    132           *
    133           * @param error is a negative error code returned from an mbed function and
    134           *              will be negated to store a positive error code in errno
    135           */
    136          static int handle_open_errors(int error, unsigned filehandle_idx) {
    137              errno = -error;
    138              // Free file handle
    139              filehandles[filehandle_idx] = NULL;
    140              return -1;
    141          }
    142          
    143          static inline int openmode_to_posix(int openmode) {
    144              int posix = openmode;
    145          #ifdef __ARMCC_VERSION
    146              if (openmode & OPEN_PLUS) {
    147                  posix = O_RDWR;
    148              } else if(openmode & OPEN_W) {
    149                  posix = O_WRONLY;
    150              } else if(openmode & OPEN_A) {
    151                  posix = O_WRONLY|O_APPEND;
    152              } else {
    153                  posix = O_RDONLY;
    154              }
    155              /* a, w, a+, w+ all create if file does not already exist */
    156              if (openmode & (OPEN_A|OPEN_W)) {
    157                  posix |= O_CREAT;
    158              }
    159              /* w and w+ truncate */
    160              if (openmode & OPEN_W) {
    161                  posix |= O_TRUNC;
    162              }
    163          #elif defined(__ICCARM__)
    164              switch (openmode & _LLIO_RDWRMASK) {
    165                  case _LLIO_RDONLY: posix = O_RDONLY; break;
    166                  case _LLIO_WRONLY: posix = O_WRONLY; break;
    167                  case _LLIO_RDWR  : posix = O_RDWR  ; break;
    168              }
    169              if (openmode & _LLIO_CREAT ) posix |= O_CREAT;
    170              if (openmode & _LLIO_APPEND) posix |= O_APPEND;
    171              if (openmode & _LLIO_TRUNC ) posix |= O_TRUNC;
    172          #elif defined(TOOLCHAIN_GCC)
    173              posix &= ~O_BINARY;
    174          #endif
    175              return posix;
    176          }
    177          
    178          /* @brief 	standard c library fopen() retargeting function.
    179           *
    180           * This function is invoked by the standard c library retargeting to handle fopen()
    181           *
    182           * @return
    183           *  On success, a valid FILEHANDLE is returned.
    184           *  On failure, -1 is returned and errno is set to an appropriate value e.g.
    185           *   ENOENT	    file not found (default errno setting)
    186           *	 EMFILE		the maximum number of open files was exceeded.
    187           *
    188           * */

   \                                 In section .text, align 4, keep-with-next
    189          extern "C" FILEHANDLE PREFIX(_open)(const char* name, int openmode) {
   \                     __open: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x000F             MOVS     R7,R1
    190              #if defined(__MICROLIB) && (__ARMCC_VERSION>5030000)
    191          #if !defined(MBED_CONF_RTOS_PRESENT)
    192              // valid only for mbed 2
    193              // for ulib, this is invoked after RAM init, prior c++
    194              // used as hook, as post stack/heap is not active there
    195              extern void mbed_copy_nvic(void);
    196              extern void mbed_sdk_init(void);
    197          
    198              static int mbed_sdk_inited = 0;
    199              if (!mbed_sdk_inited) {
    200                  mbed_copy_nvic();
    201                  mbed_sdk_init();
    202                  mbed_sdk_inited = 1;
    203              }
    204          #endif
    205              // Before version 5.03, we were using a patched version of microlib with proper names
    206              // This is the workaround that the microlib author suggested us
    207              static int n = 0;
    208              if (!std::strcmp(name, ":tt")) return n++;
    209              #else
    210              /* Use the posix convention that stdin,out,err are filehandles 0,1,2.
    211               */
    212              if (std::strcmp(name, __stdin_name) == 0) {
   \   00000006   0xBF00             Nop      
   \   00000008   0x....             ADR.N    R1,__stdin_name
   \   0000000A   0x.... 0x....      BL       strcmp
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD110             BNE      ??__open_0
    213                  init_serial();
   \   00000012   0x....             LDR      R0,??DataTable11
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD10A             BNE      ??__open_1
   \   0000001A   0x....             LDR      R4,??DataTable11_1
   \   0000001C   0x220B             MOVS     R2,#+11
   \   0000001E   0x2108             MOVS     R1,#+8
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       serial_init
   \   00000026   0x2196             MOVS     R1,#+150
   \   00000028   0x0189             LSLS     R1,R1,#+6        ;; #+9600
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       serial_baud
    214                  return 0;
   \                     ??__open_1: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE078             B        ??__open_2
    215              } else if (std::strcmp(name, __stdout_name) == 0) {
   \                     ??__open_0: (+1)
   \   00000034   0x....             ADR.N    R1,__stdout_name
   \   00000036   0x9806             LDR      R0,[SP, #+24]
   \   00000038   0x.... 0x....      BL       strcmp
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD110             BNE      ??__open_3
    216                  init_serial();
   \   00000040   0x....             LDR      R0,??DataTable11
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD10A             BNE      ??__open_4
   \   00000048   0x....             LDR      R4,??DataTable11_1
   \   0000004A   0x220B             MOVS     R2,#+11
   \   0000004C   0x2108             MOVS     R1,#+8
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       serial_init
   \   00000054   0x2196             MOVS     R1,#+150
   \   00000056   0x0189             LSLS     R1,R1,#+6        ;; #+9600
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       serial_baud
    217                  return 1;
   \                     ??__open_4: (+1)
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xE061             B        ??__open_2
    218              } else if (std::strcmp(name, __stderr_name) == 0) {
   \                     ??__open_3: (+1)
   \   00000062   0xBF00             Nop      
   \   00000064   0x....             ADR.N    R1,__stderr_name
   \   00000066   0x9806             LDR      R0,[SP, #+24]
   \   00000068   0x.... 0x....      BL       strcmp
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD110             BNE      ??__open_5
    219                  init_serial();
   \   00000070   0x....             LDR      R0,??DataTable11
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD10A             BNE      ??__open_6
   \   00000078   0x....             LDR      R4,??DataTable11_1
   \   0000007A   0x220B             MOVS     R2,#+11
   \   0000007C   0x2108             MOVS     R1,#+8
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       serial_init
   \   00000084   0x2196             MOVS     R1,#+150
   \   00000086   0x0189             LSLS     R1,R1,#+6        ;; #+9600
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       serial_baud
    220                  return 2;
   \                     ??__open_6: (+1)
   \   0000008E   0x2002             MOVS     R0,#+2
   \   00000090   0xE049             B        ??__open_2
    221              }
    222              #endif
    223          
    224              // find the first empty slot in filehandles
    225              filehandle_mutex->lock();
   \                     ??__open_5: (+1)
   \   00000092   0x....             LDR      R5,??DataTable10
   \   00000094   0x0028             MOVS     R0,R5
   \   00000096   0x3040             ADDS     R0,R0,#+64
   \   00000098   0x.... 0x....      BL       _ZN12SingletonPtrIN4rtos5MutexEEptEv
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0x43C9             MVNS     R1,R1            ;; #-1
   \   000000A0   0x.... 0x....      BL       _ZN4rtos5Mutex4lockEj
    226              unsigned int fh_i;
    227              for (fh_i = 0; fh_i < sizeof(filehandles)/sizeof(*filehandles); fh_i++) {
   \   000000A4   0x2600             MOVS     R6,#+0
   \   000000A6   0x2400             MOVS     R4,#+0
   \   000000A8   0x0028             MOVS     R0,R5
    228              	/* Take a next free filehandle slot available. */
    229                  if (filehandles[fh_i] == NULL) break;
   \                     ??__open_7: (+1)
   \   000000AA   0x6801             LDR      R1,[R0, #+0]
   \   000000AC   0x2900             CMP      R1,#+0
   \   000000AE   0xD00F             BEQ      ??__open_8
   \   000000B0   0x1C64             ADDS     R4,R4,#+1
   \   000000B2   0x6841             LDR      R1,[R0, #+4]
   \   000000B4   0x2900             CMP      R1,#+0
   \   000000B6   0xD00B             BEQ      ??__open_8
   \   000000B8   0x1C64             ADDS     R4,R4,#+1
   \   000000BA   0x6881             LDR      R1,[R0, #+8]
   \   000000BC   0x2900             CMP      R1,#+0
   \   000000BE   0xD007             BEQ      ??__open_8
   \   000000C0   0x1C64             ADDS     R4,R4,#+1
   \   000000C2   0x68C1             LDR      R1,[R0, #+12]
   \   000000C4   0x2900             CMP      R1,#+0
   \   000000C6   0xD003             BEQ      ??__open_8
    230              }
   \   000000C8   0x1C64             ADDS     R4,R4,#+1
   \   000000CA   0x3010             ADDS     R0,R0,#+16
   \   000000CC   0x2C10             CMP      R4,#+16
   \   000000CE   0xD3EC             BCC      ??__open_7
    231              if (fh_i >= sizeof(filehandles)/sizeof(*filehandles)) {
   \                     ??__open_8: (+1)
   \   000000D0   0x2C10             CMP      R4,#+16
   \   000000D2   0xD30A             BCC      ??__open_9
    232                  /* Too many file handles have been opened */
    233                  errno = EMFILE;
   \   000000D4   0x.... 0x....      BL       __aeabi_errno_addr
   \   000000D8   0x2118             MOVS     R1,#+24
   \   000000DA   0x6001             STR      R1,[R0, #+0]
    234                  filehandle_mutex->unlock();
   \   000000DC   0x0028             MOVS     R0,R5
   \   000000DE   0x3040             ADDS     R0,R0,#+64
   \   000000E0   0x.... 0x....      BL       _ZN12SingletonPtrIN4rtos5MutexEEptEv
   \   000000E4   0x.... 0x....      BL       _ZN4rtos5Mutex6unlockEv
    235                  return -1;
   \   000000E8   0xE02D             B.N      ??__open_10
    236              }
    237              filehandles[fh_i] = (FileHandle*)FILE_HANDLE_RESERVED;
   \                     ??__open_9: (+1)
   \   000000EA   0x00A0             LSLS     R0,R4,#+2
   \   000000EC   0x1828             ADDS     R0,R5,R0
   \   000000EE   0x9001             STR      R0,[SP, #+4]
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x43C0             MVNS     R0,R0            ;; #-1
   \   000000F4   0x9901             LDR      R1,[SP, #+4]
   \   000000F6   0x6008             STR      R0,[R1, #+0]
    238              filehandle_mutex->unlock();
   \   000000F8   0x0028             MOVS     R0,R5
   \   000000FA   0x3040             ADDS     R0,R0,#+64
   \   000000FC   0x.... 0x....      BL       _ZN12SingletonPtrIN4rtos5MutexEEptEv
   \   00000100   0x.... 0x....      BL       _ZN4rtos5Mutex6unlockEv
    239          
    240              FileHandle *res = NULL;
   \   00000104   0x9602             STR      R6,[SP, #+8]
    241          
    242              /* FILENAME: ":(pointer)" describes a FileHandle* */
    243              if (name[0] == ':') {
   \   00000106   0x9806             LDR      R0,[SP, #+24]
   \   00000108   0x7800             LDRB     R0,[R0, #+0]
   \   0000010A   0x283A             CMP      R0,#+58
   \   0000010C   0xD10D             BNE      ??__open_11
    244                  void *p;
    245                  memcpy(&p, name + 1, sizeof(p));
   \   0000010E   0x2204             MOVS     R2,#+4
   \   00000110   0x9806             LDR      R0,[SP, #+24]
   \   00000112   0x1C41             ADDS     R1,R0,#+1
   \   00000114   0x4668             MOV      R0,SP
   \   00000116   0x.... 0x....      BL       __aeabi_memcpy
    246                  res = (FileHandle*)p;
   \   0000011A   0x9800             LDR      R0,[SP, #+0]
   \                     ??__open_12: (+1)
   \   0000011C   0x9002             STR      R0,[SP, #+8]
    247          
    248              /* FILENAME: "/file_system/file_name" */
    249              } else {
    250                  FilePath path(name);
    251          
    252                  if (!path.exists()) {
    253                      /* The first part of the filename (between first 2 '/') is not a
    254                       * registered mount point in the namespace.
    255                       */
    256                      return handle_open_errors(-ENODEV, fh_i);
    257                  }
    258          
    259                  if (path.isFile()) {
    260                      res = path.file();
    261                  } else {
    262                      FileSystemHandle *fs = path.fileSystem();
    263                      if (fs == NULL) {
    264                          return handle_open_errors(-ENODEV, fh_i);
    265                      }
    266                      int posix_mode = openmode_to_posix(openmode);
    267                      int err = fs->open(&res, path.fileName(), posix_mode);
    268                      if (err) {
    269                          return handle_open_errors(err, fh_i);
    270                      }
    271                  }
    272              }
    273          
    274              filehandles[fh_i] = res;
   \                     ??__open_13: (+1)
   \   0000011E   0x9802             LDR      R0,[SP, #+8]
   \   00000120   0x9901             LDR      R1,[SP, #+4]
   \   00000122   0x6008             STR      R0,[R1, #+0]
    275          
    276              return fh_i + 3; // +3 as filehandles 0-2 are stdin/out/err
   \   00000124   0x1CE0             ADDS     R0,R4,#+3
   \                     ??__open_2: (+1)
   \   00000126   0xB007             ADD      SP,SP,#+28
   \   00000128   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??__open_11: (+1)
   \   0000012A   0x9906             LDR      R1,[SP, #+24]
   \   0000012C   0xA803             ADD      R0,SP,#+12
   \   0000012E   0x.... 0x....      BL       _ZN4mbed8FilePathC1EPKc
   \   00000132   0x.... 0x....      BL       _ZN4mbed8FilePath6existsEv
   \   00000136   0x2800             CMP      R0,#+0
   \   00000138   0xD108             BNE      ??__open_14
   \                     ??__open_15: (+1)
   \   0000013A   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000013E   0x2113             MOVS     R1,#+19
   \                     ??__open_16: (+1)
   \   00000140   0x6001             STR      R1,[R0, #+0]
   \   00000142   0x9801             LDR      R0,[SP, #+4]
   \   00000144   0x6006             STR      R6,[R0, #+0]
   \                     ??__open_10: (+1)
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000014A   0xE7EC             B        ??__open_2
   \                     ??__open_14: (+1)
   \   0000014C   0xA803             ADD      R0,SP,#+12
   \   0000014E   0x.... 0x....      BL       _ZN4mbed8FilePath6isFileEv
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xA803             ADD      R0,SP,#+12
   \   00000156   0xD002             BEQ      ??__open_17
   \   00000158   0x.... 0x....      BL       _ZN4mbed8FilePath4fileEv
   \   0000015C   0xE7DE             B        ??__open_12
   \                     ??__open_17: (+1)
   \   0000015E   0x.... 0x....      BL       _ZN4mbed8FilePath10fileSystemEv
   \   00000162   0x9000             STR      R0,[SP, #+0]
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD0E8             BEQ      ??__open_15
   \   00000168   0x003D             MOVS     R5,R7
   \   0000016A   0x07B8             LSLS     R0,R7,#+30
   \   0000016C   0x0F80             LSRS     R0,R0,#+30
   \   0000016E   0xD007             BEQ      ??__open_18
   \   00000170   0x2802             CMP      R0,#+2
   \   00000172   0xD001             BEQ      ??__open_19
   \   00000174   0xD302             BCC      ??__open_20
   \   00000176   0xE004             B        ??__open_21
   \                     ??__open_19: (+1)
   \   00000178   0x2502             MOVS     R5,#+2
   \   0000017A   0xE002             B        ??__open_21
   \                     ??__open_20: (+1)
   \   0000017C   0x2501             MOVS     R5,#+1
   \   0000017E   0xE000             B        ??__open_21
   \                     ??__open_18: (+1)
   \   00000180   0x2500             MOVS     R5,#+0
   \                     ??__open_21: (+1)
   \   00000182   0x05F8             LSLS     R0,R7,#+23
   \   00000184   0xD503             BPL      ??__open_22
   \   00000186   0x0028             MOVS     R0,R5
   \   00000188   0x2580             MOVS     R5,#+128
   \   0000018A   0x00AD             LSLS     R5,R5,#+2        ;; #+512
   \   0000018C   0x4305             ORRS     R5,R5,R0
   \                     ??__open_22: (+1)
   \   0000018E   0x2008             MOVS     R0,#+8
   \   00000190   0x4207             TST      R7,R0
   \   00000192   0xD002             BEQ      ??__open_23
   \   00000194   0x0029             MOVS     R1,R5
   \   00000196   0x2508             MOVS     R5,#+8
   \   00000198   0x430D             ORRS     R5,R5,R1
   \                     ??__open_23: (+1)
   \   0000019A   0x05B8             LSLS     R0,R7,#+22
   \   0000019C   0xD503             BPL      ??__open_24
   \   0000019E   0x0028             MOVS     R0,R5
   \   000001A0   0x2580             MOVS     R5,#+128
   \   000001A2   0x00ED             LSLS     R5,R5,#+3        ;; #+1024
   \   000001A4   0x4305             ORRS     R5,R5,R0
   \                     ??__open_24: (+1)
   \   000001A6   0xA803             ADD      R0,SP,#+12
   \   000001A8   0x.... 0x....      BL       _ZN4mbed8FilePath8fileNameEv
   \   000001AC   0x002B             MOVS     R3,R5
   \   000001AE   0x0002             MOVS     R2,R0
   \   000001B0   0xA902             ADD      R1,SP,#+8
   \   000001B2   0x9800             LDR      R0,[SP, #+0]
   \   000001B4   0x6805             LDR      R5,[R0, #+0]
   \   000001B6   0x68AD             LDR      R5,[R5, #+8]
   \   000001B8   0x47A8             BLX      R5
   \   000001BA   0x0005             MOVS     R5,R0
   \   000001BC   0xD0AF             BEQ      ??__open_13
   \   000001BE   0x.... 0x....      BL       __aeabi_errno_addr
   \   000001C2   0x4269             RSBS     R1,R5,#+0
   \   000001C4   0xE7BC             B.N      ??__open_16
    277          }
    278          

   \                                 In section .text, align 2, keep-with-next
    279          extern "C" int PREFIX(_close)(FILEHANDLE fh) {
   \                     __close: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    280              if (fh < 3) return 0;
   \   00000002   0x2803             CMP      R0,#+3
   \   00000004   0xDB18             BLT      ??__close_0
    281          
    282              FileHandle* fhc = filehandles[fh-3];
   \   00000006   0x....             LDR      R1,??DataTable10
   \   00000008   0x0080             LSLS     R0,R0,#+2
   \   0000000A   0x1809             ADDS     R1,R1,R0
   \   0000000C   0x390C             SUBS     R1,R1,#+12
   \   0000000E   0x6808             LDR      R0,[R1, #+0]
    283              filehandles[fh-3] = NULL;
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x600A             STR      R2,[R1, #+0]
    284              if (fhc == NULL) {
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD103             BNE      ??__close_1
    285                  errno = EBADF;
   \   00000018   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000001C   0x2109             MOVS     R1,#+9
   \   0000001E   0xE007             B.N      ??__close_2
    286                  return -1;
    287              }
    288          
    289              int err = fhc->close();
   \                     ??__close_1: (+1)
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x6949             LDR      R1,[R1, #+20]
   \   00000024   0x4788             BLX      R1
   \   00000026   0x0004             MOVS     R4,R0
    290              if (err < 0) {
   \   00000028   0xD506             BPL      ??__close_0
    291                  errno = -err;
   \   0000002A   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000002E   0x4261             RSBS     R1,R4,#+0
   \                     ??__close_2: (+1)
   \   00000030   0x6001             STR      R1,[R0, #+0]
    292                  return -1;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000036   0xBD10             POP      {R4,PC}
    293              } else {
    294                  return 0;
   \                     ??__close_0: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    295              }
    296          }
    297          
    298          #if defined(__ICCARM__)

   \                                 In section .text, align 2, keep-with-next
    299          extern "C" size_t    __write (int        fh, const unsigned char *buffer, size_t length) {
   \                     __write: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x000C             MOVS     R4,R1
   \   00000004   0x0017             MOVS     R7,R2
    300          #else
    301          extern "C" int PREFIX(_write)(FILEHANDLE fh, const unsigned char *buffer, unsigned int length, int mode) {
    302          #endif
    303              int n; // n is the number of bytes written
    304          
    305          #if defined(MBED_TRAP_ERRORS_ENABLED) && MBED_TRAP_ERRORS_ENABLED && defined(MBED_CONF_RTOS_PRESENT)
    306              if (core_util_is_isr_active() || !core_util_are_interrupts_enabled()) {
    307                  error("Error - writing to a file in an ISR or critical section\r\n");
    308              }
    309          #endif
    310          
    311              if (fh < 3) {
   \   00000006   0x2803             CMP      R0,#+3
   \   00000008   0xDA1A             BGE      ??__write_0
    312          #if DEVICE_SERIAL
    313                  if (!stdio_uart_inited) init_serial();
   \   0000000A   0x....             LDR      R0,??DataTable11
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD10A             BNE      ??__write_1
   \   00000012   0x....             LDR      R6,??DataTable11_1
   \   00000014   0x220B             MOVS     R2,#+11
   \   00000016   0x2108             MOVS     R1,#+8
   \   00000018   0x0030             MOVS     R0,R6
   \   0000001A   0x.... 0x....      BL       serial_init
   \   0000001E   0x2196             MOVS     R1,#+150
   \   00000020   0x0189             LSLS     R1,R1,#+6        ;; #+9600
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0x.... 0x....      BL       serial_baud
    314          #if MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES
    315                  for (unsigned int i = 0; i < length; i++) {
    316                      if (buffer[i] == '\n' && stdio_out_prev != '\r') {
    317                           serial_putc(&stdio_uart, '\r');
    318                      }
    319                      serial_putc(&stdio_uart, buffer[i]);
    320                      stdio_out_prev = buffer[i];
    321                  }
    322          #else
    323                  for (unsigned int i = 0; i < length; i++) {
   \                     ??__write_1: (+1)
   \   00000028   0x2F00             CMP      R7,#+0
   \   0000002A   0xD021             BEQ      ??__write_2
   \   0000002C   0x003D             MOVS     R5,R7
   \   0000002E   0x....             LDR      R6,??DataTable11_1
    324                      serial_putc(&stdio_uart, buffer[i]);
   \                     ??__write_3: (+1)
   \   00000030   0x7821             LDRB     R1,[R4, #+0]
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0x.... 0x....      BL       serial_putc
    325                  }
   \   00000038   0x1C64             ADDS     R4,R4,#+1
   \   0000003A   0x1E6D             SUBS     R5,R5,#+1
   \   0000003C   0xD1F8             BNE      ??__write_3
    326          #endif
    327          #endif
    328                  n = length;
   \   0000003E   0xE017             B        ??__write_2
    329              } else {
    330                  FileHandle* fhc = filehandles[fh-3];
   \                     ??__write_0: (+1)
   \   00000040   0x....             LDR      R1,??DataTable10
   \   00000042   0x0080             LSLS     R0,R0,#+2
   \   00000044   0x1808             ADDS     R0,R1,R0
   \   00000046   0x380C             SUBS     R0,R0,#+12
   \   00000048   0x6800             LDR      R0,[R0, #+0]
    331                  if (fhc == NULL) {
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD106             BNE      ??__write_4
    332                      errno = EBADF;
   \   0000004E   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000052   0x2109             MOVS     R1,#+9
   \   00000054   0x6001             STR      R1,[R0, #+0]
    333                      return -1;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000005A   0xBDF2             POP      {R1,R4-R7,PC}
    334                  }
    335          
    336                  n = fhc->write(buffer, length);
   \                     ??__write_4: (+1)
   \   0000005C   0x0021             MOVS     R1,R4
   \   0000005E   0x6803             LDR      R3,[R0, #+0]
   \   00000060   0x68DB             LDR      R3,[R3, #+12]
   \   00000062   0x4798             BLX      R3
   \   00000064   0x0007             MOVS     R7,R0
    337                  if (n < 0) {
   \   00000066   0xD503             BPL      ??__write_2
    338                      errno = -n;
   \   00000068   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000006C   0x4279             RSBS     R1,R7,#+0
   \   0000006E   0x6001             STR      R1,[R0, #+0]
    339                  }
    340              }
    341          #ifdef __ARMCC_VERSION
    342              return length-n;
    343          #else
    344              return n;
   \                     ??__write_2: (+1)
   \   00000070   0x0038             MOVS     R0,R7
   \   00000072   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    345          #endif
    346          }
    347          
    348          #if defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
    349          extern "C" void PREFIX(_exit)(int return_code) {
    350              while(1) {}
    351          }
    352          
    353          extern "C" void _ttywrch(int ch) {
    354              serial_putc(&stdio_uart, ch);
    355          }
    356          #endif
    357          
    358          #if defined(__ICCARM__)

   \                                 In section .text, align 2, keep-with-next
    359          extern "C" size_t    __read (int        fh, unsigned char *buffer, size_t       length) {
   \                     __read: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x000D             MOVS     R5,R1
    360          #else
    361          extern "C" int PREFIX(_read)(FILEHANDLE fh, unsigned char *buffer, unsigned int length, int mode) {
    362          #endif
    363              int n; // n is the number of bytes read
    364          
    365          #if defined(MBED_TRAP_ERRORS_ENABLED) && MBED_TRAP_ERRORS_ENABLED && defined(MBED_CONF_RTOS_PRESENT)
    366              if (core_util_is_isr_active() || !core_util_are_interrupts_enabled()) {
    367                  error("Error - reading from a file in an ISR or critical section\r\n");
    368              }
    369          #endif
    370          
    371              if (fh < 3) {
   \   00000004   0x2803             CMP      R0,#+3
   \   00000006   0xDA14             BGE      ??__read_0
    372                  // only read a character at a time from stdin
    373          #if DEVICE_SERIAL
    374                  if (!stdio_uart_inited) init_serial();
   \   00000008   0x....             LDR      R4,??DataTable11_1
   \   0000000A   0x....             LDR      R0,??DataTable11
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD109             BNE      ??__read_1
   \   00000012   0x220B             MOVS     R2,#+11
   \   00000014   0x2108             MOVS     R1,#+8
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       serial_init
   \   0000001C   0x2196             MOVS     R1,#+150
   \   0000001E   0x0189             LSLS     R1,R1,#+6        ;; #+9600
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       serial_baud
    375          #if MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES
    376                  while (true) {
    377                      char c = serial_getc(&stdio_uart);
    378                      if ((c == '\r' && stdio_in_prev != '\n') ||
    379                          (c == '\n' && stdio_in_prev != '\r')) {
    380                          stdio_in_prev = c;
    381                          *buffer = '\n';
    382                          break;
    383                      } else if ((c == '\r' && stdio_in_prev == '\n') ||
    384                                 (c == '\n' && stdio_in_prev == '\r')) {
    385                          stdio_in_prev = c;
    386                          // onto next character
    387                          continue;
    388                      } else {
    389                          stdio_in_prev = c;
    390                          *buffer = c;
    391                          break;
    392                      }
    393                  }
    394          #else
    395                  *buffer = serial_getc(&stdio_uart);
   \                     ??__read_1: (+1)
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       serial_getc
   \   0000002C   0x7028             STRB     R0,[R5, #+0]
    396          #endif
    397          #endif
    398                  n = 1;
   \   0000002E   0x2401             MOVS     R4,#+1
   \   00000030   0xE017             B        ??__read_2
    399              } else {
    400                  FileHandle* fhc = filehandles[fh-3];
   \                     ??__read_0: (+1)
   \   00000032   0x....             LDR      R1,??DataTable15
   \   00000034   0x0080             LSLS     R0,R0,#+2
   \   00000036   0x1808             ADDS     R0,R1,R0
   \   00000038   0x380C             SUBS     R0,R0,#+12
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
    401                  if (fhc == NULL) {
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD106             BNE      ??__read_3
    402                      errno = EBADF;
   \   00000040   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000044   0x2109             MOVS     R1,#+9
   \   00000046   0x6001             STR      R1,[R0, #+0]
    403                      return -1;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000004C   0xBD32             POP      {R1,R4,R5,PC}
    404                  }
    405          
    406                  n = fhc->read(buffer, length);
   \                     ??__read_3: (+1)
   \   0000004E   0x0029             MOVS     R1,R5
   \   00000050   0x6803             LDR      R3,[R0, #+0]
   \   00000052   0x689B             LDR      R3,[R3, #+8]
   \   00000054   0x4798             BLX      R3
   \   00000056   0x0004             MOVS     R4,R0
    407                  if (n < 0) {
   \   00000058   0xD503             BPL      ??__read_2
    408                      errno = -n;
   \   0000005A   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000005E   0x4261             RSBS     R1,R4,#+0
   \   00000060   0x6001             STR      R1,[R0, #+0]
    409                  }
    410              }
    411          #ifdef __ARMCC_VERSION
    412              return length-n;
    413          #else
    414              return n;
   \                     ??__read_2: (+1)
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    415          #endif
    416          }
    417          
    418          
    419          #ifdef __ARMCC_VERSION
    420          extern "C" int PREFIX(_istty)(FILEHANDLE fh)
    421          #else

   \                                 In section .text, align 2, keep-with-next
    422          extern "C" int _isatty(FILEHANDLE fh)
    423          #endif
    424          {
   \                     _isatty: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    425              /* stdin, stdout and stderr should be tty */
    426              if (fh < 3) return 1;
   \   00000002   0x2803             CMP      R0,#+3
   \   00000004   0xDA01             BGE      ??_isatty_0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    427          
    428              FileHandle* fhc = filehandles[fh-3];
   \                     ??_isatty_0: (+1)
   \   0000000A   0x....             LDR      R1,??DataTable15
   \   0000000C   0x0080             LSLS     R0,R0,#+2
   \   0000000E   0x1808             ADDS     R0,R1,R0
   \   00000010   0x380C             SUBS     R0,R0,#+12
   \   00000012   0x6800             LDR      R0,[R0, #+0]
    429              if (fhc == NULL) {
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD103             BNE      ??_isatty_1
    430                  errno = EBADF;
   \   00000018   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000001C   0x2109             MOVS     R1,#+9
   \   0000001E   0xE007             B        ??_isatty_2
    431                  return 0;
    432              }
    433          
    434              int tty = fhc->isatty();
   \                     ??_isatty_1: (+1)
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x69C9             LDR      R1,[R1, #+28]
   \   00000024   0x4788             BLX      R1
   \   00000026   0x0004             MOVS     R4,R0
    435              if (tty < 0) {
   \   00000028   0xD504             BPL      ??_isatty_3
    436                  errno = -tty;
   \   0000002A   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000002E   0x4261             RSBS     R1,R4,#+0
   \                     ??_isatty_2: (+1)
   \   00000030   0x6001             STR      R1,[R0, #+0]
    437                  return 0;
   \   00000032   0x2000             MOVS     R0,#+0
    438              } else {
    439                  return tty;
   \                     ??_isatty_3: (+1)
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    440              }
    441          }
    442          

   \                                 In section .text, align 2, keep-with-next
    443          extern "C"
    444          #if defined(__ARMCC_VERSION)
    445          int _sys_seek(FILEHANDLE fh, long offset)
    446          #elif defined(__ICCARM__)
    447          long __lseek(int fh, long offset, int whence)
    448          #else
    449          int _lseek(FILEHANDLE fh, int offset, int whence)
    450          #endif
    451          {
   \                     __lseek: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    452          #if defined(__ARMCC_VERSION)
    453              int whence = SEEK_SET;
    454          #endif
    455          
    456              if (fh < 3) {
   \   00000002   0x2803             CMP      R0,#+3
   \   00000004   0xDA03             BGE      ??__lseek_0
    457                  errno = ESPIPE;
   \   00000006   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000000A   0x211D             MOVS     R1,#+29
   \   0000000C   0xE012             B        ??__lseek_1
    458                  return -1;
    459              }
    460          
    461              FileHandle* fhc = filehandles[fh-3];
   \                     ??__lseek_0: (+1)
   \   0000000E   0x....             LDR      R3,??DataTable15
   \   00000010   0x0080             LSLS     R0,R0,#+2
   \   00000012   0x1818             ADDS     R0,R3,R0
   \   00000014   0x380C             SUBS     R0,R0,#+12
   \   00000016   0x6800             LDR      R0,[R0, #+0]
    462              if (fhc == NULL) {
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD103             BNE      ??__lseek_2
    463                  errno = EBADF;
   \   0000001C   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000020   0x2109             MOVS     R1,#+9
   \   00000022   0xE007             B        ??__lseek_1
    464                  return -1;
    465              }
    466          
    467              off_t off = fhc->seek(offset, whence);
   \                     ??__lseek_2: (+1)
   \   00000024   0x6803             LDR      R3,[R0, #+0]
   \   00000026   0x691B             LDR      R3,[R3, #+16]
   \   00000028   0x4798             BLX      R3
   \   0000002A   0x0004             MOVS     R4,R0
    468              if (off < 0) {
   \   0000002C   0xD505             BPL      ??__lseek_3
    469                  errno = -off;
   \   0000002E   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000032   0x4261             RSBS     R1,R4,#+0
   \                     ??__lseek_1: (+1)
   \   00000034   0x6001             STR      R1,[R0, #+0]
    470                  return -1;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x43C0             MVNS     R0,R0            ;; #-1
    471              }
    472              // Assuming INT_MAX = LONG_MAX, so we don't care about prototype difference
    473              if (off > INT_MAX) {
    474                  errno = EOVERFLOW;
    475                  return -1;
    476              }
    477              return off;
   \                     ??__lseek_3: (+1)
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    478          }
    479          
    480          #ifdef __ARMCC_VERSION
    481          extern "C" int PREFIX(_ensure)(FILEHANDLE fh) {
    482              if (fh < 3) return 0;
    483          
    484              FileHandle* fhc = filehandles[fh-3];
    485              if (fhc == NULL) {
    486                  errno = EBADF;
    487                  return -1;
    488              }
    489          
    490              int err = fhc->sync();
    491              if (err < 0) {
    492                  errno = -err;
    493                  return -1;
    494              } else {
    495                  return 0;
    496              }
    497          }
    498          
    499          extern "C" long PREFIX(_flen)(FILEHANDLE fh) {
    500              if (fh < 3) {
    501                  errno = EINVAL;
    502                  return -1;
    503              }
    504          
    505              FileHandle* fhc = filehandles[fh-3];
    506              if (fhc == NULL) {
    507                  errno = EBADF;
    508                  return -1;
    509              }
    510          
    511              off_t size = fhc->size();
    512              if (size < 0) {
    513                  errno = -size;
    514                  return -1;
    515              }
    516              if (size > LONG_MAX) {
    517                  errno = EOVERFLOW;
    518                  return -1;
    519              }
    520              return size;
    521          }
    522          
    523          extern "C" char Image$$RW_IRAM1$$ZI$$Limit[];
    524          
    525          extern "C" MBED_WEAK __value_in_regs struct __initial_stackheap _mbed_user_setup_stackheap(uint32_t R0, uint32_t R1, uint32_t R2, uint32_t R3)
    526          {
    527              uint32_t zi_limit = (uint32_t)Image$$RW_IRAM1$$ZI$$Limit;
    528              uint32_t sp_limit = __current_sp();
    529          
    530              zi_limit = (zi_limit + 7) & ~0x7;    // ensure zi_limit is 8-byte aligned
    531          
    532              struct __initial_stackheap r;
    533              r.heap_base = zi_limit;
    534              r.heap_limit = sp_limit;
    535              return r;
    536          }
    537          
    538          extern "C" __value_in_regs struct __initial_stackheap __user_setup_stackheap(uint32_t R0, uint32_t R1, uint32_t R2, uint32_t R3) {
    539              return _mbed_user_setup_stackheap(R0, R1, R2, R3);
    540          }
    541          
    542          #endif
    543          
    544          
    545          #if !defined(__ARMCC_VERSION) && !defined(__ICCARM__)
    546          extern "C" int _fstat(int fh, struct stat *st) {
    547              if (fh < 3) {
    548                  st->st_mode = S_IFCHR;
    549                  return  0;
    550              }
    551          
    552              FileHandle* fhc = filehandles[fh-3];
    553              if (fhc == NULL) {
    554                  errno = EBADF;
    555                  return -1;
    556              }
    557          
    558              st->st_mode = fhc->isatty() ? S_IFCHR : S_IFREG;
    559              st->st_size = fhc->size();
    560              return 0;
    561          }
    562          #endif
    563          
    564          namespace std {

   \                                 In section .text, align 2, keep-with-next
    565          extern "C" int remove(const char *path) {
   \                     remove: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    566              FilePath fp(path);
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      BL       _ZN4mbed8FilePathC1EPKc
    567              FileSystemHandle *fs = fp.fileSystem();
   \   0000000A   0x.... 0x....      BL       _ZN4mbed8FilePath10fileSystemEv
   \   0000000E   0x0004             MOVS     R4,R0
    568              if (fs == NULL) {
   \   00000010   0xD103             BNE      ??remove_0
    569                  errno = ENODEV;
   \   00000012   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000016   0x2113             MOVS     R1,#+19
   \   00000018   0xE00C             B.N      ??remove_1
    570                  return -1;
    571              }
    572          
    573              int err = fs->remove(fp.fileName());
   \                     ??remove_0: (+1)
   \   0000001A   0x4668             MOV      R0,SP
   \   0000001C   0x.... 0x....      BL       _ZN4mbed8FilePath8fileNameEv
   \   00000020   0x0001             MOVS     R1,R0
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x6822             LDR      R2,[R4, #+0]
   \   00000026   0x6912             LDR      R2,[R2, #+16]
   \   00000028   0x4790             BLX      R2
   \   0000002A   0x0004             MOVS     R4,R0
    574              if (err < 0) {
   \   0000002C   0xD506             BPL      ??remove_2
    575                  errno = -err;
   \   0000002E   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000032   0x4261             RSBS     R1,R4,#+0
   \                     ??remove_1: (+1)
   \   00000034   0x6001             STR      R1,[R0, #+0]
    576                  return -1;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000003A   0xBD16             POP      {R1,R2,R4,PC}
    577              } else {
    578                  return 0;
   \                     ??remove_2: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    579              }
    580          }
    581          

   \                                 In section .text, align 2, keep-with-next
    582          extern "C" int rename(const char *oldname, const char *newname) {
   \                     rename: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x000C             MOVS     R4,R1
    583              FilePath fpOld(oldname);
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0xA802             ADD      R0,SP,#+8
   \   0000000A   0x.... 0x....      BL       _ZN4mbed8FilePathC1EPKc
    584              FilePath fpNew(newname);
   \   0000000E   0x0021             MOVS     R1,R4
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x.... 0x....      BL       _ZN4mbed8FilePathC1EPKc
    585              FileSystemHandle *fsOld = fpOld.fileSystem();
   \   00000016   0xA802             ADD      R0,SP,#+8
   \   00000018   0x.... 0x....      BL       _ZN4mbed8FilePath10fileSystemEv
   \   0000001C   0x0004             MOVS     R4,R0
    586              FileSystemHandle *fsNew = fpNew.fileSystem();
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0x.... 0x....      BL       _ZN4mbed8FilePath10fileSystemEv
    587          
    588              if (fsOld == NULL) {
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD103             BNE      ??rename_0
    589                  errno = ENODEV;
   \   00000028   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000002C   0x2113             MOVS     R1,#+19
   \   0000002E   0xE017             B.N      ??rename_1
    590                  return -1;
    591              }
    592          
    593              /* rename only if both files are on the same FS */
    594              if (fsOld != fsNew) {
   \                     ??rename_0: (+1)
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD003             BEQ      ??rename_2
    595                  errno = EXDEV;
   \   00000034   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000038   0x2112             MOVS     R1,#+18
   \   0000003A   0xE011             B.N      ??rename_1
    596                  return -1;
    597              }
    598          
    599              int err = fsOld->rename(fpOld.fileName(), fpNew.fileName());
   \                     ??rename_2: (+1)
   \   0000003C   0x4668             MOV      R0,SP
   \   0000003E   0x.... 0x....      BL       _ZN4mbed8FilePath8fileNameEv
   \   00000042   0x0005             MOVS     R5,R0
   \   00000044   0xA802             ADD      R0,SP,#+8
   \   00000046   0x.... 0x....      BL       _ZN4mbed8FilePath8fileNameEv
   \   0000004A   0x002A             MOVS     R2,R5
   \   0000004C   0x0001             MOVS     R1,R0
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x6823             LDR      R3,[R4, #+0]
   \   00000052   0x695B             LDR      R3,[R3, #+20]
   \   00000054   0x4798             BLX      R3
   \   00000056   0x0004             MOVS     R4,R0
    600              if (err < 0) {
   \   00000058   0xD506             BPL      ??rename_3
    601                  errno = -err;
   \   0000005A   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000005E   0x4261             RSBS     R1,R4,#+0
   \                     ??rename_1: (+1)
   \   00000060   0x6001             STR      R1,[R0, #+0]
    602                  return -1;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000066   0xE000             B        ??rename_4
    603              } else {
    604                  return 0;
   \                     ??rename_3: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \                     ??rename_4: (+1)
   \   0000006A   0xB005             ADD      SP,SP,#+20
   \   0000006C   0xBD30             POP      {R4,R5,PC}       ;; return
    605              }
    606          }
    607          

   \                                 In section .text, align 2, keep-with-next
    608          extern "C" char *tmpnam(char *s) {
   \                     tmpnam: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    609              errno = EBADF;
   \   00000002   0x....             B.N      ?Subroutine0
    610              return NULL;
    611          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000004   0x2109             MOVS     R1,#+9
   \   00000006   0x6001             STR      R1,[R0, #+0]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    612          

   \                                 In section .text, align 2, keep-with-next
    613          extern "C" FILE *tmpfile() {
   \                     tmpfile: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    614              errno = EBADF;
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0
    615              return NULL;
    616          }
    617          } // namespace std
    618          
    619          #ifdef __ARMCC_VERSION
    620          extern "C" char *_sys_command_string(char *cmd, int len) {
    621              return NULL;
    622          }
    623          #endif
    624          

   \                                 In section .text, align 2, keep-with-next
    625          extern "C" DIR *opendir(const char *path) {
   \                     opendir: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    626              FilePath fp(path);
   \   00000004   0x0001             MOVS     R1,R0
   \   00000006   0xA801             ADD      R0,SP,#+4
   \   00000008   0x.... 0x....      BL       _ZN4mbed8FilePathC1EPKc
    627              FileSystemHandle* fs = fp.fileSystem();
   \   0000000C   0x.... 0x....      BL       _ZN4mbed8FilePath10fileSystemEv
   \   00000010   0x0004             MOVS     R4,R0
    628              if (fs == NULL) {
   \   00000012   0xD103             BNE      ??opendir_0
    629                  errno = ENODEV;
   \   00000014   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000018   0x2113             MOVS     R1,#+19
   \   0000001A   0xE00D             B.N      ??opendir_1
    630                  return NULL;
    631              }
    632          
    633              DirHandle *dir;
    634              int err = fs->open(&dir, fp.fileName());
   \                     ??opendir_0: (+1)
   \   0000001C   0xA801             ADD      R0,SP,#+4
   \   0000001E   0x.... 0x....      BL       _ZN4mbed8FilePath8fileNameEv
   \   00000022   0x0002             MOVS     R2,R0
   \   00000024   0x4669             MOV      R1,SP
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x6823             LDR      R3,[R4, #+0]
   \   0000002A   0x68DB             LDR      R3,[R3, #+12]
   \   0000002C   0x4798             BLX      R3
   \   0000002E   0x0004             MOVS     R4,R0
    635              if (err < 0) {
   \   00000030   0xD505             BPL      ??opendir_2
    636                  errno = -err;
   \   00000032   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000036   0x4261             RSBS     R1,R4,#+0
   \                     ??opendir_1: (+1)
   \   00000038   0x6001             STR      R1,[R0, #+0]
    637                  return NULL;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE000             B        ??opendir_3
    638              }
    639          
    640              return dir;
   \                     ??opendir_2: (+1)
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \                     ??opendir_3: (+1)
   \   00000040   0xB004             ADD      SP,SP,#+16
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    641          }
    642          

   \                                 In section .text, align 2, keep-with-next
    643          extern "C" struct dirent *readdir(DIR *dir) {
   \                     readdir: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    644              static struct dirent ent;
    645              int err = dir->read(&ent);
   \   00000002   0x....             LDR      R4,??DataTable17
   \   00000004   0x0021             MOVS     R1,R4
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x6892             LDR      R2,[R2, #+8]
   \   0000000A   0x4790             BLX      R2
   \   0000000C   0x0005             MOVS     R5,R0
    646              if (err < 1) {
   \   0000000E   0x2D01             CMP      R5,#+1
   \   00000010   0xDA07             BGE      ??readdir_0
    647                  if (err < 0) {
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD503             BPL      ??readdir_1
    648                      errno = -err;
   \   00000016   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000001A   0x4269             RSBS     R1,R5,#+0
   \   0000001C   0x6001             STR      R1,[R0, #+0]
    649                  }
    650                  return NULL;
   \                     ??readdir_1: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}
    651              }
    652          
    653              return &ent;
   \                     ??readdir_0: (+1)
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    654          }

   \                                 In section .bss, align 4
   \                     `readdir::ent`:
   \   00000000                      DS8 260
    655          

   \                                 In section .text, align 2, keep-with-next
    656          extern "C" int closedir(DIR *dir) {
   \                     closedir: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    657              int err = dir->close();
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x68C9             LDR      R1,[R1, #+12]
   \   00000006   0x4788             BLX      R1
   \   00000008   0x0004             MOVS     R4,R0
    658              if (err < 0) {
   \   0000000A   0xD506             BPL      ??closedir_0
    659                  errno = -err;
   \   0000000C   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000010   0x4261             RSBS     R1,R4,#+0
   \   00000012   0x6001             STR      R1,[R0, #+0]
    660                  return -1;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000018   0xBD10             POP      {R4,PC}
    661              } else {
    662                  return 0;
   \                     ??closedir_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    663              }
    664          }
    665          

   \                                 In section .text, align 2, keep-with-next
    666          extern "C" void rewinddir(DIR *dir) {
   \                     rewinddir: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    667              dir->rewind();
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x6989             LDR      R1,[R1, #+24]
   \   00000006   0x4788             BLX      R1
    668          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    669          

   \                                 In section .text, align 2, keep-with-next
    670          extern "C" off_t telldir(DIR *dir) {
   \                     telldir: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    671              return dir->tell();
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x6949             LDR      R1,[R1, #+20]
   \   00000006   0x4788             BLX      R1
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    672          }
    673          

   \                                 In section .text, align 2, keep-with-next
    674          extern "C" void seekdir(DIR *dir, off_t off) {
   \                     seekdir: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    675              dir->seek(off);
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0x6912             LDR      R2,[R2, #+16]
   \   00000006   0x4790             BLX      R2
    676          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    677          

   \                                 In section .text, align 2, keep-with-next
    678          extern "C" int mkdir(const char *path, mode_t mode) {
   \                     mkdir: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x000D             MOVS     R5,R1
    679              FilePath fp(path);
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       _ZN4mbed8FilePathC1EPKc
    680              FileSystemHandle *fs = fp.fileSystem();
   \   0000000E   0x.... 0x....      BL       _ZN4mbed8FilePath10fileSystemEv
   \   00000012   0x0004             MOVS     R4,R0
    681              if (fs == NULL) {
   \   00000014   0xD103             BNE      ??mkdir_0
    682                  errno = ENODEV;
   \   00000016   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000001A   0x2113             MOVS     R1,#+19
   \   0000001C   0xE00D             B.N      ??mkdir_1
    683                  return -1;
    684              }
    685          
    686              int err = fs->mkdir(fp.fileName(), mode);
   \                     ??mkdir_0: (+1)
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0x.... 0x....      BL       _ZN4mbed8FilePath8fileNameEv
   \   00000024   0x0001             MOVS     R1,R0
   \   00000026   0x002A             MOVS     R2,R5
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x6823             LDR      R3,[R4, #+0]
   \   0000002C   0x69DB             LDR      R3,[R3, #+28]
   \   0000002E   0x4798             BLX      R3
   \   00000030   0x0004             MOVS     R4,R0
    687              if (err < 0) {
   \   00000032   0xD506             BPL      ??mkdir_2
    688                  errno = -err;
   \   00000034   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000038   0x4261             RSBS     R1,R4,#+0
   \                     ??mkdir_1: (+1)
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    689                  return -1;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000040   0xE000             B        ??mkdir_3
    690              } else {
    691                  return 0;
   \                     ??mkdir_2: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \                     ??mkdir_3: (+1)
   \   00000044   0xB003             ADD      SP,SP,#+12
   \   00000046   0xBD30             POP      {R4,R5,PC}       ;; return
    692              }
    693          }
    694          

   \                                 In section .text, align 2, keep-with-next
    695          extern "C" int stat(const char *path, struct stat *st) {
   \                     stat: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x000D             MOVS     R5,R1
    696              FilePath fp(path);
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       _ZN4mbed8FilePathC1EPKc
    697              FileSystemHandle *fs = fp.fileSystem();
   \   0000000E   0x.... 0x....      BL       _ZN4mbed8FilePath10fileSystemEv
   \   00000012   0x0004             MOVS     R4,R0
    698              if (fs == NULL) {
   \   00000014   0xD103             BNE      ??stat_0
    699                  errno = ENODEV;
   \   00000016   0x.... 0x....      BL       __aeabi_errno_addr
   \   0000001A   0x2113             MOVS     R1,#+19
   \   0000001C   0xE00D             B.N      ??stat_1
    700                  return -1;
    701              }
    702          
    703              int err = fs->stat(fp.fileName(), st);
   \                     ??stat_0: (+1)
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0x.... 0x....      BL       _ZN4mbed8FilePath8fileNameEv
   \   00000024   0x0001             MOVS     R1,R0
   \   00000026   0x002A             MOVS     R2,R5
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x6823             LDR      R3,[R4, #+0]
   \   0000002C   0x699B             LDR      R3,[R3, #+24]
   \   0000002E   0x4798             BLX      R3
   \   00000030   0x0004             MOVS     R4,R0
    704              if (err < 0) {
   \   00000032   0xD506             BPL      ??stat_2
    705                  errno = -err;
   \   00000034   0x.... 0x....      BL       __aeabi_errno_addr
   \   00000038   0x4261             RSBS     R1,R4,#+0
   \                     ??stat_1: (+1)
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    706                  return -1;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000040   0xE000             B        ??stat_3
    707              } else {
    708                  return 0;
   \                     ??stat_2: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \                     ??stat_3: (+1)
   \   00000044   0xB003             ADD      SP,SP,#+12
   \   00000046   0xBD30             POP      {R4,R5,PC}       ;; return
    709              }
    710          }
    711          
    712          #if defined(TOOLCHAIN_GCC)
    713          /* prevents the exception handling name demangling code getting pulled in */
    714          #include "mbed_error.h"
    715          namespace __gnu_cxx {
    716              void __verbose_terminate_handler() {
    717                  error("Exception");
    718              }
    719          }
    720          extern "C" WEAK void __cxa_pure_virtual(void);
    721          extern "C" WEAK void __cxa_pure_virtual(void) {
    722              exit(1);
    723          }
    724          
    725          #endif
    726          
    727          // Provide implementation of _sbrk (low-level dynamic memory allocation
    728          // routine) for GCC_ARM which compares new heap pointer with MSP instead of
    729          // SP.  This make it compatible with RTX RTOS thread stacks.
    730          #if defined(TOOLCHAIN_GCC_ARM) || defined(TOOLCHAIN_GCC_CR)
    731          
    732          #if defined(TARGET_CORTEX_A)
    733          extern "C" uint32_t  __HeapLimit;
    734          #endif
    735          
    736          // Turn off the errno macro and use actual global variable instead.
    737          #undef errno
    738          extern "C" int errno;
    739          
    740          // Dynamic memory allocation related syscall.
    741          #if defined(TARGET_NUVOTON)
    742          // Overwrite _sbrk() to support two region model (heap and stack are two distinct regions).
    743          // __wrap__sbrk() is implemented in:
    744          // TARGET_NUMAKER_PFM_NUC472    targets/TARGET_NUVOTON/TARGET_NUC472/TARGET_NUMAKER_PFM_NUC472/TOOLCHAIN_GCC_ARM/nuc472_retarget.c
    745          // TARGET_NUMAKER_PFM_M453      targets/TARGET_NUVOTON/TARGET_M451/TARGET_NUMAKER_PFM_M453/TOOLCHAIN_GCC_ARM/m451_retarget.c
    746          extern "C" void *__wrap__sbrk(int incr);
    747          extern "C" caddr_t _sbrk(int incr) {
    748              return (caddr_t) __wrap__sbrk(incr);
    749          }
    750          #else
    751          // Linker defined symbol used by _sbrk to indicate where heap should start.
    752          extern "C" uint32_t __end__;
    753          extern "C" caddr_t _sbrk(int incr) {
    754              static unsigned char* heap = (unsigned char*)&__end__;
    755              unsigned char*        prev_heap = heap;
    756              unsigned char*        new_heap = heap + incr;
    757          
    758          #if defined(TARGET_CORTEX_A)
    759              if (new_heap >= (unsigned char*)&__HeapLimit) {     /* __HeapLimit is end of heap section */
    760          #else
    761              if (new_heap >= (unsigned char*)__get_MSP()) {
    762          #endif
    763                  errno = ENOMEM;
    764                  return (caddr_t)-1;
    765              }
    766          
    767              // Additional heap checking if set
    768              if (mbed_heap_size && (new_heap >= mbed_heap_start + mbed_heap_size)) {
    769                  errno = ENOMEM;
    770                  return (caddr_t)-1;
    771              }
    772          
    773              heap = new_heap;
    774              return (caddr_t) prev_heap;
    775          }
    776          #endif
    777          #endif
    778          
    779          #if defined(TOOLCHAIN_GCC_ARM) || defined(TOOLCHAIN_GCC_CR)
    780          extern "C" void _exit(int return_code) {
    781          #else
    782          namespace std {

   \                                 In section .text, align 2, keep-with-next
    783          extern "C" void exit(int return_code) {
    784          #endif
    785          
    786          #if DEVICE_STDIO_MESSAGES
    787          #if MBED_CONF_PLATFORM_STDIO_FLUSH_AT_EXIT
    788              fflush(stdout);
    789              fflush(stderr);
    790          #endif
    791          #endif
    792          
    793          #if DEVICE_SEMIHOST
    794              if (mbed_interface_connected()) {
    795                  semihost_exit();
    796              }
    797          #endif
    798              if (return_code) {
   \                     exit: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD001             BEQ      ??exit_0
    799                  mbed_die();
   \   00000004   0x.... 0x....      BL       mbed_die
    800              }
    801          
    802              while (1);
   \                     ??exit_0: (+1)
   \   00000008   0xE7FE             B        ??exit_0
    803          }
    804          
    805          #if !defined(TOOLCHAIN_GCC_ARM) && !defined(TOOLCHAIN_GCC_CR)
    806          } //namespace std
    807          #endif
    808          
    809          #if defined(TOOLCHAIN_ARM) || defined(TOOLCHAIN_GCC)
    810          
    811          // This series of function disable the registration of global destructors
    812          // in a dynamic table which will be called when the application exit.
    813          // In mbed, program never exit properly, it dies.
    814          // More informations about this topic for ARMCC here:
    815          // http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/6449.html
    816          extern "C" {
    817          int __aeabi_atexit(void *object, void (*dtor)(void* /*this*/), void *handle) {
    818              return 1;
    819          }
    820          
    821          int __cxa_atexit(void (*dtor)(void* /*this*/), void *object, void *handle) {
    822              return 1;
    823          }
    824          
    825          void __cxa_finalize(void *handle) {
    826          }
    827          
    828          } // end of extern "C"
    829          
    830          #endif
    831          
    832          
    833          #if defined(TOOLCHAIN_GCC)
    834          
    835          /*
    836           * Depending on how newlib is  configured, it is often not enough to define
    837           * __aeabi_atexit, __cxa_atexit and __cxa_finalize in order to override the
    838           * behavior regarding the registration of handlers with atexit.
    839           *
    840           * To overcome this limitation, exit and atexit are overriden here.
    841           */
    842          extern "C"{
    843          
    844          /**
    845           * @brief Retarget of exit for GCC.
    846           * @details Unlike the standard version, this function doesn't call any function
    847           * registered with atexit before calling _exit.
    848           */
    849          void __wrap_exit(int return_code) {
    850              _exit(return_code);
    851          }
    852          
    853          /**
    854           * @brief Retarget atexit from GCC.
    855           * @details This function will always fail and never register any handler to be
    856           * called at exit.
    857           */
    858          int __wrap_atexit(void (*func)()) {
    859              return 1;
    860          }
    861          
    862          }
    863          
    864          #endif
    865          
    866          
    867          
    868          namespace mbed {
    869          

   \                                 In section .text, align 2, keep-with-next
    870          void mbed_set_unbuffered_stream(std::FILE *_file) {
   \                     _ZN4mbed26mbed_set_unbuffered_streamEPSt6__FILE: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    871          #if defined (__ICCARM__)
    872              char buf[2];
    873              std::setvbuf(_file,buf,_IONBF,NULL);
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2202             MOVS     R2,#+2
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x.... 0x....      BL       setvbuf
    874          #else
    875              setbuf(_file, NULL);
    876          #endif
    877          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
    878          
    879          /* Applications are expected to use fdopen()
    880           * not this function directly. This code had to live here because FILE and FileHandle
    881           * processes are all linked together here.
    882           */

   \                                 In section .text, align 2, keep-with-next
    883          std::FILE *mbed_fdopen(FileHandle *fh, const char *mode)
    884          {
   \                     _ZN4mbed11mbed_fdopenEPNS_10FileHandleEPKc: (+1)
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x000C             MOVS     R4,R1
    885              // This is to avoid scanf(buf, ":%.4s", fh) and the bloat it brings.
    886              char buf[1 + sizeof(fh)]; /* :(pointer) */
    887              MBED_STATIC_ASSERT(sizeof(buf) == 5, "Pointers should be 4 bytes.");
    888              buf[0] = ':';
   \   00000006   0xA801             ADD      R0,SP,#+4
   \   00000008   0x213A             MOVS     R1,#+58
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
    889              memcpy(buf + 1, &fh, sizeof(fh));
   \   0000000C   0x2204             MOVS     R2,#+4
   \   0000000E   0xA903             ADD      R1,SP,#+12
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy
    890          
    891              std::FILE *stream = std::fopen(buf, mode);
   \   00000016   0x0021             MOVS     R1,R4
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       fopen
   \   0000001E   0x0004             MOVS     R4,R0
    892              /* newlib-nano doesn't appear to ever call _isatty itself, so
    893               * happily fully buffers an interactive stream. Deal with that here.
    894               */
    895              if (stream && fh->isatty()) {
   \   00000020   0xD00B             BEQ      ??mbed_fdopen_0
   \   00000022   0x9803             LDR      R0,[SP, #+12]
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x69C9             LDR      R1,[R1, #+28]
   \   00000028   0x4788             BLX      R1
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD005             BEQ      ??mbed_fdopen_0
    896                  mbed_set_unbuffered_stream(stream);
   \   0000002E   0x2300             MOVS     R3,#+0
   \   00000030   0x2202             MOVS     R2,#+2
   \   00000032   0x4669             MOV      R1,SP
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       setvbuf
    897              }
    898              return stream;
   \                     ??mbed_fdopen_0: (+1)
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0xB004             ADD      SP,SP,#+16
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    899          }
    900          

   \                                 In section .text, align 2, keep-with-next
    901          int mbed_getc(std::FILE *_file){
   \                     _ZN4mbed9mbed_getcEPSt6__FILE: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    902          #if defined(__IAR_SYSTEMS_ICC__ ) && (__VER__ < 8000000)
    903              /*This is only valid for unbuffered streams*/
    904              int res = std::fgetc(_file);
   \   00000004   0x.... 0x....      BL       fgetc
    905              if (res>=0){
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD407             BMI      ??mbed_getc_0
    906                  _file->_Mode = (unsigned short)(_file->_Mode & ~ 0x1000);/* Unset read mode */
   \   0000000C   0x8821             LDRH     R1,[R4, #+0]
   \   0000000E   0x....             LDR      R2,??DataTable17_1  ;; 0xefff
   \   00000010   0x400A             ANDS     R2,R2,R1
   \   00000012   0x8022             STRH     R2,[R4, #+0]
    907                  _file->_Rend = _file->_Wend;
   \   00000014   0x6961             LDR      R1,[R4, #+20]
   \   00000016   0x6121             STR      R1,[R4, #+16]
    908                  _file->_Next = _file->_Wend;
   \   00000018   0x6961             LDR      R1,[R4, #+20]
   \   0000001A   0x60E1             STR      R1,[R4, #+12]
    909              }
    910              return res;
   \                     ??mbed_getc_0: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    911          #else
    912              return std::fgetc(_file);
    913          #endif
    914          }
    915          

   \                                 In section .text, align 2, keep-with-next
    916          char* mbed_gets(char*s, int size, std::FILE *_file){
   \                     _ZN4mbed9mbed_getsEPciPSt6__FILE: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0014             MOVS     R4,R2
    917          #if defined(__IAR_SYSTEMS_ICC__ ) && (__VER__ < 8000000)
    918              /*This is only valid for unbuffered streams*/
    919              char *str = fgets(s,size,_file);
   \   00000004   0x.... 0x....      BL       fgets
    920              if (str!=NULL){
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD007             BEQ      ??mbed_gets_0
    921                  _file->_Mode = (unsigned short)(_file->_Mode & ~ 0x1000);/* Unset read mode */
   \   0000000C   0x8821             LDRH     R1,[R4, #+0]
   \   0000000E   0x....             LDR      R2,??DataTable17_1  ;; 0xefff
   \   00000010   0x400A             ANDS     R2,R2,R1
   \   00000012   0x8022             STRH     R2,[R4, #+0]
    922                  _file->_Rend = _file->_Wend;
   \   00000014   0x6961             LDR      R1,[R4, #+20]
   \   00000016   0x6121             STR      R1,[R4, #+16]
    923                  _file->_Next = _file->_Wend;
   \   00000018   0x6961             LDR      R1,[R4, #+20]
   \   0000001A   0x60E1             STR      R1,[R4, #+12]
    924              }
    925              return str;
   \                     ??mbed_gets_0: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    926          #else
    927              return std::fgets(s,size,_file);
    928          #endif
    929          }
    930          
    931          } // namespace mbed
    932          
    933          #if defined (__ICCARM__)
    934          // Stub out locks when an rtos is not present

   \                                 In section .text, align 2
    935          extern "C" WEAK void __iar_system_Mtxinit(__iar_Rmtx *mutex) {}
   \                     __iar_system_Mtxinit: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
    936          extern "C" WEAK void __iar_system_Mtxdst(__iar_Rmtx *mutex) {}
   \                     __iar_system_Mtxdst: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
    937          extern "C" WEAK void __iar_system_Mtxlock(__iar_Rmtx *mutex) {}
   \                     __iar_system_Mtxlock: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
    938          extern "C" WEAK void __iar_system_Mtxunlock(__iar_Rmtx *mutex) {}
   \                     __iar_system_Mtxunlock: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
    939          extern "C" WEAK void __iar_file_Mtxinit(__iar_Rmtx *mutex) {}
   \                     __iar_file_Mtxinit: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
    940          extern "C" WEAK void __iar_file_Mtxdst(__iar_Rmtx *mutex) {}
   \                     __iar_file_Mtxdst: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
    941          extern "C" WEAK void __iar_file_Mtxlock(__iar_Rmtx *mutex) {}
   \                     __iar_file_Mtxlock: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
    942          extern "C" WEAK void __iar_file_Mtxunlock(__iar_Rmtx *mutex) {}
   \                     __iar_file_Mtxunlock: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    943          #if defined(__IAR_SYSTEMS_ICC__ ) && (__VER__ >= 8000000)
    944          #pragma section="__iar_tls$$DATA"
    945          extern "C" WEAK void *__aeabi_read_tp (void) {
    946            // Thread Local storage is not supported, using main thread memory for errno
    947            return __section_begin("__iar_tls$$DATA");
    948          }
    949          #endif
    950          #elif defined(__CC_ARM)
    951          // Do nothing
    952          #elif defined (__GNUC__)
    953          struct _reent;
    954          // Stub out locks when an rtos is not present
    955          extern "C" WEAK void __rtos_malloc_lock( struct _reent *_r ) {}
    956          extern "C" WEAK void __rtos_malloc_unlock( struct _reent *_r ) {}
    957          extern "C" WEAK void __rtos_env_lock( struct _reent *_r ) {}
    958          extern "C" WEAK void __rtos_env_unlock( struct _reent *_r ) {}
    959          
    960          extern "C" void __malloc_lock( struct _reent *_r )
    961          {
    962              __rtos_malloc_lock(_r);
    963          }
    964          
    965          extern "C" void __malloc_unlock( struct _reent *_r )
    966          {
    967              __rtos_malloc_unlock(_r);
    968          }
    969          
    970          extern "C" void __env_lock( struct _reent *_r )
    971          {
    972              __rtos_env_lock(_r);
    973          }
    974          
    975          extern "C" void __env_unlock( struct _reent *_r )
    976          {
    977              __rtos_env_unlock(_r);
    978          }
    979          
    980          #define CXA_GUARD_INIT_DONE             (1 << 0)
    981          #define CXA_GUARD_INIT_IN_PROGRESS      (1 << 1)
    982          #define CXA_GUARD_MASK                  (CXA_GUARD_INIT_DONE | CXA_GUARD_INIT_IN_PROGRESS)
    983          
    984          extern "C" int __cxa_guard_acquire(int *guard_object_p)
    985          {
    986              uint8_t *guard_object = (uint8_t *)guard_object_p;
    987              if (CXA_GUARD_INIT_DONE == (*guard_object & CXA_GUARD_MASK)) {
    988                  return 0;
    989              }
    990              singleton_lock();
    991              if (CXA_GUARD_INIT_DONE == (*guard_object & CXA_GUARD_MASK)) {
    992                  singleton_unlock();
    993                  return 0;
    994              }
    995              MBED_ASSERT(0 == (*guard_object & CXA_GUARD_MASK));
    996              *guard_object = *guard_object | CXA_GUARD_INIT_IN_PROGRESS;
    997              return 1;
    998          }
    999          
   1000          extern "C" void __cxa_guard_release(int *guard_object_p)
   1001          {
   1002              uint8_t *guard_object = (uint8_t *)guard_object_p;
   1003              MBED_ASSERT(CXA_GUARD_INIT_IN_PROGRESS == (*guard_object & CXA_GUARD_MASK));
   1004              *guard_object = (*guard_object & ~CXA_GUARD_MASK) | CXA_GUARD_INIT_DONE;
   1005              singleton_unlock();
   1006          }
   1007          
   1008          extern "C" void __cxa_guard_abort(int *guard_object_p)
   1009          {
   1010              uint8_t *guard_object = (uint8_t *)guard_object_p;
   1011              MBED_ASSERT(CXA_GUARD_INIT_IN_PROGRESS == (*guard_object & CXA_GUARD_MASK));
   1012              *guard_object = *guard_object & ~CXA_GUARD_INIT_IN_PROGRESS;
   1013              singleton_unlock();
   1014          }
   1015          
   1016          #endif
   1017          

   \                                 In section .text, align 4, keep-with-next
   1018          void *operator new(std::size_t count)
   1019          {
   \                     _Znwj: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1020              void *buffer = malloc(count);
   \   00000002   0x.... 0x....      BL       malloc
   \   00000006   0x0004             MOVS     R4,R0
   1021              if (NULL == buffer) {
   \   00000008   0xD103             BNE      `??operator new_0`
   1022                  error("Operator new out of memory\r\n");
   \   0000000A   0xBF00             Nop      
   \   0000000C   0x....             ADR.N    R0,?_0
   \   0000000E   0x.... 0x....      BL       error
   1023              }
   1024              return buffer;
   \                     `??operator new_0`: (+1)
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
   1025          }
   1026          

   \                                 In section .text, align 4, keep-with-next
   1027          void *operator new[](std::size_t count)
   1028          {
   \                     _Znaj: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1029              void *buffer = malloc(count);
   \   00000002   0x.... 0x....      BL       malloc
   \   00000006   0x0004             MOVS     R4,R0
   1030              if (NULL == buffer) {
   \   00000008   0xD103             BNE      `??operator new[]_0`
   1031                  error("Operator new[] out of memory\r\n");
   \   0000000A   0xBF00             Nop      
   \   0000000C   0x....             ADR.N    R0,?_1
   \   0000000E   0x.... 0x....      BL       error
   1032              }
   1033              return buffer;
   \                     `??operator new[]_0`: (+1)
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
   1034          }
   1035          

   \                                 In section .text, align 2, keep-with-next
   1036          void *operator new(std::size_t count, const std::nothrow_t& tag)
   1037          {
   \                     _ZnwjRKSt9nothrow_t: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1038              return malloc(count);
   \   00000002   0x.... 0x....      BL       malloc
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
   1039          }
   1040          

   \                                 In section .text, align 2, keep-with-next
   1041          void *operator new[](std::size_t count, const std::nothrow_t& tag)
   1042          {
   \                     _ZnajRKSt9nothrow_t: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1043              return malloc(count);
   \   00000002   0x.... 0x....      BL       malloc
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
   1044          }
   1045          

   \                                 In section .text, align 2, keep-with-next
   1046          void operator delete(void *ptr)
   1047          {
   1048              if (ptr != NULL) {
   \                     _ZdlPv: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD100             BNE      `??operator delete_0`
   \   00000004   0x4770             BX       LR
   1049                  free(ptr);
   \                     `??operator delete_0`: (+1)
   \   00000006   0xB580             PUSH     {R7,LR}
   \   00000008   0x.... 0x....      BL       free
   1050              }
   1051          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   1052          void operator delete[](void *ptr)
   1053          {
   1054              if (ptr != NULL) {
   \                     _ZdaPv: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD100             BNE      `??operator delete[]_0`
   \   00000004   0x4770             BX       LR
   1055                  free(ptr);
   \                     `??operator delete[]_0`: (+1)
   \   00000006   0xB580             PUSH     {R7,LR}
   \   00000008   0x.... 0x....      BL       free
   1056              }
   1057          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
   1058          
   1059          /* @brief   standard c library clock() function.
   1060           *
   1061           * This function returns the number of clock ticks elapsed since the start of the program.
   1062           *
   1063           * @note Synchronization level: Thread safe
   1064           *
   1065           * @return
   1066           *  the number of clock ticks elapsed since the start of the program.
   1067           *
   1068           * */

   \                                 In section .text, align 2, keep-with-next
   1069          extern "C" clock_t clock()
   1070          {
   \                     clock: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1071              _mutex->lock();
   \   00000002   0x....             LDR      R4,??DataTable17_2
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _ZN12SingletonPtrIN4rtos5MutexEEptEv
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000000E   0x.... 0x....      BL       _ZN4rtos5Mutex4lockEj
   1072              clock_t t = ticker_read(get_us_ticker_data());
   \   00000012   0x.... 0x....      BL       get_us_ticker_data
   \   00000016   0x.... 0x....      BL       ticker_read
   \   0000001A   0x0005             MOVS     R5,R0
   1073              t /= 1000000 / CLOCKS_PER_SEC; // convert to processor time
   1074              _mutex->unlock();
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       _ZN12SingletonPtrIN4rtos5MutexEEptEv
   \   00000022   0x.... 0x....      BL       _ZN4rtos5Mutex6unlockEv
   1075              return t;
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0x....             LDR      R1,??DataTable17_3  ;; 0xf4240
   \   0000002A   0x.... 0x....      BL       __aeabi_uidiv
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1076          }
   1077          
   1078          // temporary - Default to 1MHz at 32 bits if target does not have us_ticker_get_info

   \                                 In section .text, align 4
   1079          MBED_WEAK const ticker_info_t* us_ticker_get_info()
   1080          {
   1081              static const ticker_info_t info = {
   1082                  1000000,
   1083                  32
   1084              };
   1085              return &info;
   \                     us_ticker_get_info: (+1)
   \   00000000   0x4800             LDR      R0,??us_ticker_get_info_0
   \   00000002   0x4770             BX       LR               ;; return
   \                     ??us_ticker_get_info_0:
   \   00000004   0x........         DC32     `us_ticker_get_info::info`
   1086          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     `us_ticker_get_info::info`:
   \   00000000   0x000F4240         DC32 1000000, 32
   \              0x00000020   
   1087          
   1088          // temporary - Default to 1MHz at 32 bits if target does not have lp_ticker_get_info

   \                                 In section .text, align 4
   1089          MBED_WEAK const ticker_info_t* lp_ticker_get_info()
   1090          {
   1091              static const ticker_info_t info = {
   1092                  1000000,
   1093                  32
   1094              };
   1095              return &info;
   \                     _Z18lp_ticker_get_infov: (+1)
   \   00000000   0x4800             LDR      R0,??lp_ticker_get_info_0
   \   00000002   0x4770             BX       LR               ;; return
   \                     ??lp_ticker_get_info_0:
   \   00000004   0x........         DC32     `lp_ticker_get_info()::info`
   1096          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     `lp_ticker_get_info()::info`:
   \   00000000   0x000F4240         DC32 1000000, 32
   \              0x00000020   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     filehandles

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     stdio_uart_inited

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     stdio_uart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     filehandles

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     `readdir::ent`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x0000EFFF         DC32     0xefff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     _mutex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x4F 0x70          DC8 "Operator new out of memory\015\012"
   \              0x65 0x72    
   \              0x61 0x74    
   \              0x6F 0x72    
   \              0x20 0x6E    
   \              0x65 0x77    
   \              0x20 0x6F    
   \              0x75 0x74    
   \              0x20 0x6F    
   \              0x66 0x20    
   \              0x6D 0x65    
   \              0x6D 0x6F    
   \              0x72 0x79    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x4F 0x70          DC8 "Operator new[] out of memory\015\012"
   \              0x65 0x72    
   \              0x61 0x74    
   \              0x6F 0x72    
   \              0x20 0x6E    
   \              0x65 0x77    
   \              0x5B 0x5D    
   \              0x20 0x6F    
   \              0x75 0x74    
   \              0x20 0x6F    
   \              0x66 0x20    
   \              0x6D 0x65    
   \              0x6D 0x6F    
   \              0x72 0x79    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   SingletonPtr<rtos::Mutex>::operator->()
        16   -> mbed_assert_internal
        16   -> osMutexAcquire
        16   -> osMutexRelease
        16   -> rtos::Mutex::Mutex()
       0   __iar_file_Mtxdst
       0   __iar_file_Mtxinit
       0   __iar_file_Mtxlock
       0   __iar_file_Mtxunlock
       0   __iar_system_Mtxdst
       0   __iar_system_Mtxinit
       0   __iar_system_Mtxlock
       0   __iar_system_Mtxunlock
       8   _isatty
         8   -- Indirect call
         8   -> std::__aeabi_errno_addr
       8   closedir
         8   -- Indirect call
         8   -> std::__aeabi_errno_addr
       0   lp_ticker_get_info()
      24   mbed::mbed_fdopen(mbed::FileHandle *, char const *)
        24   -- Indirect call
        24   -> __aeabi_memcpy
        24   -> std::fopen
        24   -> std::setvbuf
       8   mbed::mbed_getc(std::FILE *)
         8   -> std::fgetc
       8   mbed::mbed_gets(char *, int, std::FILE *)
         8   -> std::fgets
       8   mbed::mbed_set_unbuffered_stream(std::FILE *)
         8   -> std::setvbuf
      16   mbed::remove_filehandle(mbed::FileHandle *)
        16   -> SingletonPtr<rtos::Mutex>::operator->()
        16   -> rtos::Mutex::lock(unsigned int)
        16   -> rtos::Mutex::unlock()
      24   mkdir
        24   -- Indirect call
        24   -> mbed::FilePath::FilePath(char const *)
        24   -> mbed::FilePath::fileName()
        24   -> mbed::FilePath::fileSystem()
        24   -> std::__aeabi_errno_addr
      24   opendir
        24   -- Indirect call
        24   -> mbed::FilePath::FilePath(char const *)
        24   -> mbed::FilePath::fileName()
        24   -> mbed::FilePath::fileSystem()
        24   -> std::__aeabi_errno_addr
       8   operator delete(void *)
         8   -> std::free
       8   operator delete[](void *)
         8   -> std::free
       8   operator new(std::size_t)
         8   -> error
         8   -> std::malloc
       8   operator new(std::size_t, std::nothrow_t const &)
         8   -> std::malloc
       8   operator new[](std::size_t)
         8   -> error
         8   -> std::malloc
       8   operator new[](std::size_t, std::nothrow_t const &)
         8   -> std::malloc
      16   readdir
        16   -- Indirect call
        16   -> std::__aeabi_errno_addr
       8   rewinddir
         8   -- Indirect call
       8   seekdir
         8   -- Indirect call
      24   stat
        24   -- Indirect call
        24   -> mbed::FilePath::FilePath(char const *)
        24   -> mbed::FilePath::fileName()
        24   -> mbed::FilePath::fileSystem()
        24   -> std::__aeabi_errno_addr
       8   std::__close
         8   -- Indirect call
         8   -> std::__aeabi_errno_addr
       8   std::__lseek
         8   -- Indirect call
         8   -> std::__aeabi_errno_addr
      48   std::__open
        48   -- Indirect call
        48   -> SingletonPtr<rtos::Mutex>::operator->()
        48   -> __aeabi_memcpy
        48   -> mbed::FilePath::FilePath(char const *)
        48   -> mbed::FilePath::exists()
        48   -> mbed::FilePath::file()
        48   -> mbed::FilePath::fileName()
        48   -> mbed::FilePath::fileSystem()
        48   -> mbed::FilePath::isFile()
        48   -> rtos::Mutex::lock(unsigned int)
        48   -> rtos::Mutex::unlock()
        48   -> serial_baud
        48   -> serial_init
        48   -> std::__aeabi_errno_addr
        48   -> std::strcmp
      16   std::__read
        16   -- Indirect call
        16   -> serial_baud
        16   -> serial_getc
        16   -> serial_init
        16   -> std::__aeabi_errno_addr
      24   std::__write
        24   -- Indirect call
        24   -> serial_baud
        24   -> serial_init
        24   -> serial_putc
        24   -> std::__aeabi_errno_addr
      16   std::clock
        16   -> SingletonPtr<rtos::Mutex>::operator->()
        16   -> get_us_ticker_data
        16   -> rtos::Mutex::lock(unsigned int)
        16   -> rtos::Mutex::unlock()
        16   -> ticker_read
        16 __aeabi_uidiv
       0   std::exit
         0   -> mbed_die
      16   std::remove
        16   -- Indirect call
        16   -> mbed::FilePath::FilePath(char const *)
        16   -> mbed::FilePath::fileName()
        16   -> mbed::FilePath::fileSystem()
        16   -> std::__aeabi_errno_addr
      32   std::rename
        32   -- Indirect call
        32   -> mbed::FilePath::FilePath(char const *)
        32   -> mbed::FilePath::fileName()
        32   -> mbed::FilePath::fileSystem()
        32   -> std::__aeabi_errno_addr
       0   std::tmpfile
         8   -> std::__aeabi_errno_addr
       8   std::tmpnam
         8   -> std::__aeabi_errno_addr
       8   telldir
         8   -- Indirect call
       0   us_ticker_get_info


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable15
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
      12  ?Subroutine0
      32  ?_0
      32  ?_1
      80  SingletonPtr<rtos::Mutex>::operator->()
       2  __iar_file_Mtxdst
       2  __iar_file_Mtxinit
       2  __iar_file_Mtxlock
       2  __iar_file_Mtxunlock
       2  __iar_system_Mtxdst
       2  __iar_system_Mtxinit
       2  __iar_system_Mtxlock
       2  __iar_system_Mtxunlock
       8  __stderr_name
       8  __stdin_name
       8  __stdout_name
      54  _isatty
      40  _mutex
      30  closedir
     260  ent
     104  filehandles
          filehandle_mutex
       8  info
       8  info
       8  lp_ticker_get_info()
      64  mbed::mbed_fdopen(mbed::FileHandle *, char const *)
      30  mbed::mbed_getc(std::FILE *)
      30  mbed::mbed_gets(char *, int, std::FILE *)
      14  mbed::mbed_set_unbuffered_stream(std::FILE *)
      88  mbed::remove_filehandle(mbed::FileHandle *)
       4  mbed_heap_size
       4  mbed_heap_start
      72  mkdir
      68  opendir
      14  operator delete(void *)
      14  operator delete[](void *)
      22  operator new(std::size_t)
       8  operator new(std::size_t, std::nothrow_t const &)
      22  operator new[](std::size_t)
       8  operator new[](std::size_t, std::nothrow_t const &)
      38  readdir
      10  rewinddir
      10  seekdir
      72  stat
      60  std::__close
      60  std::__lseek
     454  std::__open
     102  std::__read
     116  std::__write
      48  std::clock
      10  std::exit
      64  std::remove
     110  std::rename
       2  std::tmpfile
       4  std::tmpnam
      10  telldir
       8  us_ticker_get_info
     392  -- Other

 
   412 bytes in section .bss
   408 bytes in section .rodata
 1 952 bytes in section .text
 
 1 840 bytes of CODE  memory (+ 112 bytes shared)
    16 bytes of CONST memory (+ 392 bytes shared)
   412 bytes of DATA  memory

Errors: none
Warnings: none

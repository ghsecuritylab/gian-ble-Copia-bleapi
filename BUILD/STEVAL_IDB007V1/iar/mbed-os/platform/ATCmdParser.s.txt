###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:41
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\platform\ATCmdParser.cpp
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --c++ --no_rtti --no_exceptions --guard_calls
#        --no_static_destruction -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\platform\ATCmdParser.d -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\platform\ATCmdParser.s.txt -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\platform\ATCmdParser.o
#        .\mbed-os\platform\ATCmdParser.cpp
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\platform\ATCmdParser.s.txt
#    Object file  =  .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\platform\ATCmdParser.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\platform\ATCmdParser.cpp
      1          /* Copyright (c) 2017 ARM Limited
      2           *
      3           * Licensed under the Apache License, Version 2.0 (the "License");
      4           * you may not use this file except in compliance with the License.
      5           * You may obtain a copy of the License at
      6           *
      7           *     http://www.apache.org/licenses/LICENSE-2.0
      8           *
      9           * Unless required by applicable law or agreed to in writing, software
     10           * distributed under the License is distributed on an "AS IS" BASIS,
     11           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     12           * See the License for the specific language governing permissions and
     13           * limitations under the License.
     14           *
     15           * @section DESCRIPTION
     16           *
     17           * Parser for the AT command syntax
     18           *
     19           */
     20          
     21          #include "ATCmdParser.h"

   \                                 In section .rodata, align 4
   \   __absolute mbed::Callback<void ()>::ops const mbed::Callback<void ()>::generate<>(void (*const &)())::ops
   \                     _ZZN4mbed8CallbackIFvvEE8generateIPS1_EEvRKT_E3ops:
   \   00000000   0x........         DC32 _ZN4mbed8CallbackIFvvEE13function_callIPS1_EEvPKv
   \   00000004   0x........         DC32 _ZN4mbed8CallbackIFvvEE13function_moveIPS1_EEvPvPKv
   \   00000008   0x........         DC32 _ZN4mbed8CallbackIFvvEE13function_dtorIPS1_EEvPv

   \                                 In section .rodata, align 4
   \   __absolute mbed::Callback<void ()>::ops const mbed::Callback<void ()>::generate<>(mbed::Callback<void ()>::function_context<void (*)(void *), void> const &)::ops
   \                     _ZZN4mbed8CallbackIFvvEE8generateINS2_16function_contextIPFvPvEvEEEEvRKT_E3ops:
   \   00000000   0x........         DC32 _ZN4mbed8CallbackIFvvEE13function_callINS2_16function_contextIPFvPvEvEEEEvPKv
   \   00000004   0x........         DC32 _ZN4mbed8CallbackIFvvEE13function_moveINS2_16function_contextIPFvPvEvEEEEvS5_PKv
   \   00000008   0x........         DC32 _ZN4mbed8CallbackIFvvEE13function_dtorINS2_16function_contextIPFvPvEvEEEEvS5_

   \                                 In section .text, align 2
   \   __interwork __softfp void mbed::Callback<void ()>::function_call<void (*)()>(void const *)
   \                     _ZN4mbed8CallbackIFvvEE13function_callIPS1_EEvPKv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4780             BLX      R0
   \   00000006   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void mbed::Callback<void ()>::function_call<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void const *)
   \                     _ZN4mbed8CallbackIFvvEE13function_callINS2_16function_contextIPFvPvEvEEEEvPKv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0x6848             LDR      R0,[R1, #+4]
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x4788             BLX      R1
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void mbed::Callback<void ()>::function_move<void (*)()>(void *, void const *)
   \                     _ZN4mbed8CallbackIFvvEE13function_moveIPS1_EEvPvPKv: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD001             BEQ      ??function_move_0
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x6001             STR      R1,[R0, #+0]
   \                     ??function_move_0: (+1)
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void mbed::Callback<void ()>::function_move<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *, void const *)
   \                     _ZN4mbed8CallbackIFvvEE13function_moveINS2_16function_contextIPFvPvEvEEEEvS5_PKv: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD001             BEQ      ??function_move_1
   \   00000004   0xC90C             LDM      R1!,{R2,R3}
   \   00000006   0xC00C             STM      R0!,{R2,R3}
   \                     ??function_move_1: (+1)
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void mbed::Callback<void ()>::function_dtor<void (*)()>(void *)
   \                     _ZN4mbed8CallbackIFvvEE13function_dtorIPS1_EEvPv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void mbed::Callback<void ()>::function_dtor<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *)
   \                     _ZN4mbed8CallbackIFvvEE13function_dtorINS2_16function_contextIPFvPvEvEEEEvS5_: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp void mbed::callback<>(void (*)(void *), void *)
   \                     _ZN4mbed8callbackIvvvEENS_8CallbackIFT1_vEEEPFS2_PT_EPT0_: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0xC078             STM      R0!,{R3-R6}
   \   0000000C   0x3810             SUBS     R0,R0,#+16
   \   0000000E   0xD001             BEQ      ??callback_0
   \   00000010   0x6001             STR      R1,[R0, #+0]
   \   00000012   0x6042             STR      R2,[R0, #+4]
   \                     ??callback_0: (+1)
   \   00000014   0x4901             LDR      R1,??callback_1
   \   00000016   0x60C1             STR      R1,[R0, #+12]
   \   00000018   0xBC70             POP      {R4-R6}
   \   0000001A   0x4770             BX       LR               ;; return
   \                     ??callback_1:
   \   0000001C   0x........         DC32     _ZZN4mbed8CallbackIFvvEE8generateINS2_16function_contextIPFvPvEvEEEEvRKT_E3ops

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void debug_if(int, char const *, ...)
   \                     _Z8debug_ifiPKcz: (+1)
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB002             ADD      SP,SP,#+8
   \   00000004   0x4770             BX       LR               ;; return
     22          #include "mbed_poll.h"
     23          #include "mbed_debug.h"
     24          
     25          #ifdef LF
     26          #undef LF
     27          #define LF  10
     28          #else
     29          #define LF  10
     30          #endif
     31          
     32          #ifdef CR
     33          #undef CR
     34          #define CR  13
     35          #else
     36          #define CR  13
     37          #endif
     38          
     39          // getc/putc handling with timeouts

   \                                 In section .text, align 2, keep-with-next
     40          int ATCmdParser::putc(char c)
     41          {
   \                     _ZN4mbed11ATCmdParser4putcEc: (+1)
   \   00000000   0xB572             PUSH     {R1,R4-R6,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0006             MOVS     R6,R0
     42              pollfh fhs;
     43              fhs.fh = _fh;
   \   00000006   0x6830             LDR      R0,[R6, #+0]
   \   00000008   0x9000             STR      R0,[SP, #+0]
     44              fhs.events = POLLOUT;
   \   0000000A   0x2510             MOVS     R5,#+16
   \   0000000C   0x466C             MOV      R4,SP
   \   0000000E   0x80A5             STRH     R5,[R4, #+4]
     45          
     46              int count = poll(&fhs, 1, _timeout);
     47              if (count > 0 && (fhs.revents & POLLOUT)) {
   \   00000010   0x68F2             LDR      R2,[R6, #+12]
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x4668             MOV      R0,SP
   \   00000016   0x.... 0x....      BL       _ZN4mbed4pollEPNS_6pollfhEji
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xDB0C             BLT      ??putc_0
   \   0000001E   0x88E0             LDRH     R0,[R4, #+6]
   \   00000020   0x4228             TST      R0,R5
   \   00000022   0xD009             BEQ      ??putc_0
     48                  return _fh->write(&c, 1) == 1 ? 0 : -1;
   \   00000024   0x6830             LDR      R0,[R6, #+0]
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0xA903             ADD      R1,SP,#+12
   \   0000002A   0x6803             LDR      R3,[R0, #+0]
   \   0000002C   0x68DB             LDR      R3,[R3, #+12]
   \   0000002E   0x4798             BLX      R3
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD101             BNE      ??putc_0
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE001             B        ??putc_1
     49              } else {
     50                  return -1;
   \                     ??putc_0: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x43C0             MVNS     R0,R0            ;; #-1
   \                     ??putc_1: (+1)
   \   0000003C   0xB004             ADD      SP,SP,#+16
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
     51              }
     52          }
     53          

   \                                 In section .text, align 2, keep-with-next
     54          int ATCmdParser::getc()
     55          {
   \                     _ZN4mbed11ATCmdParser4getcEv: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0005             MOVS     R5,R0
     56              pollfh fhs;
     57              fhs.fh = _fh;
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x9001             STR      R0,[SP, #+4]
     58              fhs.events = POLLIN;
   \   0000000A   0xAC01             ADD      R4,SP,#+4
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x80A0             STRH     R0,[R4, #+4]
     59          
     60              int count = poll(&fhs, 1, _timeout);
     61              if (count > 0 && (fhs.revents & POLLIN)) {
   \   00000010   0x68EA             LDR      R2,[R5, #+12]
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      BL       _ZN4mbed4pollEPNS_6pollfhEji
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xDB0D             BLT      ??getc_0
   \   0000001E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000020   0x07C0             LSLS     R0,R0,#+31
   \   00000022   0xD50A             BPL      ??getc_0
     62                  unsigned char ch;
     63                  return _fh->read(&ch, 1) == 1 ? ch : -1;
   \   00000024   0x6828             LDR      R0,[R5, #+0]
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x6803             LDR      R3,[R0, #+0]
   \   0000002C   0x689B             LDR      R3,[R3, #+8]
   \   0000002E   0x4798             BLX      R3
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD102             BNE      ??getc_0
   \   00000034   0x4668             MOV      R0,SP
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0xE001             B        ??getc_1
     64              } else {
     65                  return -1;
   \                     ??getc_0: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x43C0             MVNS     R0,R0            ;; #-1
   \                     ??getc_1: (+1)
   \   0000003E   0xB003             ADD      SP,SP,#+12
   \   00000040   0xBD30             POP      {R4,R5,PC}       ;; return
     66              }
     67          }
     68          

   \                                 In section .text, align 2, keep-with-next
     69          void ATCmdParser::flush()
     70          {
   \                     _ZN4mbed11ATCmdParser5flushEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0xE005             B        ??flush_0
     71              while (_fh->readable()) {
     72                  unsigned char ch;
     73                  _fh->read(&ch, 1);
   \                     ??flush_1: (+1)
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x6803             LDR      R3,[R0, #+0]
   \   00000010   0x689B             LDR      R3,[R3, #+8]
   \   00000012   0x4798             BLX      R3
     74              }
   \                     ??flush_0: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x6BD2             LDR      R2,[R2, #+60]
   \   0000001C   0x4790             BLX      R2
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD4F2             BMI      ??flush_1
     75          }
   \   00000022   0xBD13             POP      {R0,R1,R4,PC}    ;; return
     76          
     77          
     78          // read/write handling with timeouts

   \                                 In section .text, align 2, keep-with-next
     79          int ATCmdParser::write(const char *data, int size)
     80          {
   \                     _ZN4mbed11ATCmdParser5writeEPKci: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x0017             MOVS     R7,R2
     81              int i = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x2F01             CMP      R7,#+1
   \   0000000A   0xDB0D             BLT      ??write_0
   \   0000000C   0x000D             MOVS     R5,R1
     82              for ( ; i < size; i++) {
     83                  if (putc(data[i]) < 0) {
   \                     ??write_1: (+1)
   \   0000000E   0x7829             LDRB     R1,[R5, #+0]
   \   00000010   0x0030             MOVS     R0,R6
   \   00000012   0x.... 0x....      BL       _ZN4mbed11ATCmdParser4putcEc
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD502             BPL      ??write_2
     84                      return -1;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000001E   0xBDF2             POP      {R1,R4-R7,PC}
     85                  }
     86              }
   \                     ??write_2: (+1)
   \   00000020   0x1C64             ADDS     R4,R4,#+1
   \   00000022   0x1C6D             ADDS     R5,R5,#+1
   \   00000024   0x42BC             CMP      R4,R7
   \   00000026   0xDBF2             BLT      ??write_1
     87              return i;
   \                     ??write_0: (+1)
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     88          }
     89          

   \                                 In section .text, align 2, keep-with-next
     90          int ATCmdParser::read(char *data, int size)
     91          {
   \                     _ZN4mbed11ATCmdParser4readEPci: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0017             MOVS     R7,R2
     92              int i = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x2F01             CMP      R7,#+1
   \   0000000A   0xDB0D             BLT      ??read_0
   \   0000000C   0x000E             MOVS     R6,R1
     93              for ( ; i < size; i++) {
     94                  int c = getc();
   \                     ??read_1: (+1)
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       _ZN4mbed11ATCmdParser4getcEv
     95                  if (c < 0) {
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD502             BPL      ??read_2
     96                      return -1;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000001C   0xBDF2             POP      {R1,R4-R7,PC}
     97                  }
     98                  data[i] = c;
   \                     ??read_2: (+1)
   \   0000001E   0x7030             STRB     R0,[R6, #+0]
     99              }
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
   \   00000022   0x1C76             ADDS     R6,R6,#+1
   \   00000024   0x42BD             CMP      R5,R7
   \   00000026   0xDBF2             BLT      ??read_1
    100              return i;
   \                     ??read_0: (+1)
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    101          }
    102          
    103          
    104          // printf/scanf handling

   \                                 In section .text, align 2, keep-with-next
    105          int ATCmdParser::vprintf(const char *format, va_list args)
    106          {
   \                     _ZN4mbed11ATCmdParser7vprintfEPKc9__va_list: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    107          
    108              if (vsprintf(_buffer, format, args) < 0) {
   \   00000004   0x68A0             LDR      R0,[R4, #+8]
   \   00000006   0x.... 0x....      BL       vsprintf
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD501             BPL      ??vprintf_0
    109                  return false;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
    110              }
    111          
    112              int i = 0;
   \                     ??vprintf_0: (+1)
   \   00000012   0x2500             MOVS     R5,#+0
   \   00000014   0xE000             B        ??vprintf_1
    113              for ( ; _buffer[i]; i++) {
   \                     ??vprintf_2: (+1)
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
   \                     ??vprintf_1: (+1)
   \   00000018   0x68A0             LDR      R0,[R4, #+8]
   \   0000001A   0x5D41             LDRB     R1,[R0, R5]
   \   0000001C   0x0008             MOVS     R0,R1
   \   0000001E   0xD007             BEQ      ??vprintf_3
    114                  if (putc(_buffer[i]) < 0) {
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       _ZN4mbed11ATCmdParser4putcEc
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD5F5             BPL      ??vprintf_2
    115                      return -1;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}
    116                  }
    117              }
    118              return i;
   \                     ??vprintf_3: (+1)
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    119          }
    120          

   \                                 In section .text, align 2, keep-with-next
    121          int ATCmdParser::vscanf(const char *format, va_list args)
    122          {
   \                     _ZN4mbed11ATCmdParser6vscanfEPKc9__va_list: (+1)
   \   00000000   0xB5F6             PUSH     {R1,R2,R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0005             MOVS     R5,R0
    123              // Since format is const, we need to copy it into our buffer to
    124              // add the line's null terminator and clobber value-matches with asterisks.
    125              //
    126              // We just use the beginning of the buffer to avoid unnecessary allocations.
    127              int i = 0;
   \   00000006   0x2700             MOVS     R7,#+0
   \   00000008   0x2000             MOVS     R0,#+0
    128              int offset = 0;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0xE007             B        ??vscanf_0
    129          
    130              while (format[i]) {
    131                  if (format[i] == '%' && format[i+1] != '%' && format[i+1] != '*') {
    132                      _buffer[offset++] = '%';
   \                     ??vscanf_1: (+1)
   \   0000000E   0x68AB             LDR      R3,[R5, #+8]
   \   00000010   0x545A             STRB     R2,[R3, R1]
   \   00000012   0x1C49             ADDS     R1,R1,#+1
    133                      _buffer[offset++] = '*';
   \   00000014   0x222A             MOVS     R2,#+42
   \   00000016   0x68AB             LDR      R3,[R5, #+8]
   \   00000018   0x545A             STRB     R2,[R3, R1]
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
    134                      i++;
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
    135                  } else {
   \                     ??vscanf_0: (+1)
   \   0000001E   0x9A03             LDR      R2,[SP, #+12]
   \   00000020   0x5C12             LDRB     R2,[R2, R0]
   \   00000022   0x0013             MOVS     R3,R2
   \   00000024   0xD00D             BEQ      ??vscanf_2
   \   00000026   0x2A25             CMP      R2,#+37
   \   00000028   0xD106             BNE      ??vscanf_3
   \   0000002A   0x9B03             LDR      R3,[SP, #+12]
   \   0000002C   0x181B             ADDS     R3,R3,R0
   \   0000002E   0x785B             LDRB     R3,[R3, #+1]
   \   00000030   0x2B25             CMP      R3,#+37
   \   00000032   0xD001             BEQ      ??vscanf_3
   \   00000034   0x2B2A             CMP      R3,#+42
   \   00000036   0xD1EA             BNE      ??vscanf_1
    136                      _buffer[offset++] = format[i++];
   \                     ??vscanf_3: (+1)
   \   00000038   0x68AB             LDR      R3,[R5, #+8]
   \   0000003A   0x545A             STRB     R2,[R3, R1]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x1C49             ADDS     R1,R1,#+1
   \   00000040   0xE7ED             B        ??vscanf_0
    137                  }
    138              }
    139          
    140              // Scanf has very poor support for catching errors
    141              // fortunately, we can abuse the %n specifier to determine
    142              // if the entire string was matched.
    143              _buffer[offset++] = '%';
   \                     ??vscanf_2: (+1)
   \   00000042   0x2025             MOVS     R0,#+37
   \   00000044   0x68AA             LDR      R2,[R5, #+8]
   \   00000046   0x5450             STRB     R0,[R2, R1]
   \   00000048   0x1C49             ADDS     R1,R1,#+1
    144              _buffer[offset++] = 'n';
   \   0000004A   0x206E             MOVS     R0,#+110
   \   0000004C   0x68AA             LDR      R2,[R5, #+8]
   \   0000004E   0x5450             STRB     R0,[R2, R1]
   \   00000050   0x1C49             ADDS     R1,R1,#+1
    145              _buffer[offset++] = 0;
   \   00000052   0x68AA             LDR      R2,[R5, #+8]
   \   00000054   0x5457             STRB     R7,[R2, R1]
   \   00000056   0x1C49             ADDS     R1,R1,#+1
   \   00000058   0x9100             STR      R1,[SP, #+0]
    146          
    147              // To workaround scanf's lack of error reporting, we actually
    148              // make two passes. One checks the validity with the modified
    149              // format string that only stores the matched characters (%n).
    150              // The other reads in the actual matched values.
    151              //
    152              // We keep trying the match until we succeed or some other error
    153              // derails us.
    154              int j = 0;
   \   0000005A   0x2400             MOVS     R4,#+0
   \   0000005C   0x460E             MOV      R6,R1
    155          
    156              while (true) {
    157                  // Ran out of space
    158                  if (j+1 >= _buffer_size - offset) {
   \                     ??vscanf_4: (+1)
   \   0000005E   0x1C64             ADDS     R4,R4,#+1
   \   00000060   0x6868             LDR      R0,[R5, #+4]
   \   00000062   0x9900             LDR      R1,[SP, #+0]
   \   00000064   0x1A40             SUBS     R0,R0,R1
   \   00000066   0x4284             CMP      R4,R0
   \   00000068   0xDB01             BLT      ??vscanf_5
    159                      return false;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE021             B        ??vscanf_6
    160                  }
    161                  // Recieve next character
    162                  int c = getc();
   \                     ??vscanf_5: (+1)
   \   0000006E   0x0028             MOVS     R0,R5
   \   00000070   0x.... 0x....      BL       _ZN4mbed11ATCmdParser4getcEv
    163                  if (c < 0) {
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD502             BPL      ??vscanf_7
    164                      return -1;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000007C   0xE019             B        ??vscanf_6
    165                  }
    166                  _buffer[offset + j++] = c;
   \                     ??vscanf_7: (+1)
   \   0000007E   0x68A9             LDR      R1,[R5, #+8]
   \   00000080   0x5588             STRB     R0,[R1, R6]
    167                  _buffer[offset + j] = 0;
   \   00000082   0x68A9             LDR      R1,[R5, #+8]
   \   00000084   0x1989             ADDS     R1,R1,R6
   \   00000086   0x704F             STRB     R7,[R1, #+1]
    168          
    169                  // Check for match
    170                  int count = -1;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000008C   0x9001             STR      R0,[SP, #+4]
    171                  sscanf(_buffer+offset, _buffer, &count);
   \   0000008E   0x68A9             LDR      R1,[R5, #+8]
   \   00000090   0xAA01             ADD      R2,SP,#+4
   \   00000092   0x9800             LDR      R0,[SP, #+0]
   \   00000094   0x1808             ADDS     R0,R1,R0
   \   00000096   0x.... 0x....      BL       sscanf
    172          
    173                  // We only succeed if all characters in the response are matched
    174                  if (count == j) {
   \   0000009A   0x1C76             ADDS     R6,R6,#+1
   \   0000009C   0x9801             LDR      R0,[SP, #+4]
   \   0000009E   0x42A0             CMP      R0,R4
   \   000000A0   0xD1DD             BNE      ??vscanf_4
    175                      // Store the found results
    176                      vsscanf(_buffer+offset, format, args);
   \   000000A2   0x9A04             LDR      R2,[SP, #+16]
   \   000000A4   0x9903             LDR      R1,[SP, #+12]
   \   000000A6   0x68A8             LDR      R0,[R5, #+8]
   \   000000A8   0x9B00             LDR      R3,[SP, #+0]
   \   000000AA   0x18C0             ADDS     R0,R0,R3
   \   000000AC   0x.... 0x....      BL       vsscanf
    177                      return j;
   \   000000B0   0x0020             MOVS     R0,R4
   \                     ??vscanf_6: (+1)
   \   000000B2   0xB005             ADD      SP,SP,#+20
   \   000000B4   0xBDF0             POP      {R4-R7,PC}       ;; return
    178                  }
    179              }
    180          }
    181          
    182          
    183          // Command parsing with line handling

   \                                 In section .text, align 4, keep-with-next
    184          bool ATCmdParser::vsend(const char *command, va_list args)
    185          {
   \                     _ZN4mbed11ATCmdParser5vsendEPKc9__va_list: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    186              // Create and send command
    187              if (vsprintf(_buffer, command, args) < 0) {
   \   00000004   0x68A0             LDR      R0,[R4, #+8]
   \   00000006   0x.... 0x....      BL       vsprintf
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD417             BMI      ??vsend_0
    188                  return false;
    189              }
    190          
    191              for (int i = 0; _buffer[i]; i++) {
   \   0000000E   0x2600             MOVS     R6,#+0
   \   00000010   0x2500             MOVS     R5,#+0
   \   00000012   0xE005             B        ??vsend_1
    192                  if (putc(_buffer[i]) < 0) {
   \                     ??vsend_2: (+1)
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       _ZN4mbed11ATCmdParser4putcEc
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD40F             BMI      ??vsend_0
    193                      return false;
    194                  }
    195              }
   \   0000001E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??vsend_1: (+1)
   \   00000020   0x68A0             LDR      R0,[R4, #+8]
   \   00000022   0x5D41             LDRB     R1,[R0, R5]
   \   00000024   0x0008             MOVS     R0,R1
   \   00000026   0xD1F5             BNE      ??vsend_2
    196          
    197              // Finish with newline
    198              for (size_t i = 0; _output_delimiter[i]; i++) {
   \   00000028   0xE000             B        ??vsend_3
   \                     ??vsend_4: (+1)
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
   \                     ??vsend_3: (+1)
   \   0000002C   0x6920             LDR      R0,[R4, #+16]
   \   0000002E   0x5D81             LDRB     R1,[R0, R6]
   \   00000030   0x0008             MOVS     R0,R1
   \   00000032   0xD006             BEQ      ??vsend_5
    199                  if (putc(_output_delimiter[i]) < 0) {
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       _ZN4mbed11ATCmdParser4putcEc
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD5F5             BPL      ??vsend_4
    200                      return false;
   \                     ??vsend_0: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD70             POP      {R4-R6,PC}
    201                  }
    202              }
    203          
    204              debug_if(_dbg_on, "AT> %s\n", _buffer);
   \                     ??vsend_5: (+1)
   \   00000042   0x68A2             LDR      R2,[R4, #+8]
   \   00000044   0x....             ADR.N    R1,?_0
   \   00000046   0x7E60             LDRB     R0,[R4, #+25]
   \   00000048   0x.... 0x....      BL       _Z8debug_ifiPKcz
    205              return true;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
    206          }
    207          

   \                                 In section .text, align 4, keep-with-next
    208          bool ATCmdParser::vrecv(const char *response, va_list args)
    209          {
   \                     _ZN4mbed11ATCmdParser5vrecvEPKc9__va_list: (+1)
   \   00000000   0xB5F6             PUSH     {R1,R2,R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0006             MOVS     R6,R0
    210          restart:
    211              _aborted = false;
   \                     ??vrecv_0: (+1)
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x76B0             STRB     R0,[R6, #+26]
   \   0000000A   0xE018             B        ??vrecv_1
    212              // Iterate through each line in the expected response
    213              while (response[0]) {
    214                  // Since response is const, we need to copy it into our buffer to
    215                  // add the line's null terminator and clobber value-matches with asterisks.
    216                  //
    217                  // We just use the beginning of the buffer to avoid unnecessary allocations.
    218                  int i = 0;
    219                  int offset = 0;
    220                  bool whole_line_wanted = false;
    221          
    222                  while (response[i]) {
    223                      if (response[i] == '%' && response[i+1] != '%' && response[i+1] != '*') {
    224                          _buffer[offset++] = '%';
    225                          _buffer[offset++] = '*';
    226                          i++;
    227                      } else {
    228                          _buffer[offset++] = response[i++];
    229                          // Find linebreaks, taking care not to be fooled if they're in a %[^\n] conversion specification
    230                          if (response[i - 1] == '\n' && !(i >= 3 && response[i-3] == '[' && response[i-2] == '^')) {
    231                              whole_line_wanted = true;
    232                              break;
    233                          }
    234                      }
    235                  }
    236          
    237                  // Scanf has very poor support for catching errors
    238                  // fortunately, we can abuse the %n specifier to determine
    239                  // if the entire string was matched.
    240                  _buffer[offset++] = '%';
    241                  _buffer[offset++] = 'n';
    242                  _buffer[offset++] = 0;
    243          
    244                  debug_if(_dbg_on, "AT? %s\n", _buffer);
    245                  // To workaround scanf's lack of error reporting, we actually
    246                  // make two passes. One checks the validity with the modified
    247                  // format string that only stores the matched characters (%n).
    248                  // The other reads in the actual matched values.
    249                  //
    250                  // We keep trying the match until we succeed or some other error
    251                  // derails us.
    252                  int j = 0;
    253          
    254                  while (true) {
    255                      // Receive next character
    256                      int c = getc();
    257                      if (c < 0) {
    258                          debug_if(_dbg_on, "AT(Timeout)\n");
    259                          return false;
    260                      }
    261                      // Simplify newlines (borrowed from retarget.cpp)
    262                      if ((c == CR && _in_prev != LF) ||
    263                          (c == LF && _in_prev != CR)) {
    264                          _in_prev = c;
    265                          c = '\n';
    266                      } else if ((c == CR && _in_prev == LF) ||
    267                                 (c == LF && _in_prev == CR)) {
    268                          _in_prev = c;
    269                          // onto next character
    270                          continue;
    271                      } else {
    272                          _in_prev = c;
    273                      }
    274                      _buffer[offset + j++] = c;
    275                      _buffer[offset + j] = 0;
    276          
    277                      // Check for oob data
    278                      for (struct oob *oob = _oobs; oob; oob = oob->next) {
    279                          if ((unsigned)j == oob->len && memcmp(
    280                                  oob->prefix, _buffer+offset, oob->len) == 0) {
    281                              debug_if(_dbg_on, "AT! %s\n", oob->prefix);
    282                              oob->cb();
    283          
    284                              if (_aborted) {
    285                                  debug_if(_dbg_on, "AT(Aborted)\n");
    286                                  return false;
    287                              }
    288                              // oob may have corrupted non-reentrant buffer,
    289                              // so we need to set it up again
    290                              goto restart;
    291                          }
    292                      }
    293          
    294                      // Check for match
    295                      int count = -1;
    296                      if (whole_line_wanted && c != '\n') {
    297                          // Don't attempt scanning until we get delimiter if they included it in format
    298                          // This allows recv("Foo: %s\n") to work, and not match with just the first character of a string
    299                          // (scanf does not itself match whitespace in its format string, so \n is not significant to it)
    300                      } else {
    301                          sscanf(_buffer+offset, _buffer, &count);
    302                      }
    303          
    304                      // We only succeed if all characters in the response are matched
    305                      if (count == j) {
    306                          debug_if(_dbg_on, "AT= %s\n", _buffer+offset);
   \                     ??vrecv_2: (+1)
   \   0000000C   0x68B0             LDR      R0,[R6, #+8]
   \   0000000E   0x9901             LDR      R1,[SP, #+4]
   \   00000010   0x1842             ADDS     R2,R0,R1
   \   00000012   0xBF00             Nop      
   \   00000014   0x....             ADR.N    R1,?_5
   \   00000016   0x7E70             LDRB     R0,[R6, #+25]
   \   00000018   0x.... 0x....      BL       _Z8debug_ifiPKcz
    307                          // Reuse the front end of the buffer
    308                          memcpy(_buffer, response, i);
   \   0000001C   0x003A             MOVS     R2,R7
   \   0000001E   0x9907             LDR      R1,[SP, #+28]
   \   00000020   0x68B0             LDR      R0,[R6, #+8]
   \   00000022   0x.... 0x....      BL       __aeabi_memcpy
    309                          _buffer[i] = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x68B1             LDR      R1,[R6, #+8]
   \   0000002A   0x55C8             STRB     R0,[R1, R7]
    310          
    311                          // Store the found results
    312                          vsscanf(_buffer+offset, _buffer, args);
   \   0000002C   0x68B1             LDR      R1,[R6, #+8]
   \   0000002E   0x9A08             LDR      R2,[SP, #+32]
   \   00000030   0x9801             LDR      R0,[SP, #+4]
   \   00000032   0x1808             ADDS     R0,R1,R0
   \   00000034   0x.... 0x....      BL       vsscanf
    313          
    314                          // Jump to next line and continue parsing
    315                          response += i;
   \   00000038   0x9807             LDR      R0,[SP, #+28]
   \   0000003A   0x19C0             ADDS     R0,R0,R7
   \   0000003C   0x9007             STR      R0,[SP, #+28]
    316                          break;
    317                      }
   \                     ??vrecv_1: (+1)
   \   0000003E   0x9807             LDR      R0,[SP, #+28]
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD100             BNE      .+4
   \   00000046   0xE0CF             B        ??vrecv_3
   \   00000048   0x2700             MOVS     R7,#+0
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x9003             STR      R0,[SP, #+12]
   \   0000004E   0xE007             B        ??vrecv_4
   \                     ??vrecv_5: (+1)
   \   00000050   0x68B2             LDR      R2,[R6, #+8]
   \   00000052   0x5411             STRB     R1,[R2, R0]
   \   00000054   0x1C40             ADDS     R0,R0,#+1
   \   00000056   0x212A             MOVS     R1,#+42
   \   00000058   0x68B2             LDR      R2,[R6, #+8]
   \   0000005A   0x5411             STRB     R1,[R2, R0]
   \   0000005C   0x1C40             ADDS     R0,R0,#+1
   \   0000005E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??vrecv_4: (+1)
   \   00000060   0x9907             LDR      R1,[SP, #+28]
   \   00000062   0x5DC9             LDRB     R1,[R1, R7]
   \   00000064   0x000A             MOVS     R2,R1
   \   00000066   0xD01C             BEQ      ??vrecv_6
   \   00000068   0x2925             CMP      R1,#+37
   \   0000006A   0xD106             BNE      ??vrecv_7
   \   0000006C   0x9A07             LDR      R2,[SP, #+28]
   \   0000006E   0x19D2             ADDS     R2,R2,R7
   \   00000070   0x7852             LDRB     R2,[R2, #+1]
   \   00000072   0x2A25             CMP      R2,#+37
   \   00000074   0xD001             BEQ      ??vrecv_7
   \   00000076   0x2A2A             CMP      R2,#+42
   \   00000078   0xD1EA             BNE      ??vrecv_5
   \                     ??vrecv_7: (+1)
   \   0000007A   0x68B2             LDR      R2,[R6, #+8]
   \   0000007C   0x5411             STRB     R1,[R2, R0]
   \   0000007E   0x1C7F             ADDS     R7,R7,#+1
   \   00000080   0x1C40             ADDS     R0,R0,#+1
   \   00000082   0x9907             LDR      R1,[SP, #+28]
   \   00000084   0x19C9             ADDS     R1,R1,R7
   \   00000086   0x1EC9             SUBS     R1,R1,#+3
   \   00000088   0x788A             LDRB     R2,[R1, #+2]
   \   0000008A   0x2A0A             CMP      R2,#+10
   \   0000008C   0xD1E8             BNE      ??vrecv_4
   \   0000008E   0x2F03             CMP      R7,#+3
   \   00000090   0xDB05             BLT      ??vrecv_8
   \   00000092   0x780A             LDRB     R2,[R1, #+0]
   \   00000094   0x2A5B             CMP      R2,#+91
   \   00000096   0xD102             BNE      ??vrecv_8
   \   00000098   0x7849             LDRB     R1,[R1, #+1]
   \   0000009A   0x295E             CMP      R1,#+94
   \   0000009C   0xD0E0             BEQ      ??vrecv_4
   \                     ??vrecv_8: (+1)
   \   0000009E   0x2101             MOVS     R1,#+1
   \   000000A0   0x9103             STR      R1,[SP, #+12]
   \                     ??vrecv_6: (+1)
   \   000000A2   0x2125             MOVS     R1,#+37
   \   000000A4   0x68B2             LDR      R2,[R6, #+8]
   \   000000A6   0x5411             STRB     R1,[R2, R0]
   \   000000A8   0x1C40             ADDS     R0,R0,#+1
   \   000000AA   0x216E             MOVS     R1,#+110
   \   000000AC   0x68B2             LDR      R2,[R6, #+8]
   \   000000AE   0x5411             STRB     R1,[R2, R0]
   \   000000B0   0x1C40             ADDS     R0,R0,#+1
   \   000000B2   0x2100             MOVS     R1,#+0
   \   000000B4   0x68B2             LDR      R2,[R6, #+8]
   \   000000B6   0x5411             STRB     R1,[R2, R0]
   \   000000B8   0x1C40             ADDS     R0,R0,#+1
   \   000000BA   0x9001             STR      R0,[SP, #+4]
   \   000000BC   0x68B2             LDR      R2,[R6, #+8]
   \   000000BE   0xBF00             Nop      
   \   000000C0   0x....             ADR.N    R1,?_1
   \                     ??vrecv_9: (+1)
   \   000000C2   0x7E70             LDRB     R0,[R6, #+25]
   \   000000C4   0x.... 0x....      BL       _Z8debug_ifiPKcz
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x9000             STR      R0,[SP, #+0]
   \   000000CC   0xE005             B        ??vrecv_10
   \                     ??vrecv_11: (+1)
   \   000000CE   0x2C0D             CMP      R4,#+13
   \   000000D0   0xD122             BNE      ??vrecv_12
   \   000000D2   0x7E30             LDRB     R0,[R6, #+24]
   \   000000D4   0x280A             CMP      R0,#+10
   \   000000D6   0xD124             BNE      ??vrecv_13
   \                     ??vrecv_14: (+1)
   \   000000D8   0x7634             STRB     R4,[R6, #+24]
   \                     ??vrecv_10: (+1)
   \   000000DA   0x6830             LDR      R0,[R6, #+0]
   \   000000DC   0x9005             STR      R0,[SP, #+20]
   \   000000DE   0x2001             MOVS     R0,#+1
   \   000000E0   0xA905             ADD      R1,SP,#+20
   \   000000E2   0x8088             STRH     R0,[R1, #+4]
   \   000000E4   0x68F2             LDR      R2,[R6, #+12]
   \   000000E6   0x2101             MOVS     R1,#+1
   \   000000E8   0xA805             ADD      R0,SP,#+20
   \   000000EA   0x.... 0x....      BL       _ZN4mbed4pollEPNS_6pollfhEji
   \   000000EE   0x2801             CMP      R0,#+1
   \   000000F0   0xDB0F             BLT      ??vrecv_15
   \   000000F2   0xA805             ADD      R0,SP,#+20
   \   000000F4   0x7980             LDRB     R0,[R0, #+6]
   \   000000F6   0x07C0             LSLS     R0,R0,#+31
   \   000000F8   0xD50B             BPL      ??vrecv_15
   \   000000FA   0x6830             LDR      R0,[R6, #+0]
   \   000000FC   0x2201             MOVS     R2,#+1
   \   000000FE   0xA902             ADD      R1,SP,#+8
   \   00000100   0x6803             LDR      R3,[R0, #+0]
   \   00000102   0x689B             LDR      R3,[R3, #+8]
   \   00000104   0x4798             BLX      R3
   \   00000106   0x2801             CMP      R0,#+1
   \   00000108   0xD103             BNE      ??vrecv_15
   \   0000010A   0x4668             MOV      R0,SP
   \   0000010C   0x7A04             LDRB     R4,[R0, #+8]
   \   0000010E   0x2C00             CMP      R4,#+0
   \   00000110   0xD5DD             BPL      ??vrecv_11
   \                     ??vrecv_15: (+1)
   \   00000112   0xBF00             Nop      
   \   00000114   0x....             ADR.N    R1,?_2
   \   00000116   0xE040             B.N      ??vrecv_16
   \                     ??vrecv_12: (+1)
   \   00000118   0x2C0A             CMP      R4,#+10
   \   0000011A   0xD105             BNE      ??vrecv_17
   \   0000011C   0x7E30             LDRB     R0,[R6, #+24]
   \   0000011E   0x280D             CMP      R0,#+13
   \   00000120   0xD0DA             BEQ      ??vrecv_14
   \                     ??vrecv_13: (+1)
   \   00000122   0x0020             MOVS     R0,R4
   \   00000124   0x240A             MOVS     R4,#+10
   \   00000126   0xE000             B        ??vrecv_18
   \                     ??vrecv_17: (+1)
   \   00000128   0x0020             MOVS     R0,R4
   \                     ??vrecv_18: (+1)
   \   0000012A   0x7630             STRB     R0,[R6, #+24]
   \   0000012C   0x68B1             LDR      R1,[R6, #+8]
   \   0000012E   0x9A01             LDR      R2,[SP, #+4]
   \   00000130   0x9B00             LDR      R3,[SP, #+0]
   \   00000132   0x18D2             ADDS     R2,R2,R3
   \   00000134   0x548C             STRB     R4,[R1, R2]
   \   00000136   0x9800             LDR      R0,[SP, #+0]
   \   00000138   0x1C40             ADDS     R0,R0,#+1
   \   0000013A   0x9000             STR      R0,[SP, #+0]
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0x68B1             LDR      R1,[R6, #+8]
   \   00000140   0x9A01             LDR      R2,[SP, #+4]
   \   00000142   0x9B00             LDR      R3,[SP, #+0]
   \   00000144   0x18D2             ADDS     R2,R2,R3
   \   00000146   0x5488             STRB     R0,[R1, R2]
   \   00000148   0x69F5             LDR      R5,[R6, #+28]
   \   0000014A   0xE000             B        ??vrecv_19
   \                     ??vrecv_20: (+1)
   \   0000014C   0x69AD             LDR      R5,[R5, #+24]
   \                     ??vrecv_19: (+1)
   \   0000014E   0x2D00             CMP      R5,#+0
   \   00000150   0xD028             BEQ      ??vrecv_21
   \   00000152   0x682A             LDR      R2,[R5, #+0]
   \   00000154   0x9800             LDR      R0,[SP, #+0]
   \   00000156   0x4290             CMP      R0,R2
   \   00000158   0xD1F8             BNE      ??vrecv_20
   \   0000015A   0x68B0             LDR      R0,[R6, #+8]
   \   0000015C   0x9901             LDR      R1,[SP, #+4]
   \   0000015E   0x1841             ADDS     R1,R0,R1
   \   00000160   0x6868             LDR      R0,[R5, #+4]
   \   00000162   0x.... 0x....      BL       memcmp
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xD1F0             BNE      ??vrecv_20
   \   0000016A   0x686A             LDR      R2,[R5, #+4]
   \   0000016C   0x....             ADR.N    R1,?_3
   \   0000016E   0x7E70             LDRB     R0,[R6, #+25]
   \   00000170   0x.... 0x....      BL       _Z8debug_ifiPKcz
   \   00000174   0x6968             LDR      R0,[R5, #+20]
   \   00000176   0x2800             CMP      R0,#+0
   \   00000178   0xD105             BNE      ??vrecv_22
   \   0000017A   0x2284             MOVS     R2,#+132
   \   0000017C   0x0092             LSLS     R2,R2,#+2        ;; #+528
   \   0000017E   0x....             LDR      R1,??DataTable9
   \   00000180   0x....             LDR      R0,??DataTable9_1
   \   00000182   0x.... 0x....      BL       mbed_assert_internal
   \                     ??vrecv_22: (+1)
   \   00000186   0x0028             MOVS     R0,R5
   \   00000188   0x3008             ADDS     R0,R0,#+8
   \   0000018A   0x6969             LDR      R1,[R5, #+20]
   \   0000018C   0x6809             LDR      R1,[R1, #+0]
   \   0000018E   0x4788             BLX      R1
   \   00000190   0x7EB0             LDRB     R0,[R6, #+26]
   \   00000192   0x2800             CMP      R0,#+0
   \   00000194   0xD100             BNE      .+4
   \   00000196   0xE736             B        ??vrecv_0
   \   00000198   0x....             ADR.N    R1,?_4
   \                     ??vrecv_16: (+1)
   \   0000019A   0x7E70             LDRB     R0,[R6, #+25]
   \   0000019C   0x.... 0x....      BL       _Z8debug_ifiPKcz
   \   000001A0   0x2000             MOVS     R0,#+0
   \   000001A2   0xE022             B        ??vrecv_23
   \                     ??vrecv_21: (+1)
   \   000001A4   0x2000             MOVS     R0,#+0
   \   000001A6   0x43C0             MVNS     R0,R0            ;; #-1
   \   000001A8   0x9004             STR      R0,[SP, #+16]
   \   000001AA   0x9803             LDR      R0,[SP, #+12]
   \   000001AC   0x2800             CMP      R0,#+0
   \   000001AE   0xD001             BEQ      ??vrecv_24
   \   000001B0   0x2C0A             CMP      R4,#+10
   \   000001B2   0xD105             BNE      ??vrecv_25
   \                     ??vrecv_24: (+1)
   \   000001B4   0x68B1             LDR      R1,[R6, #+8]
   \   000001B6   0xAA04             ADD      R2,SP,#+16
   \   000001B8   0x9801             LDR      R0,[SP, #+4]
   \   000001BA   0x1808             ADDS     R0,R1,R0
   \   000001BC   0x.... 0x....      BL       sscanf
   \                     ??vrecv_25: (+1)
   \   000001C0   0x9804             LDR      R0,[SP, #+16]
   \   000001C2   0x9900             LDR      R1,[SP, #+0]
   \   000001C4   0x4288             CMP      R0,R1
   \   000001C6   0xD100             BNE      .+4
   \   000001C8   0xE720             B        ??vrecv_2
    318          
    319                      // Clear the buffer when we hit a newline or ran out of space
    320                      // running out of space usually means we ran into binary data
    321                      if (c == '\n' || j+1 >= _buffer_size - offset) {
   \   000001CA   0x2C0A             CMP      R4,#+10
   \   000001CC   0xD006             BEQ      ??vrecv_26
   \   000001CE   0x1C48             ADDS     R0,R1,#+1
   \   000001D0   0x6871             LDR      R1,[R6, #+4]
   \   000001D2   0x9A01             LDR      R2,[SP, #+4]
   \   000001D4   0x1A89             SUBS     R1,R1,R2
   \   000001D6   0x4288             CMP      R0,R1
   \   000001D8   0xDA00             BGE      .+4
   \   000001DA   0xE77E             B        ??vrecv_10
    322                          debug_if(_dbg_on, "AT< %s", _buffer+offset);
   \                     ??vrecv_26: (+1)
   \   000001DC   0x68B0             LDR      R0,[R6, #+8]
   \   000001DE   0x9901             LDR      R1,[SP, #+4]
   \   000001E0   0x1842             ADDS     R2,R0,R1
   \   000001E2   0xBF00             Nop      
   \   000001E4   0x....             ADR.N    R1,?_6
   \   000001E6   0xE76C             B.N      ??vrecv_9
    323                          j = 0;
    324                      }
    325                  }
    326              }
    327          
    328              return true;
   \                     ??vrecv_3: (+1)
   \   000001E8   0x2001             MOVS     R0,#+1
   \                     ??vrecv_23: (+1)
   \   000001EA   0xB009             ADD      SP,SP,#+36
   \   000001EC   0xBDF0             POP      {R4-R7,PC}       ;; return
    329          }
    330          
    331          // Mapping to vararg functions

   \                                 In section .text, align 2, keep-with-next
    332          int ATCmdParser::printf(const char *format, ...)
    333          {
   \                     _ZN4mbed11ATCmdParser6printfEPKcz: (+1)
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    334              va_list args;
    335              va_start(args, format);
   \   00000004   0xAA02             ADD      R2,SP,#+8
    336              int res = vprintf(format, args);
    337              va_end(args);
    338              return res;
   \   00000006   0x.... 0x....      BL       _ZN4mbed11ATCmdParser7vprintfEPKc9__va_list
   \   0000000A   0x9901             LDR      R1,[SP, #+4]
   \   0000000C   0xB004             ADD      SP,SP,#+16
   \   0000000E   0x4708             BX       R1               ;; return
    339          }
    340          

   \                                 In section .text, align 2, keep-with-next
    341          int ATCmdParser::scanf(const char *format, ...)
    342          {
   \                     _ZN4mbed11ATCmdParser5scanfEPKcz: (+1)
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    343              va_list args;
    344              va_start(args, format);
   \   00000004   0xAA02             ADD      R2,SP,#+8
    345              int res = vscanf(format, args);
    346              va_end(args);
    347              return res;
   \   00000006   0x.... 0x....      BL       _ZN4mbed11ATCmdParser6vscanfEPKc9__va_list
   \   0000000A   0x9901             LDR      R1,[SP, #+4]
   \   0000000C   0xB004             ADD      SP,SP,#+16
   \   0000000E   0x4708             BX       R1               ;; return
    348          }
    349          

   \                                 In section .text, align 2, keep-with-next
    350          bool ATCmdParser::send(const char *command, ...)
    351          {
   \                     _ZN4mbed11ATCmdParser4sendEPKcz: (+1)
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    352              va_list args;
    353              va_start(args, command);
   \   00000004   0xAA02             ADD      R2,SP,#+8
    354              bool res = vsend(command, args);
    355              va_end(args);
    356              return res;
   \   00000006   0x.... 0x....      BL       _ZN4mbed11ATCmdParser5vsendEPKc9__va_list
   \   0000000A   0x9901             LDR      R1,[SP, #+4]
   \   0000000C   0xB004             ADD      SP,SP,#+16
   \   0000000E   0x4708             BX       R1               ;; return
    357          }
    358          

   \                                 In section .text, align 2, keep-with-next
    359          bool ATCmdParser::recv(const char *response, ...)
    360          {
   \                     _ZN4mbed11ATCmdParser4recvEPKcz: (+1)
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    361              va_list args;
    362              va_start(args, response);
   \   00000004   0xAA02             ADD      R2,SP,#+8
    363              bool res = vrecv(response, args);
    364              va_end(args);
    365              return res;
   \   00000006   0x.... 0x....      BL       _ZN4mbed11ATCmdParser5vrecvEPKc9__va_list
   \   0000000A   0x9901             LDR      R1,[SP, #+4]
   \   0000000C   0xB004             ADD      SP,SP,#+16
   \   0000000E   0x4708             BX       R1               ;; return
    366          }
    367          
    368          // oob registration

   \                                 In section .text, align 2, keep-with-next
    369          void ATCmdParser::oob(const char *prefix, Callback<void()> cb)
    370          {
   \                     _ZN4mbed11ATCmdParser3oobEPKcNS_8CallbackIFvvEEE: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
    371              struct oob *oob = new struct oob;
   \   00000008   0x201C             MOVS     R0,#+28
   \   0000000A   0x.... 0x....      BL       _Znwj
   \   0000000E   0x0005             MOVS     R5,R0
   \   00000010   0xD004             BEQ      ??oob_0
   \   00000012   0x2110             MOVS     R1,#+16
   \   00000014   0x3008             ADDS     R0,R0,#+8
   \   00000016   0x.... 0x....      BL       __aeabi_memclr
   \   0000001A   0xE000             B        ??oob_1
   \                     ??oob_0: (+1)
   \   0000001C   0x2500             MOVS     R5,#+0
    372              oob->len = strlen(prefix);
   \                     ??oob_1: (+1)
   \   0000001E   0x0030             MOVS     R0,R6
   \   00000020   0x.... 0x....      BL       strlen
   \   00000024   0x6028             STR      R0,[R5, #+0]
    373              oob->prefix = prefix;
   \   00000026   0x606E             STR      R6,[R5, #+4]
    374              oob->cb = cb;
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0x3008             ADDS     R0,R0,#+8
   \   0000002C   0x42A0             CMP      R0,R4
   \   0000002E   0xD013             BEQ      ??oob_2
   \   00000030   0x6969             LDR      R1,[R5, #+20]
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD003             BEQ      ??oob_3
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0x3008             ADDS     R0,R0,#+8
   \   0000003A   0x6889             LDR      R1,[R1, #+8]
   \   0000003C   0x4788             BLX      R1
   \                     ??oob_3: (+1)
   \   0000003E   0x0028             MOVS     R0,R5
   \   00000040   0x3008             ADDS     R0,R0,#+8
   \   00000042   0xD009             BEQ      ??oob_2
   \   00000044   0x68E2             LDR      R2,[R4, #+12]
   \   00000046   0x2A00             CMP      R2,#+0
   \   00000048   0xD004             BEQ      ??oob_4
   \   0000004A   0x0021             MOVS     R1,R4
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0x3008             ADDS     R0,R0,#+8
   \   00000050   0x6852             LDR      R2,[R2, #+4]
   \   00000052   0x4790             BLX      R2
   \                     ??oob_4: (+1)
   \   00000054   0x68E0             LDR      R0,[R4, #+12]
   \   00000056   0x6168             STR      R0,[R5, #+20]
    375              oob->next = _oobs;
   \                     ??oob_2: (+1)
   \   00000058   0x69F8             LDR      R0,[R7, #+28]
   \   0000005A   0x61A8             STR      R0,[R5, #+24]
    376              _oobs = oob;
   \   0000005C   0x61FD             STR      R5,[R7, #+28]
    377          }
   \   0000005E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    378          

   \                                 In section .text, align 2, keep-with-next
    379          void ATCmdParser::abort()
    380          {
    381              _aborted = true;
   \                     _ZN4mbed11ATCmdParser5abortEv: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x7681             STRB     R1,[R0, #+26]
    382          }
   \   00000004   0x4770             BX       LR               ;; return
    383          

   \                                 In section .text, align 4, keep-with-next
    384          bool ATCmdParser::process_oob()
    385          {
   \                     _ZN4mbed11ATCmdParser11process_oobEv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
    386              if (!_fh->readable()) {
   \   00000004   0x6830             LDR      R0,[R6, #+0]
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x6802             LDR      R2,[R0, #+0]
   \   0000000A   0x6BD2             LDR      R2,[R2, #+60]
   \   0000000C   0x4790             BLX      R2
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xD51A             BPL      ??process_oob_0
    387                  return false;
    388              }
    389          
    390              int i = 0;
   \   00000012   0x2700             MOVS     R7,#+0
   \   00000014   0xE012             B        ??process_oob_1
    391              while (true) {
    392                  // Receive next character
    393                  int c = getc();
    394                  if (c < 0) {
    395                      return false;
    396                  }
    397                  _buffer[i++] = c;
    398                  _buffer[i] = 0;
    399          
    400                  // Check for oob data
    401                  struct oob *oob = _oobs;
    402                  while (oob) {
    403                      if (i == (int)oob->len && memcmp(
    404                              oob->prefix, _buffer, oob->len) == 0) {
    405                          debug_if(_dbg_on, "AT! %s\r\n", oob->prefix);
    406                          oob->cb();
    407                          return true;
    408                      }
    409                      oob = oob->next;
    410                  }
    411                  
    412                  // Clear the buffer when we hit a newline or ran out of space
    413                  // running out of space usually means we ran into binary data
    414                  if (i+1 >= _buffer_size ||
    415                      strcmp(&_buffer[i-_output_delim_size], _output_delimiter) == 0) {
   \                     ??process_oob_2: (+1)
   \   00000016   0x68B4             LDR      R4,[R6, #+8]
   \   00000018   0x1C68             ADDS     R0,R5,#+1
   \   0000001A   0x6871             LDR      R1,[R6, #+4]
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xDA07             BGE      ??process_oob_3
   \   00000020   0x6931             LDR      R1,[R6, #+16]
   \   00000022   0x6970             LDR      R0,[R6, #+20]
   \   00000024   0x1A28             SUBS     R0,R5,R0
   \   00000026   0x1820             ADDS     R0,R4,R0
   \   00000028   0x.... 0x....      BL       strcmp
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD106             BNE      ??process_oob_4
    416          
    417                      debug_if(_dbg_on, "AT< %s", _buffer);
   \                     ??process_oob_3: (+1)
   \   00000030   0x0022             MOVS     R2,R4
   \   00000032   0xBF00             Nop      
   \   00000034   0x....             ADR.N    R1,?_6
   \   00000036   0x7E70             LDRB     R0,[R6, #+25]
   \   00000038   0x.... 0x....      BL       _Z8debug_ifiPKcz
    418                      i = 0;
   \                     ??process_oob_1: (+1)
   \   0000003C   0x2500             MOVS     R5,#+0
    419                  }
   \                     ??process_oob_4: (+1)
   \   0000003E   0x0030             MOVS     R0,R6
   \   00000040   0x.... 0x....      BL       _ZN4mbed11ATCmdParser4getcEv
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD501             BPL      ??process_oob_5
   \                     ??process_oob_0: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??process_oob_5: (+1)
   \   0000004C   0x68B1             LDR      R1,[R6, #+8]
   \   0000004E   0x5548             STRB     R0,[R1, R5]
   \   00000050   0x1C6D             ADDS     R5,R5,#+1
   \   00000052   0x68B1             LDR      R1,[R6, #+8]
   \   00000054   0x554F             STRB     R7,[R1, R5]
   \   00000056   0x69F4             LDR      R4,[R6, #+28]
   \   00000058   0xE000             B        ??process_oob_6
   \                     ??process_oob_7: (+1)
   \   0000005A   0x69A4             LDR      R4,[R4, #+24]
   \                     ??process_oob_6: (+1)
   \   0000005C   0x2C00             CMP      R4,#+0
   \   0000005E   0xD0DA             BEQ      ??process_oob_2
   \   00000060   0x6822             LDR      R2,[R4, #+0]
   \   00000062   0x4295             CMP      R5,R2
   \   00000064   0xD1F9             BNE      ??process_oob_7
   \   00000066   0x68B1             LDR      R1,[R6, #+8]
   \   00000068   0x6860             LDR      R0,[R4, #+4]
   \   0000006A   0x.... 0x....      BL       memcmp
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD1F3             BNE      ??process_oob_7
   \   00000072   0x6862             LDR      R2,[R4, #+4]
   \   00000074   0x....             ADR.N    R1,?_7
   \   00000076   0x7E70             LDRB     R0,[R6, #+25]
   \   00000078   0x.... 0x....      BL       _Z8debug_ifiPKcz
   \   0000007C   0x6960             LDR      R0,[R4, #+20]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD105             BNE      ??process_oob_8
   \   00000082   0x2284             MOVS     R2,#+132
   \   00000084   0x0092             LSLS     R2,R2,#+2        ;; #+528
   \   00000086   0x....             LDR      R1,??DataTable9
   \   00000088   0x....             LDR      R0,??DataTable9_1
   \   0000008A   0x.... 0x....      BL       mbed_assert_internal
   \                     ??process_oob_8: (+1)
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x3008             ADDS     R0,R0,#+8
   \   00000092   0x6961             LDR      R1,[R4, #+20]
   \   00000094   0x6809             LDR      R1,[R1, #+0]
   \   00000096   0x4788             BLX      R1
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    420              }
    421          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x41 0x54          DC8 "AT> %s\012"
   \              0x3E 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x41 0x54          DC8 "AT= %s\012"
   \              0x3D 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     _ZZNK4mbed8CallbackIFvvEE4callEvEs_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     _ZZNK4mbed8CallbackIFvvEE4callEvEs

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x41 0x54          DC8 "AT? %s\012"
   \              0x3F 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x41 0x54          DC8 "AT(Timeout)\012"
   \              0x28 0x54    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x29 0x0A    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x41 0x54          DC8 "AT! %s\012"
   \              0x21 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x41 0x54          DC8 "AT(Aborted)\012"
   \              0x28 0x41    
   \              0x62 0x6F    
   \              0x72 0x74    
   \              0x65 0x64    
   \              0x29 0x0A    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x41 0x54          DC8 "AT< %s"
   \              0x3C 0x20    
   \              0x25 0x73    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x41 0x54          DC8 "AT! %s\015\012"
   \              0x21 0x20    
   \              0x25 0x73    
   \              0x0D 0x0A    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    422          
    423          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   debug_if(int, char const *, ...)
       0   mbed::ATCmdParser::abort()
      16   mbed::ATCmdParser::flush()
        16   -- Indirect call
      24   mbed::ATCmdParser::getc()
        24   -- Indirect call
        24   -> mbed::poll(mbed::pollfh *, unsigned int, int)
      24   mbed::ATCmdParser::oob(char const *, mbed::Callback<void ()>)
        24   -- Indirect call
        24   -> __aeabi_memclr
        24   -> operator new(std::size_t)
        24   -> std::strlen
      16   mbed::ATCmdParser::printf(char const *, ...)
        16   -> mbed::ATCmdParser::vprintf(char const *, __va_list)
      24   mbed::ATCmdParser::process_oob()
        24   -- Indirect call
        24   -> debug_if(int, char const *, ...)
        24   -> mbed::ATCmdParser::getc()
        24   -> mbed_assert_internal
        24   -> std::memcmp
        24   -> std::strcmp
      32   mbed::ATCmdParser::putc(char)
        32   -- Indirect call
        32   -> mbed::poll(mbed::pollfh *, unsigned int, int)
      24   mbed::ATCmdParser::read(char *, int)
        24   -> mbed::ATCmdParser::getc()
      16   mbed::ATCmdParser::recv(char const *, ...)
        16   -> mbed::ATCmdParser::vrecv(char const *, __va_list)
      16   mbed::ATCmdParser::scanf(char const *, ...)
        16   -> mbed::ATCmdParser::vscanf(char const *, __va_list)
      16   mbed::ATCmdParser::send(char const *, ...)
        16   -> mbed::ATCmdParser::vsend(char const *, __va_list)
      16   mbed::ATCmdParser::vprintf(char const *, __va_list)
        16   -> mbed::ATCmdParser::putc(char)
        16   -> std::vsprintf
      56   mbed::ATCmdParser::vrecv(char const *, __va_list)
        56   -- Indirect call
        56   -> __aeabi_memcpy
        56   -> debug_if(int, char const *, ...)
        56   -> mbed::poll(mbed::pollfh *, unsigned int, int)
        56   -> mbed_assert_internal
        56   -> std::memcmp
        56   -> std::sscanf
        56   -> std::vsscanf
      40   mbed::ATCmdParser::vscanf(char const *, __va_list)
        40   -> mbed::ATCmdParser::getc()
        40   -> std::sscanf
        40   -> std::vsscanf
      16   mbed::ATCmdParser::vsend(char const *, __va_list)
        16   -> debug_if(int, char const *, ...)
        16   -> mbed::ATCmdParser::putc(char)
        16   -> std::vsprintf
      24   mbed::ATCmdParser::write(char const *, int)
        24   -> mbed::ATCmdParser::putc(char)
       8   mbed::Callback<void ()>::function_call<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void const *)
         8   -- Indirect call
       8   mbed::Callback<void ()>::function_call<void (*)()>(void const *)
         8   -- Indirect call
       0   mbed::Callback<void ()>::function_dtor<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *)
       0   mbed::Callback<void ()>::function_dtor<void (*)()>(void *)
       0   mbed::Callback<void ()>::function_move<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *, void const *)
       0   mbed::Callback<void ()>::function_move<void (*)()>(void *, void const *)
      12   mbed::callback<>(void (*)(void *), void *)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       8  ?_0
       8  ?_1
      16  ?_2
       8  ?_3
      16  ?_4
       8  ?_5
       8  ?_6
      12  ?_7
       6  debug_if(int, char const *, ...)
       6  mbed::ATCmdParser::abort()
      36  mbed::ATCmdParser::flush()
      66  mbed::ATCmdParser::getc()
      96  mbed::ATCmdParser::oob(char const *, mbed::Callback<void ()>)
      16  mbed::ATCmdParser::printf(char const *, ...)
     156  mbed::ATCmdParser::process_oob()
      64  mbed::ATCmdParser::putc(char)
      44  mbed::ATCmdParser::read(char *, int)
      16  mbed::ATCmdParser::recv(char const *, ...)
      16  mbed::ATCmdParser::scanf(char const *, ...)
      16  mbed::ATCmdParser::send(char const *, ...)
      52  mbed::ATCmdParser::vprintf(char const *, __va_list)
     494  mbed::ATCmdParser::vrecv(char const *, __va_list)
     182  mbed::ATCmdParser::vscanf(char const *, __va_list)
      80  mbed::ATCmdParser::vsend(char const *, __va_list)
      44  mbed::ATCmdParser::write(char const *, int)
      12  mbed::Callback<void ()>::function_call<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void const *)
       8  mbed::Callback<void ()>::function_call<void (*)()>(void const *)
       2  mbed::Callback<void ()>::function_dtor<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *)
       2  mbed::Callback<void ()>::function_dtor<void (*)()>(void *)
      10  mbed::Callback<void ()>::function_move<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *, void const *)
      10  mbed::Callback<void ()>::function_move<void (*)()>(void *, void const *)
      32  mbed::callback<>(void (*)(void *), void *)
      12  ops
      12  ops
     380  -- Other

 
   404 bytes in section .rodata
 1 558 bytes in section .text
 
 1 482 bytes of CODE  memory (+  76 bytes shared)
     0 bytes of CONST memory (+ 404 bytes shared)

Errors: none
Warnings: none

###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:44
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\platform\mbed_critical.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\platform\mbed_critical.d -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\platform\mbed_critical.s.txt -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\platform\mbed_critical.o
#        .\mbed-os\platform\mbed_critical.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\platform\mbed_critical.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\platform\mbed_critical.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\platform\mbed_critical.c
      1          /*
      2           * Copyright (c) 2015-2016, ARM Limited, All Rights Reserved
      3           * SPDX-License-Identifier: Apache-2.0
      4           *
      5           * Licensed under the Apache License, Version 2.0 (the "License"); you may
      6           * not use this file except in compliance with the License.
      7           * You may obtain a copy of the License at
      8           *
      9           * http://www.apache.org/licenses/LICENSE-2.0
     10           *
     11           * Unless required by applicable law or agreed to in writing, software
     12           * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     13           * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     14           * See the License for the specific language governing permissions and
     15           * limitations under the License.
     16           */
     17          
     18          /* Declare __STDC_LIMIT_MACROS so stdint.h defines UINT32_MAX when using C++ */
     19          #define __STDC_LIMIT_MACROS
     20          #include "platform/mbed_critical.h"
     21          
     22          #include "cmsis.h"

  typedef uint8_t BOOL;  //already defined in "hal_type.h"
                  ^
"C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\TARGET_STEVAL_IDB007V1\device\system_BlueNRG1.h",240  Warning[Pe301]: typedef name has already been declared (with same type)
     23          #include "platform/mbed_assert.h"
     24          #include "platform/mbed_toolchain.h"
     25          

   \                                 In section .bss, align 4
     26          static volatile uint32_t interrupt_enable_counter = 0;
     27          static volatile bool critical_interrupts_disabled = false;
   \                     critical_interrupts_disabled:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \   00000004                      DS8 4
     28          

   \                                 In section .text, align 2, keep-with-next
     29          bool core_util_are_interrupts_enabled(void)
     30          {
     31          #if defined(__CORTEX_A9)
     32              return ((__get_CPSR() & 0x80) == 0);
     33          #else
     34              return ((__get_PRIMASK() & 0x1) == 0);
   \                     core_util_are_interrupts_enabled: (+1)
   \   00000000   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000004   0x07C1             LSLS     R1,R0,#+31
   \   00000006   0x0FC9             LSRS     R1,R1,#+31
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4048             EORS     R0,R0,R1
   \   0000000C   0x4770             BX       LR               ;; return
     35          #endif
     36          }
     37          

   \                                 In section .text, align 2, keep-with-next
     38          bool core_util_is_isr_active(void)
     39          {
     40          #if defined(__CORTEX_A9)
     41              switch(__get_CPSR() & 0x1FU) {
     42                  case CPSR_M_USR:
     43                  case CPSR_M_SYS:
     44                      return false;
     45                  case CPSR_M_SVC:
     46                  default:
     47                      return true;
     48              }
     49          #else
     50              return (__get_IPSR() != 0U);
   \                     core_util_is_isr_active: (+1)
   \   00000000   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000004   0x1E40             SUBS     R0,R0,#+1
   \   00000006   0x4180             SBCS     R0,R0,R0
   \   00000008   0x43C0             MVNS     R0,R0
   \   0000000A   0x0FC0             LSRS     R0,R0,#+31
   \   0000000C   0x4770             BX       LR               ;; return
     51          #endif
     52          }
     53          

   \                                 In section .text, align 4
     54          MBED_WEAK void core_util_critical_section_enter(void)
     55          {
   \                     core_util_critical_section_enter: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     56              bool interrupts_disabled = !core_util_are_interrupts_enabled();
   \   00000002   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   00000006   0x07C5             LSLS     R5,R0,#+31
   \   00000008   0x0FED             LSRS     R5,R5,#+31
     57              __disable_irq();
   \   0000000A   0xB672             CPSID    I
     58          
     59              /* Save the interrupt disabled state as it was prior to any nested critical section lock use */
     60              if (!interrupt_enable_counter) {
   \   0000000C   0x4C0E             LDR      R4,??core_util_critical_section_enter_0
   \   0000000E   0x6860             LDR      R0,[R4, #+4]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD100             BNE      ??core_util_critical_section_enter_1
     61                  critical_interrupts_disabled = interrupts_disabled;
   \   00000014   0x7025             STRB     R5,[R4, #+0]
     62              }
     63          
     64              /* If the interrupt_enable_counter overflows or we are in a nested critical section and interrupts
     65                 are enabled, then something has gone badly wrong thus assert an error.
     66              */
     67              MBED_ASSERT(interrupt_enable_counter < UINT32_MAX); 
   \                     ??core_util_critical_section_enter_1: (+1)
   \   00000016   0x6860             LDR      R0,[R4, #+4]
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD104             BNE      ??core_util_critical_section_enter_2
   \   00000020   0x2243             MOVS     R2,#+67
   \   00000022   0x490A             LDR      R1,??core_util_critical_section_enter_0+0x4
   \   00000024   0x480A             LDR      R0,??core_util_critical_section_enter_0+0x8
   \   00000026   0x.... 0x....      BL       mbed_assert_internal
     68          // FIXME
     69          #ifndef   FEATURE_UVISOR
     70              if (interrupt_enable_counter > 0) {
   \                     ??core_util_critical_section_enter_2: (+1)
   \   0000002A   0x6860             LDR      R0,[R4, #+4]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD006             BEQ      ??core_util_critical_section_enter_3
     71                  MBED_ASSERT(interrupts_disabled);
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD104             BNE      ??core_util_critical_section_enter_3
   \   00000034   0x2247             MOVS     R2,#+71
   \   00000036   0x4905             LDR      R1,??core_util_critical_section_enter_0+0x4
   \   00000038   0x4806             LDR      R0,??core_util_critical_section_enter_0+0xC
   \   0000003A   0x.... 0x....      BL       mbed_assert_internal
     72              }
     73          #else
     74          #warning "core_util_critical_section_enter needs fixing to work from unprivileged code"
     75          #endif /* FEATURE_UVISOR */
     76              interrupt_enable_counter++;
   \                     ??core_util_critical_section_enter_3: (+1)
   \   0000003E   0x6860             LDR      R0,[R4, #+4]
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0x6060             STR      R0,[R4, #+4]
     77          }
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \   00000046   0xBF00             Nop      
   \                     ??core_util_critical_section_enter_0:
   \   00000048   0x........         DC32     critical_interrupts_disabled
   \   0000004C   0x........         DC32     ?_1
   \   00000050   0x........         DC32     ?_0
   \   00000054   0x........         DC32     ?_2
     78          

   \                                 In section .text, align 4
     79          MBED_WEAK void core_util_critical_section_exit(void)
     80          {
   \                     core_util_critical_section_exit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     81              /* If critical_section_enter has not previously been called, do nothing */
     82              if (interrupt_enable_counter) {
   \   00000002   0x4C0C             LDR      R4,??core_util_critical_section_exit_0
   \   00000004   0x6860             LDR      R0,[R4, #+4]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD012             BEQ      ??core_util_critical_section_exit_1
     83          
     84          // FIXME
     85          #ifndef   FEATURE_UVISOR
     86                  bool interrupts_disabled = !core_util_are_interrupts_enabled(); /* get the current interrupt disabled state */
     87          
     88                  MBED_ASSERT(interrupts_disabled); /* Interrupts must be disabled on invoking an exit from a critical section */
   \   0000000A   0xF3EF 0x8010      MRS      R0,PRIMASK
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xD404             BMI      ??core_util_critical_section_exit_2
   \   00000012   0x2258             MOVS     R2,#+88
   \   00000014   0x4908             LDR      R1,??core_util_critical_section_exit_0+0x4
   \   00000016   0x4809             LDR      R0,??core_util_critical_section_exit_0+0x8
   \   00000018   0x.... 0x....      BL       mbed_assert_internal
     89          #else
     90          #warning "core_util_critical_section_exit needs fixing to work from unprivileged code"
     91          #endif /* FEATURE_UVISOR */
     92          
     93                  interrupt_enable_counter--;
   \                     ??core_util_critical_section_exit_2: (+1)
   \   0000001C   0x6860             LDR      R0,[R4, #+4]
   \   0000001E   0x1E40             SUBS     R0,R0,#+1
   \   00000020   0x6060             STR      R0,[R4, #+4]
     94          
     95                  /* Only re-enable interrupts if we are exiting the last of the nested critical sections and
     96                     interrupts were enabled on entry to the first critical section.
     97                  */
     98                  if (!interrupt_enable_counter && !critical_interrupts_disabled) {
   \   00000022   0x6860             LDR      R0,[R4, #+4]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD103             BNE      ??core_util_critical_section_exit_1
   \   00000028   0x7820             LDRB     R0,[R4, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD100             BNE      ??core_util_critical_section_exit_1
     99                      __enable_irq();
   \   0000002E   0xB662             CPSIE    I
    100                  }
    101              }
    102          }
   \                     ??core_util_critical_section_exit_1: (+1)
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
   \   00000032   0xBF00             Nop      
   \                     ??core_util_critical_section_exit_0:
   \   00000034   0x........         DC32     critical_interrupts_disabled
   \   00000038   0x........         DC32     ?_1
   \   0000003C   0x........         DC32     ?_2
    103          
    104          #if __EXCLUSIVE_ACCESS
    105          
    106          /* Supress __ldrex and __strex deprecated warnings - "#3731-D: intrinsic is deprecated" */
    107          #if defined (__CC_ARM) 
    108          #pragma diag_suppress 3731
    109          #endif
    110          
    111          bool core_util_atomic_cas_u8(uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue)
    112          {
    113              uint8_t currentValue = __LDREXB((volatile uint8_t*)ptr);
    114              if (currentValue != *expectedCurrentValue) {
    115                  *expectedCurrentValue = currentValue;
    116                  __CLREX();
    117                  return false;
    118              }
    119          
    120              return !__STREXB(desiredValue, (volatile uint8_t*)ptr);
    121          }
    122          
    123          bool core_util_atomic_cas_u16(uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue)
    124          {
    125              uint16_t currentValue = __LDREXH((volatile uint16_t*)ptr);
    126              if (currentValue != *expectedCurrentValue) {
    127                  *expectedCurrentValue = currentValue;
    128                  __CLREX();
    129                  return false;
    130              }
    131          
    132              return !__STREXH(desiredValue, (volatile uint16_t*)ptr);
    133          }
    134          
    135          
    136          bool core_util_atomic_cas_u32(uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue)
    137          {
    138              uint32_t currentValue = __LDREXW((volatile uint32_t*)ptr);
    139              if (currentValue != *expectedCurrentValue) {
    140                  *expectedCurrentValue = currentValue;
    141                  __CLREX();
    142                  return false;
    143              }
    144          
    145              return !__STREXW(desiredValue, (volatile uint32_t*)ptr);
    146          }
    147          
    148          uint8_t core_util_atomic_incr_u8(uint8_t *valuePtr, uint8_t delta)
    149          {
    150              uint8_t newValue;
    151              do {
    152                  newValue = __LDREXB((volatile uint8_t*)valuePtr) + delta;
    153              } while (__STREXB(newValue, (volatile uint8_t*)valuePtr));
    154              return newValue;
    155          }
    156          
    157          uint16_t core_util_atomic_incr_u16(uint16_t *valuePtr, uint16_t delta)
    158          {
    159              uint16_t newValue;
    160              do {
    161                  newValue = __LDREXH((volatile uint16_t*)valuePtr) + delta;
    162              } while (__STREXH(newValue, (volatile uint16_t*)valuePtr));
    163              return newValue;
    164          }
    165          
    166          uint32_t core_util_atomic_incr_u32(uint32_t *valuePtr, uint32_t delta)
    167          {
    168              uint32_t newValue;
    169              do {
    170                  newValue = __LDREXW((volatile uint32_t*)valuePtr) + delta;
    171              } while (__STREXW(newValue, (volatile uint32_t*)valuePtr));
    172              return newValue;
    173          }
    174          
    175          
    176          uint8_t core_util_atomic_decr_u8(uint8_t *valuePtr, uint8_t delta)
    177          {
    178              uint8_t newValue;
    179              do {
    180                  newValue = __LDREXB((volatile uint8_t*)valuePtr) - delta;
    181              } while (__STREXB(newValue, (volatile uint8_t*)valuePtr));
    182              return newValue;
    183          }
    184          
    185          uint16_t core_util_atomic_decr_u16(uint16_t *valuePtr, uint16_t delta)
    186          {
    187              uint16_t newValue;
    188              do {
    189                  newValue = __LDREXH((volatile uint16_t*)valuePtr) - delta;
    190              } while (__STREXH(newValue, (volatile uint16_t*)valuePtr));
    191              return newValue;
    192          }
    193          
    194          uint32_t core_util_atomic_decr_u32(uint32_t *valuePtr, uint32_t delta)
    195          {
    196              uint32_t newValue;
    197              do {
    198                  newValue = __LDREXW((volatile uint32_t*)valuePtr) - delta;
    199              } while (__STREXW(newValue, (volatile uint32_t*)valuePtr));
    200              return newValue;
    201          }
    202          
    203          #else
    204          

   \                                 In section .text, align 2, keep-with-next
    205          bool core_util_atomic_cas_u8(uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue)
    206          {
   \                     core_util_atomic_cas_u8: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    207              bool success;
    208              uint8_t currentValue;
    209              core_util_critical_section_enter();
   \   00000008   0x.... 0x....      BL       core_util_critical_section_enter
    210              currentValue = *ptr;
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
    211              if (currentValue == *expectedCurrentValue) {
   \   0000000E   0x782A             LDRB     R2,[R5, #+0]
   \   00000010   0x4290             CMP      R0,R2
   \   00000012   0xD102             BNE      ??core_util_atomic_cas_u8_0
    212                  *ptr = desiredValue;
   \   00000014   0x7026             STRB     R6,[R4, #+0]
    213                  success = true;
   \   00000016   0x2401             MOVS     R4,#+1
   \   00000018   0xE001             B        ??core_util_atomic_cas_u8_1
    214              } else {
    215                  *expectedCurrentValue = currentValue;
   \                     ??core_util_atomic_cas_u8_0: (+1)
   \   0000001A   0x7028             STRB     R0,[R5, #+0]
    216                  success = false;
   \   0000001C   0x2400             MOVS     R4,#+0
    217              }
    218              core_util_critical_section_exit();
   \                     ??core_util_atomic_cas_u8_1: (+1)
   \   0000001E   0x....             B.N      ??Subroutine0_0
    219              return success;
    220          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x0004             MOVS     R4,R0
   \   00000002   0x000D             MOVS     R5,R1
   \   00000004   0x0016             MOVS     R6,R2
   \   00000006   0x.... 0x....      BL       core_util_critical_section_enter
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6829             LDR      R1,[R5, #+0]
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD102             BNE      ??Subroutine0_1
   \   00000012   0x6026             STR      R6,[R4, #+0]
   \   00000014   0x2401             MOVS     R4,#+1
   \   00000016   0xE001             B        ??Subroutine0_0
   \                     ??Subroutine0_1: (+1)
   \   00000018   0x6028             STR      R0,[R5, #+0]
   \   0000001A   0x2400             MOVS     R4,#+0
   \                     ??Subroutine0_0: (+1)
   \   0000001C   0x.... 0x....      BL       core_util_critical_section_exit
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
    221          

   \                                 In section .text, align 2, keep-with-next
    222          bool core_util_atomic_cas_u16(uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue)
    223          {
   \                     core_util_atomic_cas_u16: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    224              bool success;
    225              uint16_t currentValue;
    226              core_util_critical_section_enter();
   \   00000008   0x.... 0x....      BL       core_util_critical_section_enter
    227              currentValue = *ptr;
   \   0000000C   0x8820             LDRH     R0,[R4, #+0]
    228              if (currentValue == *expectedCurrentValue) {
   \   0000000E   0x882A             LDRH     R2,[R5, #+0]
   \   00000010   0x4290             CMP      R0,R2
   \   00000012   0xD102             BNE      ??core_util_atomic_cas_u16_0
    229                  *ptr = desiredValue;
   \   00000014   0x8026             STRH     R6,[R4, #+0]
    230                  success = true;
   \   00000016   0x2401             MOVS     R4,#+1
   \   00000018   0xE001             B        ??core_util_atomic_cas_u16_1
    231              } else {
    232                  *expectedCurrentValue = currentValue;
   \                     ??core_util_atomic_cas_u16_0: (+1)
   \   0000001A   0x8028             STRH     R0,[R5, #+0]
    233                  success = false;
   \   0000001C   0x2400             MOVS     R4,#+0
    234              }
    235              core_util_critical_section_exit();
   \                     ??core_util_atomic_cas_u16_1: (+1)
   \   0000001E   0x....             B.N      ??Subroutine0_0
    236              return success;
    237          }
    238          
    239          

   \                                 In section .text, align 2, keep-with-next
    240          bool core_util_atomic_cas_u32(uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue)
   \                     core_util_atomic_cas_u32: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x....             B.N      ?Subroutine0
    241          {
    242              bool success;
    243              uint32_t currentValue;
    244              core_util_critical_section_enter();
    245              currentValue = *ptr;
    246              if (currentValue == *expectedCurrentValue) {
    247                  *ptr = desiredValue;
    248                  success = true;
    249              } else {
    250                  *expectedCurrentValue = currentValue;
    251                  success = false;
    252              }
    253              core_util_critical_section_exit();
    254              return success;
    255          }
    256          
    257          

   \                                 In section .text, align 2, keep-with-next
    258          uint8_t core_util_atomic_incr_u8(uint8_t *valuePtr, uint8_t delta)
    259          {
   \                     core_util_atomic_incr_u8: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    260              uint8_t newValue;
    261              core_util_critical_section_enter();
   \   00000006   0x.... 0x....      BL       core_util_critical_section_enter
    262              newValue = *valuePtr + delta;
   \   0000000A   0x7828             LDRB     R0,[R5, #+0]
   \   0000000C   0x1904             ADDS     R4,R0,R4
    263              *valuePtr = newValue;
   \   0000000E   0x....             B.N      ?Subroutine2
    264              core_util_critical_section_exit();
    265              return newValue;
    266          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x702C             STRB     R4,[R5, #+0]
   \   00000002   0x.... 0x....      BL       core_util_critical_section_exit
   \   00000006   0xB2E0             UXTB     R0,R4
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    267          

   \                                 In section .text, align 2, keep-with-next
    268          uint16_t core_util_atomic_incr_u16(uint16_t *valuePtr, uint16_t delta)
    269          {
   \                     core_util_atomic_incr_u16: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    270              uint16_t newValue;
    271              core_util_critical_section_enter();
   \   00000006   0x.... 0x....      BL       core_util_critical_section_enter
    272              newValue = *valuePtr + delta;
   \   0000000A   0x8828             LDRH     R0,[R5, #+0]
   \   0000000C   0x1904             ADDS     R4,R0,R4
    273              *valuePtr = newValue;
   \   0000000E   0x....             B.N      ?Subroutine3
    274              core_util_critical_section_exit();
    275              return newValue;
    276          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x802C             STRH     R4,[R5, #+0]
   \   00000002   0x.... 0x....      BL       core_util_critical_section_exit
   \   00000006   0xB2A0             UXTH     R0,R4
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    277          

   \                                 In section .text, align 2, keep-with-next
    278          uint32_t core_util_atomic_incr_u32(uint32_t *valuePtr, uint32_t delta)
   \                     core_util_atomic_incr_u32: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x....             B.N      ?Subroutine1

   \                                 In section .text, align 2, keep-with-next
    279          {
   \                     ?Subroutine1: (+1)
   \   00000000   0x0005             MOVS     R5,R0
   \   00000002   0x000C             MOVS     R4,R1
    280              uint32_t newValue;
    281              core_util_critical_section_enter();
   \   00000004   0x.... 0x....      BL       core_util_critical_section_enter
    282              newValue = *valuePtr + delta;
   \   00000008   0x6828             LDR      R0,[R5, #+0]
   \   0000000A   0x1904             ADDS     R4,R0,R4
    283              *valuePtr = newValue;
   \   0000000C                      REQUIRE ??Subroutine4_0
   \   0000000C                      ;; // Fall through to label ??Subroutine4_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine4_0: (+1)
   \   00000000   0x602C             STR      R4,[R5, #+0]
    284              core_util_critical_section_exit();
   \   00000002   0x.... 0x....      BL       core_util_critical_section_exit
    285              return newValue;
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    286          }
    287          
    288          

   \                                 In section .text, align 2, keep-with-next
    289          uint8_t core_util_atomic_decr_u8(uint8_t *valuePtr, uint8_t delta)
    290          {
   \                     core_util_atomic_decr_u8: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    291              uint8_t newValue;
    292              core_util_critical_section_enter();
   \   00000006   0x.... 0x....      BL       core_util_critical_section_enter
    293              newValue = *valuePtr - delta;
   \   0000000A   0x7828             LDRB     R0,[R5, #+0]
   \   0000000C   0x1B04             SUBS     R4,R0,R4
    294              *valuePtr = newValue;
   \   0000000E                      REQUIRE ?Subroutine2
   \   0000000E                      ;; // Fall through to label ?Subroutine2
    295              core_util_critical_section_exit();
    296              return newValue;
    297          }
    298          

   \                                 In section .text, align 2, keep-with-next
    299          uint16_t core_util_atomic_decr_u16(uint16_t *valuePtr, uint16_t delta)
    300          {
   \                     core_util_atomic_decr_u16: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    301              uint16_t newValue;
    302              core_util_critical_section_enter();
   \   00000006   0x.... 0x....      BL       core_util_critical_section_enter
    303              newValue = *valuePtr - delta;
   \   0000000A   0x8828             LDRH     R0,[R5, #+0]
   \   0000000C   0x1B04             SUBS     R4,R0,R4
    304              *valuePtr = newValue;
   \   0000000E                      REQUIRE ?Subroutine3
   \   0000000E                      ;; // Fall through to label ?Subroutine3
    305              core_util_critical_section_exit();
    306              return newValue;
    307          }
    308          

   \                                 In section .text, align 2, keep-with-next
    309          uint32_t core_util_atomic_decr_u32(uint32_t *valuePtr, uint32_t delta)
    310          {
   \                     core_util_atomic_decr_u32: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    311              uint32_t newValue;
    312              core_util_critical_section_enter();
   \   00000006   0x.... 0x....      BL       core_util_critical_section_enter
    313              newValue = *valuePtr - delta;
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0x1B04             SUBS     R4,R0,R4
    314              *valuePtr = newValue;
   \   0000000E   0x....             B.N      ??Subroutine4_0
    315              core_util_critical_section_exit();
    316              return newValue;
    317          }
    318          
    319          #endif
    320          
    321          

   \                                 In section .text, align 2, keep-with-next
    322          bool core_util_atomic_cas_ptr(void **ptr, void **expectedCurrentValue, void *desiredValue) {
   \                     core_util_atomic_cas_ptr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0
    323              return core_util_atomic_cas_u32(
    324                      (uint32_t *)ptr,
    325                      (uint32_t *)expectedCurrentValue,
    326                      (uint32_t)desiredValue);
    327          }
    328          

   \                                 In section .text, align 2, keep-with-next
    329          void *core_util_atomic_incr_ptr(void **valuePtr, ptrdiff_t delta) {
   \                     core_util_atomic_incr_ptr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002                      REQUIRE ?Subroutine1
   \   00000002                      ;; // Fall through to label ?Subroutine1
    330              return (void *)core_util_atomic_incr_u32((uint32_t *)valuePtr, (uint32_t)delta);
    331          }
    332          

   \                                 In section .text, align 2, keep-with-next
    333          void *core_util_atomic_decr_ptr(void **valuePtr, ptrdiff_t delta) {
   \                     core_util_atomic_decr_ptr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    334              return (void *)core_util_atomic_decr_u32((uint32_t *)valuePtr, (uint32_t)delta);
   \   00000006   0x.... 0x....      BL       core_util_critical_section_enter
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0x1B04             SUBS     R4,R0,R4
   \   0000000E   0x....             B.N      ??Subroutine4_0
    335          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x69 0x6E          DC8 "interrupt_enable_counter < UINT32_MAX"
   \              0x74 0x65    
   \              0x72 0x72    
   \              0x75 0x70    
   \              0x74 0x5F    
   \              0x65 0x6E    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x5F 0x63    
   \              0x6F 0x75    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x20 0x3C    
   \              0x20 0x55    
   \              0x49 0x4E    
   \              0x54 0x33    
   \              0x32 0x5F    
   \              0x4D 0x41    
   \              0x58 0x00    
   \   00000026   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x2E 0x5C          DC8 ".\\mbed-os\\platform\\mbed_critical.c"
   \              0x6D 0x62    
   \              0x65 0x64    
   \              0x2D 0x6F    
   \              0x73 0x5C    
   \              0x70 0x6C    
   \              0x61 0x74    
   \              0x66 0x6F    
   \              0x72 0x6D    
   \              0x5C 0x6D    
   \              0x62 0x65    
   \              0x64 0x5F    
   \              0x63 0x72    
   \              0x69 0x74    
   \              0x69 0x63    
   \              0x61 0x6C    
   \              0x2E 0x63    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x69 0x6E          DC8 "interrupts_disabled"
   \              0x74 0x65    
   \              0x72 0x72    
   \              0x75 0x70    
   \              0x74 0x73    
   \              0x5F 0x64    
   \              0x69 0x73    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x64 0x00    
    336          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   core_util_are_interrupts_enabled
       0   core_util_atomic_cas_ptr
        16   -> core_util_critical_section_enter
        16   -> core_util_critical_section_exit
      16   core_util_atomic_cas_u16
        16   -> core_util_critical_section_enter
        16   -> core_util_critical_section_exit
      16   core_util_atomic_cas_u32
        16   -> core_util_critical_section_enter
        16   -> core_util_critical_section_exit
      16   core_util_atomic_cas_u8
        16   -> core_util_critical_section_enter
        16   -> core_util_critical_section_exit
      16   core_util_atomic_decr_ptr
        16   -> core_util_critical_section_enter
        16   -> core_util_critical_section_exit
      16   core_util_atomic_decr_u16
        16   -> core_util_critical_section_enter
        16   -> core_util_critical_section_exit
      16   core_util_atomic_decr_u32
        16   -> core_util_critical_section_enter
        16   -> core_util_critical_section_exit
      16   core_util_atomic_decr_u8
        16   -> core_util_critical_section_enter
        16   -> core_util_critical_section_exit
       0   core_util_atomic_incr_ptr
        16   -> core_util_critical_section_enter
        16   -> core_util_critical_section_exit
      16   core_util_atomic_incr_u16
        16   -> core_util_critical_section_enter
        16   -> core_util_critical_section_exit
      16   core_util_atomic_incr_u32
        16   -> core_util_critical_section_enter
        16   -> core_util_critical_section_exit
      16   core_util_atomic_incr_u8
        16   -> core_util_critical_section_enter
        16   -> core_util_critical_section_exit
      16   core_util_critical_section_enter
        16   -> mbed_assert_internal
       8   core_util_critical_section_exit
         8   -> mbed_assert_internal
       0   core_util_is_isr_active


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      10  ??Subroutine4_0
      36  ?Subroutine0
      12  ?Subroutine1
      10  ?Subroutine2
      10  ?Subroutine3
      40  ?_0
      36  ?_1
      20  ?_2
      14  core_util_are_interrupts_enabled
       2  core_util_atomic_cas_ptr
      32  core_util_atomic_cas_u16
       4  core_util_atomic_cas_u32
      32  core_util_atomic_cas_u8
      16  core_util_atomic_decr_ptr
      14  core_util_atomic_decr_u16
      16  core_util_atomic_decr_u32
      14  core_util_atomic_decr_u8
       2  core_util_atomic_incr_ptr
      16  core_util_atomic_incr_u16
       4  core_util_atomic_incr_u32
      16  core_util_atomic_incr_u8
      88  core_util_critical_section_enter
      64  core_util_critical_section_exit
      14  core_util_is_isr_active
       8  critical_interrupts_disabled
          interrupt_enable_counter

 
   8 bytes in section .bss
  96 bytes in section .rodata
 426 bytes in section .text
 
 274 bytes of CODE  memory (+ 152 bytes shared)
  96 bytes of CONST memory
   8 bytes of DATA  memory

Errors: none
Warnings: 1

###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       16/Mar/2018  12:16:41
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\features\netsocket\SocketAddress.cpp
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --c++ --no_rtti --no_exceptions --guard_calls
#        --no_static_destruction -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DDEVICE_SERIAL=1 -DTARGET_CORTEX_M -DDEVICE_SPI=1 -DTARGET_LIKE_MBED
#        -DMBED_BUILD_TIMESTAMP=1521198946.13 -DARM_MATH_CM0 -DTARGET_RELEASE
#        -D__CORTEX_M0 -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0
#        -DTOOLCHAIN_object -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -f
#        .\BUILD\STEVAL_IDB007V1\iar\.includes_fc2e77952737cb4522ab0dffe8cfd8aa.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN
#        -I./mbed-os/features/frameworks
#        -I./mbed-os/features/frameworks/greentea-client
#        -I./mbed-os/features/frameworks/greentea-client/greentea-client
#        -I./mbed-os/features/frameworks/greentea-client/source
#        -I./mbed-os/features/frameworks/unity
#        -I./mbed-os/features/frameworks/unity/source
#        -I./mbed-os/features/frameworks/unity/unity
#        -I./mbed-os/features/frameworks/utest
#        -I./mbed-os/features/frameworks/utest/source
#        -I./mbed-os/features/frameworks/utest/utest
#        -I./mbed-os/features/mbedtls -I./mbed-os/features/mbedtls/importer
#        -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/features/netsocket
#        -I./mbed-os/features/netsocket/cellular
#        -I./mbed-os/features/netsocket/cellular/generic_modem_driver
#        -I./mbed-os/features/netsocket/cellular/utils
#        -I./mbed-os/features/storage -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\iar\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\iar\mbed-os\features\netsocket\SocketAddress.d
#        -l
#        .\BUILD\STEVAL_IDB007V1\iar\mbed-os\features\netsocket\SocketAddress.s.txt
#        -o
#        .\BUILD\STEVAL_IDB007V1\iar\mbed-os\features\netsocket\SocketAddress.o
#        .\mbed-os\features\netsocket\SocketAddress.cpp
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\iar\mbed-os\features\netsocket\SocketAddress.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\iar\mbed-os\features\netsocket\SocketAddress.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia\mbed-os\features\netsocket\SocketAddress.cpp
      1          /* Socket
      2           * Copyright (c) 2015 ARM Limited
      3           *
      4           * Licensed under the Apache License, Version 2.0 (the "License");
      5           * you may not use this file except in compliance with the License.
      6           * You may obtain a copy of the License at
      7           *
      8           *     http://www.apache.org/licenses/LICENSE-2.0
      9           *
     10           * Unless required by applicable law or agreed to in writing, software
     11           * distributed under the License is distributed on an "AS IS" BASIS,
     12           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13           * See the License for the specific language governing permissions and
     14           * limitations under the License.
     15           */
     16          
     17          #include "SocketAddress.h"
     18          #include "NetworkInterface.h"
     19          #include "NetworkStack.h"
     20          #include <string.h>
     21          #include "mbed.h"

   \                                 In section .rodata, align 4
   \   __absolute mbed::Callback<void ()>::ops const mbed::Callback<void ()>::generate<>(mbed::Callback<void ()>::function_context<void (*)(void *), void> const &)::ops
   \                     _ZZN4mbed8CallbackIFvvEE8generateINS2_16function_contextIPFvPvEvEEEEvRKT_E3ops:
   \   00000000   0x........         DC32 _ZN4mbed8CallbackIFvvEE13function_callINS2_16function_contextIPFvPvEvEEEEvPKv
   \   00000004   0x........         DC32 _ZN4mbed8CallbackIFvvEE13function_moveINS2_16function_contextIPFvPvEvEEEEvS5_PKv
   \   00000008   0x........         DC32 _ZN4mbed8CallbackIFvvEE13function_dtorINS2_16function_contextIPFvPvEvEEEEvS5_

   \                                 In section .text, align 2
   \   __interwork __softfp void mbed::Callback<void ()>::function_call<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void const *)
   \                     _ZN4mbed8CallbackIFvvEE13function_callINS2_16function_contextIPFvPvEvEEEEvPKv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0001             MOVS     R1,R0
   \   00000004   0x6848             LDR      R0,[R1, #+4]
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x4788             BLX      R1
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void mbed::Callback<void ()>::function_move<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *, void const *)
   \                     _ZN4mbed8CallbackIFvvEE13function_moveINS2_16function_contextIPFvPvEvEEEEvS5_PKv: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD001             BEQ      ??function_move_0
   \   00000004   0xC90C             LDM      R1!,{R2,R3}
   \   00000006   0xC00C             STM      R0!,{R2,R3}
   \                     ??function_move_0: (+1)
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void mbed::Callback<void ()>::function_dtor<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *)
   \                     _ZN4mbed8CallbackIFvvEE13function_dtorINS2_16function_contextIPFvPvEvEEEEvS5_: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp void mbed::callback<>(void (*)(void *), void *)
   \                     _ZN4mbed8callbackIvvvEENS_8CallbackIFT1_vEEEPFS2_PT_EPT0_: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0xC078             STM      R0!,{R3-R6}
   \   0000000C   0x3810             SUBS     R0,R0,#+16
   \   0000000E   0xD001             BEQ      ??callback_0
   \   00000010   0x6001             STR      R1,[R0, #+0]
   \   00000012   0x6042             STR      R2,[R0, #+4]
   \                     ??callback_0: (+1)
   \   00000014   0x4901             LDR      R1,??callback_1
   \   00000016   0x60C1             STR      R1,[R0, #+12]
   \   00000018   0xBC70             POP      {R4-R6}
   \   0000001A   0x4770             BX       LR               ;; return
   \                     ??callback_1:
   \   0000001C   0x........         DC32     _ZZN4mbed8CallbackIFvvEE8generateINS2_16function_contextIPFvPvEvEEEEvRKT_E3ops
     22          
     23          
     24          static bool ipv4_is_valid(const char *addr)
     25          {
     26              int i = 0;
     27          
     28              // Check each digit for [0-9.]
     29              for (; addr[i]; i++) {
     30                  if (!(addr[i] >= '0' && addr[i] <= '9') && addr[i] != '.') {
     31                      return false;
     32                  }
     33              }
     34          
     35              // Ending with '.' garuntees host
     36              if (i > 0 && addr[i-1] == '.') {
     37                  return false;
     38              }
     39          
     40              return true;
     41          }
     42          
     43          static bool ipv6_is_valid(const char *addr)
     44          {
     45              // Check each digit for [0-9a-fA-F:]
     46              // Must also have at least 2 colons
     47              int colons = 0;
     48              for (int i = 0; addr[i]; i++) {
     49                  if (!(addr[i] >= '0' && addr[i] <= '9') &&
     50                      !(addr[i] >= 'a' && addr[i] <= 'f') &&
     51                      !(addr[i] >= 'A' && addr[i] <= 'F') &&
     52                      addr[i] != ':') {
     53                      return false;
     54                  }
     55                  if (addr[i] == ':') {
     56                      colons++;
     57                  }
     58              }
     59          
     60              return colons >= 2;
     61          }
     62          
     63          static void ipv4_from_address(uint8_t *bytes, const char *addr)
     64          {
     65              int count = 0;
     66              int i = 0;
     67          
     68              for (; count < NSAPI_IPv4_BYTES; count++) {
     69                  unsigned char b;
     70                  int scanned = sscanf(&addr[i], "%hhu", &b);
                                                                  ^
Warning[Pe721]: nonstandard format string conversion
     71                  if (scanned < 1) {
     72                      return;
     73                  }
     74          
     75                  bytes[count] = b;
     76          
     77                  for (; addr[i] != '.'; i++) {
     78                      if (!addr[i]) {
     79                          return;
     80                      }
     81                  }
     82          
     83                  i++;
     84              }
     85          }
     86          

   \                                 In section .text, align 2, keep-with-next
     87          static int ipv6_scan_chunk(uint16_t *shorts, const char *chunk) {
   \                     _Z15ipv6_scan_chunkPtPKc: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x000F             MOVS     R7,R1
     88              int count = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2500             MOVS     R5,#+0
     89              int i = 0;
   \   00000008   0x0006             MOVS     R6,R0
     90          
     91              for (; count < NSAPI_IPv6_BYTES/2; count++) {
     92                  unsigned short s;
     93                  int scanned = sscanf(&chunk[i], "%hx", &s);
     94                  if (scanned < 1) {
   \                     ??ipv6_scan_chunk_0: (+1)
   \   0000000A   0x466A             MOV      R2,SP
   \   0000000C   0x....             ADR      R1,??DataTable4  ;; "%hx"
   \   0000000E   0x1938             ADDS     R0,R7,R4
   \   00000010   0x.... 0x....      BL       sscanf
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xDB12             BLT      ??ipv6_scan_chunk_1
     95                      return count;
     96                  }
     97          
     98                  shorts[count] = s;
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x8800             LDRH     R0,[R0, #+0]
   \   0000001C   0x8030             STRH     R0,[R6, #+0]
   \   0000001E   0x1938             ADDS     R0,R7,R4
   \   00000020   0xE001             B        ??ipv6_scan_chunk_2
     99          
    100                  for (; chunk[i] != ':'; i++) {
   \                     ??ipv6_scan_chunk_3: (+1)
   \   00000022   0x1C64             ADDS     R4,R4,#+1
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \                     ??ipv6_scan_chunk_2: (+1)
   \   00000026   0x7801             LDRB     R1,[R0, #+0]
   \   00000028   0x293A             CMP      R1,#+58
   \   0000002A   0xD003             BEQ      ??ipv6_scan_chunk_4
    101                      if (!chunk[i]) {
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD1F8             BNE      ??ipv6_scan_chunk_3
    102                          return count+1;
   \   00000030   0x1C68             ADDS     R0,R5,#+1
   \   00000032   0xBDF2             POP      {R1,R4-R7,PC}
    103                      }
    104                  }
    105          
    106                  i++;
   \                     ??ipv6_scan_chunk_4: (+1)
   \   00000034   0x1C64             ADDS     R4,R4,#+1
    107              }
   \   00000036   0x1C6D             ADDS     R5,R5,#+1
   \   00000038   0x1CB6             ADDS     R6,R6,#+2
   \   0000003A   0x2D08             CMP      R5,#+8
   \   0000003C   0xDBE5             BLT      ??ipv6_scan_chunk_0
    108          
    109              return count;
   \                     ??ipv6_scan_chunk_1: (+1)
   \   0000003E   0x0028             MOVS     R0,R5
   \   00000040   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    110          }
    111          

   \                                 In section .text, align 2, keep-with-next
    112          static void ipv6_from_address(uint8_t *bytes, const char *addr)
    113          {
   \                     _Z17ipv6_from_addressPhPKc: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
    114              // Start with zeroed address
    115              uint16_t shorts[NSAPI_IPv6_BYTES/2];
    116              int suffix = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x2700             MOVS     R7,#+0
    117          
    118              // Find double colons and scan suffix
    119              for (int i = 0; addr[i]; i++) {
   \   0000000C   0xE001             B        ??ipv6_from_address_0
   \                     ??ipv6_from_address_1: (+1)
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x1C49             ADDS     R1,R1,#+1
   \                     ??ipv6_from_address_0: (+1)
   \   00000012   0x780A             LDRB     R2,[R1, #+0]
   \   00000014   0x0013             MOVS     R3,R2
   \   00000016   0xD00A             BEQ      ??ipv6_from_address_2
    120                  if (addr[i] == ':' && addr[i+1] == ':') {
   \   00000018   0x2A3A             CMP      R2,#+58
   \   0000001A   0xD1F8             BNE      ??ipv6_from_address_1
   \   0000001C   0x784A             LDRB     R2,[R1, #+1]
   \   0000001E   0x2A3A             CMP      R2,#+58
   \   00000020   0xD1F5             BNE      ??ipv6_from_address_1
    121                      suffix = ipv6_scan_chunk(shorts, &addr[i+2]);
   \   00000022   0x1830             ADDS     R0,R6,R0
   \   00000024   0x1C81             ADDS     R1,R0,#+2
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x.... 0x....      BL       _Z15ipv6_scan_chunkPtPKc
   \   0000002C   0x0007             MOVS     R7,R0
    122                      break;
    123                  }
    124              }
    125          
    126              // Move suffix to end
    127              memmove(&shorts[NSAPI_IPv6_BYTES/2-suffix], &shorts[0],
    128                      suffix*sizeof(uint16_t));
   \                     ??ipv6_from_address_2: (+1)
   \   0000002E   0x466C             MOV      R4,SP
   \   00000030   0x007A             LSLS     R2,R7,#+1
   \   00000032   0x4669             MOV      R1,SP
   \   00000034   0x4278             RSBS     R0,R7,#+0
   \   00000036   0x0040             LSLS     R0,R0,#+1
   \   00000038   0x1820             ADDS     R0,R4,R0
   \   0000003A   0x3010             ADDS     R0,R0,#+16
   \   0000003C   0x.... 0x....      BL       __aeabi_memmove
    129              memset(&shorts[0], 0,
    130                      (NSAPI_IPv6_BYTES/2-suffix)*sizeof(uint16_t));
   \   00000040   0x2008             MOVS     R0,#+8
   \   00000042   0x1BC0             SUBS     R0,R0,R7
   \   00000044   0x0041             LSLS     R1,R0,#+1
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x.... 0x....      BL       __aeabi_memclr4
    131          
    132              // Scan prefix
    133              ipv6_scan_chunk(shorts, &addr[0]);
   \   0000004C   0x0031             MOVS     R1,R6
   \   0000004E   0x4668             MOV      R0,SP
   \   00000050   0x.... 0x....      BL       _Z15ipv6_scan_chunkPtPKc
    134          
    135              // Flip bytes
    136              for (int i = 0; i < NSAPI_IPv6_BYTES/2; i++) {
    137                  bytes[2*i+0] = (uint8_t)(shorts[i] >> 8);
   \   00000054   0x8820             LDRH     R0,[R4, #+0]
   \   00000056   0x0A00             LSRS     R0,R0,#+8
   \   00000058   0x7028             STRB     R0,[R5, #+0]
    138                  bytes[2*i+1] = (uint8_t)(shorts[i] >> 0);
   \   0000005A   0x8820             LDRH     R0,[R4, #+0]
   \   0000005C   0x7068             STRB     R0,[R5, #+1]
   \   0000005E   0x8860             LDRH     R0,[R4, #+2]
   \   00000060   0x0A00             LSRS     R0,R0,#+8
   \   00000062   0x70A8             STRB     R0,[R5, #+2]
   \   00000064   0x8860             LDRH     R0,[R4, #+2]
   \   00000066   0x70E8             STRB     R0,[R5, #+3]
   \   00000068   0x88A0             LDRH     R0,[R4, #+4]
   \   0000006A   0x0A00             LSRS     R0,R0,#+8
   \   0000006C   0x7128             STRB     R0,[R5, #+4]
   \   0000006E   0x88A0             LDRH     R0,[R4, #+4]
   \   00000070   0x7168             STRB     R0,[R5, #+5]
   \   00000072   0x88E0             LDRH     R0,[R4, #+6]
   \   00000074   0x0A00             LSRS     R0,R0,#+8
   \   00000076   0x71A8             STRB     R0,[R5, #+6]
   \   00000078   0x88E0             LDRH     R0,[R4, #+6]
   \   0000007A   0x71E8             STRB     R0,[R5, #+7]
   \   0000007C   0x8920             LDRH     R0,[R4, #+8]
   \   0000007E   0x0A00             LSRS     R0,R0,#+8
   \   00000080   0x7228             STRB     R0,[R5, #+8]
   \   00000082   0x8920             LDRH     R0,[R4, #+8]
   \   00000084   0x7268             STRB     R0,[R5, #+9]
   \   00000086   0x8960             LDRH     R0,[R4, #+10]
   \   00000088   0x0A00             LSRS     R0,R0,#+8
   \   0000008A   0x72A8             STRB     R0,[R5, #+10]
   \   0000008C   0x8960             LDRH     R0,[R4, #+10]
   \   0000008E   0x72E8             STRB     R0,[R5, #+11]
   \   00000090   0x89A0             LDRH     R0,[R4, #+12]
   \   00000092   0x0A00             LSRS     R0,R0,#+8
   \   00000094   0x7328             STRB     R0,[R5, #+12]
   \   00000096   0x89A0             LDRH     R0,[R4, #+12]
   \   00000098   0x7368             STRB     R0,[R5, #+13]
   \   0000009A   0x89E0             LDRH     R0,[R4, #+14]
   \   0000009C   0x0A00             LSRS     R0,R0,#+8
   \   0000009E   0x73A8             STRB     R0,[R5, #+14]
   \   000000A0   0x89E0             LDRH     R0,[R4, #+14]
   \   000000A2   0x73E8             STRB     R0,[R5, #+15]
    139              }
    140          }
   \   000000A4   0xB005             ADD      SP,SP,#+20
   \   000000A6   0xBDF0             POP      {R4-R7,PC}       ;; return
    141          
    142          static void ipv4_to_address(char *addr, const uint8_t *bytes)
    143          {
    144              sprintf(addr, "%d.%d.%d.%d", bytes[0], bytes[1], bytes[2], bytes[3]);
    145          }
    146          
    147          static void ipv6_to_address(char *addr, const uint8_t *bytes)
    148          {
    149              for (int i = 0; i < NSAPI_IPv6_BYTES/2; i++) {
    150                  sprintf(&addr[5*i], "%02x%02x", bytes[2*i], bytes[2*i+1]);
    151                  addr[5*i+4] = ':';
    152              }
    153              addr[NSAPI_IPv6_SIZE-1] = '\0';
    154          }
    155          
    156          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp SocketAddress::subobject SocketAddress(nsapi_addr, std::uint16_t)
   \                     _ZN13SocketAddressC2E10nsapi_addrt: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x980A             LDR      R0,[SP, #+40]
   \   0000000A   0x9002             STR      R0,[SP, #+8]
   \   0000000C   0xA905             ADD      R1,SP,#+20
   \   0000000E   0xB083             SUB      SP,SP,#+12
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x2214             MOVS     R2,#+20
   \   00000014   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000018   0xBC0E             POP      {R1-R3}
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       _ZN13SocketAddressC1E10nsapi_addrt
   \   00000020   0x....             B.N      ?Subroutine0

   \                                 In section .text, align 2, keep-with-next
    157          SocketAddress::SocketAddress(nsapi_addr_t addr, uint16_t port)
    158          {
   \                     _ZN13SocketAddressC1E10nsapi_addrt: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
    159              _ip_address[0] = '\0';
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x7020             STRB     R0,[R4, #+0]
    160              set_addr(addr);
   \   0000000C   0xA905             ADD      R1,SP,#+20
   \   0000000E   0xB083             SUB      SP,SP,#+12
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x2214             MOVS     R2,#+20
   \   00000014   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000018   0xBC0E             POP      {R1-R3}
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       _ZN13SocketAddress8set_addrE10nsapi_addr
    161              set_port(port);
   \   00000020   0x980A             LDR      R0,[SP, #+40]
   \   00000022   0x8760             STRH     R0,[R4, #+58]
    162          }
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026                      REQUIRE ?Subroutine0
   \   00000026                      ;; // Fall through to label ?Subroutine0

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xB003             ADD      SP,SP,#+12
   \   00000002   0x9901             LDR      R1,[SP, #+4]
   \   00000004   0xBC10             POP      {R4}
   \   00000006   0xB004             ADD      SP,SP,#+16
   \   00000008   0x4708             BX       R1               ;; return
    163          

   \                                 In section .text, align 2, keep-with-next
    164          SocketAddress::SocketAddress(const char *addr, uint16_t port)
   \                     _ZN13SocketAddressC1EPKct: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002                      REQUIRE ?Subroutine1
   \   00000002                      ;; // Fall through to label ?Subroutine1

   \                                 In section .text, align 2, keep-with-next
    165          {
   \                     ?Subroutine1: (+1)
   \   00000000   0x0004             MOVS     R4,R0
   \   00000002   0x0015             MOVS     R5,R2
    166              _ip_address[0] = '\0';
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x7020             STRB     R0,[R4, #+0]
    167              set_ip_address(addr);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       _ZN13SocketAddress14set_ip_addressEPKc
    168              set_port(port);
   \   0000000E                      REQUIRE ??Subroutine2_0
   \   0000000E                      ;; // Fall through to label ??Subroutine2_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine2_0: (+1)
   \   00000000   0x8765             STRH     R5,[R4, #+58]
    169          }
   \   00000002   0x0020             MOVS     R0,R4
   \   00000004   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    170          

   \                                 In section .text, align 2, keep-with-next
    171          SocketAddress::SocketAddress(const void *bytes, nsapi_version_t version, uint16_t port)
    172          {
   \                     _ZN13SocketAddressC1EPKv13nsapi_versiont: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    173              _ip_address[0] = '\0';
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x7020             STRB     R0,[R4, #+0]
    174              set_ip_bytes(bytes, version);
   \   00000010   0x2111             MOVS     R1,#+17
   \   00000012   0xA805             ADD      R0,SP,#+20
   \   00000014   0x.... 0x....      BL       __aeabi_memclr4
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0xA905             ADD      R1,SP,#+20
   \   0000001C   0x2214             MOVS     R2,#+20
   \   0000001E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x7006             STRB     R6,[R0, #+0]
   \   00000026   0x2E02             CMP      R6,#+2
   \   00000028   0xD101             BNE      ??SocketAddress_0
   \   0000002A   0x2210             MOVS     R2,#+16
   \   0000002C   0xE002             B        ??SocketAddress_1
   \                     ??SocketAddress_0: (+1)
   \   0000002E   0x2E01             CMP      R6,#+1
   \   00000030   0xD104             BNE      ??SocketAddress_2
   \   00000032   0x2204             MOVS     R2,#+4
   \                     ??SocketAddress_1: (+1)
   \   00000034   0x0029             MOVS     R1,R5
   \   00000036   0x1C40             ADDS     R0,R0,#+1
   \   00000038   0x.... 0x....      BL       __aeabi_memcpy
   \                     ??SocketAddress_2: (+1)
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x3028             ADDS     R0,R0,#+40
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x2211             MOVS     R2,#+17
   \   00000044   0x.... 0x....      BL       __aeabi_memcpy
    175              set_port(port);
   \   00000048   0x8767             STRH     R7,[R4, #+58]
    176          }
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0xB00B             ADD      SP,SP,#+44
   \   0000004E   0xBDF0             POP      {R4-R7,PC}       ;; return
    177          

   \                                 In section .text, align 2, keep-with-next
    178          SocketAddress::SocketAddress(const SocketAddress &addr)
    179          {
   \                     _ZN13SocketAddressC1ERKS_: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000C             MOVS     R4,R1
    180              _ip_address[0] = '\0';
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x7028             STRB     R0,[R5, #+0]
    181              set_addr(addr.get_addr());
   \   0000000C   0x3128             ADDS     R1,R1,#+40
   \   0000000E   0xB083             SUB      SP,SP,#+12
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x2211             MOVS     R2,#+17
   \   00000014   0x.... 0x....      BL       __aeabi_memcpy
   \   00000018   0xBC0E             POP      {R1-R3}
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0x.... 0x....      BL       _ZN13SocketAddress8set_addrE10nsapi_addr
    182              set_port(addr.get_port());
   \   00000020   0x8F60             LDRH     R0,[R4, #+58]
   \   00000022   0x8768             STRH     R0,[R5, #+58]
    183          }
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0xB003             ADD      SP,SP,#+12
   \   00000028   0xBD30             POP      {R4,R5,PC}       ;; return
    184          

   \                                 In section .text, align 4, keep-with-next
    185          bool SocketAddress::set_ip_address(const char *addr)
    186          {
   \                     _ZN13SocketAddress14set_ip_addressEPKc: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000F             MOVS     R7,R1
    187              _ip_address[0] = '\0';
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x7028             STRB     R0,[R5, #+0]
    188          
    189              if (addr && ipv4_is_valid(addr)) {
   \   0000000E   0x2F00             CMP      R7,#+0
   \   00000010   0xD046             BEQ      ??set_ip_address_0
   \   00000012   0xE006             B        ??set_ip_address_1
   \                     ??set_ip_address_2: (+1)
   \   00000014   0x3B30             SUBS     R3,R3,#+48
   \   00000016   0x2B0A             CMP      R3,#+10
   \   00000018   0xD301             BCC      ??set_ip_address_3
   \   0000001A   0x2A2E             CMP      R2,#+46
   \   0000001C   0xD12A             BNE      ??set_ip_address_4
   \                     ??set_ip_address_3: (+1)
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x1C49             ADDS     R1,R1,#+1
   \                     ??set_ip_address_1: (+1)
   \   00000022   0x780A             LDRB     R2,[R1, #+0]
   \   00000024   0x0013             MOVS     R3,R2
   \   00000026   0xD1F5             BNE      ??set_ip_address_2
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xDB04             BLT      ??set_ip_address_5
   \   0000002C   0x1838             ADDS     R0,R7,R0
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x282E             CMP      R0,#+46
   \   00000034   0xD01E             BEQ      ??set_ip_address_4
    190                  _addr.version = NSAPI_IPv4;
   \                     ??set_ip_address_5: (+1)
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x2128             MOVS     R1,#+40
   \   0000003A   0x5468             STRB     R0,[R5, R1]
    191                  ipv4_from_address(_addr.bytes, addr);
   \   0000003C   0x002E             MOVS     R6,R5
   \   0000003E   0x3629             ADDS     R6,R6,#+41
   \   00000040   0x2504             MOVS     R5,#+4
   \                     ??set_ip_address_6: (+1)
   \   00000042   0x466A             MOV      R2,SP
   \   00000044   0x....             ADR.N    R1,?_0
   \   00000046   0x1938             ADDS     R0,R7,R4
   \   00000048   0x.... 0x....      BL       sscanf
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xDB3E             BLT      ??set_ip_address_7
   \   00000050   0x4668             MOV      R0,SP
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x7030             STRB     R0,[R6, #+0]
   \   00000056   0x1938             ADDS     R0,R7,R4
   \   00000058   0xE001             B        ??set_ip_address_8
   \                     ??set_ip_address_9: (+1)
   \   0000005A   0x1C64             ADDS     R4,R4,#+1
   \   0000005C   0x1C40             ADDS     R0,R0,#+1
   \                     ??set_ip_address_8: (+1)
   \   0000005E   0x7801             LDRB     R1,[R0, #+0]
   \   00000060   0x292E             CMP      R1,#+46
   \   00000062   0xD104             BNE      ??set_ip_address_10
   \   00000064   0x1C64             ADDS     R4,R4,#+1
   \   00000066   0x1C76             ADDS     R6,R6,#+1
   \   00000068   0x1E6D             SUBS     R5,R5,#+1
   \   0000006A   0xD030             BEQ      ??set_ip_address_7
   \   0000006C   0xE7E9             B        ??set_ip_address_6
   \                     ??set_ip_address_10: (+1)
   \   0000006E   0x2900             CMP      R1,#+0
   \   00000070   0xD1F3             BNE      ??set_ip_address_9
    192                  return true;
   \   00000072   0xE02C             B.N      ??set_ip_address_7
    193              } else if (addr && ipv6_is_valid(addr)) {
   \                     ??set_ip_address_4: (+1)
   \   00000074   0x0038             MOVS     R0,R7
   \   00000076   0xE003             B        ??set_ip_address_11
   \                     ??set_ip_address_12: (+1)
   \   00000078   0x293A             CMP      R1,#+58
   \   0000007A   0xD100             BNE      ??set_ip_address_13
   \                     ??set_ip_address_14: (+1)
   \   0000007C   0x1C64             ADDS     R4,R4,#+1
   \                     ??set_ip_address_13: (+1)
   \   0000007E   0x1C40             ADDS     R0,R0,#+1
   \                     ??set_ip_address_11: (+1)
   \   00000080   0x7801             LDRB     R1,[R0, #+0]
   \   00000082   0x000A             MOVS     R2,R1
   \   00000084   0xD019             BEQ      ??set_ip_address_15
   \   00000086   0x0013             MOVS     R3,R2
   \   00000088   0x3B30             SUBS     R3,R3,#+48
   \   0000008A   0x2B0A             CMP      R3,#+10
   \   0000008C   0xD3F4             BCC      ??set_ip_address_12
   \   0000008E   0x0013             MOVS     R3,R2
   \   00000090   0x3B61             SUBS     R3,R3,#+97
   \   00000092   0x2B06             CMP      R3,#+6
   \   00000094   0xD3F0             BCC      ??set_ip_address_12
   \   00000096   0x3A41             SUBS     R2,R2,#+65
   \   00000098   0x2A06             CMP      R2,#+6
   \   0000009A   0xD3ED             BCC      ??set_ip_address_12
   \   0000009C   0x293A             CMP      R1,#+58
   \   0000009E   0xD0ED             BEQ      ??set_ip_address_14
    194                  _addr.version = NSAPI_IPv6;
    195                  ipv6_from_address(_addr.bytes, addr);
    196                  return true;
    197              } else {
    198                  _addr = nsapi_addr_t();
   \                     ??set_ip_address_0: (+1)
   \   000000A0   0x2111             MOVS     R1,#+17
   \   000000A2   0xA801             ADD      R0,SP,#+4
   \   000000A4   0x.... 0x....      BL       __aeabi_memclr4
   \   000000A8   0x0028             MOVS     R0,R5
   \   000000AA   0x3028             ADDS     R0,R0,#+40
   \   000000AC   0xA901             ADD      R1,SP,#+4
   \   000000AE   0x2211             MOVS     R2,#+17
   \   000000B0   0x.... 0x....      BL       __aeabi_memcpy
    199                  return false;
   \   000000B4   0x2000             MOVS     R0,#+0
   \                     ??set_ip_address_16: (+1)
   \   000000B6   0xB007             ADD      SP,SP,#+28
   \   000000B8   0xBDF0             POP      {R4-R7,PC}       ;; return
    200              }
   \                     ??set_ip_address_15: (+1)
   \   000000BA   0x2C02             CMP      R4,#+2
   \   000000BC   0xDBF0             BLT      ??set_ip_address_0
   \   000000BE   0x2002             MOVS     R0,#+2
   \   000000C0   0x2128             MOVS     R1,#+40
   \   000000C2   0x5468             STRB     R0,[R5, R1]
   \   000000C4   0x0039             MOVS     R1,R7
   \   000000C6   0x0028             MOVS     R0,R5
   \   000000C8   0x3029             ADDS     R0,R0,#+41
   \   000000CA   0x.... 0x....      BL       _Z17ipv6_from_addressPhPKc
   \                     ??set_ip_address_7: (+1)
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0xE7F1             B        ??set_ip_address_16
    201          }
    202          

   \                                 In section .text, align 2, keep-with-next
    203          void SocketAddress::set_ip_bytes(const void *bytes, nsapi_version_t version)
    204          {
   \                     _ZN13SocketAddress12set_ip_bytesEPKv13nsapi_version: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    205              nsapi_addr_t addr;
    206          
    207              addr = nsapi_addr_t();
   \   0000000A   0x2111             MOVS     R1,#+17
   \   0000000C   0xA807             ADD      R0,SP,#+28
   \   0000000E   0x.... 0x....      BL       __aeabi_memclr4
   \   00000012   0xA802             ADD      R0,SP,#+8
   \   00000014   0xA907             ADD      R1,SP,#+28
   \   00000016   0x2214             MOVS     R2,#+20
   \   00000018   0x.... 0x....      BL       __aeabi_memcpy4
    208              addr.version = version;
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x7206             STRB     R6,[R0, #+8]
    209              if (version == NSAPI_IPv6) {
   \   00000020   0x2E02             CMP      R6,#+2
   \   00000022   0xD101             BNE      ??set_ip_bytes_0
    210                  memcpy(addr.bytes, bytes, NSAPI_IPv6_BYTES);
   \   00000024   0x2210             MOVS     R2,#+16
   \   00000026   0xE002             B        ??set_ip_bytes_1
    211              } else if (version == NSAPI_IPv4) {
   \                     ??set_ip_bytes_0: (+1)
   \   00000028   0x2E01             CMP      R6,#+1
   \   0000002A   0xD105             BNE      ??set_ip_bytes_2
    212                  memcpy(addr.bytes, bytes, NSAPI_IPv4_BYTES);
   \   0000002C   0x2204             MOVS     R2,#+4
   \                     ??set_ip_bytes_1: (+1)
   \   0000002E   0x0029             MOVS     R1,R5
   \   00000030   0xA802             ADD      R0,SP,#+8
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \   00000034   0x.... 0x....      BL       __aeabi_memcpy
    213              }
    214              set_addr(addr);
   \                     ??set_ip_bytes_2: (+1)
   \   00000038   0xA902             ADD      R1,SP,#+8
   \   0000003A   0xB083             SUB      SP,SP,#+12
   \   0000003C   0x4668             MOV      R0,SP
   \   0000003E   0x2214             MOVS     R2,#+20
   \   00000040   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000044   0xBC0E             POP      {R1-R3}
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       _ZN13SocketAddress8set_addrE10nsapi_addr
    215          }
   \   0000004C   0xB00C             ADD      SP,SP,#+48
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
    216          

   \                                 In section .text, align 2, keep-with-next
    217          void SocketAddress::set_addr(nsapi_addr_t addr)
    218          {
   \                     _ZN13SocketAddress8set_addrE10nsapi_addr: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB500             PUSH     {LR}
    219              _ip_address[0] = '\0';
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    220              _addr = addr;
   \   00000008   0x3028             ADDS     R0,R0,#+40
   \   0000000A   0xA901             ADD      R1,SP,#+4
   \   0000000C   0x2211             MOVS     R2,#+17
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy
    221          }
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0xB004             ADD      SP,SP,#+16
   \   00000016   0x4700             BX       R0               ;; return
    222          

   \                                 In section .text, align 2, keep-with-next
    223          void SocketAddress::set_port(uint16_t port)
    224          {
    225              _port = port;
   \                     _ZN13SocketAddress8set_portEt: (+1)
   \   00000000   0x8741             STRH     R1,[R0, #+58]
    226          }
   \   00000002   0x4770             BX       LR               ;; return
    227          

   \                                 In section .text, align 4, keep-with-next
    228          const char *SocketAddress::get_ip_address() const
    229          {
   \                     _ZNK13SocketAddress14get_ip_addressEv: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0005             MOVS     R5,R0
    230              if (_addr.version == NSAPI_UNSPEC) {
   \   00000006   0x002C             MOVS     R4,R5
   \   00000008   0x3422             ADDS     R4,R4,#+34
   \   0000000A   0x79A0             LDRB     R0,[R4, #+6]
   \   0000000C   0x0001             MOVS     R1,R0
   \   0000000E   0xD101             BNE      ??get_ip_address_0
    231                  return NULL;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE055             B        ??get_ip_address_1
    232              }
    233          
    234              if (!_ip_address[0]) {
   \                     ??get_ip_address_0: (+1)
   \   00000014   0x7829             LDRB     R1,[R5, #+0]
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD151             BNE      ??get_ip_address_2
    235                  if (_addr.version == NSAPI_IPv4) {
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD10B             BNE      ??get_ip_address_3
    236                      ipv4_to_address(_ip_address, _addr.bytes);
   \   0000001E   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000020   0x9001             STR      R0,[SP, #+4]
   \   00000022   0x7A60             LDRB     R0,[R4, #+9]
   \   00000024   0x9000             STR      R0,[SP, #+0]
   \   00000026   0x7A23             LDRB     R3,[R4, #+8]
   \   00000028   0x79E2             LDRB     R2,[R4, #+7]
   \   0000002A   0xBF00             Nop      
   \   0000002C   0x....             ADR.N    R1,?_2
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0x.... 0x....      BL       sprintf
    237                  } else if (_addr.version == NSAPI_IPv6) {
   \   00000034   0xE043             B        ??get_ip_address_2
   \                     ??get_ip_address_3: (+1)
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xD141             BNE      ??get_ip_address_2
    238                      ipv6_to_address(_ip_address, _addr.bytes);
   \   0000003A   0x263A             MOVS     R6,#+58
   \   0000003C   0x....             ADR.N    R7,?_3
   \   0000003E   0x7A23             LDRB     R3,[R4, #+8]
   \   00000040   0x79E2             LDRB     R2,[R4, #+7]
   \   00000042   0x0039             MOVS     R1,R7
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0x.... 0x....      BL       sprintf
   \   0000004A   0x712E             STRB     R6,[R5, #+4]
   \   0000004C   0x7AA3             LDRB     R3,[R4, #+10]
   \   0000004E   0x7A62             LDRB     R2,[R4, #+9]
   \   00000050   0x0039             MOVS     R1,R7
   \   00000052   0x1D68             ADDS     R0,R5,#+5
   \   00000054   0x.... 0x....      BL       sprintf
   \   00000058   0x726E             STRB     R6,[R5, #+9]
   \   0000005A   0x7B23             LDRB     R3,[R4, #+12]
   \   0000005C   0x7AE2             LDRB     R2,[R4, #+11]
   \   0000005E   0x0039             MOVS     R1,R7
   \   00000060   0x0028             MOVS     R0,R5
   \   00000062   0x300A             ADDS     R0,R0,#+10
   \   00000064   0x.... 0x....      BL       sprintf
   \   00000068   0x73AE             STRB     R6,[R5, #+14]
   \   0000006A   0x7BA3             LDRB     R3,[R4, #+14]
   \   0000006C   0x7B62             LDRB     R2,[R4, #+13]
   \   0000006E   0x0039             MOVS     R1,R7
   \   00000070   0x0028             MOVS     R0,R5
   \   00000072   0x300F             ADDS     R0,R0,#+15
   \   00000074   0x.... 0x....      BL       sprintf
   \   00000078   0x74EE             STRB     R6,[R5, #+19]
   \   0000007A   0x7C23             LDRB     R3,[R4, #+16]
   \   0000007C   0x7BE2             LDRB     R2,[R4, #+15]
   \   0000007E   0x0039             MOVS     R1,R7
   \   00000080   0x0028             MOVS     R0,R5
   \   00000082   0x3014             ADDS     R0,R0,#+20
   \   00000084   0x.... 0x....      BL       sprintf
   \   00000088   0x762E             STRB     R6,[R5, #+24]
   \   0000008A   0x7CA3             LDRB     R3,[R4, #+18]
   \   0000008C   0x7C62             LDRB     R2,[R4, #+17]
   \   0000008E   0x0039             MOVS     R1,R7
   \   00000090   0x0028             MOVS     R0,R5
   \   00000092   0x3019             ADDS     R0,R0,#+25
   \   00000094   0x.... 0x....      BL       sprintf
   \   00000098   0x776E             STRB     R6,[R5, #+29]
   \   0000009A   0x7D23             LDRB     R3,[R4, #+20]
   \   0000009C   0x7CE2             LDRB     R2,[R4, #+19]
   \   0000009E   0x0039             MOVS     R1,R7
   \   000000A0   0x0028             MOVS     R0,R5
   \   000000A2   0x301E             ADDS     R0,R0,#+30
   \   000000A4   0x.... 0x....      BL       sprintf
   \   000000A8   0x7026             STRB     R6,[R4, #+0]
   \   000000AA   0x7DA3             LDRB     R3,[R4, #+22]
   \   000000AC   0x7D62             LDRB     R2,[R4, #+21]
   \   000000AE   0x0039             MOVS     R1,R7
   \   000000B0   0x0028             MOVS     R0,R5
   \   000000B2   0x3023             ADDS     R0,R0,#+35
   \   000000B4   0x.... 0x....      BL       sprintf
   \   000000B8   0x7166             STRB     R6,[R4, #+5]
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x7160             STRB     R0,[R4, #+5]
    239                  }
    240              }
    241          
    242              return _ip_address;
   \                     ??get_ip_address_2: (+1)
   \   000000BE   0x0028             MOVS     R0,R5
   \                     ??get_ip_address_1: (+1)
   \   000000C0   0xB003             ADD      SP,SP,#+12
   \   000000C2   0xBDF0             POP      {R4-R7,PC}       ;; return
    243          }
    244          

   \                                 In section .text, align 2, keep-with-next
    245          const void *SocketAddress::get_ip_bytes() const
    246          {
    247              return _addr.bytes;
   \                     _ZNK13SocketAddress12get_ip_bytesEv: (+1)
   \   00000000   0x3029             ADDS     R0,R0,#+41
   \   00000002   0x4770             BX       LR               ;; return
    248          }
    249          

   \                                 In section .text, align 2, keep-with-next
    250          nsapi_version_t SocketAddress::get_ip_version() const
    251          {
    252              return _addr.version;
   \                     _ZNK13SocketAddress14get_ip_versionEv: (+1)
   \   00000000   0x2128             MOVS     R1,#+40
   \   00000002   0x5C40             LDRB     R0,[R0, R1]
   \   00000004   0x4770             BX       LR               ;; return
    253          }
    254          

   \                                 In section .text, align 2, keep-with-next
    255          nsapi_addr_t SocketAddress::get_addr() const
    256          {
   \                     _ZNK13SocketAddress8get_addrEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    257              return _addr;
   \   00000002   0x3128             ADDS     R1,R1,#+40
   \   00000004   0x2211             MOVS     R2,#+17
   \   00000006   0x.... 0x....      BL       __aeabi_memcpy
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    258          }
    259          

   \                                 In section .text, align 2, keep-with-next
    260          uint16_t SocketAddress::get_port() const
    261          {
    262              return _port;
   \                     _ZNK13SocketAddress8get_portEv: (+1)
   \   00000000   0x8F40             LDRH     R0,[R0, #+58]
   \   00000002   0x4770             BX       LR               ;; return
    263          }
    264          

   \                                 In section .text, align 2, keep-with-next
    265          SocketAddress::operator bool() const
    266          {
    267              if (_addr.version == NSAPI_IPv4) {
   \                     _ZNK13SocketAddresscvbEv: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0x3128             ADDS     R1,R1,#+40
   \   00000004   0x780A             LDRB     R2,[R1, #+0]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xD10C             BNE      `??operator bool_0`
    268                  for (int i = 0; i < NSAPI_IPv4_BYTES; i++) {
    269                      if (_addr.bytes[i]) {
   \   0000000A   0x7848             LDRB     R0,[R1, #+1]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD110             BNE      `??operator bool_1`
   \   00000010   0x7888             LDRB     R0,[R1, #+2]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD10D             BNE      `??operator bool_1`
   \   00000016   0x78C8             LDRB     R0,[R1, #+3]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD10A             BNE      `??operator bool_1`
   \   0000001C   0x7908             LDRB     R0,[R1, #+4]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD107             BNE      `??operator bool_1`
   \   00000022   0xE015             B        `??operator bool_2`
    270                          return true;
    271                      }
    272                  }
    273          
    274                  return false;
    275              } else if (_addr.version == NSAPI_IPv6) {
   \                     `??operator bool_0`: (+1)
   \   00000024   0x2A02             CMP      R2,#+2
   \   00000026   0xD113             BNE      `??operator bool_2`
    276                  for (int i = 0; i < NSAPI_IPv6_BYTES; i++) {
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x3029             ADDS     R0,R0,#+41
    277                      if (_addr.bytes[i]) {
   \                     `??operator bool_3`: (+1)
   \   0000002C   0x7802             LDRB     R2,[R0, #+0]
   \   0000002E   0x2A00             CMP      R2,#+0
   \   00000030   0xD001             BEQ      `??operator bool_4`
    278                          return true;
   \                     `??operator bool_1`: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x4770             BX       LR
    279                      }
   \                     `??operator bool_4`: (+1)
   \   00000036   0x7842             LDRB     R2,[R0, #+1]
   \   00000038   0x2A00             CMP      R2,#+0
   \   0000003A   0xD1FA             BNE      `??operator bool_1`
   \   0000003C   0x7882             LDRB     R2,[R0, #+2]
   \   0000003E   0x2A00             CMP      R2,#+0
   \   00000040   0xD1F7             BNE      `??operator bool_1`
   \   00000042   0x78C2             LDRB     R2,[R0, #+3]
   \   00000044   0x2A00             CMP      R2,#+0
   \   00000046   0xD1F4             BNE      `??operator bool_1`
    280                  }
   \   00000048   0x1D09             ADDS     R1,R1,#+4
   \   0000004A   0x1D00             ADDS     R0,R0,#+4
   \   0000004C   0x2910             CMP      R1,#+16
   \   0000004E   0xDBED             BLT      `??operator bool_3`
    281          
    282                  return false;
    283              } else {
    284                  return false;
   \                     `??operator bool_2`: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x4770             BX       LR               ;; return
    285              }
    286          }
    287          

   \                                 In section .text, align 2, keep-with-next
    288          bool operator==(const SocketAddress &a, const SocketAddress &b)
    289          {
   \                     _ZeqRK13SocketAddressS1_: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    290              if (!a && !b) {
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x3428             ADDS     R4,R4,#+40
   \   00000006   0x7822             LDRB     R2,[R4, #+0]
   \   00000008   0x2A01             CMP      R2,#+1
   \   0000000A   0xD111             BNE      `??operator==_0`
   \   0000000C   0x7865             LDRB     R5,[R4, #+1]
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD108             BNE      `??operator==_1`
   \   00000012   0x78A5             LDRB     R5,[R4, #+2]
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD105             BNE      `??operator==_1`
   \   00000018   0x78E5             LDRB     R5,[R4, #+3]
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD102             BNE      `??operator==_1`
   \   0000001E   0x7924             LDRB     R4,[R4, #+4]
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD01A             BEQ      `??operator==_2`
    291                  return true;
    292              } else if (a._addr.version != b._addr.version) {
   \                     `??operator==_1`: (+1)
   \   00000024   0x2428             MOVS     R4,#+40
   \   00000026   0x5D0C             LDRB     R4,[R1, R4]
   \   00000028   0x42A2             CMP      R2,R4
   \   0000002A   0xD03F             BEQ      `??operator==_3`
    293                  return false;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD70             POP      {R4-R6,PC}
    294              } else if (a._addr.version == NSAPI_IPv4) {
   \                     `??operator==_0`: (+1)
   \   00000030   0x2A02             CMP      R2,#+2
   \   00000032   0xD112             BNE      `??operator==_2`
   \   00000034   0x2400             MOVS     R4,#+0
   \   00000036   0x0005             MOVS     R5,R0
   \   00000038   0x3529             ADDS     R5,R5,#+41
   \                     `??operator==_4`: (+1)
   \   0000003A   0x782E             LDRB     R6,[R5, #+0]
   \   0000003C   0x2E00             CMP      R6,#+0
   \   0000003E   0xD1F1             BNE      `??operator==_1`
   \   00000040   0x786E             LDRB     R6,[R5, #+1]
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD1EE             BNE      `??operator==_1`
   \   00000046   0x78AE             LDRB     R6,[R5, #+2]
   \   00000048   0x2E00             CMP      R6,#+0
   \   0000004A   0xD1EB             BNE      `??operator==_1`
   \   0000004C   0x78EE             LDRB     R6,[R5, #+3]
   \   0000004E   0x2E00             CMP      R6,#+0
   \   00000050   0xD1E8             BNE      `??operator==_1`
   \   00000052   0x1D24             ADDS     R4,R4,#+4
   \   00000054   0x1D2D             ADDS     R5,R5,#+4
   \   00000056   0x2C10             CMP      R4,#+16
   \   00000058   0xDBEF             BLT      `??operator==_4`
   \                     `??operator==_2`: (+1)
   \   0000005A   0x000C             MOVS     R4,R1
   \   0000005C   0x3428             ADDS     R4,R4,#+40
   \   0000005E   0x7825             LDRB     R5,[R4, #+0]
   \   00000060   0x2D01             CMP      R5,#+1
   \   00000062   0xD10C             BNE      `??operator==_5`
   \   00000064   0x7865             LDRB     R5,[R4, #+1]
   \   00000066   0x2D00             CMP      R5,#+0
   \   00000068   0xD1DC             BNE      `??operator==_1`
   \   0000006A   0x78A5             LDRB     R5,[R4, #+2]
   \   0000006C   0x2D00             CMP      R5,#+0
   \   0000006E   0xD1D9             BNE      `??operator==_1`
   \   00000070   0x78E5             LDRB     R5,[R4, #+3]
   \   00000072   0x2D00             CMP      R5,#+0
   \   00000074   0xD1D6             BNE      `??operator==_1`
   \   00000076   0x7924             LDRB     R4,[R4, #+4]
   \   00000078   0x2C00             CMP      R4,#+0
   \   0000007A   0xD1D3             BNE      `??operator==_1`
   \   0000007C   0xE014             B        `??operator==_6`
   \                     `??operator==_5`: (+1)
   \   0000007E   0x2D02             CMP      R5,#+2
   \   00000080   0xD112             BNE      `??operator==_6`
   \   00000082   0x2400             MOVS     R4,#+0
   \   00000084   0x000D             MOVS     R5,R1
   \   00000086   0x3529             ADDS     R5,R5,#+41
   \                     `??operator==_7`: (+1)
   \   00000088   0x782E             LDRB     R6,[R5, #+0]
   \   0000008A   0x2E00             CMP      R6,#+0
   \   0000008C   0xD1CA             BNE      `??operator==_1`
   \   0000008E   0x786E             LDRB     R6,[R5, #+1]
   \   00000090   0x2E00             CMP      R6,#+0
   \   00000092   0xD1C7             BNE      `??operator==_1`
   \   00000094   0x78AE             LDRB     R6,[R5, #+2]
   \   00000096   0x2E00             CMP      R6,#+0
   \   00000098   0xD1C4             BNE      `??operator==_1`
   \   0000009A   0x78EE             LDRB     R6,[R5, #+3]
   \   0000009C   0x2E00             CMP      R6,#+0
   \   0000009E   0xD1C1             BNE      `??operator==_1`
   \   000000A0   0x1D24             ADDS     R4,R4,#+4
   \   000000A2   0x1D2D             ADDS     R5,R5,#+4
   \   000000A4   0x2C10             CMP      R4,#+16
   \   000000A6   0xDBEF             BLT      `??operator==_7`
   \                     `??operator==_6`: (+1)
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     `??operator==_3`: (+1)
   \   000000AC   0x2A01             CMP      R2,#+1
   \   000000AE   0xD108             BNE      `??operator==_8`
    295                  return memcmp(a._addr.bytes, b._addr.bytes, NSAPI_IPv4_BYTES) == 0;
   \   000000B0   0x2204             MOVS     R2,#+4
   \                     `??operator==_9`: (+1)
   \   000000B2   0x3129             ADDS     R1,R1,#+41
   \   000000B4   0x3029             ADDS     R0,R0,#+41
   \   000000B6   0x.... 0x....      BL       memcmp
   \   000000BA   0x1E40             SUBS     R0,R0,#+1
   \   000000BC   0x4180             SBCS     R0,R0,R0
   \   000000BE   0x0FC0             LSRS     R0,R0,#+31
   \   000000C0   0xBD70             POP      {R4-R6,PC}
    296              } else if (a._addr.version == NSAPI_IPv6) {
   \                     `??operator==_8`: (+1)
   \   000000C2   0x2A02             CMP      R2,#+2
   \   000000C4   0xD101             BNE      `??operator==_10`
    297                  return memcmp(a._addr.bytes, b._addr.bytes, NSAPI_IPv6_BYTES) == 0;
   \   000000C6   0x2210             MOVS     R2,#+16
   \   000000C8   0xE7F3             B.N      `??operator==_9`
    298              }
    299          
    300              MBED_UNREACHABLE;
   \                     `??operator==_10`: (+1)
   \   000000CA   0xE7FE             B        `??operator==_10`
    301          }
    302          

   \                                 In section .text, align 2, keep-with-next
    303          bool operator!=(const SocketAddress &a, const SocketAddress &b)
    304          {
   \                     _ZneRK13SocketAddressS1_: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    305              return !(a == b);
   \   00000002   0x.... 0x....      BL       _ZeqRK13SocketAddressS1_
   \   00000006   0x07C1             LSLS     R1,R0,#+31
   \   00000008   0x0FC9             LSRS     R1,R1,#+31
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x4048             EORS     R0,R0,R1
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
    306          }
    307          

   \                                 In section .text, align 2, keep-with-next
    308          void SocketAddress::_SocketAddress(NetworkStack *iface, const char *host, uint16_t port)
    309          {
   \                     _ZN13SocketAddress14_SocketAddressEP12NetworkStackPKct: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0008             MOVS     R0,R1
   \   00000008   0x0011             MOVS     R1,R2
   \   0000000A   0x001E             MOVS     R6,R3
    310              _ip_address[0] = '\0';
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0x7025             STRB     R5,[R4, #+0]
    311          
    312              // gethostbyname must check for literals, so can call it directly
    313              int err = iface->gethostbyname(host, this);
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x0022             MOVS     R2,R4
   \   00000014   0x6807             LDR      R7,[R0, #+0]
   \   00000016   0x68FF             LDR      R7,[R7, #+12]
   \   00000018   0x47B8             BLX      R7
    314              _port = port;
   \   0000001A   0x8766             STRH     R6,[R4, #+58]
    315              if (err) {
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD00A             BEQ      ??_SocketAddress_0
    316                  _addr = nsapi_addr_t();
   \   00000020   0x2111             MOVS     R1,#+17
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x.... 0x....      BL       __aeabi_memclr4
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x3028             ADDS     R0,R0,#+40
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x2211             MOVS     R2,#+17
   \   00000030   0x.... 0x....      BL       __aeabi_memcpy
    317                  _port = 0;
   \   00000034   0x8765             STRH     R5,[R4, #+58]
    318              }
    319          }
   \                     ??_SocketAddress_0: (+1)
   \   00000036   0xB005             ADD      SP,SP,#+20
   \   00000038   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x25 0x68          DC8 "%hx"
   \              0x78 0x00    

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp SocketAddress::subobject SocketAddress(char const *, std::uint16_t)
   \                     _ZN13SocketAddressC2EPKct: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x....             B.N      ?Subroutine1

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp SocketAddress::subobject SocketAddress(void const *, nsapi_version, std::uint16_t)
   \                     _ZN13SocketAddressC2EPKv13nsapi_versiont: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x001D             MOVS     R5,R3
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x7020             STRB     R0,[R4, #+0]
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       _ZN13SocketAddress12set_ip_bytesEPKv13nsapi_version
   \   00000010   0x....             B.N      ??Subroutine2_0

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp SocketAddress::subobject SocketAddress(SocketAddress const &)
   \                     _ZN13SocketAddressC2ERKS_: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x7020             STRB     R0,[R4, #+0]
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x3028             ADDS     R0,R0,#+40
   \   0000000E   0x3128             ADDS     R1,R1,#+40
   \   00000010   0x2211             MOVS     R2,#+17
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy
   \   00000016   0x8F68             LDRH     R0,[R5, #+58]
   \   00000018   0x8760             STRH     R0,[R4, #+58]
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x25 0x68          DC8      "%hx"
   \              0x78 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x25 0x68          DC8 "%hhu"
   \              0x68 0x75    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x25 0x64          DC8 "%d.%d.%d.%d"
   \              0x2E 0x25    
   \              0x64 0x2E    
   \              0x25 0x64    
   \              0x2E 0x25    
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x25 0x30          DC8 "%02x%02x"
   \              0x32 0x78    
   \              0x25 0x30    
   \              0x32 0x78    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      36   SocketAddress::SocketAddress(SocketAddress const &)
        24   -> SocketAddress::set_addr(nsapi_addr)
        36   -> __aeabi_memcpy
       0   SocketAddress::SocketAddress(char const *, std::uint16_t)
        16   -> SocketAddress::set_ip_address(char const *)
      44   SocketAddress::SocketAddress(nsapi_addr, std::uint16_t)
        32   -> SocketAddress::set_addr(nsapi_addr)
        44   -> __aeabi_memcpy4
      64   SocketAddress::SocketAddress(void const *, nsapi_version, std::uint16_t)
        64   -> __aeabi_memclr4
        64   -> __aeabi_memcpy
        64   -> __aeabi_memcpy4
      40   SocketAddress::_SocketAddress(NetworkStack *, char const *, std::uint16_t)
        40   -- Indirect call
        40   -> __aeabi_memclr4
        40   -> __aeabi_memcpy
       8   SocketAddress::get_addr() const
         8   -> __aeabi_memcpy
      32   SocketAddress::get_ip_address() const
        32   -> std::sprintf
       0   SocketAddress::get_ip_bytes() const
       0   SocketAddress::get_ip_version() const
       0   SocketAddress::get_port() const
       0   SocketAddress::operator bool() const
      16   SocketAddress::set_addr(nsapi_addr)
        16   -> __aeabi_memcpy
      48   SocketAddress::set_ip_address(char const *)
        48   -> __aeabi_memclr4
        48   -> __aeabi_memcpy
        48   -> ipv6_from_address(std::uint8_t *, char const *)
        48   -> std::sscanf
      76   SocketAddress::set_ip_bytes(void const *, nsapi_version)
        64   -> SocketAddress::set_addr(nsapi_addr)
        64   -> __aeabi_memclr4
        64   -> __aeabi_memcpy
        64   -> __aeabi_memcpy4
        76   -> __aeabi_memcpy4
       0   SocketAddress::set_port(std::uint16_t)
      16   SocketAddress::subobject SocketAddress(SocketAddress const &)
        16   -> __aeabi_memcpy
      16   SocketAddress::subobject SocketAddress(char const *, std::uint16_t)
        16   -> SocketAddress::set_ip_address(char const *)
      44   SocketAddress::subobject SocketAddress(nsapi_addr, std::uint16_t)
        32   -> SocketAddress::SocketAddress(nsapi_addr, std::uint16_t)
        44   -> __aeabi_memcpy4
      16   SocketAddress::subobject SocketAddress(void const *, nsapi_version, std::uint16_t)
        16   -> SocketAddress::set_ip_bytes(void const *, nsapi_version)
      40   ipv6_from_address(std::uint8_t *, char const *)
        40   -> __aeabi_memclr4
        40   -> __aeabi_memmove
        40   -> ipv6_scan_chunk(std::uint16_t *, char const *)
      24   ipv6_scan_chunk(std::uint16_t *, char const *)
        24   -> std::sscanf
       8   mbed::Callback<void ()>::function_call<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void const *)
         8   -- Indirect call
       0   mbed::Callback<void ()>::function_dtor<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *)
       0   mbed::Callback<void ()>::function_move<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *, void const *)
      12   mbed::callback<>(void (*)(void *), void *)
       8   operator!=(SocketAddress const &, SocketAddress const &)
         8   -> operator==(SocketAddress const &, SocketAddress const &)
      16   operator==(SocketAddress const &, SocketAddress const &)
        16   -> std::memcmp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       6  ??Subroutine2_0
      10  ?Subroutine0
      14  ?Subroutine1
       8  ?_0
       4  ?_1
      12  ?_2
      12  ?_3
      42  SocketAddress::SocketAddress(SocketAddress const &)
       2  SocketAddress::SocketAddress(char const *, std::uint16_t)
      38  SocketAddress::SocketAddress(nsapi_addr, std::uint16_t)
      80  SocketAddress::SocketAddress(void const *, nsapi_version, std::uint16_t)
      58  SocketAddress::_SocketAddress(NetworkStack *, char const *, std::uint16_t)
      12  SocketAddress::get_addr() const
     196  SocketAddress::get_ip_address() const
       4  SocketAddress::get_ip_bytes() const
       6  SocketAddress::get_ip_version() const
       4  SocketAddress::get_port() const
      84  SocketAddress::operator bool() const
      24  SocketAddress::set_addr(nsapi_addr)
     210  SocketAddress::set_ip_address(char const *)
      80  SocketAddress::set_ip_bytes(void const *, nsapi_version)
       4  SocketAddress::set_port(std::uint16_t)
      30  SocketAddress::subobject SocketAddress(SocketAddress const &)
       4  SocketAddress::subobject SocketAddress(char const *, std::uint16_t)
      34  SocketAddress::subobject SocketAddress(nsapi_addr, std::uint16_t)
      18  SocketAddress::subobject SocketAddress(void const *, nsapi_version, std::uint16_t)
     168  ipv6_from_address(std::uint8_t *, char const *)
      66  ipv6_scan_chunk(std::uint16_t *, char const *)
      12  mbed::Callback<void ()>::function_call<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void const *)
       2  mbed::Callback<void ()>::function_dtor<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *)
      10  mbed::Callback<void ()>::function_move<mbed::Callback<void ()>::function_context<void (*)(void *), void>>(void *, void const *)
      32  mbed::callback<>(void (*)(void *), void *)
      16  operator!=(SocketAddress const &, SocketAddress const &)
     204  operator==(SocketAddress const &, SocketAddress const &)
      12  ops
     292  -- Other

 
   308 bytes in section .rodata
 1 506 bytes in section .text
 
 1 450 bytes of CODE  memory (+  56 bytes shared)
     4 bytes of CONST memory (+ 304 bytes shared)

Errors: none
Warnings: 1

###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:20
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\features\filesystem\fat\ChaN\ff.cpp
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --c++ --no_rtti --no_exceptions --guard_calls
#        --no_static_destruction -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\filesystem\fat\ChaN\ff.d
#        -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\filesystem\fat\ChaN\ff.s.txt
#        -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\filesystem\fat\ChaN\ff.o
#        .\mbed-os\features\filesystem\fat\ChaN\ff.cpp
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\filesystem\fat\ChaN\ff.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\filesystem\fat\ChaN\ff.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\features\filesystem\fat\ChaN\ff.cpp
      1          /*----------------------------------------------------------------------------/
      2          /  FatFs - FAT file system module  R0.11a                (C)ChaN, 2015        /
      3          /-----------------------------------------------------------------------------/
      4          / FatFs module is a free software that opened under license policy of
      5          / following conditions.
      6          /
      7          / Copyright (C) 2015, ChaN, all right reserved.
      8          /
      9          / 1. Redistributions of source code must retain the above copyright notice,
     10          /    this condition and the following disclaimer.
     11          /
     12          / This software is provided by the copyright holder and contributors "AS IS"
     13          / and any warranties related to this software are DISCLAIMED.
     14          / The copyright owner or contributors be NOT LIABLE for any damages caused
     15          / by use of this software.
     16          /----------------------------------------------------------------------------*/
     17          
     18          
     19          #include "ff.h"			/* Declarations of FatFs API */
     20          #include "diskio.h"		/* Declarations of disk I/O functions */
     21          
     22          
     23          /*--------------------------------------------------------------------------
     24          
     25             Module Private Definitions
     26          
     27          ---------------------------------------------------------------------------*/
     28          
     29          #if _FATFS != 64180	/* Revision ID */
     30          #error Wrong include file (ff.h).
     31          #endif
     32          
     33          
     34          /* Reentrancy related */
     35          #if _FS_REENTRANT
     36          #if _USE_LFN == 1
     37          #error Static LFN work area cannot be used at thread-safe configuration
     38          #endif
     39          #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
     40          #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
     41          #else
     42          #define	ENTER_FF(fs)
     43          #define LEAVE_FF(fs, res)	return res
     44          #endif
     45          
     46          #define	ABORT(fs, res)		{ fp->err = (BYTE)(res); LEAVE_FF(fs, res); }
     47          
     48          
     49          /* Definitions of sector size */
     50          #if (_MAX_SS < _MIN_SS) || (_MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096) || (_MIN_SS != 512 && _MIN_SS != 1024 && _MIN_SS != 2048 && _MIN_SS != 4096)
     51          #error Wrong sector size configuration
     52          #endif
     53          #if _MAX_SS == _MIN_SS
     54          #define	SS(fs)	((UINT)_MAX_SS)	/* Fixed sector size */
     55          #else
     56          #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
     57          #endif
     58          
     59          
     60          /* Timestamp feature */
     61          #if _FS_NORTC == 1
     62          #if _NORTC_YEAR < 1980 || _NORTC_YEAR > 2107 || _NORTC_MON < 1 || _NORTC_MON > 12 || _NORTC_MDAY < 1 || _NORTC_MDAY > 31
     63          #error Invalid _FS_NORTC settings
     64          #endif
     65          #define GET_FATTIME()	((DWORD)(_NORTC_YEAR - 1980) << 25 | (DWORD)_NORTC_MON << 21 | (DWORD)_NORTC_MDAY << 16)
     66          #else
     67          #define GET_FATTIME()	get_fattime()
     68          #endif
     69          
     70          
     71          /* File access control feature */
     72          #if _FS_LOCK
     73          #if _FS_READONLY
     74          #error _FS_LOCK must be 0 at read-only configuration
     75          #endif
     76          typedef struct {
     77          	FATFS *fs;		/* Object ID 1, volume (NULL:blank entry) */
     78          	DWORD clu;		/* Object ID 2, directory (0:root) */
     79          	WORD idx;		/* Object ID 3, directory index */
     80          	WORD ctr;		/* Object open counter, 0:none, 0x01..0xFF:read mode open count, 0x100:write mode */
     81          } FILESEM;
     82          #endif
     83          
     84          
     85          
     86          /* DBCS code ranges and SBCS upper conversion tables */
     87          
     88          #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
     89          #define _DF1S	0x81	/* DBC 1st byte range 1 start */
     90          #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
     91          #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
     92          #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
     93          #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
     94          #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
     95          #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
     96          #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
     97          
     98          #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
     99          #define _DF1S	0x81
    100          #define _DF1E	0xFE
    101          #define _DS1S	0x40
    102          #define _DS1E	0x7E
    103          #define _DS2S	0x80
    104          #define _DS2E	0xFE
    105          
    106          #elif _CODE_PAGE == 949	/* Korean */
    107          #define _DF1S	0x81
    108          #define _DF1E	0xFE
    109          #define _DS1S	0x41
    110          #define _DS1E	0x5A
    111          #define _DS2S	0x61
    112          #define _DS2E	0x7A
    113          #define _DS3S	0x81
    114          #define _DS3E	0xFE
    115          
    116          #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
    117          #define _DF1S	0x81
    118          #define _DF1E	0xFE
    119          #define _DS1S	0x40
    120          #define _DS1E	0x7E
    121          #define _DS2S	0xA1
    122          #define _DS2E	0xFE
    123          
    124          #elif _CODE_PAGE == 437	/* U.S. */
    125          #define _DF1S	0
    126          #define _EXCVT {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
    127          				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    128          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    129          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    130          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    131          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    132          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    133          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    134          
    135          #elif _CODE_PAGE == 720	/* Arabic */
    136          #define _DF1S	0
    137          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    138          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    139          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    140          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    141          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    142          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    143          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    144          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    145          
    146          #elif _CODE_PAGE == 737	/* Greek */
    147          #define _DF1S	0
    148          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    149          				0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
    150          				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96, \
    151          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    152          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    153          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    154          				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xEF,0xF5,0xF0,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    155          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    156          
    157          #elif _CODE_PAGE == 771	/* KBL */
    158          #define _DF1S	0
    159          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    160          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    161          				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    162          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    163          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    164          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDC,0xDE,0xDE, \
    165          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    166          				0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFE,0xFF}
    167          
    168          #elif _CODE_PAGE == 775	/* Baltic */
    169          #define _DF1S	0
    170          #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F, \
    171          				0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    172          				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    173          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    174          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    175          				0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    176          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF, \
    177          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    178          
    179          #elif _CODE_PAGE == 850	/* Latin 1 */
    180          #define _DF1S	0
    181          #define _EXCVT {0x43,0x55,0x45,0x41,0x41,0x41,0x41,0x43,0x45,0x45,0x45,0x49,0x49,0x49,0x41,0x41, \
    182          				0x45,0x92,0x92,0x4F,0x4F,0x4F,0x55,0x55,0x59,0x4F,0x55,0x4F,0x9C,0x4F,0x9E,0x9F, \
    183          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    184          				0xB0,0xB1,0xB2,0xB3,0xB4,0x41,0x41,0x41,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    185          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0x41,0x41,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    186          				0xD1,0xD1,0x45,0x45,0x45,0x49,0x49,0x49,0x49,0xD9,0xDA,0xDB,0xDC,0xDD,0x49,0xDF, \
    187          				0x4F,0xE1,0x4F,0x4F,0x4F,0x4F,0xE6,0xE8,0xE8,0x55,0x55,0x55,0x59,0x59,0xEE,0xEF, \
    188          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    189          
    190          #elif _CODE_PAGE == 852	/* Latin 2 */
    191          #define _DF1S	0
    192          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F, \
    193          				0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0xAC, \
    194          				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF, \
    195          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
    196          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    197          				0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    198          				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF, \
    199          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
    200          
    201          #elif _CODE_PAGE == 855	/* Cyrillic */
    202          #define _DF1S	0
    203          #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F, \
    204          				0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
    205          				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF, \
    206          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
    207          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    208          				0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
    209          				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF, \
    210          				0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
    211          
    212          #elif _CODE_PAGE == 857	/* Turkish */
    213          #define _DF1S	0
    214          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x49,0x8E,0x8F, \
    215          				0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
    216          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    217          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    218          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    219          				0xD0,0xD1,0xD2,0xD3,0xD4,0x49,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    220          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0xED,0xEE,0xEF, \
    221          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    222          
    223          #elif _CODE_PAGE == 860	/* Portuguese */
    224          #define _DF1S	0
    225          #define _EXCVT {0x80,0x9A,0x90,0x8F,0x8E,0x91,0x86,0x80,0x89,0x89,0x92,0x8B,0x8C,0x98,0x8E,0x8F, \
    226          				0x90,0x91,0x92,0x8C,0x99,0xA9,0x96,0x9D,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    227          				0x86,0x8B,0x9F,0x96,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    228          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    229          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    230          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    231          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    232          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    233          
    234          #elif _CODE_PAGE == 861	/* Icelandic */
    235          #define _DF1S	0
    236          #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x8B,0x8B,0x8D,0x8E,0x8F, \
    237          				0x90,0x92,0x92,0x4F,0x99,0x8D,0x55,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    238          				0xA4,0xA5,0xA6,0xA7,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    239          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    240          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    241          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    242          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    243          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    244          
    245          #elif _CODE_PAGE == 862	/* Hebrew */
    246          #define _DF1S	0
    247          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    248          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    249          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    250          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    251          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    252          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    253          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    254          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    255          
    256          #elif _CODE_PAGE == 863	/* Canadian-French */
    257          #define _DF1S	0
    258          #define _EXCVT {0x43,0x55,0x45,0x41,0x41,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x41,0x8F, \
    259          				0x45,0x45,0x45,0x4F,0x45,0x49,0x55,0x55,0x98,0x4F,0x55,0x9B,0x9C,0x55,0x55,0x9F, \
    260          				0xA0,0xA1,0x4F,0x55,0xA4,0xA5,0xA6,0xA7,0x49,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    261          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    262          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    263          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    264          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    265          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    266          
    267          #elif _CODE_PAGE == 864	/* Arabic */
    268          #define _DF1S	0
    269          #define _EXCVT {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
    270          				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    271          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    272          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    273          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    274          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    275          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    276          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    277          
    278          #elif _CODE_PAGE == 865	/* Nordic */
    279          #define _DF1S	0
    280          #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
    281          				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    282          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    283          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    284          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    285          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    286          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    287          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    288          
    289          #elif _CODE_PAGE == 866	/* Russian */
    290          #define _DF1S	0
    291          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    292          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    293          				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    294          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    295          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    296          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    297          				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    298          				0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    299          
    300          #elif _CODE_PAGE == 869	/* Greek 2 */
    301          #define _DF1S	0
    302          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    303          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x86,0x9C,0x8D,0x8F,0x90, \
    304          				0x91,0x90,0x92,0x95,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    305          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    306          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    307          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xA4,0xA5,0xA6,0xD9,0xDA,0xDB,0xDC,0xA7,0xA8,0xDF, \
    308          				0xA9,0xAA,0xAC,0xAD,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xCF,0xCF,0xD0,0xEF, \
    309          				0xF0,0xF1,0xD1,0xD2,0xD3,0xF5,0xD4,0xF7,0xF8,0xF9,0xD5,0x96,0x95,0x98,0xFE,0xFF}
    310          
    311          #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
    312          #if _USE_LFN
    313          #error Cannot use LFN feature without valid code page.
    314          #endif
    315          #define _DF1S	0
    316          
    317          #else
    318          #error Unknown code page
    319          
    320          #endif
    321          
    322          
    323          /* Character code support macros */
    324          #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
    325          #define IsLower(c)	(((c)>='a')&&((c)<='z'))
    326          #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
    327          
    328          #if _DF1S		/* Code page is DBCS */
    329          
    330          #ifdef _DF2S	/* Two 1st byte areas */
    331          #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
    332          #else			/* One 1st byte area */
    333          #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
    334          #endif
    335          
    336          #ifdef _DS3S	/* Three 2nd byte areas */
    337          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
    338          #else			/* Two 2nd byte areas */
    339          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
    340          #endif
    341          
    342          #else			/* Code page is SBCS */
    343          
    344          #define IsDBCS1(c)	0
    345          #define IsDBCS2(c)	0
    346          
    347          #endif /* _DF1S */
    348          
    349          
    350          /* Name status flags */
    351          #define NSFLAG		11		/* Index of name status byte in fn[] */
    352          #define NS_LOSS		0x01	/* Out of 8.3 format */
    353          #define NS_LFN		0x02	/* Force to create LFN entry */
    354          #define NS_LAST		0x04	/* Last segment */
    355          #define NS_BODY		0x08	/* Lower case flag (body) */
    356          #define NS_EXT		0x10	/* Lower case flag (ext) */
    357          #define NS_DOT		0x20	/* Dot entry */
    358          
    359          
    360          /* FAT sub-type boundaries (Differ from specs but correct for real DOS/Windows) */
    361          #define MIN_FAT16	4086U	/* Minimum number of clusters of FAT16 */
    362          #define	MIN_FAT32	65526U	/* Minimum number of clusters of FAT32 */
    363          
    364          
    365          /* FatFs refers the members in the FAT structures as byte array instead of
    366          / structure members because the structure is not binary compatible between
    367          / different platforms */
    368          
    369          #define BS_jmpBoot			0		/* x86 jump instruction (3) */
    370          #define BS_OEMName			3		/* OEM name (8) */
    371          #define BPB_BytsPerSec		11		/* Sector size [byte] (2) */
    372          #define BPB_SecPerClus		13		/* Cluster size [sector] (1) */
    373          #define BPB_RsvdSecCnt		14		/* Size of reserved area [sector] (2) */
    374          #define BPB_NumFATs			16		/* Number of FAT copies (1) */
    375          #define BPB_RootEntCnt		17		/* Number of root directory entries for FAT12/16 (2) */
    376          #define BPB_TotSec16		19		/* Volume size [sector] (2) */
    377          #define BPB_Media			21		/* Media descriptor (1) */
    378          #define BPB_FATSz16			22		/* FAT size [sector] (2) */
    379          #define BPB_SecPerTrk		24		/* Track size [sector] (2) */
    380          #define BPB_NumHeads		26		/* Number of heads (2) */
    381          #define BPB_HiddSec			28		/* Number of special hidden sectors (4) */
    382          #define BPB_TotSec32		32		/* Volume size [sector] (4) */
    383          #define BS_DrvNum			36		/* Physical drive number (1) */
    384          #define BS_NTres			37		/* Error flag (1) */
    385          #define BS_BootSig			38		/* Extended boot signature (1) */
    386          #define BS_VolID			39		/* Volume serial number (4) */
    387          #define BS_VolLab			43		/* Volume label (8) */
    388          #define BS_FilSysType		54		/* File system type (1) */
    389          #define BPB_FATSz32			36		/* FAT size [sector] (4) */
    390          #define BPB_ExtFlags		40		/* Extended flags (2) */
    391          #define BPB_FSVer			42		/* File system version (2) */
    392          #define BPB_RootClus		44		/* Root directory first cluster (4) */
    393          #define BPB_FSInfo			48		/* Offset of FSINFO sector (2) */
    394          #define BPB_BkBootSec		50		/* Offset of backup boot sector (2) */
    395          #define BS_DrvNum32			64		/* Physical drive number (1) */
    396          #define BS_NTres32			65		/* Error flag (1) */
    397          #define BS_BootSig32		66		/* Extended boot signature (1) */
    398          #define BS_VolID32			67		/* Volume serial number (4) */
    399          #define BS_VolLab32			71		/* Volume label (8) */
    400          #define BS_FilSysType32		82		/* File system type (1) */
    401          #define	FSI_LeadSig			0		/* FSI: Leading signature (4) */
    402          #define	FSI_StrucSig		484		/* FSI: Structure signature (4) */
    403          #define	FSI_Free_Count		488		/* FSI: Number of free clusters (4) */
    404          #define	FSI_Nxt_Free		492		/* FSI: Last allocated cluster (4) */
    405          #define MBR_Table			446		/* MBR: Partition table offset (2) */
    406          #define	SZ_PTE				16		/* MBR: Size of a partition table entry */
    407          #define BS_55AA				510		/* Signature word (2) */
    408          
    409          #define	DIR_Name			0		/* Short file name (11) */
    410          #define	DIR_Attr			11		/* Attribute (1) */
    411          #define	DIR_NTres			12		/* Lower case flag (1) */
    412          #define DIR_CrtTimeTenth	13		/* Created time sub-second (1) */
    413          #define	DIR_CrtTime			14		/* Created time (2) */
    414          #define	DIR_CrtDate			16		/* Created date (2) */
    415          #define DIR_LstAccDate		18		/* Last accessed date (2) */
    416          #define	DIR_FstClusHI		20		/* Higher 16-bit of first cluster (2) */
    417          #define	DIR_WrtTime			22		/* Modified time (2) */
    418          #define	DIR_WrtDate			24		/* Modified date (2) */
    419          #define	DIR_FstClusLO		26		/* Lower 16-bit of first cluster (2) */
    420          #define	DIR_FileSize		28		/* File size (4) */
    421          #define	LDIR_Ord			0		/* LFN entry order and LLE flag (1) */
    422          #define	LDIR_Attr			11		/* LFN attribute (1) */
    423          #define	LDIR_Type			12		/* LFN type (1) */
    424          #define	LDIR_Chksum			13		/* Checksum of corresponding SFN entry */
    425          #define	LDIR_FstClusLO		26		/* Must be zero (0) */
    426          #define	SZ_DIRE				32		/* Size of a directory entry */
    427          #define	LLEF				0x40	/* Last long entry flag in LDIR_Ord */
    428          #define	DDEM				0xE5	/* Deleted directory entry mark at DIR_Name[0] */
    429          #define	RDDEM				0x05	/* Replacement of the character collides with DDEM */
    430          
    431          
    432          
    433          
    434          /*--------------------------------------------------------------------------
    435          
    436             Module Private Work Area
    437          
    438          ---------------------------------------------------------------------------*/
    439          
    440          /* Remark: Uninitialized variables with static duration are guaranteed
    441          /  zero/null at start-up. If not, either the linker or start-up routine
    442          /  being used is not compliance with ANSI-C standard.
    443          */
    444          
    445          #if _VOLUMES < 1 || _VOLUMES > 9
    446          #error Wrong _VOLUMES setting
    447          #endif

   \                                 In section .bss, align 4
    448          static FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
    449          static WORD Fsid;				/* File system mount ID */
    450          
    451          #if _FS_RPATH && _VOLUMES >= 2
    452          static BYTE CurrVol;			/* Current drive */
   \                     CurrVol:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 2
   \   00000004                      DS8 16
   \   00000014                      DS8 512
    453          #endif
    454          
    455          #if _FS_LOCK
    456          static FILESEM Files[_FS_LOCK];	/* Open object lock semaphores */
    457          #endif
    458          
    459          #if _USE_LFN == 0			/* Non LFN feature */
    460          #define	DEFINE_NAMEBUF		BYTE sfn[12]
    461          #define INIT_BUF(dobj)		(dobj).fn = sfn
    462          #define	FREE_BUF()
    463          #else
    464          #if _MAX_LFN < 12 || _MAX_LFN > 255
    465          #error Wrong _MAX_LFN setting
    466          #endif
    467          #if _USE_LFN == 1			/* LFN feature with static working buffer */
    468          static WCHAR LfnBuf[_MAX_LFN + 1];
    469          #define	DEFINE_NAMEBUF		BYTE sfn[12]
    470          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
    471          #define	FREE_BUF()
    472          #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
    473          #define	DEFINE_NAMEBUF		BYTE sfn[12]; WCHAR lbuf[_MAX_LFN + 1]
    474          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
    475          #define	FREE_BUF()
    476          #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
    477          #define	DEFINE_NAMEBUF		BYTE sfn[12]; WCHAR *lfn
    478          #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); (dobj).lfn = lfn; (dobj).fn = sfn; }
    479          #define	FREE_BUF()			ff_memfree(lfn)
    480          #else
    481          #error Wrong _USE_LFN setting
    482          #endif
    483          #endif
    484          
    485          #ifdef _EXCVT

   \                                 In section .text, align 4, keep-with-next
    486          static const BYTE ExCvt[] = _EXCVT;	/* Upper conversion table for SBCS extended characters */
   \                     ExCvt:
   \   00000000   0x43 0x55          DC8 67, 85, 69, 65, 65, 65, 65, 67, 69, 69, 69, 73, 73, 73, 65, 65, 69
   \              0x45 0x41    
   \              0x41 0x41    
   \              0x41 0x43    
   \              0x45 0x45    
   \              0x45 0x49    
   \              0x49 0x49    
   \              0x41 0x41    
   \              0x45         
   \   00000011   0x92 0x92          DC8 146, 146, 79, 79, 79, 85, 85, 89, 79, 85, 79, 156, 79, 158, 159, 65
   \              0x4F 0x4F    
   \              0x4F 0x55    
   \              0x55 0x59    
   \              0x4F 0x55    
   \              0x4F 0x9C    
   \              0x4F 0x9E    
   \              0x9F 0x41    
   \   00000021   0x49 0x4F          DC8 73, 79, 85, 165, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174
   \              0x55 0xA5    
   \              0xA5 0xA6    
   \              0xA7 0xA8    
   \              0xA9 0xAA    
   \              0xAB 0xAC    
   \              0xAD 0xAE    
   \   0000002F   0xAF 0xB0          DC8 175, 176, 177, 178, 179, 180, 65, 65, 65, 184, 185, 186, 187, 188
   \              0xB1 0xB2    
   \              0xB3 0xB4    
   \              0x41 0x41    
   \              0x41 0xB8    
   \              0xB9 0xBA    
   \              0xBB 0xBC    
   \   0000003D   0xBD 0xBE          DC8 189, 190, 191, 192, 193, 194, 195, 196, 197, 65, 65, 200, 201, 202
   \              0xBF 0xC0    
   \              0xC1 0xC2    
   \              0xC3 0xC4    
   \              0xC5 0x41    
   \              0x41 0xC8    
   \              0xC9 0xCA    
   \   0000004B   0xCB 0xCC          DC8 203, 204, 205, 206, 207, 209, 209, 69, 69, 69, 73, 73, 73, 73, 217
   \              0xCD 0xCE    
   \              0xCF 0xD1    
   \              0xD1 0x45    
   \              0x45 0x45    
   \              0x49 0x49    
   \              0x49 0x49    
   \              0xD9         
   \   0000005A   0xDA 0xDB          DC8 218, 219, 220, 221, 73, 223, 79, 225, 79, 79, 79, 79, 230, 232, 232
   \              0xDC 0xDD    
   \              0x49 0xDF    
   \              0x4F 0xE1    
   \              0x4F 0x4F    
   \              0x4F 0x4F    
   \              0xE6 0xE8    
   \              0xE8         
   \   00000069   0x55 0x55          DC8 85, 85, 85, 89, 89, 238, 239, 240, 241, 242, 243, 244, 245, 246
   \              0x55 0x59    
   \              0x59 0xEE    
   \              0xEF 0xF0    
   \              0xF1 0xF2    
   \              0xF3 0xF4    
   \              0xF5 0xF6    
   \   00000077   0xF7 0xF8          DC8 247, 248, 249, 250, 251, 252, 253, 254, 255
   \              0xF9 0xFA    
   \              0xFB 0xFC    
   \              0xFD 0xFE    
   \              0xFF         
    487          #endif
    488          
    489          
    490          
    491          
    492          
    493          
    494          /*--------------------------------------------------------------------------
    495          
    496             Module Private Functions
    497          
    498          ---------------------------------------------------------------------------*/
    499          
    500          
    501          /*-----------------------------------------------------------------------*/
    502          /* String functions                                                      */
    503          /*-----------------------------------------------------------------------*/
    504          
    505          /* Copy memory to memory */
    506          static
    507          void mem_cpy (void* dst, const void* src, UINT cnt) {
    508          	BYTE *d = (BYTE*)dst;
    509          	const BYTE *s = (const BYTE*)src;
    510          
    511          #if _WORD_ACCESS == 1
    512          	while (cnt >= sizeof (int)) {
    513          		*(int*)d = *(int*)s;
    514          		d += sizeof (int); s += sizeof (int);
    515          		cnt -= sizeof (int);
    516          	}
    517          #endif
    518          	while (cnt--)
    519          		*d++ = *s++;
    520          }
    521          
    522          /* Fill memory */
    523          static
    524          void mem_set (void* dst, int val, UINT cnt) {
    525          	BYTE *d = (BYTE*)dst;
    526          
    527          	while (cnt--)
    528          		*d++ = (BYTE)val;
    529          }
    530          
    531          /* Compare memory to memory */
    532          static
    533          int mem_cmp (const void* dst, const void* src, UINT cnt) {
    534          	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    535          	int r = 0;
    536          
    537          	while (cnt-- && (r = *d++ - *s++) == 0) ;
    538          	return r;
    539          }
    540          
    541          /* Check if chr is contained in the string */
    542          static
    543          int chk_chr (const char* str, int chr) {
    544          	while (*str && *str != chr) str++;
    545          	return *str;
    546          }
    547          
    548          
    549          
    550          
    551          /*-----------------------------------------------------------------------*/
    552          /* Request/Release grant to access the volume                            */
    553          /*-----------------------------------------------------------------------*/
    554          #if _FS_REENTRANT
    555          static
    556          int lock_fs (
    557          	FATFS* fs		/* File system object */
    558          )
    559          {
    560          	return ff_req_grant(fs->sobj);
    561          }
    562          
    563          
    564          static
    565          void unlock_fs (
    566          	FATFS* fs,		/* File system object */
    567          	FRESULT res		/* Result code to be returned */
    568          )
    569          {
    570          	if (fs &&
    571          		res != FR_NOT_ENABLED &&
    572          		res != FR_INVALID_DRIVE &&
    573          		res != FR_INVALID_OBJECT &&
    574          		res != FR_TIMEOUT) {
    575          		ff_rel_grant(fs->sobj);
    576          	}
    577          }
    578          #endif
    579          
    580          
    581          
    582          
    583          /*-----------------------------------------------------------------------*/
    584          /* File lock control functions                                           */
    585          /*-----------------------------------------------------------------------*/
    586          #if _FS_LOCK
    587          
    588          static
    589          FRESULT chk_lock (	/* Check if the file can be accessed */
    590          	FATFS_DIR* dp,		/* Directory object pointing the file to be checked */
    591          	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
    592          )
    593          {
    594          	UINT i, be;
    595          
    596          	/* Search file semaphore table */
    597          	for (i = be = 0; i < _FS_LOCK; i++) {
    598          		if (Files[i].fs) {	/* Existing entry */
    599          			if (Files[i].fs == dp->fs &&	 	/* Check if the object matched with an open object */
    600          				Files[i].clu == dp->sclust &&
    601          				Files[i].idx == dp->index) break;
    602          		} else {			/* Blank entry */
    603          			be = 1;
    604          		}
    605          	}
    606          	if (i == _FS_LOCK)	/* The object is not opened */
    607          		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
    608          
    609          	/* The object has been opened. Reject any open against writing file and all write mode open */
    610          	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
    611          }
    612          
    613          
    614          static
    615          int enq_lock (void)	/* Check if an entry is available for a new object */
    616          {
    617          	UINT i;
    618          
    619          	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
    620          	return (i == _FS_LOCK) ? 0 : 1;
    621          }
    622          
    623          
    624          static
    625          UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
    626          	FATFS_DIR* dp,	/* Directory object pointing the file to register or increment */
    627          	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
    628          )
    629          {
    630          	UINT i;
    631          
    632          
    633          	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
    634          		if (Files[i].fs == dp->fs &&
    635          			Files[i].clu == dp->sclust &&
    636          			Files[i].idx == dp->index) break;
    637          	}
    638          
    639          	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
    640          		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
    641          		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
    642          		Files[i].fs = dp->fs;
    643          		Files[i].clu = dp->sclust;
    644          		Files[i].idx = dp->index;
    645          		Files[i].ctr = 0;
    646          	}
    647          
    648          	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
    649          
    650          	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
    651          
    652          	return i + 1;
    653          }
    654          
    655          
    656          static
    657          FRESULT dec_lock (	/* Decrement object open counter */
    658          	UINT i			/* Semaphore index (1..) */
    659          )
    660          {
    661          	WORD n;
    662          	FRESULT res;
    663          
    664          
    665          	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
    666          		n = Files[i].ctr;
    667          		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
    668          		if (n) n--;					/* Decrement read mode open count */
    669          		Files[i].ctr = n;
    670          		if (!n) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
    671          		res = FR_OK;
    672          	} else {
    673          		res = FR_INT_ERR;			/* Invalid index nunber */
    674          	}
    675          	return res;
    676          }
    677          
    678          
    679          static
    680          void clear_lock (	/* Clear lock entries of the volume */
    681          	FATFS *fs
    682          )
    683          {
    684          	UINT i;
    685          
    686          	for (i = 0; i < _FS_LOCK; i++) {
    687          		if (Files[i].fs == fs) Files[i].fs = 0;
    688          	}
    689          }
    690          #endif
    691          
    692          
    693          
    694          
    695          /*-----------------------------------------------------------------------*/
    696          /* Move/Flush disk access window in the file system object               */
    697          /*-----------------------------------------------------------------------*/
    698          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    699          static
    700          FRESULT sync_window (	/* FR_OK:succeeded, !=0:error */
    701          	FATFS* fs		/* File system object */
    702          )
    703          {
   \                     _Z11sync_windowP5FATFS: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
    704          	DWORD wsect;
    705          	UINT nf;
    706          	FRESULT res = FR_OK;
   \   00000004   0x2600             MOVS     R6,#+0
   \   00000006   0x2700             MOVS     R7,#+0
    707          
    708          
    709          	if (fs->wflag) {	/* Write back the sector if it is dirty */
   \   00000008   0x7928             LDRB     R0,[R5, #+4]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD01E             BEQ      ??sync_window_0
    710          		wsect = fs->winsect;	/* Current sector number */
   \   0000000E   0x6B2C             LDR      R4,[R5, #+48]
    711          		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x0022             MOVS     R2,R4
   \   00000014   0x6B69             LDR      R1,[R5, #+52]
   \   00000016   0x7868             LDRB     R0,[R5, #+1]
   \   00000018   0x.... 0x....      BL       disk_write
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ      ??sync_window_1
    712          			res = FR_DISK_ERR;
   \   00000020   0x2701             MOVS     R7,#+1
   \   00000022   0xE013             B        ??sync_window_0
    713          		} else {
    714          			fs->wflag = 0;
   \                     ??sync_window_1: (+1)
   \   00000024   0x712E             STRB     R6,[R5, #+4]
    715          			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
   \   00000026   0x6A68             LDR      R0,[R5, #+36]
   \   00000028   0x1A20             SUBS     R0,R4,R0
   \   0000002A   0x69E9             LDR      R1,[R5, #+28]
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD20D             BCS      ??sync_window_0
    716          				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
   \   00000030   0x78EE             LDRB     R6,[R5, #+3]
   \   00000032   0x2E02             CMP      R6,#+2
   \   00000034   0xD30A             BCC      ??sync_window_0
   \   00000036   0x1E76             SUBS     R6,R6,#+1
    717          					wsect += fs->fsize;
   \                     ??sync_window_2: (+1)
   \   00000038   0x69E8             LDR      R0,[R5, #+28]
   \   0000003A   0x1824             ADDS     R4,R4,R0
    718          					disk_write(fs->drv, fs->win, wsect, 1);
   \   0000003C   0x2301             MOVS     R3,#+1
   \   0000003E   0x0022             MOVS     R2,R4
   \   00000040   0x6B69             LDR      R1,[R5, #+52]
   \   00000042   0x7868             LDRB     R0,[R5, #+1]
   \   00000044   0x.... 0x....      BL       disk_write
    719          				}
   \   00000048   0x1E76             SUBS     R6,R6,#+1
   \   0000004A   0xD1F5             BNE      ??sync_window_2
    720          			}
    721          		}
    722          	}
    723          	return res;
   \                     ??sync_window_0: (+1)
   \   0000004C   0x0038             MOVS     R0,R7
   \   0000004E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    724          }
    725          #endif
    726          
    727          

   \                                 In section .text, align 2, keep-with-next
    728          static
    729          FRESULT move_window (	/* FR_OK(0):succeeded, !=0:error */
    730          	FATFS* fs,		/* File system object */
    731          	DWORD sector	/* Sector number to make appearance in the fs->win[] */
    732          )
    733          {
   \                     _Z11move_windowP5FATFSm: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
    734          	FRESULT res = FR_OK;
   \   00000006   0x2500             MOVS     R5,#+0
    735          
    736          
    737          	if (sector != fs->winsect) {	/* Window offset changed? */
   \   00000008   0x6B30             LDR      R0,[R6, #+48]
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD010             BEQ      ??move_window_0
    738          #if !_FS_READONLY
    739          		res = sync_window(fs);		/* Write-back changes */
   \   0000000E   0x0030             MOVS     R0,R6
   \   00000010   0x.... 0x....      BL       _Z11sync_windowP5FATFS
   \   00000014   0x0005             MOVS     R5,R0
    740          #endif
    741          		if (res == FR_OK) {			/* Fill sector window with new data */
   \   00000016   0xD10B             BNE      ??move_window_0
    742          			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
   \   00000018   0x2301             MOVS     R3,#+1
   \   0000001A   0x0022             MOVS     R2,R4
   \   0000001C   0x6B71             LDR      R1,[R6, #+52]
   \   0000001E   0x7870             LDRB     R0,[R6, #+1]
   \   00000020   0x.... 0x....      BL       disk_read
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD002             BEQ      ??move_window_1
    743          				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
   \   00000028   0x2400             MOVS     R4,#+0
   \   0000002A   0x43E4             MVNS     R4,R4            ;; #-1
    744          				res = FR_DISK_ERR;
   \   0000002C   0x2501             MOVS     R5,#+1
    745          			}
    746          			fs->winsect = sector;
   \                     ??move_window_1: (+1)
   \   0000002E   0x6334             STR      R4,[R6, #+48]
    747          		}
    748          	}
    749          	return res;
   \                     ??move_window_0: (+1)
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    750          }
    751          
    752          
    753          
    754          
    755          /*-----------------------------------------------------------------------*/
    756          /* Synchronize file system and strage device                             */
    757          /*-----------------------------------------------------------------------*/
    758          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    759          static
    760          FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
    761          	FATFS* fs		/* File system object */
    762          )
    763          {
   \                     _Z7sync_fsP5FATFS: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    764          	FRESULT res;
    765          
    766          
    767          	res = sync_window(fs);
   \   00000004   0x.... 0x....      BL       _Z11sync_windowP5FATFS
   \   00000008   0x0005             MOVS     R5,R0
    768          	if (res == FR_OK) {
   \   0000000A   0xD167             BNE      ??sync_fs_0
    769          		/* Update FSInfo sector if needed */
    770          		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xD15C             BNE      ??sync_fs_1
   \   00000012   0x7960             LDRB     R0,[R4, #+5]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD159             BNE      ??sync_fs_1
    771          			/* Create FSInfo structure */
    772          			mem_set(fs->win, 0, SS(fs));
   \   00000018   0x8961             LDRH     R1,[R4, #+10]
   \   0000001A   0x0008             MOVS     R0,R1
   \   0000001C   0xD002             BEQ      ??sync_fs_2
   \   0000001E   0x6B60             LDR      R0,[R4, #+52]
   \   00000020   0x.... 0x....      BL       __aeabi_memclr
    773          			ST_WORD(fs->win + BS_55AA, 0xAA55);
   \                     ??sync_fs_2: (+1)
   \   00000024   0x2055             MOVS     R0,#+85
   \   00000026   0x6B61             LDR      R1,[R4, #+52]
   \   00000028   0x22FF             MOVS     R2,#+255
   \   0000002A   0x0052             LSLS     R2,R2,#+1        ;; #+510
   \   0000002C   0x5488             STRB     R0,[R1, R2]
   \   0000002E   0x20AA             MOVS     R0,#+170
   \   00000030   0x6B61             LDR      R1,[R4, #+52]
   \   00000032   0x1C52             ADDS     R2,R2,#+1
   \   00000034   0x5488             STRB     R0,[R1, R2]
    774          			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
   \   00000036   0x2052             MOVS     R0,#+82
   \   00000038   0x6B61             LDR      R1,[R4, #+52]
   \   0000003A   0x7008             STRB     R0,[R1, #+0]
   \   0000003C   0x6B61             LDR      R1,[R4, #+52]
   \   0000003E   0x7048             STRB     R0,[R1, #+1]
   \   00000040   0x2061             MOVS     R0,#+97
   \   00000042   0x6B61             LDR      R1,[R4, #+52]
   \   00000044   0x7088             STRB     R0,[R1, #+2]
   \   00000046   0x2141             MOVS     R1,#+65
   \   00000048   0x6B62             LDR      R2,[R4, #+52]
   \   0000004A   0x70D1             STRB     R1,[R2, #+3]
    775          			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
   \   0000004C   0x2272             MOVS     R2,#+114
   \   0000004E   0x6B63             LDR      R3,[R4, #+52]
   \   00000050   0x26F2             MOVS     R6,#+242
   \   00000052   0x0076             LSLS     R6,R6,#+1        ;; #+484
   \   00000054   0x559A             STRB     R2,[R3, R6]
   \   00000056   0x6B63             LDR      R3,[R4, #+52]
   \   00000058   0x1C76             ADDS     R6,R6,#+1
   \   0000005A   0x559A             STRB     R2,[R3, R6]
   \   0000005C   0x6B62             LDR      R2,[R4, #+52]
   \   0000005E   0x1C73             ADDS     R3,R6,#+1
   \   00000060   0x54D1             STRB     R1,[R2, R3]
   \   00000062   0x6B61             LDR      R1,[R4, #+52]
   \   00000064   0x1C5A             ADDS     R2,R3,#+1
   \   00000066   0x5488             STRB     R0,[R1, R2]
    776          			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
   \   00000068   0x6920             LDR      R0,[R4, #+16]
   \   0000006A   0x6B61             LDR      R1,[R4, #+52]
   \   0000006C   0x1C52             ADDS     R2,R2,#+1
   \   0000006E   0x5488             STRB     R0,[R1, R2]
   \   00000070   0x6920             LDR      R0,[R4, #+16]
   \   00000072   0x0400             LSLS     R0,R0,#+16
   \   00000074   0x0E00             LSRS     R0,R0,#+24
   \   00000076   0x6B61             LDR      R1,[R4, #+52]
   \   00000078   0x1C52             ADDS     R2,R2,#+1
   \   0000007A   0x5488             STRB     R0,[R1, R2]
   \   0000007C   0x6920             LDR      R0,[R4, #+16]
   \   0000007E   0x0C00             LSRS     R0,R0,#+16
   \   00000080   0x6B61             LDR      R1,[R4, #+52]
   \   00000082   0x1C52             ADDS     R2,R2,#+1
   \   00000084   0x5488             STRB     R0,[R1, R2]
   \   00000086   0x6920             LDR      R0,[R4, #+16]
   \   00000088   0x0E00             LSRS     R0,R0,#+24
   \   0000008A   0x6B61             LDR      R1,[R4, #+52]
   \   0000008C   0x1C52             ADDS     R2,R2,#+1
   \   0000008E   0x5488             STRB     R0,[R1, R2]
    777          			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
   \   00000090   0x68E0             LDR      R0,[R4, #+12]
   \   00000092   0x6B61             LDR      R1,[R4, #+52]
   \   00000094   0x1C52             ADDS     R2,R2,#+1
   \   00000096   0x5488             STRB     R0,[R1, R2]
   \   00000098   0x68E0             LDR      R0,[R4, #+12]
   \   0000009A   0x0400             LSLS     R0,R0,#+16
   \   0000009C   0x0E00             LSRS     R0,R0,#+24
   \   0000009E   0x6B61             LDR      R1,[R4, #+52]
   \   000000A0   0x1C52             ADDS     R2,R2,#+1
   \   000000A2   0x5488             STRB     R0,[R1, R2]
   \   000000A4   0x68E0             LDR      R0,[R4, #+12]
   \   000000A6   0x0C00             LSRS     R0,R0,#+16
   \   000000A8   0x6B61             LDR      R1,[R4, #+52]
   \   000000AA   0x1C52             ADDS     R2,R2,#+1
   \   000000AC   0x5488             STRB     R0,[R1, R2]
   \   000000AE   0x68E0             LDR      R0,[R4, #+12]
   \   000000B0   0x0E00             LSRS     R0,R0,#+24
   \   000000B2   0x6B61             LDR      R1,[R4, #+52]
   \   000000B4   0x1C52             ADDS     R2,R2,#+1
   \   000000B6   0x5488             STRB     R0,[R1, R2]
    778          			/* Write it into the FSInfo sector */
    779          			fs->winsect = fs->volbase + 1;
   \   000000B8   0x6A22             LDR      R2,[R4, #+32]
   \   000000BA   0x1C52             ADDS     R2,R2,#+1
   \   000000BC   0x6322             STR      R2,[R4, #+48]
    780          			disk_write(fs->drv, fs->win, fs->winsect, 1);
   \   000000BE   0x2301             MOVS     R3,#+1
   \   000000C0   0x6B61             LDR      R1,[R4, #+52]
   \   000000C2   0x7860             LDRB     R0,[R4, #+1]
   \   000000C4   0x.... 0x....      BL       disk_write
    781          			fs->fsi_flag = 0;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x7160             STRB     R0,[R4, #+5]
    782          		}
    783          		/* Make sure that no pending write process in the physical drive */
    784          		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
   \                     ??sync_fs_1: (+1)
   \   000000CC   0x2200             MOVS     R2,#+0
   \   000000CE   0x2100             MOVS     R1,#+0
   \   000000D0   0x7860             LDRB     R0,[R4, #+1]
   \   000000D2   0x.... 0x....      BL       disk_ioctl
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD000             BEQ      ??sync_fs_0
    785          			res = FR_DISK_ERR;
   \   000000DA   0x2501             MOVS     R5,#+1
    786          	}
    787          
    788          	return res;
   \                     ??sync_fs_0: (+1)
   \   000000DC   0x0028             MOVS     R0,R5
   \   000000DE   0xBD70             POP      {R4-R6,PC}       ;; return
    789          }
    790          #endif
    791          
    792          
    793          
    794          
    795          /*-----------------------------------------------------------------------*/
    796          /* Get sector# from cluster#                                             */
    797          /*-----------------------------------------------------------------------*/
    798          /* Hidden API for hacks and disk tools */
    799          

   \                                 In section .text, align 2, keep-with-next
    800          DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
    801          	FATFS* fs,		/* File system object */
    802          	DWORD clst		/* Cluster# to be converted */
    803          )
    804          {
    805          	clst -= 2;
   \                     _Z10clust2sectP5FATFSm: (+1)
   \   00000000   0x1E89             SUBS     R1,R1,#+2
    806          	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
   \   00000002   0x6982             LDR      R2,[R0, #+24]
   \   00000004   0x1E92             SUBS     R2,R2,#+2
   \   00000006   0x4291             CMP      R1,R2
   \   00000008   0xD301             BCC      ??clust2sect_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR
    807          	return clst * fs->csize + fs->database;
   \                     ??clust2sect_0: (+1)
   \   0000000E   0x7882             LDRB     R2,[R0, #+2]
   \   00000010   0x4351             MULS     R1,R2,R1
   \   00000012   0x6AC0             LDR      R0,[R0, #+44]
   \   00000014   0x1808             ADDS     R0,R1,R0
   \   00000016   0x4770             BX       LR               ;; return
    808          }
    809          
    810          
    811          
    812          
    813          /*-----------------------------------------------------------------------*/
    814          /* FAT access - Read value of a FAT entry                                */
    815          /*-----------------------------------------------------------------------*/
    816          /* Hidden API for hacks and disk tools */
    817          

   \                                 In section .text, align 2, keep-with-next
    818          DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
    819          	FATFS* fs,	/* File system object */
    820          	DWORD clst	/* FAT index number (cluster number) to get the value */
    821          )
    822          {
   \                     _Z7get_fatP5FATFSm: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    823          	UINT wc, bc;
    824          	BYTE *p;
    825          	DWORD val;
    826          
    827          
    828          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
   \   00000008   0x2D02             CMP      R5,#+2
   \   0000000A   0xD377             BCC      ??get_fat_0
   \   0000000C   0x69A0             LDR      R0,[R4, #+24]
   \   0000000E   0x4285             CMP      R5,R0
   \   00000010   0xD274             BCS      ??get_fat_0
    829          		val = 1;	/* Internal error */
    830          
    831          	} else {
    832          		val = 0xFFFFFFFF;	/* Default value falls on disk error */
   \   00000012   0x2600             MOVS     R6,#+0
   \   00000014   0x43F6             MVNS     R6,R6            ;; #-1
    833          
    834          		switch (fs->fs_type) {
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD004             BEQ      ??get_fat_1
   \   0000001C   0xD36E             BCC      ??get_fat_0
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xD04D             BEQ      ??get_fat_2
   \   00000022   0xD335             BCC      ??get_fat_3
   \   00000024   0xE06A             B        ??get_fat_0
    835          		case FS_FAT12 :
    836          			bc = (UINT)clst; bc += bc / 2;
   \                     ??get_fat_1: (+1)
   \   00000026   0x0868             LSRS     R0,R5,#+1
   \   00000028   0x1828             ADDS     R0,R5,R0
   \   0000002A   0x9001             STR      R0,[SP, #+4]
    837          			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
   \   0000002C   0x6A67             LDR      R7,[R4, #+36]
   \   0000002E   0x8961             LDRH     R1,[R4, #+10]
   \   00000030   0x.... 0x....      BL       __aeabi_uidiv
   \   00000034   0x1839             ADDS     R1,R7,R0
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD15E             BNE      ??get_fat_4
    838          			wc = fs->win[bc++ % SS(fs)];
   \   00000040   0x8960             LDRH     R0,[R4, #+10]
   \   00000042   0x9002             STR      R0,[SP, #+8]
   \   00000044   0x6B67             LDR      R7,[R4, #+52]
   \   00000046   0x9801             LDR      R0,[SP, #+4]
   \   00000048   0x9902             LDR      R1,[SP, #+8]
   \   0000004A   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000004E   0x5C7F             LDRB     R7,[R7, R1]
   \   00000050   0x9801             LDR      R0,[SP, #+4]
   \   00000052   0x1C40             ADDS     R0,R0,#+1
   \   00000054   0x9001             STR      R0,[SP, #+4]
    839          			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
   \   00000056   0x6A61             LDR      R1,[R4, #+36]
   \   00000058   0x9100             STR      R1,[SP, #+0]
   \   0000005A   0x9801             LDR      R0,[SP, #+4]
   \   0000005C   0x9902             LDR      R1,[SP, #+8]
   \   0000005E   0x.... 0x....      BL       __aeabi_uidiv
   \   00000062   0x9900             LDR      R1,[SP, #+0]
   \   00000064   0x1809             ADDS     R1,R1,R0
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD146             BNE      ??get_fat_4
    840          			wc |= fs->win[bc % SS(fs)] << 8;
   \   00000070   0x6B66             LDR      R6,[R4, #+52]
   \   00000072   0x9801             LDR      R0,[SP, #+4]
   \   00000074   0x8961             LDRH     R1,[R4, #+10]
   \   00000076   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000007A   0x5C70             LDRB     R0,[R6, R1]
   \   0000007C   0x0200             LSLS     R0,R0,#+8
   \   0000007E   0x4338             ORRS     R0,R0,R7
   \   00000080   0x0007             MOVS     R7,R0
    841          			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
   \   00000082   0x07E8             LSLS     R0,R5,#+31
   \   00000084   0xD501             BPL      ??get_fat_5
   \   00000086   0x093E             LSRS     R6,R7,#+4
   \   00000088   0xE039             B        ??get_fat_4
   \                     ??get_fat_5: (+1)
   \   0000008A   0x053E             LSLS     R6,R7,#+20
   \   0000008C   0x0D36             LSRS     R6,R6,#+20
   \   0000008E   0xE036             B        ??get_fat_4
    842          			break;
    843          
    844          		case FS_FAT16 :
    845          			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
   \                     ??get_fat_3: (+1)
   \   00000090   0x6A67             LDR      R7,[R4, #+36]
   \   00000092   0x0028             MOVS     R0,R5
   \   00000094   0x8961             LDRH     R1,[R4, #+10]
   \   00000096   0x0849             LSRS     R1,R1,#+1
   \   00000098   0x.... 0x....      BL       __aeabi_uidiv
   \   0000009C   0x1839             ADDS     R1,R7,R0
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD12A             BNE      ??get_fat_4
    846          			p = &fs->win[clst * 2 % SS(fs)];
   \   000000A8   0x6B66             LDR      R6,[R4, #+52]
   \   000000AA   0x0068             LSLS     R0,R5,#+1
   \   000000AC   0x8961             LDRH     R1,[R4, #+10]
   \   000000AE   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000B2   0x1870             ADDS     R0,R6,R1
    847          			val = LD_WORD(p);
   \   000000B4   0x7841             LDRB     R1,[R0, #+1]
   \   000000B6   0x020E             LSLS     R6,R1,#+8
   \   000000B8   0x7800             LDRB     R0,[R0, #+0]
   \   000000BA   0x4306             ORRS     R6,R6,R0
    848          			break;
   \   000000BC   0xE01F             B        ??get_fat_4
    849          
    850          		case FS_FAT32 :
    851          			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
   \                     ??get_fat_2: (+1)
   \   000000BE   0x6A67             LDR      R7,[R4, #+36]
   \   000000C0   0x0028             MOVS     R0,R5
   \   000000C2   0x8961             LDRH     R1,[R4, #+10]
   \   000000C4   0x0889             LSRS     R1,R1,#+2
   \   000000C6   0x.... 0x....      BL       __aeabi_uidiv
   \   000000CA   0x1839             ADDS     R1,R7,R0
   \   000000CC   0x0020             MOVS     R0,R4
   \   000000CE   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD113             BNE      ??get_fat_4
    852          			p = &fs->win[clst * 4 % SS(fs)];
   \   000000D6   0x6B66             LDR      R6,[R4, #+52]
   \   000000D8   0x00A8             LSLS     R0,R5,#+2
   \   000000DA   0x8961             LDRH     R1,[R4, #+10]
   \   000000DC   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000E0   0x1870             ADDS     R0,R6,R1
    853          			val = LD_DWORD(p) & 0x0FFFFFFF;
   \   000000E2   0x78C1             LDRB     R1,[R0, #+3]
   \   000000E4   0x0609             LSLS     R1,R1,#+24
   \   000000E6   0x7882             LDRB     R2,[R0, #+2]
   \   000000E8   0x0412             LSLS     R2,R2,#+16
   \   000000EA   0x430A             ORRS     R2,R2,R1
   \   000000EC   0x7841             LDRB     R1,[R0, #+1]
   \   000000EE   0x0209             LSLS     R1,R1,#+8
   \   000000F0   0x4311             ORRS     R1,R1,R2
   \   000000F2   0x7800             LDRB     R0,[R0, #+0]
   \   000000F4   0x4308             ORRS     R0,R0,R1
   \   000000F6   0x0106             LSLS     R6,R0,#+4
   \   000000F8   0x0936             LSRS     R6,R6,#+4
    854          			break;
   \   000000FA   0xE000             B        ??get_fat_4
    855          
    856          		default:
    857          			val = 1;	/* Internal error */
   \                     ??get_fat_0: (+1)
   \   000000FC   0x2601             MOVS     R6,#+1
    858          		}
    859          	}
    860          
    861          	return val;
   \                     ??get_fat_4: (+1)
   \   000000FE   0x0030             MOVS     R0,R6
   \   00000100   0xB003             ADD      SP,SP,#+12
   \   00000102   0xBDF0             POP      {R4-R7,PC}       ;; return
    862          }
    863          
    864          
    865          
    866          
    867          /*-----------------------------------------------------------------------*/
    868          /* FAT access - Change value of a FAT entry                              */
    869          /*-----------------------------------------------------------------------*/
    870          /* Hidden API for hacks and disk tools */
    871          
    872          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    873          FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
    874          	FATFS* fs,		/* File system object */
    875          	DWORD clst,		/* FAT index number (cluster number) to be changed */
    876          	DWORD val		/* New value to be set to the entry */
    877          )
    878          {
   \                     _Z7put_fatP5FATFSmm: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0014             MOVS     R4,R2
    879          	UINT bc;
    880          	BYTE *p;
    881          	FRESULT res;
    882          
    883          
    884          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
   \   0000000A   0x2E02             CMP      R6,#+2
   \   0000000C   0xD200             BCS      .+4
   \   0000000E   0xE08C             B        ??put_fat_0
   \   00000010   0x69A8             LDR      R0,[R5, #+24]
   \   00000012   0x4286             CMP      R6,R0
   \   00000014   0xD300             BCC      .+4
   \   00000016   0xE088             B        ??put_fat_0
    885          		res = FR_INT_ERR;
    886          
    887          	} else {
    888          		switch (fs->fs_type) {
   \   00000018   0x7828             LDRB     R0,[R5, #+0]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD005             BEQ      ??put_fat_1
   \   0000001E   0xD200             BCS      .+4
   \   00000020   0xE083             B        ??put_fat_0
   \   00000022   0x2803             CMP      R0,#+3
   \   00000024   0xD05C             BEQ      ??put_fat_2
   \   00000026   0xD342             BCC      ??put_fat_3
   \   00000028   0xE07F             B        ??put_fat_0
    889          		case FS_FAT12 :
    890          			bc = (UINT)clst; bc += bc / 2;
   \                     ??put_fat_1: (+1)
   \   0000002A   0x0870             LSRS     R0,R6,#+1
   \   0000002C   0x1830             ADDS     R0,R6,R0
   \   0000002E   0x9001             STR      R0,[SP, #+4]
    891          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   00000030   0x6A6F             LDR      R7,[R5, #+36]
   \   00000032   0x8969             LDRH     R1,[R5, #+10]
   \   00000034   0x.... 0x....      BL       __aeabi_uidiv
   \   00000038   0x1839             ADDS     R1,R7,R0
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   00000040   0x0007             MOVS     R7,R0
    892          			if (res != FR_OK) break;
   \   00000042   0xD173             BNE      ??put_fat_4
    893          			p = &fs->win[bc++ % SS(fs)];
   \   00000044   0x6B6F             LDR      R7,[R5, #+52]
   \   00000046   0x9801             LDR      R0,[SP, #+4]
   \   00000048   0x8969             LDRH     R1,[R5, #+10]
   \   0000004A   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000004E   0x1879             ADDS     R1,R7,R1
   \   00000050   0x9801             LDR      R0,[SP, #+4]
   \   00000052   0x1C40             ADDS     R0,R0,#+1
   \   00000054   0x9001             STR      R0,[SP, #+4]
   \   00000056   0x07F6             LSLS     R6,R6,#+31
   \   00000058   0x0FF6             LSRS     R6,R6,#+31
   \   0000005A   0xD005             BEQ      ??put_fat_5
   \   0000005C   0x7808             LDRB     R0,[R1, #+0]
   \   0000005E   0x0702             LSLS     R2,R0,#+28
   \   00000060   0x0F12             LSRS     R2,R2,#+28
   \   00000062   0x0120             LSLS     R0,R4,#+4
   \   00000064   0x4310             ORRS     R0,R0,R2
   \   00000066   0xE000             B        ??put_fat_6
   \                     ??put_fat_5: (+1)
   \   00000068   0x0020             MOVS     R0,R4
   \                     ??put_fat_6: (+1)
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
    894          			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    895          			fs->wflag = 1;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x7128             STRB     R0,[R5, #+4]
    896          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   00000070   0x6A6F             LDR      R7,[R5, #+36]
   \   00000072   0x9801             LDR      R0,[SP, #+4]
   \   00000074   0x8969             LDRH     R1,[R5, #+10]
   \   00000076   0x.... 0x....      BL       __aeabi_uidiv
   \   0000007A   0x1839             ADDS     R1,R7,R0
   \   0000007C   0x0028             MOVS     R0,R5
   \   0000007E   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   00000082   0x0007             MOVS     R7,R0
    897          			if (res != FR_OK) break;
   \   00000084   0xD152             BNE      ??put_fat_4
    898          			p = &fs->win[bc % SS(fs)];
   \   00000086   0x6B68             LDR      R0,[R5, #+52]
   \   00000088   0x9000             STR      R0,[SP, #+0]
   \   0000008A   0x9801             LDR      R0,[SP, #+4]
   \   0000008C   0x8969             LDRH     R1,[R5, #+10]
   \   0000008E   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000092   0x9800             LDR      R0,[SP, #+0]
   \   00000094   0x1841             ADDS     R1,R0,R1
    899          			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   \   00000096   0x2E00             CMP      R6,#+0
   \   00000098   0xD001             BEQ      ??put_fat_7
   \   0000009A   0x0920             LSRS     R0,R4,#+4
   \   0000009C   0xE005             B        ??put_fat_8
   \                     ??put_fat_7: (+1)
   \   0000009E   0x7808             LDRB     R0,[R1, #+0]
   \   000000A0   0x22F0             MOVS     R2,#+240
   \   000000A2   0x4002             ANDS     R2,R2,R0
   \   000000A4   0x0520             LSLS     R0,R4,#+20
   \   000000A6   0x0F00             LSRS     R0,R0,#+28
   \   000000A8   0x4310             ORRS     R0,R0,R2
   \                     ??put_fat_8: (+1)
   \   000000AA   0x7008             STRB     R0,[R1, #+0]
    900          			fs->wflag = 1;
   \   000000AC   0xE03A             B.N      ??put_fat_9
    901          			break;
    902          
    903          		case FS_FAT16 :
    904          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   \                     ??put_fat_3: (+1)
   \   000000AE   0x6A6F             LDR      R7,[R5, #+36]
   \   000000B0   0x0030             MOVS     R0,R6
   \   000000B2   0x8969             LDRH     R1,[R5, #+10]
   \   000000B4   0x0849             LSRS     R1,R1,#+1
   \   000000B6   0x.... 0x....      BL       __aeabi_uidiv
   \   000000BA   0x1839             ADDS     R1,R7,R0
   \   000000BC   0x0028             MOVS     R0,R5
   \   000000BE   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   000000C2   0x0007             MOVS     R7,R0
    905          			if (res != FR_OK) break;
   \   000000C4   0xD132             BNE      ??put_fat_4
    906          			p = &fs->win[clst * 2 % SS(fs)];
   \   000000C6   0x6B68             LDR      R0,[R5, #+52]
   \   000000C8   0x9000             STR      R0,[SP, #+0]
   \   000000CA   0x0070             LSLS     R0,R6,#+1
   \   000000CC   0x8969             LDRH     R1,[R5, #+10]
   \   000000CE   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000D2   0x9800             LDR      R0,[SP, #+0]
   \   000000D4   0x1841             ADDS     R1,R0,R1
    907          			ST_WORD(p, (WORD)val);
   \   000000D6   0x700C             STRB     R4,[R1, #+0]
   \   000000D8   0x0420             LSLS     R0,R4,#+16
   \   000000DA   0x0E00             LSRS     R0,R0,#+24
   \   000000DC   0x7048             STRB     R0,[R1, #+1]
    908          			fs->wflag = 1;
   \   000000DE   0xE021             B.N      ??put_fat_9
    909          			break;
    910          
    911          		case FS_FAT32 :
    912          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   \                     ??put_fat_2: (+1)
   \   000000E0   0x6A6F             LDR      R7,[R5, #+36]
   \   000000E2   0x0030             MOVS     R0,R6
   \   000000E4   0x8969             LDRH     R1,[R5, #+10]
   \   000000E6   0x0889             LSRS     R1,R1,#+2
   \   000000E8   0x.... 0x....      BL       __aeabi_uidiv
   \   000000EC   0x1839             ADDS     R1,R7,R0
   \   000000EE   0x0028             MOVS     R0,R5
   \   000000F0   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   000000F4   0x0007             MOVS     R7,R0
    913          			if (res != FR_OK) break;
   \   000000F6   0xD119             BNE      ??put_fat_4
    914          			p = &fs->win[clst * 4 % SS(fs)];
   \   000000F8   0x6B68             LDR      R0,[R5, #+52]
   \   000000FA   0x9000             STR      R0,[SP, #+0]
   \   000000FC   0x00B0             LSLS     R0,R6,#+2
   \   000000FE   0x8969             LDRH     R1,[R5, #+10]
   \   00000100   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000104   0x9800             LDR      R0,[SP, #+0]
   \   00000106   0x1841             ADDS     R1,R0,R1
    915          			val |= LD_DWORD(p) & 0xF0000000;
   \   00000108   0x78C8             LDRB     R0,[R1, #+3]
   \   0000010A   0x0600             LSLS     R0,R0,#+24
   \   0000010C   0x0F00             LSRS     R0,R0,#+28
   \   0000010E   0x0700             LSLS     R0,R0,#+28
   \   00000110   0x4320             ORRS     R0,R0,R4
   \   00000112   0x0004             MOVS     R4,R0
    916          			ST_DWORD(p, val);
   \   00000114   0x7008             STRB     R0,[R1, #+0]
   \   00000116   0x0400             LSLS     R0,R0,#+16
   \   00000118   0x0E00             LSRS     R0,R0,#+24
   \   0000011A   0x7048             STRB     R0,[R1, #+1]
   \   0000011C   0x0C20             LSRS     R0,R4,#+16
   \   0000011E   0x7088             STRB     R0,[R1, #+2]
   \   00000120   0x0E20             LSRS     R0,R4,#+24
   \   00000122   0x70C8             STRB     R0,[R1, #+3]
    917          			fs->wflag = 1;
   \                     ??put_fat_9: (+1)
   \   00000124   0x2001             MOVS     R0,#+1
   \   00000126   0x7128             STRB     R0,[R5, #+4]
    918          			break;
   \   00000128   0xE000             B        ??put_fat_4
    919          
    920          		default :
    921          			res = FR_INT_ERR;
   \                     ??put_fat_0: (+1)
   \   0000012A   0x2702             MOVS     R7,#+2
    922          		}
    923          	}
    924          
    925          	return res;
   \                     ??put_fat_4: (+1)
   \   0000012C   0x0038             MOVS     R0,R7
   \   0000012E   0xB003             ADD      SP,SP,#+12
   \   00000130   0xBDF0             POP      {R4-R7,PC}       ;; return
    926          }
    927          #endif /* !_FS_READONLY */
    928          
    929          
    930          
    931          
    932          /*-----------------------------------------------------------------------*/
    933          /* FAT handling - Remove a cluster chain                                 */
    934          /*-----------------------------------------------------------------------*/
    935          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    936          static
    937          FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
    938          	FATFS* fs,			/* File system object */
    939          	DWORD clst			/* Cluster# to remove a chain from */
    940          )
    941          {
   \                     _Z12remove_chainP5FATFSm: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    942          	FRESULT res;
    943          	DWORD nxt;
    944          #if _USE_TRIM
    945          	DWORD scl = clst, ecl = clst, rt[2];
   \   00000008   0x9504             STR      R5,[SP, #+16]
   \   0000000A   0x9503             STR      R5,[SP, #+12]
    946          #endif
    947          
    948          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
   \   0000000C   0x2D02             CMP      R5,#+2
   \   0000000E   0xD30D             BCC      ??remove_chain_0
   \   00000010   0x69A0             LDR      R0,[R4, #+24]
   \   00000012   0x4285             CMP      R5,R0
   \   00000014   0xD20A             BCS      ??remove_chain_0
   \   00000016   0x2600             MOVS     R6,#+0
    949          		res = FR_INT_ERR;
    950          
    951          	} else {
    952          		res = FR_OK;
    953          		while (clst < fs->n_fatent) {			/* Not a last link? */
    954          			nxt = get_fat(fs, clst);			/* Get cluster status */
   \                     ??remove_chain_1: (+1)
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   \   00000020   0x9001             STR      R0,[SP, #+4]
    955          			if (nxt == 0) break;				/* Empty cluster? */
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD100             BNE      .+4
   \   00000026   0xE0C7             B        ??remove_chain_2
    956          			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD101             BNE      ??remove_chain_3
   \                     ??remove_chain_0: (+1)
   \   0000002C   0x2602             MOVS     R6,#+2
   \   0000002E   0xE0C3             B        ??remove_chain_2
    957          			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
   \                     ??remove_chain_3: (+1)
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD101             BNE      ??remove_chain_4
   \   00000038   0x2601             MOVS     R6,#+1
   \   0000003A   0xE0BD             B        ??remove_chain_2
    958          			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
   \                     ??remove_chain_4: (+1)
   \   0000003C   0x2D02             CMP      R5,#+2
   \   0000003E   0xD37C             BCC      ??remove_chain_5
   \   00000040   0x69A0             LDR      R0,[R4, #+24]
   \   00000042   0x4285             CMP      R5,R0
   \   00000044   0xD279             BCS      ??remove_chain_5
   \   00000046   0x7820             LDRB     R0,[R4, #+0]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD039             BEQ      ??remove_chain_6
   \   0000004C   0xD375             BCC      ??remove_chain_5
   \   0000004E   0x2803             CMP      R0,#+3
   \   00000050   0xD001             BEQ      ??remove_chain_7
   \   00000052   0xD31D             BCC      ??remove_chain_8
   \   00000054   0xE071             B        ??remove_chain_5
   \                     ??remove_chain_7: (+1)
   \   00000056   0x6A66             LDR      R6,[R4, #+36]
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0x8961             LDRH     R1,[R4, #+10]
   \   0000005C   0x0889             LSRS     R1,R1,#+2
   \   0000005E   0x.... 0x....      BL       __aeabi_uidiv
   \   00000062   0x1831             ADDS     R1,R6,R0
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   0000006A   0x0007             MOVS     R7,R0
   \   0000006C   0xD166             BNE      ??remove_chain_9
   \   0000006E   0x6B66             LDR      R6,[R4, #+52]
   \   00000070   0x00A8             LSLS     R0,R5,#+2
   \   00000072   0x8961             LDRH     R1,[R4, #+10]
   \   00000074   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000078   0x1870             ADDS     R0,R6,R1
   \   0000007A   0x78C1             LDRB     R1,[R0, #+3]
   \   0000007C   0x0609             LSLS     R1,R1,#+24
   \   0000007E   0x0F09             LSRS     R1,R1,#+28
   \   00000080   0x0709             LSLS     R1,R1,#+28
   \   00000082   0x2200             MOVS     R2,#+0
   \   00000084   0x7002             STRB     R2,[R0, #+0]
   \   00000086   0x7042             STRB     R2,[R0, #+1]
   \   00000088   0x7082             STRB     R2,[R0, #+2]
   \   0000008A   0x0E09             LSRS     R1,R1,#+24
   \   0000008C   0x70C1             STRB     R1,[R0, #+3]
   \   0000008E   0xE014             B.N      ??remove_chain_10
   \                     ??remove_chain_8: (+1)
   \   00000090   0x6A66             LDR      R6,[R4, #+36]
   \   00000092   0x0028             MOVS     R0,R5
   \   00000094   0x8961             LDRH     R1,[R4, #+10]
   \   00000096   0x0849             LSRS     R1,R1,#+1
   \   00000098   0x.... 0x....      BL       __aeabi_uidiv
   \   0000009C   0x1831             ADDS     R1,R6,R0
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   000000A4   0x0007             MOVS     R7,R0
   \   000000A6   0xD149             BNE      ??remove_chain_9
   \   000000A8   0x6B66             LDR      R6,[R4, #+52]
   \   000000AA   0x0068             LSLS     R0,R5,#+1
   \   000000AC   0x8961             LDRH     R1,[R4, #+10]
   \   000000AE   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000B2   0x1870             ADDS     R0,R6,R1
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0x7001             STRB     R1,[R0, #+0]
   \   000000B8   0x7041             STRB     R1,[R0, #+1]
   \                     ??remove_chain_10: (+1)
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0x7120             STRB     R0,[R4, #+4]
   \   000000BE   0xE03D             B        ??remove_chain_9
   \                     ??remove_chain_6: (+1)
   \   000000C0   0x0868             LSRS     R0,R5,#+1
   \   000000C2   0x1828             ADDS     R0,R5,R0
   \   000000C4   0x9002             STR      R0,[SP, #+8]
   \   000000C6   0x6A66             LDR      R6,[R4, #+36]
   \   000000C8   0x8961             LDRH     R1,[R4, #+10]
   \   000000CA   0x.... 0x....      BL       __aeabi_uidiv
   \   000000CE   0x1831             ADDS     R1,R6,R0
   \   000000D0   0x0020             MOVS     R0,R4
   \   000000D2   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   000000D6   0x0007             MOVS     R7,R0
   \   000000D8   0xD130             BNE      ??remove_chain_9
   \   000000DA   0x6B66             LDR      R6,[R4, #+52]
   \   000000DC   0x9802             LDR      R0,[SP, #+8]
   \   000000DE   0x8961             LDRH     R1,[R4, #+10]
   \   000000E0   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000E4   0x1870             ADDS     R0,R6,R1
   \   000000E6   0x9902             LDR      R1,[SP, #+8]
   \   000000E8   0x1C49             ADDS     R1,R1,#+1
   \   000000EA   0x9102             STR      R1,[SP, #+8]
   \   000000EC   0x2601             MOVS     R6,#+1
   \   000000EE   0x4035             ANDS     R5,R5,R6
   \   000000F0   0xD003             BEQ      ??remove_chain_11
   \   000000F2   0x7801             LDRB     R1,[R0, #+0]
   \   000000F4   0x0709             LSLS     R1,R1,#+28
   \   000000F6   0x0F09             LSRS     R1,R1,#+28
   \   000000F8   0xE000             B        ??remove_chain_12
   \                     ??remove_chain_11: (+1)
   \   000000FA   0x2100             MOVS     R1,#+0
   \                     ??remove_chain_12: (+1)
   \   000000FC   0x7001             STRB     R1,[R0, #+0]
   \   000000FE   0x7126             STRB     R6,[R4, #+4]
   \   00000100   0x6A67             LDR      R7,[R4, #+36]
   \   00000102   0x9802             LDR      R0,[SP, #+8]
   \   00000104   0x8961             LDRH     R1,[R4, #+10]
   \   00000106   0x.... 0x....      BL       __aeabi_uidiv
   \   0000010A   0x1839             ADDS     R1,R7,R0
   \   0000010C   0x0020             MOVS     R0,R4
   \   0000010E   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   00000112   0x0007             MOVS     R7,R0
   \   00000114   0xD112             BNE      ??remove_chain_9
   \   00000116   0x6B60             LDR      R0,[R4, #+52]
   \   00000118   0x9000             STR      R0,[SP, #+0]
   \   0000011A   0x9802             LDR      R0,[SP, #+8]
   \   0000011C   0x8961             LDRH     R1,[R4, #+10]
   \   0000011E   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000122   0x9800             LDR      R0,[SP, #+0]
   \   00000124   0x1840             ADDS     R0,R0,R1
   \   00000126   0x2D00             CMP      R5,#+0
   \   00000128   0xD001             BEQ      ??remove_chain_13
   \   0000012A   0x2100             MOVS     R1,#+0
   \   0000012C   0xE002             B        ??remove_chain_14
   \                     ??remove_chain_13: (+1)
   \   0000012E   0x7802             LDRB     R2,[R0, #+0]
   \   00000130   0x21F0             MOVS     R1,#+240
   \   00000132   0x4011             ANDS     R1,R1,R2
   \                     ??remove_chain_14: (+1)
   \   00000134   0x7001             STRB     R1,[R0, #+0]
   \   00000136   0x7126             STRB     R6,[R4, #+4]
   \   00000138   0xE000             B        ??remove_chain_9
   \                     ??remove_chain_5: (+1)
   \   0000013A   0x2702             MOVS     R7,#+2
   \                     ??remove_chain_9: (+1)
   \   0000013C   0x003E             MOVS     R6,R7
    959          			if (res != FR_OK) break;
   \   0000013E   0xD13B             BNE      ??remove_chain_2
    960          			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
   \   00000140   0x6920             LDR      R0,[R4, #+16]
   \   00000142   0x2100             MOVS     R1,#+0
   \   00000144   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000146   0x4288             CMP      R0,R1
   \   00000148   0xD005             BEQ      ??remove_chain_15
    961          				fs->free_clust++;
   \   0000014A   0x1C40             ADDS     R0,R0,#+1
   \   0000014C   0x6120             STR      R0,[R4, #+16]
    962          				fs->fsi_flag |= 1;
   \   0000014E   0x7960             LDRB     R0,[R4, #+5]
   \   00000150   0x2101             MOVS     R1,#+1
   \   00000152   0x4301             ORRS     R1,R1,R0
   \   00000154   0x7161             STRB     R1,[R4, #+5]
    963          			}
    964          #if _USE_TRIM
    965          			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
   \                     ??remove_chain_15: (+1)
   \   00000156   0x9803             LDR      R0,[SP, #+12]
   \   00000158   0x1C40             ADDS     R0,R0,#+1
   \   0000015A   0x9901             LDR      R1,[SP, #+4]
   \   0000015C   0x4288             CMP      R0,R1
   \   0000015E   0xD101             BNE      ??remove_chain_16
    966          				ecl = nxt;
   \   00000160   0x9103             STR      R1,[SP, #+12]
   \   00000162   0xE024             B        ??remove_chain_17
    967          			} else {				/* End of contiguous clusters */ 
    968          				rt[0] = clust2sect(fs, scl);					/* Start sector */
   \                     ??remove_chain_16: (+1)
   \   00000164   0x9804             LDR      R0,[SP, #+16]
   \   00000166   0x1E80             SUBS     R0,R0,#+2
   \   00000168   0x69A1             LDR      R1,[R4, #+24]
   \   0000016A   0x1E89             SUBS     R1,R1,#+2
   \   0000016C   0x4288             CMP      R0,R1
   \   0000016E   0xD301             BCC      ??remove_chain_18
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0xE003             B        ??remove_chain_19
   \                     ??remove_chain_18: (+1)
   \   00000174   0x78A1             LDRB     R1,[R4, #+2]
   \   00000176   0x4348             MULS     R0,R1,R0
   \   00000178   0x6AE1             LDR      R1,[R4, #+44]
   \   0000017A   0x1840             ADDS     R0,R0,R1
   \                     ??remove_chain_19: (+1)
   \   0000017C   0x9005             STR      R0,[SP, #+20]
    969          				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
   \   0000017E   0x9803             LDR      R0,[SP, #+12]
   \   00000180   0x1E80             SUBS     R0,R0,#+2
   \   00000182   0x69A1             LDR      R1,[R4, #+24]
   \   00000184   0x1E89             SUBS     R1,R1,#+2
   \   00000186   0x4288             CMP      R0,R1
   \   00000188   0xD301             BCC      ??remove_chain_20
   \   0000018A   0x2000             MOVS     R0,#+0
   \   0000018C   0xE003             B        ??remove_chain_21
   \                     ??remove_chain_20: (+1)
   \   0000018E   0x78A1             LDRB     R1,[R4, #+2]
   \   00000190   0x4348             MULS     R0,R1,R0
   \   00000192   0x6AE1             LDR      R1,[R4, #+44]
   \   00000194   0x1840             ADDS     R0,R0,R1
   \                     ??remove_chain_21: (+1)
   \   00000196   0x78A1             LDRB     R1,[R4, #+2]
   \   00000198   0x1840             ADDS     R0,R0,R1
   \   0000019A   0x1E40             SUBS     R0,R0,#+1
   \   0000019C   0x9006             STR      R0,[SP, #+24]
    970          				disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Erase the block */
   \   0000019E   0xAA05             ADD      R2,SP,#+20
   \   000001A0   0x2104             MOVS     R1,#+4
   \   000001A2   0x7860             LDRB     R0,[R4, #+1]
   \   000001A4   0x.... 0x....      BL       disk_ioctl
    971          				scl = ecl = nxt;
   \   000001A8   0x9801             LDR      R0,[SP, #+4]
   \   000001AA   0x9003             STR      R0,[SP, #+12]
   \   000001AC   0x9004             STR      R0,[SP, #+16]
    972          			}
    973          #endif
    974          			clst = nxt;	/* Next cluster */
   \                     ??remove_chain_17: (+1)
   \   000001AE   0x9D01             LDR      R5,[SP, #+4]
    975          		}
   \   000001B0   0x69A0             LDR      R0,[R4, #+24]
   \   000001B2   0x4285             CMP      R5,R0
   \   000001B4   0xD200             BCS      .+4
   \   000001B6   0xE72F             B        ??remove_chain_1
    976          	}
    977          
    978          	return res;
   \                     ??remove_chain_2: (+1)
   \   000001B8   0x0030             MOVS     R0,R6
   \   000001BA   0xB007             ADD      SP,SP,#+28
   \   000001BC   0xBDF0             POP      {R4-R7,PC}       ;; return
    979          }
    980          #endif
    981          
    982          
    983          
    984          
    985          /*-----------------------------------------------------------------------*/
    986          /* FAT handling - Stretch or Create a cluster chain                      */
    987          /*-----------------------------------------------------------------------*/
    988          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    989          static
    990          DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
    991          	FATFS* fs,			/* File system object */
    992          	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
    993          )
    994          {
   \                     _Z12create_chainP5FATFSm: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000F             MOVS     R7,R1
    995          	DWORD cs, ncl, scl;
    996          	FRESULT res;
    997          
    998          
    999          	if (clst == 0) {		/* Create a new chain */
   \   00000006   0xD107             BNE      ??create_chain_0
   1000          		scl = fs->last_clust;			/* Get suggested start point */
   \   00000008   0x68EE             LDR      R6,[R5, #+12]
   1001          		if (!scl || scl >= fs->n_fatent) scl = 1;
   \   0000000A   0x2E00             CMP      R6,#+0
   \   0000000C   0xD002             BEQ      ??create_chain_1
   \   0000000E   0x69A8             LDR      R0,[R5, #+24]
   \   00000010   0x4286             CMP      R6,R0
   \   00000012   0xD30F             BCC      ??create_chain_2
   \                     ??create_chain_1: (+1)
   \   00000014   0x2601             MOVS     R6,#+1
   \   00000016   0xE00D             B        ??create_chain_2
   1002          	}
   1003          	else {					/* Stretch the current chain */
   1004          		cs = get_fat(fs, clst);			/* Check the cluster status */
   \                     ??create_chain_0: (+1)
   \   00000018   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   1005          		if (cs < 2) return 1;			/* Invalid value */
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD201             BCS      ??create_chain_3
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xBDF2             POP      {R1,R4-R7,PC}
   1006          		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
   \                     ??create_chain_3: (+1)
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD03F             BEQ      ??create_chain_4
   1007          		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   \   0000002C   0x69A9             LDR      R1,[R5, #+24]
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD33C             BCC      ??create_chain_4
   1008          		scl = clst;
   \   00000032   0x003E             MOVS     R6,R7
   1009          	}
   1010          
   1011          	ncl = scl;				/* Start cluster */
   \                     ??create_chain_2: (+1)
   \   00000034   0x0034             MOVS     R4,R6
   1012          	for (;;) {
   1013          		ncl++;							/* Next cluster */
   \                     ??create_chain_5: (+1)
   \   00000036   0x1C64             ADDS     R4,R4,#+1
   1014          		if (ncl >= fs->n_fatent) {		/* Check wrap around */
   \   00000038   0x69A8             LDR      R0,[R5, #+24]
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD302             BCC      ??create_chain_6
   1015          			ncl = 2;
   \   0000003E   0x2402             MOVS     R4,#+2
   1016          			if (ncl > scl) return 0;	/* No free cluster */
   \   00000040   0x2E02             CMP      R6,#+2
   \   00000042   0xD32A             BCC      ??create_chain_7
   1017          		}
   1018          		cs = get_fat(fs, ncl);			/* Get the cluster status */
   \                     ??create_chain_6: (+1)
   \   00000044   0x0021             MOVS     R1,R4
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   1019          		if (cs == 0) break;				/* Found a free cluster */
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD11C             BNE      ??create_chain_8
   1020          		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
   1021          			return cs;
   1022          		if (ncl == scl) return 0;		/* No free cluster */
   1023          	}
   1024          
   1025          	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
   \   00000050   0x....             LDR      R2,??DataTable10  ;; 0xfffffff
   \   00000052   0x0021             MOVS     R1,R4
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       _Z7put_fatP5FATFSmm
   1026          	if (res == FR_OK && clst != 0) {
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD106             BNE      ??create_chain_9
   \   0000005E   0x2F00             CMP      R7,#+0
   \   00000060   0xD006             BEQ      ??create_chain_10
   1027          		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
   \   00000062   0x0022             MOVS     R2,R4
   \   00000064   0x0039             MOVS     R1,R7
   \   00000066   0x0028             MOVS     R0,R5
   \   00000068   0x.... 0x....      BL       _Z7put_fatP5FATFSmm
   1028          	}
   1029          	if (res == FR_OK) {
   \                     ??create_chain_9: (+1)
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD116             BNE      ??create_chain_11
   1030          		fs->last_clust = ncl;			/* Update FSINFO */
   \                     ??create_chain_10: (+1)
   \   00000070   0x60EC             STR      R4,[R5, #+12]
   1031          		if (fs->free_clust != 0xFFFFFFFF) {
   \   00000072   0x6928             LDR      R0,[R5, #+16]
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xD016             BEQ      ??create_chain_12
   1032          			fs->free_clust--;
   \   0000007C   0x1E40             SUBS     R0,R0,#+1
   \   0000007E   0x6128             STR      R0,[R5, #+16]
   1033          			fs->fsi_flag |= 1;
   \   00000080   0x7968             LDRB     R0,[R5, #+5]
   \   00000082   0x2101             MOVS     R1,#+1
   \   00000084   0x4301             ORRS     R1,R1,R0
   \   00000086   0x7169             STRB     R1,[R5, #+5]
   \   00000088   0xE00F             B        ??create_chain_12
   1034          		}
   1035          	} else {
   \                     ??create_chain_8: (+1)
   \   0000008A   0x2100             MOVS     R1,#+0
   \   0000008C   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xD00C             BEQ      ??create_chain_4
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xD00A             BEQ      ??create_chain_4
   \   00000096   0x42B4             CMP      R4,R6
   \   00000098   0xD1CD             BNE      ??create_chain_5
   \                     ??create_chain_7: (+1)
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xBDF2             POP      {R1,R4-R7,PC}
   1036          		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   \                     ??create_chain_11: (+1)
   \   0000009E   0x2801             CMP      R0,#+1
   \   000000A0   0xD102             BNE      ??create_chain_13
   \   000000A2   0x2400             MOVS     R4,#+0
   \   000000A4   0x43E4             MVNS     R4,R4            ;; #-1
   \   000000A6   0xE000             B        ??create_chain_12
   \                     ??create_chain_13: (+1)
   \   000000A8   0x2401             MOVS     R4,#+1
   1037          	}
   1038          
   1039          	return ncl;		/* Return new cluster number or error code */
   \                     ??create_chain_12: (+1)
   \   000000AA   0x0020             MOVS     R0,R4
   \                     ??create_chain_4: (+1)
   \   000000AC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1040          }
   1041          #endif /* !_FS_READONLY */
   1042          
   1043          
   1044          
   1045          
   1046          /*-----------------------------------------------------------------------*/
   1047          /* FAT handling - Convert offset into cluster with link map table        */
   1048          /*-----------------------------------------------------------------------*/
   1049          
   1050          #if _USE_FASTSEEK
   1051          static
   1052          DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
   1053          	FIL* fp,		/* Pointer to the file object */
   1054          	DWORD ofs		/* File offset to be converted to cluster# */
   1055          )
   1056          {
   1057          	DWORD cl, ncl, *tbl;
   1058          
   1059          
   1060          	tbl = fp->cltbl + 1;	/* Top of CLMT */
   1061          	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
   1062          	for (;;) {
   1063          		ncl = *tbl++;			/* Number of cluters in the fragment */
   1064          		if (!ncl) return 0;		/* End of table? (error) */
   1065          		if (cl < ncl) break;	/* In this fragment? */
   1066          		cl -= ncl; tbl++;		/* Next fragment */
   1067          	}
   1068          	return cl + *tbl;	/* Return the cluster number */
   1069          }
   1070          #endif	/* _USE_FASTSEEK */
   1071          
   1072          
   1073          
   1074          
   1075          /*-----------------------------------------------------------------------*/
   1076          /* Directory handling - Set directory index                              */
   1077          /*-----------------------------------------------------------------------*/
   1078          

   \                                 In section .text, align 2, keep-with-next
   1079          static
   1080          FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
   1081          	FATFS_DIR* dp,		/* Pointer to directory object */
   1082          	UINT idx		/* Index of directory table */
   1083          )
   1084          {
   \                     _Z7dir_sdiP9FATFS_DIRj: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   1085          	DWORD clst, sect;
   1086          	UINT ic;
   1087          
   1088          
   1089          	dp->index = (WORD)idx;	/* Current index */
   \   00000006   0x80EC             STRH     R4,[R5, #+6]
   1090          	clst = dp->sclust;		/* Table start cluster (0:root) */
   \   00000008   0x68AE             LDR      R6,[R5, #+8]
   1091          	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
   \   0000000A   0x2E01             CMP      R6,#+1
   \   0000000C   0xD031             BEQ      ??dir_sdi_0
   \   0000000E   0x6828             LDR      R0,[R5, #+0]
   \   00000010   0x6981             LDR      R1,[R0, #+24]
   \   00000012   0x428E             CMP      R6,R1
   \   00000014   0xD22D             BCS      ??dir_sdi_0
   1092          		return FR_INT_ERR;
   1093          	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD103             BNE      ??dir_sdi_1
   \   0000001A   0x7801             LDRB     R1,[R0, #+0]
   \   0000001C   0x2903             CMP      R1,#+3
   \   0000001E   0xD102             BNE      ??dir_sdi_2
   1094          		clst = dp->fs->dirbase;
   \   00000020   0x6A86             LDR      R6,[R0, #+40]
   1095          
   1096          	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
   \                     ??dir_sdi_1: (+1)
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD104             BNE      ??dir_sdi_3
   1097          		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
   \                     ??dir_sdi_2: (+1)
   \   00000026   0x8901             LDRH     R1,[R0, #+8]
   \   00000028   0x428C             CMP      R4,R1
   \   0000002A   0xD222             BCS      ??dir_sdi_0
   1098          			return FR_INT_ERR;
   1099          		sect = dp->fs->dirbase;
   \   0000002C   0x6A87             LDR      R7,[R0, #+40]
   \   0000002E   0xE01D             B        ??dir_sdi_4
   1100          	}
   1101          	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
   1102          		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
   \                     ??dir_sdi_3: (+1)
   \   00000030   0x8941             LDRH     R1,[R0, #+10]
   \   00000032   0x0949             LSRS     R1,R1,#+5
   \   00000034   0x7887             LDRB     R7,[R0, #+2]
   \   00000036   0x434F             MULS     R7,R1,R7
   \   00000038   0xE000             B        ??dir_sdi_5
   1103          		while (idx >= ic) {	/* Follow cluster chain */
   1104          			clst = get_fat(dp->fs, clst);				/* Get next cluster */
   1105          			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1106          			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
   1107          				return FR_INT_ERR;
   1108          			idx -= ic;
   \                     ??dir_sdi_6: (+1)
   \   0000003A   0x1BE4             SUBS     R4,R4,R7
   \                     ??dir_sdi_5: (+1)
   \   0000003C   0x6828             LDR      R0,[R5, #+0]
   \   0000003E   0x42BC             CMP      R4,R7
   \   00000040   0xD310             BCC      ??dir_sdi_7
   \   00000042   0x0031             MOVS     R1,R6
   \   00000044   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   \   00000048   0x0006             MOVS     R6,R0
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000004E   0x4286             CMP      R6,R0
   \   00000050   0xD101             BNE      ??dir_sdi_8
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??dir_sdi_8: (+1)
   \   00000056   0x2E02             CMP      R6,#+2
   \   00000058   0xD30B             BCC      ??dir_sdi_0
   \   0000005A   0x6828             LDR      R0,[R5, #+0]
   \   0000005C   0x6980             LDR      R0,[R0, #+24]
   \   0000005E   0x4286             CMP      R6,R0
   \   00000060   0xD3EB             BCC      ??dir_sdi_6
   \   00000062   0xE006             B.N      ??dir_sdi_0
   1109          		}
   1110          		sect = clust2sect(dp->fs, clst);
   \                     ??dir_sdi_7: (+1)
   \   00000064   0x0031             MOVS     R1,R6
   \   00000066   0x.... 0x....      BL       _Z10clust2sectP5FATFSm
   \   0000006A   0x0007             MOVS     R7,R0
   1111          	}
   1112          	dp->clust = clst;	/* Current cluster# */
   \                     ??dir_sdi_4: (+1)
   \   0000006C   0x60EE             STR      R6,[R5, #+12]
   1113          	if (!sect) return FR_INT_ERR;
   \   0000006E   0x2F00             CMP      R7,#+0
   \   00000070   0xD101             BNE      ??dir_sdi_9
   \                     ??dir_sdi_0: (+1)
   \   00000072   0x2002             MOVS     R0,#+2
   \   00000074   0xBDF2             POP      {R1,R4-R7,PC}
   1114          	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
   \                     ??dir_sdi_9: (+1)
   \   00000076   0x682E             LDR      R6,[R5, #+0]
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x8971             LDRH     R1,[R6, #+10]
   \   0000007C   0x0949             LSRS     R1,R1,#+5
   \   0000007E   0x.... 0x....      BL       __aeabi_uidiv
   \   00000082   0x1838             ADDS     R0,R7,R0
   \   00000084   0x6128             STR      R0,[R5, #+16]
   1115          	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
   \   00000086   0x6B77             LDR      R7,[R6, #+52]
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x8971             LDRH     R1,[R6, #+10]
   \   0000008C   0x0949             LSRS     R1,R1,#+5
   \   0000008E   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000092   0x0148             LSLS     R0,R1,#+5
   \   00000094   0x1838             ADDS     R0,R7,R0
   \   00000096   0x6168             STR      R0,[R5, #+20]
   1116          
   1117          	return FR_OK;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1118          }
   1119          
   1120          
   1121          
   1122          
   1123          /*-----------------------------------------------------------------------*/
   1124          /* Directory handling - Move directory table index next                  */
   1125          /*-----------------------------------------------------------------------*/
   1126          

   \                                 In section .text, align 2, keep-with-next
   1127          static
   1128          FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
   1129          	FATFS_DIR* dp,		/* Pointer to the directory object */
   1130          	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
   1131          )
   1132          {
   \                     _Z8dir_nextP9FATFS_DIRi: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1133          	DWORD clst;
   1134          	UINT i;
   1135          #if !_FS_READONLY
   1136          	UINT c;
   1137          #endif
   1138          
   1139          
   1140          	i = dp->index + 1;
   \   00000004   0x88E7             LDRH     R7,[R4, #+6]
   \   00000006   0x1C7F             ADDS     R7,R7,#+1
   1141          	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
   \   00000008   0x0438             LSLS     R0,R7,#+16
   \   0000000A   0xD02E             BEQ      ??dir_next_0
   \   0000000C   0x6926             LDR      R6,[R4, #+16]
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD02B             BEQ      ??dir_next_0
   1142          		return FR_NO_FILE;
   1143          
   1144          	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
   \   00000012   0x6825             LDR      R5,[R4, #+0]
   \   00000014   0x0038             MOVS     R0,R7
   \   00000016   0x8969             LDRH     R1,[R5, #+10]
   \   00000018   0x0949             LSRS     R1,R1,#+5
   \   0000001A   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD161             BNE      ??dir_next_1
   1145          		dp->sect++;					/* Next sector */
   \   00000022   0x1C76             ADDS     R6,R6,#+1
   \   00000024   0x6126             STR      R6,[R4, #+16]
   1146          
   1147          		if (!dp->clust) {		/* Static table */
   \   00000026   0x68E6             LDR      R6,[R4, #+12]
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD103             BNE      ??dir_next_2
   1148          			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
   \   0000002C   0x8928             LDRH     R0,[R5, #+8]
   \   0000002E   0x4287             CMP      R7,R0
   \   00000030   0xD359             BCC      ??dir_next_1
   \   00000032   0xE01A             B        ??dir_next_0
   1149          				return FR_NO_FILE;
   1150          		}
   1151          		else {					/* Dynamic table */
   1152          			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
   \                     ??dir_next_2: (+1)
   \   00000034   0x0038             MOVS     R0,R7
   \   00000036   0x8969             LDRH     R1,[R5, #+10]
   \   00000038   0x0949             LSRS     R1,R1,#+5
   \   0000003A   0x.... 0x....      BL       __aeabi_uidiv
   \   0000003E   0x78A9             LDRB     R1,[R5, #+2]
   \   00000040   0x1E49             SUBS     R1,R1,#+1
   \   00000042   0x4001             ANDS     R1,R1,R0
   \   00000044   0xD14F             BNE      ??dir_next_1
   1153          				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
   \   00000046   0x0031             MOVS     R1,R6
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   \   0000004E   0x0005             MOVS     R5,R0
   1154          				if (clst <= 1) return FR_INT_ERR;
   \   00000050   0x2D02             CMP      R5,#+2
   \   00000052   0xD315             BCC      ??dir_next_3
   1155          				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \   00000054   0x2600             MOVS     R6,#+0
   \   00000056   0x43F6             MVNS     R6,R6            ;; #-1
   \   00000058   0x42B5             CMP      R5,R6
   \   0000005A   0xD039             BEQ      ??dir_next_4
   1156          				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6981             LDR      R1,[R0, #+24]
   \   00000060   0x428D             CMP      R5,R1
   \   00000062   0xD33A             BCC      ??dir_next_5
   1157          #if !_FS_READONLY
   1158          					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
   \   00000064   0x9900             LDR      R1,[SP, #+0]
   \   00000066   0x2900             CMP      R1,#+0
   \   00000068   0xD101             BNE      ??dir_next_6
   \                     ??dir_next_0: (+1)
   \   0000006A   0x2004             MOVS     R0,#+4
   \   0000006C   0xBDF2             POP      {R1,R4-R7,PC}
   1159          					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
   \                     ??dir_next_6: (+1)
   \   0000006E   0x68E1             LDR      R1,[R4, #+12]
   \   00000070   0x.... 0x....      BL       _Z12create_chainP5FATFSm
   \   00000074   0x0005             MOVS     R5,R0
   1160          					if (clst == 0) return FR_DENIED;			/* No free cluster */
   \   00000076   0xD101             BNE      ??dir_next_7
   \   00000078   0x2007             MOVS     R0,#+7
   \   0000007A   0xBDF2             POP      {R1,R4-R7,PC}
   1161          					if (clst == 1) return FR_INT_ERR;
   \                     ??dir_next_7: (+1)
   \   0000007C   0x2D01             CMP      R5,#+1
   \   0000007E   0xD101             BNE      ??dir_next_8
   \                     ??dir_next_3: (+1)
   \   00000080   0x2002             MOVS     R0,#+2
   \   00000082   0xBDF2             POP      {R1,R4-R7,PC}
   1162          					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_8: (+1)
   \   00000084   0x42B5             CMP      R5,R6
   \   00000086   0xD023             BEQ      ??dir_next_4
   1163          					/* Clean-up stretched table */
   1164          					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x.... 0x....      BL       _Z11sync_windowP5FATFS
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD11E             BNE      ??dir_next_4
   1165          					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x8941             LDRH     R1,[R0, #+10]
   \   00000096   0x2900             CMP      R1,#+0
   \   00000098   0xD002             BEQ      ??dir_next_9
   \   0000009A   0x6B40             LDR      R0,[R0, #+52]
   \   0000009C   0x.... 0x....      BL       __aeabi_memclr
   1166          					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
   \                     ??dir_next_9: (+1)
   \   000000A0   0x0029             MOVS     R1,R5
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x.... 0x....      BL       _Z10clust2sectP5FATFSm
   \   000000A8   0x6821             LDR      R1,[R4, #+0]
   \   000000AA   0x6308             STR      R0,[R1, #+48]
   1167          					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
   \   000000AC   0x2600             MOVS     R6,#+0
   \   000000AE   0xE004             B        ??dir_next_10
   1168          						dp->fs->wflag = 1;
   1169          						if (sync_window(dp->fs)) return FR_DISK_ERR;
   1170          						dp->fs->winsect++;
   \                     ??dir_next_11: (+1)
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6B01             LDR      R1,[R0, #+48]
   \   000000B4   0x1C49             ADDS     R1,R1,#+1
   \   000000B6   0x6301             STR      R1,[R0, #+48]
   \   000000B8   0x1C76             ADDS     R6,R6,#+1
   \                     ??dir_next_10: (+1)
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x7881             LDRB     R1,[R0, #+2]
   \   000000BE   0x428E             CMP      R6,R1
   \   000000C0   0xD208             BCS      ??dir_next_12
   \   000000C2   0x2101             MOVS     R1,#+1
   \   000000C4   0x7101             STRB     R1,[R0, #+4]
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x.... 0x....      BL       _Z11sync_windowP5FATFS
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD0EF             BEQ      ??dir_next_11
   \                     ??dir_next_4: (+1)
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0xBDF2             POP      {R1,R4-R7,PC}
   1171          					}
   1172          					dp->fs->winsect -= c;						/* Rewind window offset */
   \                     ??dir_next_12: (+1)
   \   000000D4   0x6B01             LDR      R1,[R0, #+48]
   \   000000D6   0x1B89             SUBS     R1,R1,R6
   \   000000D8   0x6301             STR      R1,[R0, #+48]
   1173          #else
   1174          					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
   1175          					return FR_NO_FILE;							/* Report EOT */
   1176          #endif
   1177          				}
   1178          				dp->clust = clst;				/* Initialize data for new cluster */
   \                     ??dir_next_5: (+1)
   \   000000DA   0x60E5             STR      R5,[R4, #+12]
   1179          				dp->sect = clust2sect(dp->fs, clst);
   \   000000DC   0x0029             MOVS     R1,R5
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x.... 0x....      BL       _Z10clust2sectP5FATFSm
   \   000000E4   0x6120             STR      R0,[R4, #+16]
   1180          			}
   1181          		}
   1182          	}
   1183          
   1184          	dp->index = (WORD)i;	/* Current index */
   \                     ??dir_next_1: (+1)
   \   000000E6   0x0038             MOVS     R0,R7
   \   000000E8   0x80E0             STRH     R0,[R4, #+6]
   1185          	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
   \   000000EA   0x6821             LDR      R1,[R4, #+0]
   \   000000EC   0x6B4D             LDR      R5,[R1, #+52]
   \   000000EE   0x8949             LDRH     R1,[R1, #+10]
   \   000000F0   0x0949             LSRS     R1,R1,#+5
   \   000000F2   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000F6   0x0148             LSLS     R0,R1,#+5
   \   000000F8   0x1828             ADDS     R0,R5,R0
   \   000000FA   0x6160             STR      R0,[R4, #+20]
   1186          
   1187          	return FR_OK;
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1188          }
   1189          
   1190          
   1191          
   1192          
   1193          /*-----------------------------------------------------------------------*/
   1194          /* Directory handling - Reserve directory entry                          */
   1195          /*-----------------------------------------------------------------------*/
   1196          
   1197          #if !_FS_READONLY
   1198          static
   1199          FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
   1200          	FATFS_DIR* dp,		/* Pointer to the directory object */
   1201          	UINT nent		/* Number of contiguous entries to allocate (1-21) */
   1202          )
   1203          {
   1204          	FRESULT res;
   1205          	UINT n;
   1206          
   1207          
   1208          	res = dir_sdi(dp, 0);
   1209          	if (res == FR_OK) {
   1210          		n = 0;
   1211          		do {
   1212          			res = move_window(dp->fs, dp->sect);
   1213          			if (res != FR_OK) break;
   1214          			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
   1215          				if (++n == nent) break;	/* A block of contiguous free entries is found */
   1216          			} else {
   1217          				n = 0;					/* Not a blank entry. Restart to search */
   1218          			}
   1219          			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
   1220          		} while (res == FR_OK);
   1221          	}
   1222          	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
   1223          	return res;
   1224          }
   1225          #endif
   1226          
   1227          
   1228          
   1229          
   1230          /*-----------------------------------------------------------------------*/
   1231          /* Directory handling - Load/Store start cluster number                  */
   1232          /*-----------------------------------------------------------------------*/
   1233          

   \                                 In section .text, align 2, keep-with-next
   1234          static
   1235          DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
   1236          	FATFS* fs,		/* Pointer to the fs object */
   1237          	const BYTE* dir	/* Pointer to the SFN entry */
   1238          )
   1239          {
   \                     _Z8ld_clustP5FATFSPKh: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1240          	DWORD cl;
   1241          
   1242          	cl = LD_WORD(dir + DIR_FstClusLO);
   \   00000002   0x7EC8             LDRB     R0,[R1, #+27]
   \   00000004   0x0200             LSLS     R0,R0,#+8
   \   00000006   0x7E8B             LDRB     R3,[R1, #+26]
   \   00000008   0x4318             ORRS     R0,R0,R3
   1243          	if (fs->fs_type == FS_FAT32)
   \   0000000A   0x7812             LDRB     R2,[R2, #+0]
   \   0000000C   0x2A03             CMP      R2,#+3
   \   0000000E   0xD106             BNE      ??ld_clust_0
   1244          		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
   \   00000010   0x0002             MOVS     R2,R0
   \   00000012   0x7D48             LDRB     R0,[R1, #+21]
   \   00000014   0x0200             LSLS     R0,R0,#+8
   \   00000016   0x7D09             LDRB     R1,[R1, #+20]
   \   00000018   0x4308             ORRS     R0,R0,R1
   \   0000001A   0x0400             LSLS     R0,R0,#+16
   \   0000001C   0x4310             ORRS     R0,R0,R2
   1245          
   1246          	return cl;
   \                     ??ld_clust_0: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
   1247          }
   1248          
   1249          
   1250          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1251          static
   1252          void st_clust (
   1253          	BYTE* dir,	/* Pointer to the SFN entry */
   1254          	DWORD cl	/* Value to be set */
   1255          )
   1256          {
   1257          	ST_WORD(dir + DIR_FstClusLO, cl);
   \                     _Z8st_clustPhm: (+1)
   \   00000000   0x7681             STRB     R1,[R0, #+26]
   \   00000002   0x040A             LSLS     R2,R1,#+16
   \   00000004   0x0E12             LSRS     R2,R2,#+24
   \   00000006   0x76C2             STRB     R2,[R0, #+27]
   1258          	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
   \   00000008   0x0C09             LSRS     R1,R1,#+16
   \   0000000A   0x7501             STRB     R1,[R0, #+20]
   \   0000000C   0x0A09             LSRS     R1,R1,#+8
   \   0000000E   0x7541             STRB     R1,[R0, #+21]
   1259          }
   \   00000010   0x4770             BX       LR               ;; return
   1260          #endif
   1261          
   1262          
   1263          
   1264          
   1265          /*-----------------------------------------------------------------------*/
   1266          /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
   1267          /*-----------------------------------------------------------------------*/
   1268          #if _USE_LFN
   1269          static

   \                                 In section .text, align 4, keep-with-next
   1270          const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN characters in the directory entry */
   \                     LfnOfs:
   \   00000000   0x01 0x03          DC8 1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30, 0, 0, 0
   \              0x05 0x07    
   \              0x09 0x0E    
   \              0x10 0x12    
   \              0x14 0x16    
   \              0x18 0x1C    
   \              0x1E 0x00    
   \              0x00 0x00    
   1271          
   1272          
   1273          static
   1274          int cmp_lfn (			/* 1:matched, 0:not matched */
   1275          	WCHAR* lfnbuf,		/* Pointer to the LFN working buffer to be compared */
   1276          	BYTE* dir			/* Pointer to the directory entry containing the part of LFN */
   1277          )
   1278          {
   1279          	UINT i, s;
   1280          	WCHAR wc, uc;
   1281          
   1282          
   1283          	if (LD_WORD(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
   1284          
   1285          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   1286          
   1287          	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
   1288          		uc = LD_WORD(dir + LfnOfs[s]);		/* Pick an LFN character */
   1289          		if (wc) {
   1290          			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
   1291          				return 0;					/* Not matched */
   1292          			wc = uc;
   1293          		} else {
   1294          			if (uc != 0xFFFF) return 0;		/* Check filler */
   1295          		}
   1296          	}
   1297          
   1298          	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i])	/* Last segment matched but different length */
   1299          		return 0;
   1300          
   1301          	return 1;		/* The part of LFN matched */
   1302          }
   1303          
   1304          
   1305          
   1306          static
   1307          int pick_lfn (			/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
   1308          	WCHAR* lfnbuf,		/* Pointer to the LFN working buffer */
   1309          	BYTE* dir			/* Pointer to the LFN entry */
   1310          )
   1311          {
   1312          	UINT i, s;
   1313          	WCHAR wc, uc;
   1314          
   1315          
   1316          	if (LD_WORD(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
   1317          
   1318          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   1319          
   1320          	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
   1321          		uc = LD_WORD(dir + LfnOfs[s]);		/* Pick an LFN character */
   1322          		if (wc) {
   1323          			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
   1324          			lfnbuf[i++] = wc = uc;			/* Store it */
   1325          		} else {
   1326          			if (uc != 0xFFFF) return 0;		/* Check filler */
   1327          		}
   1328          	}
   1329          
   1330          	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
   1331          		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
   1332          		lfnbuf[i] = 0;
   1333          	}
   1334          
   1335          	return 1;		/* The part of LFN is valid */
   1336          }
   1337          
   1338          
   1339          #if !_FS_READONLY
   1340          static
   1341          void fit_lfn (
   1342          	const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer */
   1343          	BYTE* dir,				/* Pointer to the LFN entry to be processed */
   1344          	BYTE ord,				/* LFN order (1-20) */
   1345          	BYTE sum				/* Checksum of the corresponding SFN */
   1346          )
   1347          {
   1348          	UINT i, s;
   1349          	WCHAR wc;
   1350          
   1351          
   1352          	dir[LDIR_Chksum] = sum;			/* Set checksum */
   1353          	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
   1354          	dir[LDIR_Type] = 0;
   1355          	ST_WORD(dir + LDIR_FstClusLO, 0);
   1356          
   1357          	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
   1358          	s = wc = 0;
   1359          	do {
   1360          		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective character */
   1361          		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
   1362          		if (!wc) wc = 0xFFFF;		/* Padding characters following last character */
   1363          	} while (++s < 13);
   1364          	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLEF;	/* Bottom LFN part is the start of LFN sequence */
   1365          	dir[LDIR_Ord] = ord;			/* Set the LFN order */
   1366          }
   1367          
   1368          #endif
   1369          #endif
   1370          
   1371          
   1372          
   1373          
   1374          /*-----------------------------------------------------------------------*/
   1375          /* Create numbered name                                                  */
   1376          /*-----------------------------------------------------------------------*/
   1377          #if _USE_LFN

   \                                 In section .text, align 2, keep-with-next
   1378          static
   1379          void gen_numname (
   1380          	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
   1381          	const BYTE* src,	/* Pointer to SFN */
   1382          	const WCHAR* lfn,	/* Pointer to LFN */
   1383          	UINT seq			/* Sequence number */
   1384          )
   1385          {
   \                     _Z11gen_numnamePhPKhPKtj: (+1)
   \   00000000   0xB4F1             PUSH     {R0,R4-R7}
   \   00000002   0xB082             SUB      SP,SP,#+8
   1386          	BYTE ns[8], c;
   1387          	UINT i, j;
   1388          	WCHAR wc;
   1389          	DWORD sr;
   1390          
   1391          
   1392          	mem_cpy(dst, src, 11);
   \   00000004   0x780C             LDRB     R4,[R1, #+0]
   \   00000006   0x7004             STRB     R4,[R0, #+0]
   \   00000008   0x1C49             ADDS     R1,R1,#+1
   \   0000000A   0x1C40             ADDS     R0,R0,#+1
   \   0000000C   0x2405             MOVS     R4,#+5
   \                     ??gen_numname_0: (+1)
   \   0000000E   0x780D             LDRB     R5,[R1, #+0]
   \   00000010   0x7005             STRB     R5,[R0, #+0]
   \   00000012   0x784D             LDRB     R5,[R1, #+1]
   \   00000014   0x7045             STRB     R5,[R0, #+1]
   \   00000016   0x1C89             ADDS     R1,R1,#+2
   \   00000018   0x1C80             ADDS     R0,R0,#+2
   \   0000001A   0x1E64             SUBS     R4,R4,#+1
   \   0000001C   0xD1F7             BNE      ??gen_numname_0
   1393          
   1394          	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
   \   0000001E   0x2B06             CMP      R3,#+6
   \   00000020   0xD312             BCC      ??gen_numname_1
   1395          		sr = seq;
   \   00000022   0x....             LDR      R0,??DataTable11  ;; 0x11021
   \   00000024   0x2180             MOVS     R1,#+128
   \   00000026   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   1396          		while (*lfn) {	/* Create a CRC */
   \                     ??gen_numname_2: (+1)
   \   00000028   0x8815             LDRH     R5,[R2, #+0]
   \   0000002A   0x002E             MOVS     R6,R5
   \   0000002C   0xD00C             BEQ      ??gen_numname_1
   1397          			wc = *lfn++;
   \   0000002E   0x1C92             ADDS     R2,R2,#+2
   1398          			for (i = 0; i < 16; i++) {
   \   00000030   0x2610             MOVS     R6,#+16
   1399          				sr = (sr << 1) + (wc & 1);
   \                     ??gen_numname_3: (+1)
   \   00000032   0x005B             LSLS     R3,R3,#+1
   \   00000034   0x2701             MOVS     R7,#+1
   \   00000036   0x402F             ANDS     R7,R7,R5
   \   00000038   0x19DB             ADDS     R3,R3,R7
   1400          				wc >>= 1;
   \   0000003A   0x086D             LSRS     R5,R5,#+1
   1401          				if (sr & 0x10000) sr ^= 0x11021;
   \   0000003C   0x420B             TST      R3,R1
   \   0000003E   0xD000             BEQ      ??gen_numname_4
   \   00000040   0x4043             EORS     R3,R3,R0
   1402          			}
   \                     ??gen_numname_4: (+1)
   \   00000042   0x1E76             SUBS     R6,R6,#+1
   \   00000044   0xD0F0             BEQ      ??gen_numname_2
   \   00000046   0xE7F4             B        ??gen_numname_3
   1403          		}
   1404          		seq = (UINT)sr;
   1405          	}
   1406          
   1407          	/* itoa (hexdecimal) */
   1408          	i = 7;
   \                     ??gen_numname_1: (+1)
   \   00000048   0x2007             MOVS     R0,#+7
   \   0000004A   0x4669             MOV      R1,SP
   \   0000004C   0x1DC9             ADDS     R1,R1,#+7
   \   0000004E   0x220F             MOVS     R2,#+15
   1409          	do {
   1410          		c = (seq % 16) + '0';
   \                     ??gen_numname_5: (+1)
   \   00000050   0x001C             MOVS     R4,R3
   \   00000052   0x4014             ANDS     R4,R4,R2
   \   00000054   0x3430             ADDS     R4,R4,#+48
   1411          		if (c > '9') c += 7;
   \   00000056   0xB2E4             UXTB     R4,R4
   \   00000058   0x2C3A             CMP      R4,#+58
   \   0000005A   0xDB00             BLT      ??gen_numname_6
   \   0000005C   0x1DE4             ADDS     R4,R4,#+7
   1412          		ns[i--] = c;
   \                     ??gen_numname_6: (+1)
   \   0000005E   0x700C             STRB     R4,[R1, #+0]
   \   00000060   0x1E40             SUBS     R0,R0,#+1
   1413          		seq /= 16;
   \   00000062   0x091B             LSRS     R3,R3,#+4
   1414          	} while (seq);
   \   00000064   0x1E49             SUBS     R1,R1,#+1
   \   00000066   0x2B00             CMP      R3,#+0
   \   00000068   0xD1F2             BNE      ??gen_numname_5
   1415          	ns[i] = '~';
   \   0000006A   0x4669             MOV      R1,SP
   \   0000006C   0x227E             MOVS     R2,#+126
   \   0000006E   0x540A             STRB     R2,[R1, R0]
   1416          
   1417          	/* Append the number */
   1418          	for (j = 0; j < i && dst[j] != ' '; j++) {
   \   00000070   0x2200             MOVS     R2,#+0
   \   00000072   0x9B02             LDR      R3,[SP, #+8]
   \   00000074   0xE001             B        ??gen_numname_7
   \                     ??gen_numname_8: (+1)
   \   00000076   0x1C52             ADDS     R2,R2,#+1
   \   00000078   0x1C5B             ADDS     R3,R3,#+1
   \                     ??gen_numname_7: (+1)
   \   0000007A   0x4282             CMP      R2,R0
   \   0000007C   0xD202             BCS      ??gen_numname_9
   \   0000007E   0x781C             LDRB     R4,[R3, #+0]
   \   00000080   0x2C20             CMP      R4,#+32
   \   00000082   0xD1F8             BNE      ??gen_numname_8
   1419          		if (IsDBCS1(dst[j])) {
   1420          			if (j == i - 1) break;
   1421          			j++;
   1422          		}
   1423          	}
   1424          	do {
   1425          		dst[j++] = (i < 8) ? ns[i++] : ' ';
   \                     ??gen_numname_9: (+1)
   \   00000084   0x0013             MOVS     R3,R2
   \   00000086   0x1C52             ADDS     R2,R2,#+1
   \   00000088   0x2808             CMP      R0,#+8
   \   0000008A   0xD202             BCS      ??gen_numname_10
   \   0000008C   0x5C0C             LDRB     R4,[R1, R0]
   \   0000008E   0x1C40             ADDS     R0,R0,#+1
   \   00000090   0xE000             B        ??gen_numname_11
   \                     ??gen_numname_10: (+1)
   \   00000092   0x2420             MOVS     R4,#+32
   \                     ??gen_numname_11: (+1)
   \   00000094   0x9D02             LDR      R5,[SP, #+8]
   \   00000096   0x54EC             STRB     R4,[R5, R3]
   1426          	} while (j < 8);
   \   00000098   0x2A08             CMP      R2,#+8
   \   0000009A   0xD3F3             BCC      ??gen_numname_9
   1427          }
   \   0000009C   0xB003             ADD      SP,SP,#+12
   \   0000009E   0xBCF0             POP      {R4-R7}
   \   000000A0   0x4770             BX       LR               ;; return
   1428          #endif
   1429          
   1430          
   1431          
   1432          
   1433          /*-----------------------------------------------------------------------*/
   1434          /* Calculate checksum of an SFN entry                                    */
   1435          /*-----------------------------------------------------------------------*/
   1436          #if _USE_LFN

   \                                 In section .text, align 2, keep-with-next
   1437          static
   1438          BYTE sum_sfn (
   1439          	const BYTE* dir		/* Pointer to the SFN entry */
   1440          )
   1441          {
   \                     _Z7sum_sfnPKh: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1442          	BYTE sum = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   1443          	UINT n = 11;
   \   00000004   0x220B             MOVS     R2,#+11
   1444          
   1445          	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   \                     ??sum_sfn_0: (+1)
   \   00000006   0x0843             LSRS     R3,R0,#+1
   \   00000008   0x01C0             LSLS     R0,R0,#+7
   \   0000000A   0x1818             ADDS     R0,R3,R0
   \   0000000C   0x780B             LDRB     R3,[R1, #+0]
   \   0000000E   0x18C0             ADDS     R0,R0,R3
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x1E52             SUBS     R2,R2,#+1
   \   00000016   0xD1F6             BNE      ??sum_sfn_0
   1446          	return sum;
   \   00000018   0x4770             BX       LR               ;; return
   1447          }
   1448          #endif
   1449          
   1450          
   1451          
   1452          
   1453          /*-----------------------------------------------------------------------*/
   1454          /* Directory handling - Find an object in the directory                  */
   1455          /*-----------------------------------------------------------------------*/
   1456          

   \                                 In section .text, align 2, keep-with-next
   1457          static
   1458          FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
   1459          	FATFS_DIR* dp			/* Pointer to the directory object linked to the file name */
   1460          )
   1461          {
   \                     _Z8dir_findP9FATFS_DIR: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   1462          	FRESULT res;
   1463          	BYTE c, *dir;
   1464          #if _USE_LFN
   1465          	BYTE a, ord, sum;
   1466          #endif
   1467          
   1468          	res = dir_sdi(dp, 0);			/* Rewind directory object */
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      BL       _Z7dir_sdiP9FATFS_DIRj
   1469          	if (res != FR_OK) return res;
   \   0000000A   0x0001             MOVS     R1,R0
   \   0000000C   0xD000             BEQ      .+4
   \   0000000E   0xE0B6             B        ??dir_find_0
   \   00000010   0x20FF             MOVS     R0,#+255
   \   00000012   0x9002             STR      R0,[SP, #+8]
   \   00000014   0x24FF             MOVS     R4,#+255
   \   00000016   0x....             LDR      R0,??DataTable12  ;; 0xffff
   \   00000018   0x9906             LDR      R1,[SP, #+24]
   \   0000001A   0x8408             STRH     R0,[R1, #+32]
   1470          
   1471          #if _USE_LFN
   1472          	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   1473          #endif
   1474          	do {
   1475          		res = move_window(dp->fs, dp->sect);
   \                     ??dir_find_1: (+1)
   \   0000001C   0x9806             LDR      R0,[SP, #+24]
   \   0000001E   0x6901             LDR      R1,[R0, #+16]
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   1476          		if (res != FR_OK) break;
   \   00000026   0x0001             MOVS     R1,R0
   \   00000028   0xD000             BEQ      .+4
   \   0000002A   0xE0A8             B        ??dir_find_0
   1477          		dir = dp->dir;					/* Ptr to the directory entry of current index */
   \   0000002C   0x9906             LDR      R1,[SP, #+24]
   \   0000002E   0x6949             LDR      R1,[R1, #+20]
   \   00000030   0x9100             STR      R1,[SP, #+0]
   1478          		c = dir[DIR_Name];
   \   00000032   0x7809             LDRB     R1,[R1, #+0]
   1479          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD101             BNE      ??dir_find_2
   \   00000038   0x2004             MOVS     R0,#+4
   \   0000003A   0xE0A0             B        ??dir_find_0
   1480          #if _USE_LFN	/* LFN configuration */
   1481          		a = dir[DIR_Attr] & AM_MASK;
   \                     ??dir_find_2: (+1)
   \   0000003C   0x9A00             LDR      R2,[SP, #+0]
   \   0000003E   0x7AD2             LDRB     R2,[R2, #+11]
   \   00000040   0x0692             LSLS     R2,R2,#+26
   \   00000042   0x0E92             LSRS     R2,R2,#+26
   1482          		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   \   00000044   0x29E5             CMP      R1,#+229
   \   00000046   0xD100             BNE      .+4
   \   00000048   0xE08E             B        ??dir_find_3
   \   0000004A   0x0713             LSLS     R3,R2,#+28
   \   0000004C   0xD503             BPL      ??dir_find_4
   \   0000004E   0x2A0F             CMP      R2,#+15
   \   00000050   0xD000             BEQ      .+4
   \   00000052   0xE089             B        ??dir_find_3
   \   00000054   0xE001             B        ??dir_find_5
   1483          			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   1484          		} else {
   1485          			if (a == AM_LFN) {			/* An LFN entry is found */
   \                     ??dir_find_4: (+1)
   \   00000056   0x2A0F             CMP      R2,#+15
   \   00000058   0xD160             BNE      ??dir_find_6
   1486          				if (dp->lfn) {
   \                     ??dir_find_5: (+1)
   \   0000005A   0x9806             LDR      R0,[SP, #+24]
   \   0000005C   0x69C0             LDR      R0,[R0, #+28]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD100             BNE      .+4
   \   00000062   0xE085             B        ??dir_find_7
   1487          					if (c & LLEF) {		/* Is it start of LFN sequence? */
   \   00000064   0x064A             LSLS     R2,R1,#+25
   \   00000066   0xD50A             BPL      ??dir_find_8
   1488          						sum = dir[LDIR_Chksum];
   \   00000068   0x9A00             LDR      R2,[SP, #+0]
   \   0000006A   0x7B52             LDRB     R2,[R2, #+13]
   \   0000006C   0x9202             STR      R2,[SP, #+8]
   1489          						c &= ~LLEF; ord = c;	/* LFN start order */
   \   0000006E   0x000A             MOVS     R2,R1
   \   00000070   0x21BF             MOVS     R1,#+191
   \   00000072   0x4011             ANDS     R1,R1,R2
   \   00000074   0x000C             MOVS     R4,R1
   1490          						dp->lfn_idx = dp->index;	/* Start index of LFN */
   \   00000076   0x9A06             LDR      R2,[SP, #+24]
   \   00000078   0x88D2             LDRH     R2,[R2, #+6]
   \   0000007A   0x9B06             LDR      R3,[SP, #+24]
   \   0000007C   0x841A             STRH     R2,[R3, #+32]
   1491          					}
   1492          					/* Check validity of the LFN entry and compare it with given name */
   1493          					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
   \                     ??dir_find_8: (+1)
   \   0000007E   0xB2E2             UXTB     R2,R4
   \   00000080   0x4291             CMP      R1,R2
   \   00000082   0xD149             BNE      ??dir_find_9
   \   00000084   0x9902             LDR      R1,[SP, #+8]
   \   00000086   0x9A00             LDR      R2,[SP, #+0]
   \   00000088   0x7B52             LDRB     R2,[R2, #+13]
   \   0000008A   0x4291             CMP      R1,R2
   \   0000008C   0xD144             BNE      ??dir_find_9
   \   0000008E   0x9003             STR      R0,[SP, #+12]
   \   00000090   0x9800             LDR      R0,[SP, #+0]
   \   00000092   0x7EC0             LDRB     R0,[R0, #+27]
   \   00000094   0x0200             LSLS     R0,R0,#+8
   \   00000096   0x9900             LDR      R1,[SP, #+0]
   \   00000098   0x7E89             LDRB     R1,[R1, #+26]
   \   0000009A   0x4308             ORRS     R0,R0,R1
   \   0000009C   0xD13C             BNE      ??dir_find_9
   \   0000009E   0x9800             LDR      R0,[SP, #+0]
   \   000000A0   0x7800             LDRB     R0,[R0, #+0]
   \   000000A2   0x0685             LSLS     R5,R0,#+26
   \   000000A4   0x0EAD             LSRS     R5,R5,#+26
   \   000000A6   0x1E6D             SUBS     R5,R5,#+1
   \   000000A8   0x200D             MOVS     R0,#+13
   \   000000AA   0x4345             MULS     R5,R0,R5
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x....             LDR      R1,??DataTable12_1
   \   000000B0   0x9101             STR      R1,[SP, #+4]
   \   000000B2   0x270D             MOVS     R7,#+13
   \                     ??dir_find_10: (+1)
   \   000000B4   0x9900             LDR      R1,[SP, #+0]
   \   000000B6   0x9A01             LDR      R2,[SP, #+4]
   \   000000B8   0x7812             LDRB     R2,[R2, #+0]
   \   000000BA   0x1889             ADDS     R1,R1,R2
   \   000000BC   0x784A             LDRB     R2,[R1, #+1]
   \   000000BE   0x0216             LSLS     R6,R2,#+8
   \   000000C0   0x7809             LDRB     R1,[R1, #+0]
   \   000000C2   0x430E             ORRS     R6,R6,R1
   \   000000C4   0x0001             MOVS     R1,R0
   \   000000C6   0xD012             BEQ      ??dir_find_11
   \   000000C8   0x2DFF             CMP      R5,#+255
   \   000000CA   0xD225             BCS      ??dir_find_9
   \   000000CC   0x0030             MOVS     R0,R6
   \   000000CE   0x.... 0x....      BL       ff_wtoupper
   \   000000D2   0x4669             MOV      R1,SP
   \   000000D4   0x8208             STRH     R0,[R1, #+16]
   \   000000D6   0x9803             LDR      R0,[SP, #+12]
   \   000000D8   0x0069             LSLS     R1,R5,#+1
   \   000000DA   0x5A40             LDRH     R0,[R0, R1]
   \   000000DC   0x.... 0x....      BL       ff_wtoupper
   \   000000E0   0x1C6D             ADDS     R5,R5,#+1
   \   000000E2   0x4669             MOV      R1,SP
   \   000000E4   0x8A09             LDRH     R1,[R1, #+16]
   \   000000E6   0x4281             CMP      R1,R0
   \   000000E8   0xD116             BNE      ??dir_find_9
   \   000000EA   0x0030             MOVS     R0,R6
   \   000000EC   0xE002             B        ??dir_find_12
   \                     ??dir_find_11: (+1)
   \   000000EE   0x....             LDR      R1,??DataTable12  ;; 0xffff
   \   000000F0   0x428E             CMP      R6,R1
   \   000000F2   0xD111             BNE      ??dir_find_9
   \                     ??dir_find_12: (+1)
   \   000000F4   0x9901             LDR      R1,[SP, #+4]
   \   000000F6   0x1C49             ADDS     R1,R1,#+1
   \   000000F8   0x9101             STR      R1,[SP, #+4]
   \   000000FA   0x1E7F             SUBS     R7,R7,#+1
   \   000000FC   0xD1DA             BNE      ??dir_find_10
   \   000000FE   0x9900             LDR      R1,[SP, #+0]
   \   00000100   0x7809             LDRB     R1,[R1, #+0]
   \   00000102   0x0649             LSLS     R1,R1,#+25
   \   00000104   0xD506             BPL      ??dir_find_13
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD004             BEQ      ??dir_find_13
   \   0000010A   0x9803             LDR      R0,[SP, #+12]
   \   0000010C   0x0069             LSLS     R1,R5,#+1
   \   0000010E   0x5A40             LDRH     R0,[R0, R1]
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD101             BNE      ??dir_find_9
   \                     ??dir_find_13: (+1)
   \   00000114   0x1E64             SUBS     R4,R4,#+1
   \   00000116   0xE02B             B        ??dir_find_7
   \                     ??dir_find_9: (+1)
   \   00000118   0x24FF             MOVS     R4,#+255
   \   0000011A   0xE029             B        ??dir_find_7
   1494          				}
   1495          			} else {					/* An SFN entry is found */
   1496          				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
   \                     ??dir_find_6: (+1)
   \   0000011C   0x0624             LSLS     R4,R4,#+24
   \   0000011E   0xD10E             BNE      ??dir_find_14
   \   00000120   0x9900             LDR      R1,[SP, #+0]
   \   00000122   0x2300             MOVS     R3,#+0
   \   00000124   0x220B             MOVS     R2,#+11
   \                     ??dir_find_15: (+1)
   \   00000126   0x085C             LSRS     R4,R3,#+1
   \   00000128   0x01DB             LSLS     R3,R3,#+7
   \   0000012A   0x18E3             ADDS     R3,R4,R3
   \   0000012C   0x780C             LDRB     R4,[R1, #+0]
   \   0000012E   0x191B             ADDS     R3,R3,R4
   \   00000130   0xB2DB             UXTB     R3,R3
   \   00000132   0x1C49             ADDS     R1,R1,#+1
   \   00000134   0x1E52             SUBS     R2,R2,#+1
   \   00000136   0xD1F6             BNE      ??dir_find_15
   \   00000138   0x9902             LDR      R1,[SP, #+8]
   \   0000013A   0x4299             CMP      R1,R3
   \   0000013C   0xD01F             BEQ      ??dir_find_0
   1497          				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
   \                     ??dir_find_14: (+1)
   \   0000013E   0x9906             LDR      R1,[SP, #+24]
   \   00000140   0x6989             LDR      R1,[R1, #+24]
   \   00000142   0x7ACA             LDRB     R2,[R1, #+11]
   \   00000144   0x07D2             LSLS     R2,R2,#+31
   \   00000146   0xD40F             BMI      ??dir_find_3
   \   00000148   0x220B             MOVS     R2,#+11
   \   0000014A   0x9B00             LDR      R3,[SP, #+0]
   \   0000014C   0x2400             MOVS     R4,#+0
   \                     ??dir_find_16: (+1)
   \   0000014E   0x0015             MOVS     R5,R2
   \   00000150   0x1E6A             SUBS     R2,R5,#+1
   \   00000152   0x2D00             CMP      R5,#+0
   \   00000154   0xD006             BEQ      ??dir_find_17
   \   00000156   0x781C             LDRB     R4,[R3, #+0]
   \   00000158   0x780D             LDRB     R5,[R1, #+0]
   \   0000015A   0x1B64             SUBS     R4,R4,R5
   \   0000015C   0x1C49             ADDS     R1,R1,#+1
   \   0000015E   0x1C5B             ADDS     R3,R3,#+1
   \   00000160   0x2C00             CMP      R4,#+0
   \   00000162   0xD0F4             BEQ      ??dir_find_16
   \                     ??dir_find_17: (+1)
   \   00000164   0x2C00             CMP      R4,#+0
   \   00000166   0xD00A             BEQ      ??dir_find_0
   1498          				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   \                     ??dir_find_3: (+1)
   \   00000168   0x24FF             MOVS     R4,#+255
   \   0000016A   0x....             LDR      R0,??DataTable12  ;; 0xffff
   \   0000016C   0x9906             LDR      R1,[SP, #+24]
   \   0000016E   0x8408             STRH     R0,[R1, #+32]
   1499          			}
   1500          		}
   1501          #else		/* Non LFN configuration */
   1502          		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
   1503          			break;
   1504          #endif
   1505          		res = dir_next(dp, 0);		/* Next entry */
   \                     ??dir_find_7: (+1)
   \   00000170   0x2100             MOVS     R1,#+0
   \   00000172   0x9806             LDR      R0,[SP, #+24]
   \   00000174   0x.... 0x....      BL       _Z8dir_nextP9FATFS_DIRi
   1506          	} while (res == FR_OK);
   \   00000178   0x0001             MOVS     R1,R0
   \   0000017A   0xD100             BNE      .+4
   \   0000017C   0xE74E             B        ??dir_find_1
   1507          
   1508          	return res;
   \                     ??dir_find_0: (+1)
   \   0000017E   0xB007             ADD      SP,SP,#+28
   \   00000180   0xBDF0             POP      {R4-R7,PC}       ;; return
   1509          }
   1510          
   1511          
   1512          
   1513          
   1514          /*-----------------------------------------------------------------------*/
   1515          /* Read an object from the directory                                     */
   1516          /*-----------------------------------------------------------------------*/
   1517          #if _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2

   \                                 In section .text, align 2, keep-with-next
   1518          static
   1519          FRESULT dir_read (
   1520          	FATFS_DIR* dp,		/* Pointer to the directory object */
   1521          	int vol			/* Filtered by 0:file/directory or 1:volume label */
   1522          )
   1523          {
   \                     _Z8dir_readP9FATFS_DIRi: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x25FF             MOVS     R5,#+255
   1524          	FRESULT res;
   1525          	BYTE a, c, *dir;
   1526          #if _USE_LFN
   1527          	BYTE ord = 0xFF, sum = 0xFF;
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x710D             STRB     R5,[R1, #+4]
   \   0000000C   0x2604             MOVS     R6,#+4
   1528          #endif
   1529          
   1530          	res = FR_NO_FILE;
   1531          	while (dp->sect) {
   \                     ??dir_read_0: (+1)
   \   0000000E   0x6921             LDR      R1,[R4, #+16]
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD06E             BEQ      ??dir_read_1
   1532          		res = move_window(dp->fs, dp->sect);
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   0000001A   0x0006             MOVS     R6,R0
   1533          		if (res != FR_OK) break;
   \   0000001C   0xD169             BNE      ??dir_read_1
   1534          		dir = dp->dir;					/* Ptr to the directory entry of current index */
   \   0000001E   0x6960             LDR      R0,[R4, #+20]
   \   00000020   0x9000             STR      R0,[SP, #+0]
   1535          		c = dir[DIR_Name];
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   1536          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD101             BNE      ??dir_read_2
   \   00000028   0x2604             MOVS     R6,#+4
   \   0000002A   0xE064             B        ??dir_read_3
   1537          		a = dir[DIR_Attr] & AM_MASK;
   \                     ??dir_read_2: (+1)
   \   0000002C   0x9900             LDR      R1,[SP, #+0]
   \   0000002E   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000030   0x0689             LSLS     R1,R1,#+26
   \   00000032   0x0E89             LSRS     R1,R1,#+26
   1538          #if _USE_LFN	/* LFN configuration */
   1539          		if (c == DDEM || (!_FS_RPATH && c == '.') || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
   \   00000034   0x28E5             CMP      R0,#+229
   \   00000036   0xD063             BEQ      ??dir_read_4
   \   00000038   0x000A             MOVS     R2,R1
   \   0000003A   0x2320             MOVS     R3,#+32
   \   0000003C   0x439A             BICS     R2,R2,R3
   \   0000003E   0x2A08             CMP      R2,#+8
   \   00000040   0xD101             BNE      ??dir_read_5
   \   00000042   0x2201             MOVS     R2,#+1
   \   00000044   0xE000             B        ??dir_read_6
   \                     ??dir_read_5: (+1)
   \   00000046   0x2200             MOVS     R2,#+0
   \                     ??dir_read_6: (+1)
   \   00000048   0x9B04             LDR      R3,[SP, #+16]
   \   0000004A   0x429A             CMP      R2,R3
   \   0000004C   0xD158             BNE      ??dir_read_4
   1540          			ord = 0xFF;
   1541          		} else {
   1542          			if (a == AM_LFN) {			/* An LFN entry is found */
   \   0000004E   0x290F             CMP      R1,#+15
   \   00000050   0xD158             BNE      ??dir_read_7
   1543          				if (c & LLEF) {			/* Is it start of LFN sequence? */
   \   00000052   0x0641             LSLS     R1,R0,#+25
   \   00000054   0xD509             BPL      ??dir_read_8
   1544          					sum = dir[LDIR_Chksum];
   \   00000056   0x9900             LDR      R1,[SP, #+0]
   \   00000058   0x7B49             LDRB     R1,[R1, #+13]
   \   0000005A   0x466A             MOV      R2,SP
   \   0000005C   0x7111             STRB     R1,[R2, #+4]
   1545          					c &= ~LLEF; ord = c;
   \   0000005E   0x0001             MOVS     R1,R0
   \   00000060   0x20BF             MOVS     R0,#+191
   \   00000062   0x4008             ANDS     R0,R0,R1
   \   00000064   0x0005             MOVS     R5,R0
   1546          					dp->lfn_idx = dp->index;
   \   00000066   0x88E1             LDRH     R1,[R4, #+6]
   \   00000068   0x8421             STRH     R1,[R4, #+32]
   1547          				}
   1548          				/* Check LFN validity and capture it */
   1549          				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
   \                     ??dir_read_8: (+1)
   \   0000006A   0xB2E9             UXTB     R1,R5
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD147             BNE      ??dir_read_4
   \   00000070   0x4668             MOV      R0,SP
   \   00000072   0x7900             LDRB     R0,[R0, #+4]
   \   00000074   0x9900             LDR      R1,[SP, #+0]
   \   00000076   0x7B49             LDRB     R1,[R1, #+13]
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xD141             BNE      ??dir_read_4
   \   0000007C   0x69E0             LDR      R0,[R4, #+28]
   \   0000007E   0x9002             STR      R0,[SP, #+8]
   \   00000080   0x9800             LDR      R0,[SP, #+0]
   \   00000082   0x7EC0             LDRB     R0,[R0, #+27]
   \   00000084   0x0200             LSLS     R0,R0,#+8
   \   00000086   0x9900             LDR      R1,[SP, #+0]
   \   00000088   0x7E89             LDRB     R1,[R1, #+26]
   \   0000008A   0x4308             ORRS     R0,R0,R1
   \   0000008C   0xD138             BNE      ??dir_read_4
   \   0000008E   0x9800             LDR      R0,[SP, #+0]
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0x0680             LSLS     R0,R0,#+26
   \   00000094   0x0E80             LSRS     R0,R0,#+26
   \   00000096   0x1E40             SUBS     R0,R0,#+1
   \   00000098   0x210D             MOVS     R1,#+13
   \   0000009A   0x4348             MULS     R0,R1,R0
   \   0000009C   0x2101             MOVS     R1,#+1
   \   0000009E   0x....             LDR      R2,??DataTable12_1
   \   000000A0   0x230D             MOVS     R3,#+13
   \                     ??dir_read_9: (+1)
   \   000000A2   0x9E00             LDR      R6,[SP, #+0]
   \   000000A4   0x7817             LDRB     R7,[R2, #+0]
   \   000000A6   0x19F6             ADDS     R6,R6,R7
   \   000000A8   0x7877             LDRB     R7,[R6, #+1]
   \   000000AA   0x023F             LSLS     R7,R7,#+8
   \   000000AC   0x7836             LDRB     R6,[R6, #+0]
   \   000000AE   0x4337             ORRS     R7,R7,R6
   \   000000B0   0x000E             MOVS     R6,R1
   \   000000B2   0xD007             BEQ      ??dir_read_10
   \   000000B4   0x28FF             CMP      R0,#+255
   \   000000B6   0xD223             BCS      ??dir_read_4
   \   000000B8   0x0039             MOVS     R1,R7
   \   000000BA   0x9E02             LDR      R6,[SP, #+8]
   \   000000BC   0x0047             LSLS     R7,R0,#+1
   \   000000BE   0x53F1             STRH     R1,[R6, R7]
   \   000000C0   0x1C40             ADDS     R0,R0,#+1
   \   000000C2   0xE002             B        ??dir_read_11
   \                     ??dir_read_10: (+1)
   \   000000C4   0x....             LDR      R6,??DataTable12  ;; 0xffff
   \   000000C6   0x42B7             CMP      R7,R6
   \   000000C8   0xD11A             BNE      ??dir_read_4
   \                     ??dir_read_11: (+1)
   \   000000CA   0x1C52             ADDS     R2,R2,#+1
   \   000000CC   0x1E5B             SUBS     R3,R3,#+1
   \   000000CE   0xD1E8             BNE      ??dir_read_9
   \   000000D0   0x9900             LDR      R1,[SP, #+0]
   \   000000D2   0x7809             LDRB     R1,[R1, #+0]
   \   000000D4   0x0649             LSLS     R1,R1,#+25
   \   000000D6   0xD505             BPL      ??dir_read_12
   \   000000D8   0x28FF             CMP      R0,#+255
   \   000000DA   0xD211             BCS      ??dir_read_4
   \   000000DC   0x2100             MOVS     R1,#+0
   \   000000DE   0x9A02             LDR      R2,[SP, #+8]
   \   000000E0   0x0040             LSLS     R0,R0,#+1
   \   000000E2   0x5211             STRH     R1,[R2, R0]
   \                     ??dir_read_12: (+1)
   \   000000E4   0x1E6D             SUBS     R5,R5,#+1
   1550          			} else {					/* An SFN entry is found */
   1551          				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
   1552          					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
   1553          				break;
   1554          			}
   1555          		}
   1556          #else		/* Non LFN configuration */
   1557          		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
   1558          			break;
   1559          #endif
   1560          		res = dir_next(dp, 0);				/* Next entry */
   \                     ??dir_read_13: (+1)
   \   000000E6   0x2100             MOVS     R1,#+0
   \   000000E8   0x0020             MOVS     R0,R4
   \   000000EA   0x.... 0x....      BL       _Z8dir_nextP9FATFS_DIRi
   \   000000EE   0x0006             MOVS     R6,R0
   1561          		if (res != FR_OK) break;
   \   000000F0   0xD08D             BEQ      ??dir_read_0
   1562          	}
   1563          
   1564          	if (res != FR_OK) dp->sect = 0;
   \                     ??dir_read_1: (+1)
   \   000000F2   0x0030             MOVS     R0,R6
   \   000000F4   0xD001             BEQ      ??dir_read_14
   \                     ??dir_read_3: (+1)
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x6120             STR      R0,[R4, #+16]
   1565          
   1566          	return res;
   \                     ??dir_read_14: (+1)
   \   000000FA   0x0030             MOVS     R0,R6
   \   000000FC   0xB005             ADD      SP,SP,#+20
   \   000000FE   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??dir_read_4: (+1)
   \   00000100   0x25FF             MOVS     R5,#+255
   \   00000102   0xE7F0             B        ??dir_read_13
   \                     ??dir_read_7: (+1)
   \   00000104   0x062D             LSLS     R5,R5,#+24
   \   00000106   0xD002             BEQ      ??dir_read_15
   \                     ??dir_read_16: (+1)
   \   00000108   0x....             LDR      R0,??DataTable12  ;; 0xffff
   \   0000010A   0x8420             STRH     R0,[R4, #+32]
   \   0000010C   0xE7F5             B        ??dir_read_14
   \                     ??dir_read_15: (+1)
   \   0000010E   0x4668             MOV      R0,SP
   \   00000110   0x7905             LDRB     R5,[R0, #+4]
   \   00000112   0x9800             LDR      R0,[SP, #+0]
   \   00000114   0x.... 0x....      BL       _Z7sum_sfnPKh
   \   00000118   0x4285             CMP      R5,R0
   \   0000011A   0xD0EE             BEQ      ??dir_read_14
   \   0000011C   0xE7F4             B.N      ??dir_read_16
   1567          }
   1568          #endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
   1569          
   1570          
   1571          
   1572          
   1573          /*-----------------------------------------------------------------------*/
   1574          /* Register an object to the directory                                   */
   1575          /*-----------------------------------------------------------------------*/
   1576          #if !_FS_READONLY

   \                                 In section .text, align 4, keep-with-next
   1577          static
   1578          FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
   1579          	FATFS_DIR* dp				/* Target directory with object name to be created */
   1580          )
   1581          {
   \                     _Z12dir_registerP9FATFS_DIR: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x0004             MOVS     R4,R0
   1582          	FRESULT res;
   1583          #if _USE_LFN	/* LFN configuration */
   1584          	UINT n, nent;
   1585          	BYTE sn[12], *fn, sum;
   1586          	WCHAR *lfn;
   1587          
   1588          
   1589          	fn = dp->fn; lfn = dp->lfn;
   \   00000006   0x69A0             LDR      R0,[R4, #+24]
   \   00000008   0x9001             STR      R0,[SP, #+4]
   \   0000000A   0x69E0             LDR      R0,[R4, #+28]
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   1590          	mem_cpy(sn, fn, 12);
   \   0000000E   0xA805             ADD      R0,SP,#+20
   \   00000010   0x9901             LDR      R1,[SP, #+4]
   \   00000012   0x2203             MOVS     R2,#+3
   \                     ??dir_register_0: (+1)
   \   00000014   0x780B             LDRB     R3,[R1, #+0]
   \   00000016   0x7003             STRB     R3,[R0, #+0]
   \   00000018   0x784B             LDRB     R3,[R1, #+1]
   \   0000001A   0x7043             STRB     R3,[R0, #+1]
   \   0000001C   0x788B             LDRB     R3,[R1, #+2]
   \   0000001E   0x7083             STRB     R3,[R0, #+2]
   \   00000020   0x78CB             LDRB     R3,[R1, #+3]
   \   00000022   0x70C3             STRB     R3,[R0, #+3]
   \   00000024   0x1D09             ADDS     R1,R1,#+4
   \   00000026   0x1D00             ADDS     R0,R0,#+4
   \   00000028   0x1E52             SUBS     R2,R2,#+1
   \   0000002A   0xD1F3             BNE      ??dir_register_0
   1591          
   1592          	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
   \   0000002C   0xAE05             ADD      R6,SP,#+20
   \   0000002E   0x7AF0             LDRB     R0,[R6, #+11]
   \   00000030   0x0681             LSLS     R1,R0,#+26
   \   00000032   0xD501             BPL      ??dir_register_1
   1593          		return FR_INVALID_NAME;
   \   00000034   0x2006             MOVS     R0,#+6
   \   00000036   0xE174             B        ??dir_register_2
   1594          
   1595          	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
   \                     ??dir_register_1: (+1)
   \   00000038   0x07C0             LSLS     R0,R0,#+31
   \   0000003A   0xD51E             BPL      ??dir_register_3
   1596          		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
   \   0000003C   0x2500             MOVS     R5,#+0
   \   0000003E   0x9901             LDR      R1,[SP, #+4]
   \   00000040   0x72CD             STRB     R5,[R1, #+11]
   \   00000042   0x61E5             STR      R5,[R4, #+28]
   1597          		for (n = 1; n < 100; n++) {
   \   00000044   0x2501             MOVS     R5,#+1
   1598          			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
   \                     ??dir_register_4: (+1)
   \   00000046   0x002B             MOVS     R3,R5
   \   00000048   0x9A00             LDR      R2,[SP, #+0]
   \   0000004A   0xA905             ADD      R1,SP,#+20
   \   0000004C   0x9801             LDR      R0,[SP, #+4]
   \   0000004E   0x.... 0x....      BL       _Z11gen_numnamePhPKhPKtj
   1599          			res = dir_find(dp);				/* Check if the name collides with existing SFN */
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       _Z8dir_findP9FATFS_DIR
   \   00000058   0x0007             MOVS     R7,R0
   1600          			if (res != FR_OK) break;
   \   0000005A   0xD102             BNE      ??dir_register_5
   1601          		}
   \   0000005C   0x1C6D             ADDS     R5,R5,#+1
   \   0000005E   0x2D64             CMP      R5,#+100
   \   00000060   0xD3F1             BCC      ??dir_register_4
   1602          		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
   \                     ??dir_register_5: (+1)
   \   00000062   0x2D64             CMP      R5,#+100
   \   00000064   0xD101             BNE      ??dir_register_6
   \   00000066   0x2007             MOVS     R0,#+7
   \   00000068   0xE15B             B        ??dir_register_2
   1603          		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
   \                     ??dir_register_6: (+1)
   \   0000006A   0x2F04             CMP      R7,#+4
   \   0000006C   0xD000             BEQ      .+4
   \   0000006E   0xE157             B        ??dir_register_7
   1604          		fn[NSFLAG] = sn[NSFLAG]; dp->lfn = lfn;
   \   00000070   0x7AF0             LDRB     R0,[R6, #+11]
   \   00000072   0x9901             LDR      R1,[SP, #+4]
   \   00000074   0x72C8             STRB     R0,[R1, #+11]
   \   00000076   0x9800             LDR      R0,[SP, #+0]
   \   00000078   0x61E0             STR      R0,[R4, #+28]
   \                     ??dir_register_3: (+1)
   \   0000007A   0x7AF0             LDRB     R0,[R6, #+11]
   \   0000007C   0x0780             LSLS     R0,R0,#+30
   \   0000007E   0xD50D             BPL      ??dir_register_8
   1605          	}
   1606          
   1607          	if (sn[NSFLAG] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
   1608          		for (n = 0; lfn[n]; n++) ;
   \   00000080   0x2500             MOVS     R5,#+0
   \   00000082   0x9800             LDR      R0,[SP, #+0]
   \   00000084   0xE001             B        ??dir_register_9
   \                     ??dir_register_10: (+1)
   \   00000086   0x1C6D             ADDS     R5,R5,#+1
   \   00000088   0x1C80             ADDS     R0,R0,#+2
   \                     ??dir_register_9: (+1)
   \   0000008A   0x8801             LDRH     R1,[R0, #+0]
   \   0000008C   0x2900             CMP      R1,#+0
   \   0000008E   0xD1FA             BNE      ??dir_register_10
   1609          		nent = (n + 25) / 13;
   \   00000090   0x3519             ADDS     R5,R5,#+25
   \   00000092   0x0028             MOVS     R0,R5
   \   00000094   0x210D             MOVS     R1,#+13
   \   00000096   0x.... 0x....      BL       __aeabi_uidiv
   \   0000009A   0xE000             B        ??dir_register_11
   1610          	} else {						/* Otherwise allocate an entry for an SFN  */
   1611          		nent = 1;
   \                     ??dir_register_8: (+1)
   \   0000009C   0x2001             MOVS     R0,#+1
   \                     ??dir_register_11: (+1)
   \   0000009E   0x9002             STR      R0,[SP, #+8]
   1612          	}
   1613          	res = dir_alloc(dp, nent);		/* Allocate entries */
   \   000000A0   0x2100             MOVS     R1,#+0
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0x.... 0x....      BL       _Z7dir_sdiP9FATFS_DIRj
   \   000000A8   0x0006             MOVS     R6,R0
   \   000000AA   0xD000             BEQ      .+4
   \   000000AC   0xE0A6             B        ??dir_register_12
   \   000000AE   0x2500             MOVS     R5,#+0
   \   000000B0   0x9500             STR      R5,[SP, #+0]
   \   000000B2   0xE02B             B        ??dir_register_13
   \                     ??dir_register_14: (+1)
   \   000000B4   0x9800             LDR      R0,[SP, #+0]
   \   000000B6   0x1C40             ADDS     R0,R0,#+1
   \   000000B8   0x9000             STR      R0,[SP, #+0]
   \   000000BA   0x9902             LDR      R1,[SP, #+8]
   \   000000BC   0x4288             CMP      R0,R1
   \   000000BE   0xD100             BNE      .+4
   \   000000C0   0xE09E             B        ??dir_register_15
   \                     ??dir_register_16: (+1)
   \   000000C2   0x88E0             LDRH     R0,[R4, #+6]
   \   000000C4   0x1C40             ADDS     R0,R0,#+1
   \   000000C6   0x9004             STR      R0,[SP, #+16]
   \   000000C8   0x0400             LSLS     R0,R0,#+16
   \   000000CA   0xD05F             BEQ      ??dir_register_17
   \   000000CC   0x6927             LDR      R7,[R4, #+16]
   \   000000CE   0x2F00             CMP      R7,#+0
   \   000000D0   0xD05C             BEQ      ??dir_register_17
   \   000000D2   0x6826             LDR      R6,[R4, #+0]
   \   000000D4   0x9804             LDR      R0,[SP, #+16]
   \   000000D6   0x8971             LDRH     R1,[R6, #+10]
   \   000000D8   0x0949             LSRS     R1,R1,#+5
   \   000000DA   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000DE   0x2900             CMP      R1,#+0
   \   000000E0   0xD108             BNE      ??dir_register_18
   \   000000E2   0x1C7F             ADDS     R7,R7,#+1
   \   000000E4   0x6127             STR      R7,[R4, #+16]
   \   000000E6   0x68E7             LDR      R7,[R4, #+12]
   \   000000E8   0x2F00             CMP      R7,#+0
   \   000000EA   0x9804             LDR      R0,[SP, #+16]
   \   000000EC   0xD132             BNE      ??dir_register_19
   \   000000EE   0x8931             LDRH     R1,[R6, #+8]
   \   000000F0   0x4288             CMP      R0,R1
   \   000000F2   0xD24B             BCS      ??dir_register_17
   \                     ??dir_register_18: (+1)
   \   000000F4   0x9804             LDR      R0,[SP, #+16]
   \   000000F6   0x80E0             STRH     R0,[R4, #+6]
   \   000000F8   0x6821             LDR      R1,[R4, #+0]
   \   000000FA   0x6B4E             LDR      R6,[R1, #+52]
   \   000000FC   0x9804             LDR      R0,[SP, #+16]
   \   000000FE   0x8949             LDRH     R1,[R1, #+10]
   \   00000100   0x0949             LSRS     R1,R1,#+5
   \   00000102   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000106   0x0148             LSLS     R0,R1,#+5
   \   00000108   0x1830             ADDS     R0,R6,R0
   \   0000010A   0x6160             STR      R0,[R4, #+20]
   \                     ??dir_register_13: (+1)
   \   0000010C   0x6927             LDR      R7,[R4, #+16]
   \   0000010E   0x6820             LDR      R0,[R4, #+0]
   \   00000110   0x9001             STR      R0,[SP, #+4]
   \   00000112   0x2600             MOVS     R6,#+0
   \   00000114   0x6B00             LDR      R0,[R0, #+48]
   \   00000116   0x4287             CMP      R7,R0
   \   00000118   0xD012             BEQ      ??dir_register_20
   \   0000011A   0x9801             LDR      R0,[SP, #+4]
   \   0000011C   0x.... 0x....      BL       _Z11sync_windowP5FATFS
   \   00000120   0x0006             MOVS     R6,R0
   \   00000122   0xD10D             BNE      ??dir_register_20
   \   00000124   0x2301             MOVS     R3,#+1
   \   00000126   0x003A             MOVS     R2,R7
   \   00000128   0x9801             LDR      R0,[SP, #+4]
   \   0000012A   0x6B41             LDR      R1,[R0, #+52]
   \   0000012C   0x7840             LDRB     R0,[R0, #+1]
   \   0000012E   0x.... 0x....      BL       disk_read
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD002             BEQ      ??dir_register_21
   \   00000136   0x2700             MOVS     R7,#+0
   \   00000138   0x43FF             MVNS     R7,R7            ;; #-1
   \   0000013A   0x2601             MOVS     R6,#+1
   \                     ??dir_register_21: (+1)
   \   0000013C   0x9801             LDR      R0,[SP, #+4]
   \   0000013E   0x6307             STR      R7,[R0, #+48]
   \                     ??dir_register_20: (+1)
   \   00000140   0x0030             MOVS     R0,R6
   \   00000142   0xD15B             BNE      ??dir_register_12
   \   00000144   0x6960             LDR      R0,[R4, #+20]
   \   00000146   0x7800             LDRB     R0,[R0, #+0]
   \   00000148   0x28E5             CMP      R0,#+229
   \   0000014A   0xD0B3             BEQ      ??dir_register_14
   \   0000014C   0x2800             CMP      R0,#+0
   \   0000014E   0xD0B1             BEQ      ??dir_register_14
   \   00000150   0x9500             STR      R5,[SP, #+0]
   \   00000152   0xE7B6             B        ??dir_register_16
   \                     ??dir_register_19: (+1)
   \   00000154   0x8971             LDRH     R1,[R6, #+10]
   \   00000156   0x0949             LSRS     R1,R1,#+5
   \   00000158   0x.... 0x....      BL       __aeabi_uidiv
   \   0000015C   0x78B1             LDRB     R1,[R6, #+2]
   \   0000015E   0x1E49             SUBS     R1,R1,#+1
   \   00000160   0x4001             ANDS     R1,R1,R0
   \   00000162   0xD1C7             BNE      ??dir_register_18
   \   00000164   0x0039             MOVS     R1,R7
   \   00000166   0x0030             MOVS     R0,R6
   \   00000168   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   \   0000016C   0x0007             MOVS     R7,R0
   \   0000016E   0x2F02             CMP      R7,#+2
   \   00000170   0xD342             BCC      ??dir_register_22
   \   00000172   0x2600             MOVS     R6,#+0
   \   00000174   0x43F6             MVNS     R6,R6            ;; #-1
   \   00000176   0x42B7             CMP      R7,R6
   \   00000178   0xD03C             BEQ      ??dir_register_23
   \   0000017A   0x6820             LDR      R0,[R4, #+0]
   \   0000017C   0x6981             LDR      R1,[R0, #+24]
   \   0000017E   0x428F             CMP      R7,R1
   \   00000180   0xD331             BCC      ??dir_register_24
   \   00000182   0x68E1             LDR      R1,[R4, #+12]
   \   00000184   0x.... 0x....      BL       _Z12create_chainP5FATFSm
   \   00000188   0x0007             MOVS     R7,R0
   \   0000018A   0xD101             BNE      ??dir_register_25
   \                     ??dir_register_17: (+1)
   \   0000018C   0x2607             MOVS     R6,#+7
   \   0000018E   0xE037             B        ??dir_register_15
   \                     ??dir_register_25: (+1)
   \   00000190   0x2F01             CMP      R7,#+1
   \   00000192   0xD031             BEQ      ??dir_register_22
   \   00000194   0x42B7             CMP      R7,R6
   \   00000196   0xD02D             BEQ      ??dir_register_23
   \   00000198   0x6820             LDR      R0,[R4, #+0]
   \   0000019A   0x.... 0x....      BL       _Z11sync_windowP5FATFS
   \   0000019E   0x2800             CMP      R0,#+0
   \   000001A0   0xD128             BNE      ??dir_register_23
   \   000001A2   0x6820             LDR      R0,[R4, #+0]
   \   000001A4   0x8941             LDRH     R1,[R0, #+10]
   \   000001A6   0x2900             CMP      R1,#+0
   \   000001A8   0xD002             BEQ      ??dir_register_26
   \   000001AA   0x6B40             LDR      R0,[R0, #+52]
   \   000001AC   0x.... 0x....      BL       __aeabi_memclr
   \                     ??dir_register_26: (+1)
   \   000001B0   0x0039             MOVS     R1,R7
   \   000001B2   0x6820             LDR      R0,[R4, #+0]
   \   000001B4   0x.... 0x....      BL       _Z10clust2sectP5FATFSm
   \   000001B8   0x6821             LDR      R1,[R4, #+0]
   \   000001BA   0x6308             STR      R0,[R1, #+48]
   \   000001BC   0x2600             MOVS     R6,#+0
   \   000001BE   0xE00B             B        ??dir_register_27
   \                     ??dir_register_28: (+1)
   \   000001C0   0x2101             MOVS     R1,#+1
   \   000001C2   0x7101             STRB     R1,[R0, #+4]
   \   000001C4   0x6820             LDR      R0,[R4, #+0]
   \   000001C6   0x.... 0x....      BL       _Z11sync_windowP5FATFS
   \   000001CA   0x2800             CMP      R0,#+0
   \   000001CC   0xD112             BNE      ??dir_register_23
   \   000001CE   0x6820             LDR      R0,[R4, #+0]
   \   000001D0   0x6B01             LDR      R1,[R0, #+48]
   \   000001D2   0x1C49             ADDS     R1,R1,#+1
   \   000001D4   0x6301             STR      R1,[R0, #+48]
   \   000001D6   0x1C76             ADDS     R6,R6,#+1
   \                     ??dir_register_27: (+1)
   \   000001D8   0x6820             LDR      R0,[R4, #+0]
   \   000001DA   0x7881             LDRB     R1,[R0, #+2]
   \   000001DC   0x428E             CMP      R6,R1
   \   000001DE   0xD3EF             BCC      ??dir_register_28
   \   000001E0   0x6B01             LDR      R1,[R0, #+48]
   \   000001E2   0x1B89             SUBS     R1,R1,R6
   \   000001E4   0x6301             STR      R1,[R0, #+48]
   \                     ??dir_register_24: (+1)
   \   000001E6   0x60E7             STR      R7,[R4, #+12]
   \   000001E8   0x0039             MOVS     R1,R7
   \   000001EA   0x6820             LDR      R0,[R4, #+0]
   \   000001EC   0x.... 0x....      BL       _Z10clust2sectP5FATFSm
   \   000001F0   0x6120             STR      R0,[R4, #+16]
   \   000001F2   0xE77F             B        ??dir_register_18
   \                     ??dir_register_23: (+1)
   \   000001F4   0x2601             MOVS     R6,#+1
   \   000001F6   0xE003             B        ??dir_register_15
   \                     ??dir_register_22: (+1)
   \   000001F8   0x2602             MOVS     R6,#+2
   \   000001FA   0xE001             B        ??dir_register_15
   \                     ??dir_register_12: (+1)
   \   000001FC   0x2E04             CMP      R6,#+4
   \   000001FE   0xD0C5             BEQ      ??dir_register_17
   \                     ??dir_register_15: (+1)
   \   00000200   0x0037             MOVS     R7,R6
   1614          
   1615          	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
   \   00000202   0xD169             BNE      ??dir_register_29
   \   00000204   0x9802             LDR      R0,[SP, #+8]
   \   00000206   0x1E40             SUBS     R0,R0,#+1
   \   00000208   0x9002             STR      R0,[SP, #+8]
   \   0000020A   0xD067             BEQ      ??dir_register_30
   1616          		res = dir_sdi(dp, dp->index - nent);
   \   0000020C   0x88E0             LDRH     R0,[R4, #+6]
   \   0000020E   0x9902             LDR      R1,[SP, #+8]
   \   00000210   0x1A41             SUBS     R1,R0,R1
   \   00000212   0x0020             MOVS     R0,R4
   \   00000214   0x.... 0x....      BL       _Z7dir_sdiP9FATFS_DIRj
   \   00000218   0x0007             MOVS     R7,R0
   1617          		if (res == FR_OK) {
   \   0000021A   0xD15D             BNE      ??dir_register_29
   1618          			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
   \   0000021C   0x69A0             LDR      R0,[R4, #+24]
   \   0000021E   0x.... 0x....      BL       _Z7sum_sfnPKh
   \   00000222   0x4669             MOV      R1,SP
   \   00000224   0x7348             STRB     R0,[R1, #+13]
   1619          			do {					/* Store LFN entries in bottom first */
   1620          				res = move_window(dp->fs, dp->sect);
   \                     ??dir_register_31: (+1)
   \   00000226   0x6921             LDR      R1,[R4, #+16]
   \   00000228   0x6820             LDR      R0,[R4, #+0]
   \   0000022A   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   0000022E   0x0007             MOVS     R7,R0
   1621          				if (res != FR_OK) break;
   \   00000230   0xD152             BNE      ??dir_register_29
   1622          				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
   \   00000232   0x9802             LDR      R0,[SP, #+8]
   \   00000234   0x4669             MOV      R1,SP
   \   00000236   0x7308             STRB     R0,[R1, #+12]
   \   00000238   0x6960             LDR      R0,[R4, #+20]
   \   0000023A   0x9000             STR      R0,[SP, #+0]
   \   0000023C   0x69E0             LDR      R0,[R4, #+28]
   \   0000023E   0x9001             STR      R0,[SP, #+4]
   \   00000240   0x4668             MOV      R0,SP
   \   00000242   0x7B40             LDRB     R0,[R0, #+13]
   \   00000244   0x9900             LDR      R1,[SP, #+0]
   \   00000246   0x7348             STRB     R0,[R1, #+13]
   \   00000248   0x200F             MOVS     R0,#+15
   \   0000024A   0x9900             LDR      R1,[SP, #+0]
   \   0000024C   0x72C8             STRB     R0,[R1, #+11]
   \   0000024E   0x2500             MOVS     R5,#+0
   \   00000250   0x9900             LDR      R1,[SP, #+0]
   \   00000252   0x730D             STRB     R5,[R1, #+12]
   \   00000254   0x9900             LDR      R1,[SP, #+0]
   \   00000256   0x768D             STRB     R5,[R1, #+26]
   \   00000258   0x9800             LDR      R0,[SP, #+0]
   \   0000025A   0x76C5             STRB     R5,[R0, #+27]
   \   0000025C   0x4668             MOV      R0,SP
   \   0000025E   0x7B00             LDRB     R0,[R0, #+12]
   \   00000260   0x1E40             SUBS     R0,R0,#+1
   \   00000262   0x210D             MOVS     R1,#+13
   \   00000264   0x4348             MULS     R0,R1,R0
   \   00000266   0xBF00             Nop      
   \   00000268   0x....             ADR.N    R1,LfnOfs
   \   0000026A   0x220D             MOVS     R2,#+13
   \   0000026C   0xE002             B        ??dir_register_32
   \                     ??dir_register_33: (+1)
   \   0000026E   0x....             LDR      R5,??DataTable15  ;; 0xffff
   \   00000270   0x42AB             CMP      R3,R5
   \   00000272   0xD003             BEQ      ??dir_register_34
   \                     ??dir_register_32: (+1)
   \   00000274   0x9B01             LDR      R3,[SP, #+4]
   \   00000276   0x0045             LSLS     R5,R0,#+1
   \   00000278   0x5B5B             LDRH     R3,[R3, R5]
   \   0000027A   0x1C40             ADDS     R0,R0,#+1
   \                     ??dir_register_34: (+1)
   \   0000027C   0x9E00             LDR      R6,[SP, #+0]
   \   0000027E   0x780F             LDRB     R7,[R1, #+0]
   \   00000280   0x55F3             STRB     R3,[R6, R7]
   \   00000282   0x121D             ASRS     R5,R3,#+8
   \   00000284   0x9E00             LDR      R6,[SP, #+0]
   \   00000286   0x780F             LDRB     R7,[R1, #+0]
   \   00000288   0x19F6             ADDS     R6,R6,R7
   \   0000028A   0x7075             STRB     R5,[R6, #+1]
   \   0000028C   0x2B00             CMP      R3,#+0
   \   0000028E   0xD100             BNE      ??dir_register_35
   \   00000290   0x....             LDR      R3,??DataTable15  ;; 0xffff
   \                     ??dir_register_35: (+1)
   \   00000292   0x1C49             ADDS     R1,R1,#+1
   \   00000294   0x1E52             SUBS     R2,R2,#+1
   \   00000296   0xD1EA             BNE      ??dir_register_33
   \   00000298   0x....             LDR      R1,??DataTable15  ;; 0xffff
   \   0000029A   0x428B             CMP      R3,R1
   \   0000029C   0xD004             BEQ      ??dir_register_36
   \   0000029E   0x9901             LDR      R1,[SP, #+4]
   \   000002A0   0x0040             LSLS     R0,R0,#+1
   \   000002A2   0x5A08             LDRH     R0,[R1, R0]
   \   000002A4   0x2800             CMP      R0,#+0
   \   000002A6   0xD105             BNE      ??dir_register_37
   \                     ??dir_register_36: (+1)
   \   000002A8   0x4668             MOV      R0,SP
   \   000002AA   0x7B00             LDRB     R0,[R0, #+12]
   \   000002AC   0x2140             MOVS     R1,#+64
   \   000002AE   0x4301             ORRS     R1,R1,R0
   \   000002B0   0x4668             MOV      R0,SP
   \   000002B2   0x7301             STRB     R1,[R0, #+12]
   \                     ??dir_register_37: (+1)
   \   000002B4   0x4668             MOV      R0,SP
   \   000002B6   0x7B00             LDRB     R0,[R0, #+12]
   \   000002B8   0x9900             LDR      R1,[SP, #+0]
   \   000002BA   0x7008             STRB     R0,[R1, #+0]
   1623          				dp->fs->wflag = 1;
   \   000002BC   0x2001             MOVS     R0,#+1
   \   000002BE   0x6821             LDR      R1,[R4, #+0]
   \   000002C0   0x7108             STRB     R0,[R1, #+4]
   1624          				res = dir_next(dp, 0);	/* Next entry */
   \   000002C2   0x2100             MOVS     R1,#+0
   \   000002C4   0x0020             MOVS     R0,R4
   \   000002C6   0x.... 0x....      BL       _Z8dir_nextP9FATFS_DIRi
   \   000002CA   0x0007             MOVS     R7,R0
   1625          			} while (res == FR_OK && --nent);
   \   000002CC   0xD104             BNE      ??dir_register_29
   \   000002CE   0x9802             LDR      R0,[SP, #+8]
   \   000002D0   0x1E40             SUBS     R0,R0,#+1
   \   000002D2   0x9002             STR      R0,[SP, #+8]
   \   000002D4   0xD1A7             BNE      ??dir_register_31
   \   000002D6   0xE001             B        ??dir_register_30
   1626          		}
   1627          	}
   1628          #else	/* Non LFN configuration */
   1629          	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
   1630          #endif
   1631          
   1632          	if (res == FR_OK) {				/* Set SFN entry */
   \                     ??dir_register_29: (+1)
   \   000002D8   0x0038             MOVS     R0,R7
   \   000002DA   0xD121             BNE      ??dir_register_7
   1633          		res = move_window(dp->fs, dp->sect);
   \                     ??dir_register_30: (+1)
   \   000002DC   0x6921             LDR      R1,[R4, #+16]
   \   000002DE   0x6820             LDR      R0,[R4, #+0]
   \   000002E0   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   000002E4   0x0007             MOVS     R7,R0
   1634          		if (res == FR_OK) {
   \   000002E6   0xD11B             BNE      ??dir_register_7
   1635          			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
   \   000002E8   0x2120             MOVS     R1,#+32
   \   000002EA   0x6960             LDR      R0,[R4, #+20]
   \   000002EC   0x.... 0x....      BL       __aeabi_memclr
   1636          			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
   \   000002F0   0x6960             LDR      R0,[R4, #+20]
   \   000002F2   0x69A1             LDR      R1,[R4, #+24]
   \   000002F4   0x780A             LDRB     R2,[R1, #+0]
   \   000002F6   0x7002             STRB     R2,[R0, #+0]
   \   000002F8   0x1C49             ADDS     R1,R1,#+1
   \   000002FA   0x1C40             ADDS     R0,R0,#+1
   \   000002FC   0x2205             MOVS     R2,#+5
   \                     ??dir_register_38: (+1)
   \   000002FE   0x780B             LDRB     R3,[R1, #+0]
   \   00000300   0x7003             STRB     R3,[R0, #+0]
   \   00000302   0x784B             LDRB     R3,[R1, #+1]
   \   00000304   0x7043             STRB     R3,[R0, #+1]
   \   00000306   0x1C89             ADDS     R1,R1,#+2
   \   00000308   0x1C80             ADDS     R0,R0,#+2
   \   0000030A   0x1E52             SUBS     R2,R2,#+1
   \   0000030C   0xD1F7             BNE      ??dir_register_38
   1637          #if _USE_LFN
   1638          			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
   \   0000030E   0x69A0             LDR      R0,[R4, #+24]
   \   00000310   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000312   0x2118             MOVS     R1,#+24
   \   00000314   0x4001             ANDS     R1,R1,R0
   \   00000316   0x6960             LDR      R0,[R4, #+20]
   \   00000318   0x7301             STRB     R1,[R0, #+12]
   1639          #endif
   1640          			dp->fs->wflag = 1;
   \   0000031A   0x2001             MOVS     R0,#+1
   \   0000031C   0x6821             LDR      R1,[R4, #+0]
   \   0000031E   0x7108             STRB     R0,[R1, #+4]
   1641          		}
   1642          	}
   1643          
   1644          	return res;
   \                     ??dir_register_7: (+1)
   \   00000320   0x0038             MOVS     R0,R7
   \                     ??dir_register_2: (+1)
   \   00000322   0xB009             ADD      SP,SP,#+36
   \   00000324   0xBDF0             POP      {R4-R7,PC}       ;; return
   1645          }
   1646          #endif /* !_FS_READONLY */
   1647          
   1648          
   1649          
   1650          
   1651          /*-----------------------------------------------------------------------*/
   1652          /* Remove an object from the directory                                   */
   1653          /*-----------------------------------------------------------------------*/
   1654          #if !_FS_READONLY && !_FS_MINIMIZE

   \                                 In section .text, align 2, keep-with-next
   1655          static
   1656          FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
   1657          	FATFS_DIR* dp				/* Directory object pointing the entry to be removed */
   1658          )
   1659          {
   \                     _Z10dir_removeP9FATFS_DIR: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   1660          	FRESULT res;
   1661          #if _USE_LFN	/* LFN configuration */
   1662          	UINT i;
   1663          
   1664          	i = dp->index;	/* SFN index */
   \   00000004   0x88F0             LDRH     R0,[R6, #+6]
   \   00000006   0x9000             STR      R0,[SP, #+0]
   1665          	res = dir_sdi(dp, (dp->lfn_idx == 0xFFFF) ? i : dp->lfn_idx);	/* Goto the SFN or top of the LFN entries */
   \   00000008   0x8C31             LDRH     R1,[R6, #+32]
   \   0000000A   0x....             LDR      R0,??DataTable15  ;; 0xffff
   \   0000000C   0x4281             CMP      R1,R0
   \   0000000E   0xD100             BNE      ??dir_remove_0
   \   00000010   0x9900             LDR      R1,[SP, #+0]
   \                     ??dir_remove_0: (+1)
   \   00000012   0x0030             MOVS     R0,R6
   \   00000014   0x.... 0x....      BL       _Z7dir_sdiP9FATFS_DIRj
   \   00000018   0x0004             MOVS     R4,R0
   1666          	if (res == FR_OK) {
   \   0000001A   0xD16A             BNE      ??dir_remove_1
   \   0000001C   0xE026             B        ??dir_remove_2
   1667          		do {
   1668          			res = move_window(dp->fs, dp->sect);
   1669          			if (res != FR_OK) break;
   1670          			mem_set(dp->dir, 0, SZ_DIRE);	/* Clear and mark the entry "deleted" */
   1671          			*dp->dir = DDEM;
   1672          			dp->fs->wflag = 1;
   1673          			if (dp->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
   1674          			res = dir_next(dp, 0);		/* Next entry */
   \                     ??dir_remove_3: (+1)
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x8969             LDRH     R1,[R5, #+10]
   \   00000022   0x0949             LSRS     R1,R1,#+5
   \   00000024   0x.... 0x....      BL       __aeabi_uidiv
   \   00000028   0x78A9             LDRB     R1,[R5, #+2]
   \   0000002A   0x1E49             SUBS     R1,R1,#+1
   \   0000002C   0x4001             ANDS     R1,R1,R0
   \   0000002E   0xD112             BNE      ??dir_remove_4
   \   00000030   0x0039             MOVS     R1,R7
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   \   00000038   0x0001             MOVS     R1,R0
   \   0000003A   0x2902             CMP      R1,#+2
   \   0000003C   0xD353             BCC      ??dir_remove_5
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000042   0x4281             CMP      R1,R0
   \   00000044   0xD051             BEQ      ??dir_remove_6
   \   00000046   0x6830             LDR      R0,[R6, #+0]
   \   00000048   0x6982             LDR      R2,[R0, #+24]
   \   0000004A   0x4291             CMP      R1,R2
   \   0000004C   0xD24B             BCS      ??dir_remove_5
   \   0000004E   0x60F1             STR      R1,[R6, #+12]
   \   00000050   0x.... 0x....      BL       _Z10clust2sectP5FATFSm
   \   00000054   0x6130             STR      R0,[R6, #+16]
   \                     ??dir_remove_4: (+1)
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x80F0             STRH     R0,[R6, #+6]
   \   0000005A   0x6831             LDR      R1,[R6, #+0]
   \   0000005C   0x6B4D             LDR      R5,[R1, #+52]
   \   0000005E   0x8949             LDRH     R1,[R1, #+10]
   \   00000060   0x0949             LSRS     R1,R1,#+5
   \   00000062   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000066   0x0148             LSLS     R0,R1,#+5
   \   00000068   0x1828             ADDS     R0,R5,R0
   \   0000006A   0x6170             STR      R0,[R6, #+20]
   \                     ??dir_remove_2: (+1)
   \   0000006C   0x6935             LDR      R5,[R6, #+16]
   \   0000006E   0x6837             LDR      R7,[R6, #+0]
   \   00000070   0x2400             MOVS     R4,#+0
   \   00000072   0x6B38             LDR      R0,[R7, #+48]
   \   00000074   0x4285             CMP      R5,R0
   \   00000076   0xD010             BEQ      ??dir_remove_7
   \   00000078   0x0038             MOVS     R0,R7
   \   0000007A   0x.... 0x....      BL       _Z11sync_windowP5FATFS
   \   0000007E   0x0004             MOVS     R4,R0
   \   00000080   0xD10B             BNE      ??dir_remove_7
   \   00000082   0x2301             MOVS     R3,#+1
   \   00000084   0x002A             MOVS     R2,R5
   \   00000086   0x6B79             LDR      R1,[R7, #+52]
   \   00000088   0x7878             LDRB     R0,[R7, #+1]
   \   0000008A   0x.... 0x....      BL       disk_read
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD002             BEQ      ??dir_remove_8
   \   00000092   0x2500             MOVS     R5,#+0
   \   00000094   0x43ED             MVNS     R5,R5            ;; #-1
   \   00000096   0x2401             MOVS     R4,#+1
   \                     ??dir_remove_8: (+1)
   \   00000098   0x633D             STR      R5,[R7, #+48]
   \                     ??dir_remove_7: (+1)
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0xD127             BNE      ??dir_remove_9
   \   0000009E   0x2120             MOVS     R1,#+32
   \   000000A0   0x6970             LDR      R0,[R6, #+20]
   \   000000A2   0x.... 0x....      BL       __aeabi_memclr
   \   000000A6   0x20E5             MOVS     R0,#+229
   \   000000A8   0x6971             LDR      R1,[R6, #+20]
   \   000000AA   0x7008             STRB     R0,[R1, #+0]
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x6831             LDR      R1,[R6, #+0]
   \   000000B0   0x7108             STRB     R0,[R1, #+4]
   \   000000B2   0x88F0             LDRH     R0,[R6, #+6]
   \   000000B4   0x9900             LDR      R1,[SP, #+0]
   \   000000B6   0x4288             CMP      R0,R1
   \   000000B8   0xD21B             BCS      ??dir_remove_1
   \   000000BA   0x1C44             ADDS     R4,R0,#+1
   \   000000BC   0x0420             LSLS     R0,R4,#+16
   \   000000BE   0xD012             BEQ      ??dir_remove_5
   \   000000C0   0x6937             LDR      R7,[R6, #+16]
   \   000000C2   0x2F00             CMP      R7,#+0
   \   000000C4   0xD00F             BEQ      ??dir_remove_5
   \   000000C6   0x6835             LDR      R5,[R6, #+0]
   \   000000C8   0x0020             MOVS     R0,R4
   \   000000CA   0x8969             LDRH     R1,[R5, #+10]
   \   000000CC   0x0949             LSRS     R1,R1,#+5
   \   000000CE   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000D2   0x2900             CMP      R1,#+0
   \   000000D4   0xD1BF             BNE      ??dir_remove_4
   \   000000D6   0x1C7F             ADDS     R7,R7,#+1
   \   000000D8   0x6137             STR      R7,[R6, #+16]
   \   000000DA   0x68F7             LDR      R7,[R6, #+12]
   \   000000DC   0x2F00             CMP      R7,#+0
   \   000000DE   0xD19E             BNE      ??dir_remove_3
   \   000000E0   0x8928             LDRH     R0,[R5, #+8]
   \   000000E2   0x4284             CMP      R4,R0
   \   000000E4   0xD3B7             BCC      ??dir_remove_4
   \                     ??dir_remove_5: (+1)
   \   000000E6   0x2402             MOVS     R4,#+2
   \   000000E8   0xE003             B        ??dir_remove_1
   \                     ??dir_remove_6: (+1)
   \   000000EA   0x2401             MOVS     R4,#+1
   \   000000EC   0xE001             B        ??dir_remove_1
   1675          		} while (res == FR_OK);
   1676          		if (res == FR_NO_FILE) res = FR_INT_ERR;
   \                     ??dir_remove_9: (+1)
   \   000000EE   0x2C04             CMP      R4,#+4
   \   000000F0   0xD0F9             BEQ      ??dir_remove_5
   1677          	}
   1678          
   1679          #else			/* Non LFN configuration */
   1680          	res = dir_sdi(dp, dp->index);
   1681          	if (res == FR_OK) {
   1682          		res = move_window(dp->fs, dp->sect);
   1683          		if (res == FR_OK) {
   1684          			mem_set(dp->dir, 0, SZ_DIRE);	/* Clear and mark the entry "deleted" */
   1685          			*dp->dir = DDEM;
   1686          			dp->fs->wflag = 1;
   1687          		}
   1688          	}
   1689          #endif
   1690          
   1691          	return res;
   \                     ??dir_remove_1: (+1)
   \   000000F2   0x0020             MOVS     R0,R4
   \   000000F4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1692          }
   1693          #endif /* !_FS_READONLY */
   1694          
   1695          
   1696          
   1697          
   1698          /*-----------------------------------------------------------------------*/
   1699          /* Get file information from directory entry                             */
   1700          /*-----------------------------------------------------------------------*/
   1701          #if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2

   \                                 In section .text, align 2, keep-with-next
   1702          static
   1703          void get_fileinfo (		/* No return code */
   1704          	FATFS_DIR* dp,			/* Pointer to the directory object */
   1705          	FILINFO* fno	 	/* Pointer to the file information to be filled */
   1706          )
   1707          {
   \                     _Z12get_fileinfoP9FATFS_DIRP7FILINFO: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   1708          	UINT i;
   1709          	TCHAR *p, c;
   1710          	BYTE *dir;
   1711          #if _USE_LFN
   1712          	WCHAR w, *lfn;
   1713          #endif
   1714          
   1715          	p = fno->fname;
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x3509             ADDS     R5,R5,#+9
   \   00000006   0x6901             LDR      R1,[R0, #+16]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD03A             BEQ      ??get_fileinfo_0
   1716          	if (dp->sect) {		/* Get SFN */
   1717          		dir = dp->dir;
   \   0000000C   0x6941             LDR      R1,[R0, #+20]
   1718          		i = 0;
   \   0000000E   0x2400             MOVS     R4,#+0
   1719          		while (i < 11) {		/* Copy name body and extension */
   1720          			c = (TCHAR)dir[i++];
   \                     ??get_fileinfo_1: (+1)
   \   00000010   0x5D0B             LDRB     R3,[R1, R4]
   \   00000012   0x1C64             ADDS     R4,R4,#+1
   1721          			if (c == ' ') continue;				/* Skip padding spaces */
   \   00000014   0x2B20             CMP      R3,#+32
   \   00000016   0xD017             BEQ      ??get_fileinfo_2
   1722          			if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
   \   00000018   0x2B05             CMP      R3,#+5
   \   0000001A   0xD100             BNE      ??get_fileinfo_3
   \   0000001C   0x23E5             MOVS     R3,#+229
   1723          			if (i == 9) *p++ = '.';				/* Insert a . if extension is exist */
   \                     ??get_fileinfo_3: (+1)
   \   0000001E   0x2C09             CMP      R4,#+9
   \   00000020   0xD102             BNE      ??get_fileinfo_4
   \   00000022   0x262E             MOVS     R6,#+46
   \   00000024   0x702E             STRB     R6,[R5, #+0]
   \   00000026   0x1C6D             ADDS     R5,R5,#+1
   1724          #if _USE_LFN
   1725          			if (IsUpper(c) && (dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY)))
   \                     ??get_fileinfo_4: (+1)
   \   00000028   0x001E             MOVS     R6,R3
   \   0000002A   0x3E41             SUBS     R6,R6,#+65
   \   0000002C   0x2E1A             CMP      R6,#+26
   \   0000002E   0xD209             BCS      ??get_fileinfo_5
   \   00000030   0x2C09             CMP      R4,#+9
   \   00000032   0xD301             BCC      ??get_fileinfo_6
   \   00000034   0x2610             MOVS     R6,#+16
   \   00000036   0xE000             B        ??get_fileinfo_7
   \                     ??get_fileinfo_6: (+1)
   \   00000038   0x2608             MOVS     R6,#+8
   \                     ??get_fileinfo_7: (+1)
   \   0000003A   0x7B0F             LDRB     R7,[R1, #+12]
   \   0000003C   0x4237             TST      R7,R6
   \   0000003E   0xD001             BEQ      ??get_fileinfo_5
   1726          				c += 0x20;			/* To lower */
   \   00000040   0x3320             ADDS     R3,R3,#+32
   \   00000042   0xB2DB             UXTB     R3,R3
   1727          #if _LFN_UNICODE
   1728          			if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dir[i]))
   1729          				c = c << 8 | dir[i++];
   1730          			c = ff_convert(c, 1);	/* OEM -> Unicode */
   1731          			if (!c) c = '?';
   1732          #endif
   1733          #endif
   1734          			*p++ = c;
   \                     ??get_fileinfo_5: (+1)
   \   00000044   0x702B             STRB     R3,[R5, #+0]
   \   00000046   0x1C6D             ADDS     R5,R5,#+1
   1735          		}
   \                     ??get_fileinfo_2: (+1)
   \   00000048   0x2C0B             CMP      R4,#+11
   \   0000004A   0xD3E1             BCC      ??get_fileinfo_1
   1736          		fno->fattrib = dir[DIR_Attr];				/* Attribute */
   \   0000004C   0x7ACA             LDRB     R2,[R1, #+11]
   \   0000004E   0x9B00             LDR      R3,[SP, #+0]
   \   00000050   0x721A             STRB     R2,[R3, #+8]
   1737          		fno->fsize = LD_DWORD(dir + DIR_FileSize);	/* Size */
   \   00000052   0x7FCA             LDRB     R2,[R1, #+31]
   \   00000054   0x0612             LSLS     R2,R2,#+24
   \   00000056   0x7F8B             LDRB     R3,[R1, #+30]
   \   00000058   0x041B             LSLS     R3,R3,#+16
   \   0000005A   0x4313             ORRS     R3,R3,R2
   \   0000005C   0x7F4A             LDRB     R2,[R1, #+29]
   \   0000005E   0x0212             LSLS     R2,R2,#+8
   \   00000060   0x431A             ORRS     R2,R2,R3
   \   00000062   0x7F0B             LDRB     R3,[R1, #+28]
   \   00000064   0x4313             ORRS     R3,R3,R2
   \   00000066   0x9A00             LDR      R2,[SP, #+0]
   \   00000068   0x6013             STR      R3,[R2, #+0]
   1738          		fno->fdate = LD_WORD(dir + DIR_WrtDate);	/* Date */
   \   0000006A   0x7E4A             LDRB     R2,[R1, #+25]
   \   0000006C   0x0212             LSLS     R2,R2,#+8
   \   0000006E   0x7E0B             LDRB     R3,[R1, #+24]
   \   00000070   0x431A             ORRS     R2,R2,R3
   \   00000072   0x9B00             LDR      R3,[SP, #+0]
   \   00000074   0x809A             STRH     R2,[R3, #+4]
   1739          		fno->ftime = LD_WORD(dir + DIR_WrtTime);	/* Time */
   \   00000076   0x7DCA             LDRB     R2,[R1, #+23]
   \   00000078   0x0212             LSLS     R2,R2,#+8
   \   0000007A   0x7D89             LDRB     R1,[R1, #+22]
   \   0000007C   0x430A             ORRS     R2,R2,R1
   \   0000007E   0x9900             LDR      R1,[SP, #+0]
   \   00000080   0x80CA             STRH     R2,[R1, #+6]
   1740          	}
   1741          	*p = 0;		/* Terminate SFN string by a \0 */
   \                     ??get_fileinfo_0: (+1)
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x7029             STRB     R1,[R5, #+0]
   1742          
   1743          #if _USE_LFN
   1744          	if (fno->lfname) {
   \   00000086   0x9900             LDR      R1,[SP, #+0]
   \   00000088   0x698D             LDR      R5,[R1, #+24]
   \   0000008A   0x2D00             CMP      R5,#+0
   \   0000008C   0xD022             BEQ      ??get_fileinfo_8
   1745          		i = 0; p = fno->lfname;
   \   0000008E   0x2400             MOVS     R4,#+0
   1746          		if (dp->sect && fno->lfsize && dp->lfn_idx != 0xFFFF) {	/* Get LFN if available */
   \   00000090   0x6901             LDR      R1,[R0, #+16]
   \   00000092   0x2900             CMP      R1,#+0
   \   00000094   0xD01C             BEQ      ??get_fileinfo_9
   \   00000096   0x9900             LDR      R1,[SP, #+0]
   \   00000098   0x69C9             LDR      R1,[R1, #+28]
   \   0000009A   0x2900             CMP      R1,#+0
   \   0000009C   0xD018             BEQ      ??get_fileinfo_9
   \   0000009E   0x8C01             LDRH     R1,[R0, #+32]
   \   000000A0   0x....             LDR      R2,??DataTable15  ;; 0xffff
   \   000000A2   0x4291             CMP      R1,R2
   \   000000A4   0xD014             BEQ      ??get_fileinfo_9
   1747          			lfn = dp->lfn;
   \   000000A6   0x69C6             LDR      R6,[R0, #+28]
   \   000000A8   0x002F             MOVS     R7,R5
   \   000000AA   0xE002             B        ??get_fileinfo_10
   1748          			while ((w = *lfn++) != 0) {		/* Get an LFN character */
   1749          #if !_LFN_UNICODE
   1750          				w = ff_convert(w, 0);		/* Unicode -> OEM */
   1751          				if (!w) { i = 0; break; }	/* No LFN if it could not be converted */
   1752          				if (_DF1S && w >= 0x100)	/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
   1753          					p[i++] = (TCHAR)(w >> 8);
   1754          #endif
   1755          				if (i >= fno->lfsize - 1) { i = 0; break; }	/* No LFN if buffer overflow */
   1756          				p[i++] = (TCHAR)w;
   \                     ??get_fileinfo_11: (+1)
   \   000000AC   0x7038             STRB     R0,[R7, #+0]
   \   000000AE   0x1C64             ADDS     R4,R4,#+1
   \   000000B0   0x1C7F             ADDS     R7,R7,#+1
   \                     ??get_fileinfo_10: (+1)
   \   000000B2   0x8830             LDRH     R0,[R6, #+0]
   \   000000B4   0x1CB6             ADDS     R6,R6,#+2
   \   000000B6   0x0001             MOVS     R1,R0
   \   000000B8   0xD00A             BEQ      ??get_fileinfo_9
   \   000000BA   0x2100             MOVS     R1,#+0
   \   000000BC   0x.... 0x....      BL       ff_convert
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD004             BEQ      ??get_fileinfo_12
   \   000000C4   0x9900             LDR      R1,[SP, #+0]
   \   000000C6   0x69C9             LDR      R1,[R1, #+28]
   \   000000C8   0x1E49             SUBS     R1,R1,#+1
   \   000000CA   0x428C             CMP      R4,R1
   \   000000CC   0xD3EE             BCC      ??get_fileinfo_11
   \                     ??get_fileinfo_12: (+1)
   \   000000CE   0x2400             MOVS     R4,#+0
   1757          			}
   1758          		}
   1759          		p[i] = 0;	/* Terminate LFN string by a \0 */
   \                     ??get_fileinfo_9: (+1)
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x5528             STRB     R0,[R5, R4]
   1760          	}
   1761          #endif
   1762          }
   \                     ??get_fileinfo_8: (+1)
   \   000000D4   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1763          #endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 */
   1764          
   1765          
   1766          
   1767          
   1768          /*-----------------------------------------------------------------------*/
   1769          /* Pattern matching                                                      */
   1770          /*-----------------------------------------------------------------------*/
   1771          #if _USE_FIND && _FS_MINIMIZE <= 1
   1772          static
   1773          WCHAR get_achar (		/* Get a character and advances ptr 1 or 2 */
   1774          	const TCHAR** ptr	/* Pointer to pointer to the SBCS/DBCS/Unicode string */
   1775          )
   1776          {
   1777          	WCHAR chr;
   1778          
   1779          #if !_LFN_UNICODE
   1780          	chr = (BYTE)*(*ptr)++;					/* Get a byte */
   1781          	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
   1782          	if (IsDBCS1(chr) && IsDBCS2(**ptr))		/* Get DBC 2nd byte if needed */
   1783          		chr = chr << 8 | (BYTE)*(*ptr)++;
   1784          #ifdef _EXCVT
   1785          	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
   1786          #endif
   1787          #else
   1788          	chr = ff_wtoupper(*(*ptr)++);			/* Get a word and to upper */
   1789          #endif
   1790          	return chr;
   1791          }
   1792          
   1793          
   1794          static
   1795          int pattern_matching (	/* 0:mismatched, 1:matched */
   1796          	const TCHAR* pat,	/* Matching pattern */
   1797          	const TCHAR* nam,	/* String to be tested */
   1798          	int skip,			/* Number of pre-skip chars (number of ?s) */
   1799          	int inf				/* Infinite search (* specified) */
   1800          )
   1801          {
   1802          	const TCHAR *pp, *np;
   1803          	WCHAR pc, nc;
   1804          	int nm, nx;
   1805          
   1806          
   1807          	while (skip--) {				/* Pre-skip name chars */
   1808          		if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
   1809          	}
   1810          	if (!*pat && inf) return 1;		/* (short circuit) */
   1811          
   1812          	do {
   1813          		pp = pat; np = nam;			/* Top of pattern and name to match */
   1814          		for (;;) {
   1815          			if (*pp == '?' || *pp == '*') {	/* Wildcard? */
   1816          				nm = nx = 0;
   1817          				do {				/* Analyze the wildcard chars */
   1818          					if (*pp++ == '?') nm++; else nx = 1;
   1819          				} while (*pp == '?' || *pp == '*');
   1820          				if (pattern_matching(pp, np, nm, nx)) return 1;	/* Test new branch (recurs upto number of wildcard blocks in the pattern) */
   1821          				nc = *np; break;	/* Branch mismatched */
   1822          			}
   1823          			pc = get_achar(&pp);	/* Get a pattern char */
   1824          			nc = get_achar(&np);	/* Get a name char */
   1825          			if (pc != nc) break;	/* Branch mismatched? */
   1826          			if (!pc) return 1;		/* Branch matched? (matched at end of both strings) */
   1827          		}
   1828          		get_achar(&nam);			/* nam++ */
   1829          	} while (inf && nc);			/* Retry until end of name if infinite search is specified */
   1830          
   1831          	return 0;
   1832          }
   1833          #endif /* _USE_FIND && _FS_MINIMIZE <= 1 */
   1834          
   1835          
   1836          
   1837          
   1838          /*-----------------------------------------------------------------------*/
   1839          /* Pick a top segment and create the object name in directory form       */
   1840          /*-----------------------------------------------------------------------*/
   1841          

   \                                 In section .text, align 4, keep-with-next
   1842          static
   1843          FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
   1844          	FATFS_DIR* dp,			/* Pointer to the directory object */
   1845          	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
   1846          )
   1847          {
   \                     _Z11create_nameP9FATFS_DIRPPKc: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1848          #if _USE_LFN	/* LFN configuration */
   1849          	BYTE b, cf;
   1850          	WCHAR w, *lfn;
   1851          	UINT i, ni, si, di;
   1852          	const TCHAR *p;
   1853          
   1854          	/* Create LFN in Unicode */
   1855          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   \   00000004   0x680C             LDR      R4,[R1, #+0]
   \   00000006   0xE000             B        ??create_name_0
   \                     ??create_name_1: (+1)
   \   00000008   0x1C64             ADDS     R4,R4,#+1
   \                     ??create_name_0: (+1)
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x282F             CMP      R0,#+47
   \   0000000E   0xD0FB             BEQ      ??create_name_1
   \   00000010   0x285C             CMP      R0,#+92
   \   00000012   0xD0F9             BEQ      ??create_name_1
   1856          	lfn = dp->lfn;
   \   00000014   0x9805             LDR      R0,[SP, #+20]
   \   00000016   0x69C0             LDR      R0,[R0, #+28]
   \   00000018   0x9001             STR      R0,[SP, #+4]
   \   0000001A   0x2700             MOVS     R7,#+0
   \   0000001C   0x2500             MOVS     R5,#+0
   \   0000001E   0x9402             STR      R4,[SP, #+8]
   \   00000020   0x9E01             LDR      R6,[SP, #+4]
   \   00000022   0xE00D             B        ??create_name_2
   1857          	si = di = 0;
   1858          	for (;;) {
   \                     ??create_name_3: (+1)
   \   00000024   0x1C49             ADDS     R1,R1,#+1
   \                     ??create_name_4: (+1)
   \   00000026   0x780A             LDRB     R2,[R1, #+0]
   \   00000028   0x0013             MOVS     R3,R2
   \   0000002A   0xD001             BEQ      ??create_name_5
   \   0000002C   0x4282             CMP      R2,R0
   \   0000002E   0xD1F9             BNE      ??create_name_3
   1859          		w = p[si++];					/* Get a character */
   1860          		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   1861          		if (di >= _MAX_LFN)				/* Reject too long name */
   1862          			return FR_INVALID_NAME;
   1863          #if !_LFN_UNICODE
   1864          		w &= 0xFF;
   1865          		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1866          			b = (BYTE)p[si++];			/* Get 2nd byte */
   1867          			w = (w << 8) + b;			/* Create a DBC */
   1868          			if (!IsDBCS2(b))
   1869          				return FR_INVALID_NAME;	/* Reject invalid sequence */
   1870          		}
   1871          		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
   1872          		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   1873          #endif
   1874          		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
   \                     ??create_name_5: (+1)
   \   00000030   0x2A00             CMP      R2,#+0
   \   00000032   0xD155             BNE      ??create_name_6
   1875          			return FR_INVALID_NAME;
   1876          		lfn[di++] = w;					/* Store the Unicode character */
   \                     ??create_name_7: (+1)
   \   00000034   0x8030             STRH     R0,[R6, #+0]
   \   00000036   0x1C7F             ADDS     R7,R7,#+1
   \   00000038   0x1CB6             ADDS     R6,R6,#+2
   \   0000003A   0x9802             LDR      R0,[SP, #+8]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x9002             STR      R0,[SP, #+8]
   \                     ??create_name_2: (+1)
   \   00000040   0x9802             LDR      R0,[SP, #+8]
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0x1C6D             ADDS     R5,R5,#+1
   \   00000046   0x2820             CMP      R0,#+32
   \   00000048   0xDB03             BLT      ??create_name_8
   \   0000004A   0x282F             CMP      R0,#+47
   \   0000004C   0xD001             BEQ      ??create_name_8
   \   0000004E   0x285C             CMP      R0,#+92
   \   00000050   0xD106             BNE      ??create_name_9
   1877          	}
   1878          	*path = &p[si];						/* Return pointer to the next segment */
   \                     ??create_name_8: (+1)
   \   00000052   0x1961             ADDS     R1,R4,R5
   \   00000054   0x9A06             LDR      R2,[SP, #+24]
   \   00000056   0x6011             STR      R1,[R2, #+0]
   1879          	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   \   00000058   0x2820             CMP      R0,#+32
   \   0000005A   0xDA0D             BGE      ??create_name_10
   \   0000005C   0x2404             MOVS     R4,#+4
   \   0000005E   0xE00C             B        ??create_name_11
   \                     ??create_name_9: (+1)
   \   00000060   0x2FFF             CMP      R7,#+255
   \   00000062   0xD23D             BCS      ??create_name_6
   \   00000064   0x2101             MOVS     R1,#+1
   \   00000066   0x.... 0x....      BL       ff_convert
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD038             BEQ      ??create_name_6
   \   0000006E   0x2880             CMP      R0,#+128
   \   00000070   0xDAE0             BGE      ??create_name_7
   \   00000072   0x9000             STR      R0,[SP, #+0]
   \   00000074   0x....             ADR.N    R1,?_0
   \   00000076   0xE7D6             B        ??create_name_4
   \                     ??create_name_10: (+1)
   \   00000078   0x2400             MOVS     R4,#+0
   1880          #if _FS_RPATH
   1881          	if ((di == 1 && lfn[di - 1] == '.') ||
   1882          		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot entry? */
   \                     ??create_name_11: (+1)
   \   0000007A   0x2F01             CMP      R7,#+1
   \   0000007C   0xD005             BEQ      ??create_name_12
   \   0000007E   0x2F02             CMP      R7,#+2
   \   00000080   0xD12C             BNE      ??create_name_13
   \   00000082   0x9801             LDR      R0,[SP, #+4]
   \   00000084   0x8840             LDRH     R0,[R0, #+2]
   \   00000086   0x282E             CMP      R0,#+46
   \   00000088   0xD11E             BNE      ??create_name_14
   \                     ??create_name_12: (+1)
   \   0000008A   0x9801             LDR      R0,[SP, #+4]
   \   0000008C   0x8800             LDRH     R0,[R0, #+0]
   \   0000008E   0x282E             CMP      R0,#+46
   \   00000090   0xD11A             BNE      ??create_name_14
   1883          		lfn[di] = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x9901             LDR      R1,[SP, #+4]
   \   00000096   0x007A             LSLS     R2,R7,#+1
   \   00000098   0x5288             STRH     R0,[R1, R2]
   1884          		for (i = 0; i < 11; i++)		/* Create dot name for SFN entry */
   \   0000009A   0x9000             STR      R0,[SP, #+0]
   1885          			dp->fn[i] = (i < di) ? '.' : ' ';
   \                     ??create_name_15: (+1)
   \   0000009C   0x9800             LDR      R0,[SP, #+0]
   \   0000009E   0x42B8             CMP      R0,R7
   \   000000A0   0xD201             BCS      ??create_name_16
   \   000000A2   0x202E             MOVS     R0,#+46
   \   000000A4   0xE000             B        ??create_name_17
   \                     ??create_name_16: (+1)
   \   000000A6   0x2020             MOVS     R0,#+32
   \                     ??create_name_17: (+1)
   \   000000A8   0x9905             LDR      R1,[SP, #+20]
   \   000000AA   0x6989             LDR      R1,[R1, #+24]
   \   000000AC   0x9A00             LDR      R2,[SP, #+0]
   \   000000AE   0x5488             STRB     R0,[R1, R2]
   \   000000B0   0x9800             LDR      R0,[SP, #+0]
   \   000000B2   0x1C40             ADDS     R0,R0,#+1
   \   000000B4   0x9000             STR      R0,[SP, #+0]
   \   000000B6   0x280B             CMP      R0,#+11
   \   000000B8   0xD3F0             BCC      ??create_name_15
   1886          		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
   \   000000BA   0x2020             MOVS     R0,#+32
   \   000000BC   0x4320             ORRS     R0,R0,R4
   \   000000BE   0x9905             LDR      R1,[SP, #+20]
   \   000000C0   0x6989             LDR      R1,[R1, #+24]
   \   000000C2   0x9A00             LDR      R2,[SP, #+0]
   \   000000C4   0x5488             STRB     R0,[R1, R2]
   1887          		return FR_OK;
   \   000000C6   0xE07B             B        ??create_name_18
   1888          	}
   1889          #endif
   1890          	while (di) {						/* Snip off trailing spaces and dots if exist */
   1891          		w = lfn[di - 1];
   \                     ??create_name_14: (+1)
   \   000000C8   0x9801             LDR      R0,[SP, #+4]
   \   000000CA   0x0079             LSLS     R1,R7,#+1
   \   000000CC   0x1841             ADDS     R1,R0,R1
   \   000000CE   0x1E88             SUBS     R0,R1,#+2
   \   000000D0   0x8800             LDRH     R0,[R0, #+0]
   1892          		if (w != ' ' && w != '.') break;
   \   000000D2   0x2820             CMP      R0,#+32
   \   000000D4   0xD001             BEQ      ??create_name_19
   \   000000D6   0x282E             CMP      R0,#+46
   \   000000D8   0xD104             BNE      ??create_name_20
   1893          		di--;
   \                     ??create_name_19: (+1)
   \   000000DA   0x1E7F             SUBS     R7,R7,#+1
   1894          	}
   \                     ??create_name_13: (+1)
   \   000000DC   0x2F00             CMP      R7,#+0
   \   000000DE   0xD1F3             BNE      ??create_name_14
   1895          	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
   \                     ??create_name_6: (+1)
   \   000000E0   0x2006             MOVS     R0,#+6
   \   000000E2   0xE06E             B        ??create_name_21
   1896          	lfn[di] = 0;						/* LFN is created */
   \                     ??create_name_20: (+1)
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x8008             STRH     R0,[R1, #+0]
   1897          
   1898          	/* Create SFN in directory form */
   1899          	mem_set(dp->fn, ' ', 11);
   \   000000E8   0x2220             MOVS     R2,#+32
   \   000000EA   0x210B             MOVS     R1,#+11
   \   000000EC   0x9805             LDR      R0,[SP, #+20]
   \   000000EE   0x6980             LDR      R0,[R0, #+24]
   \   000000F0   0x.... 0x....      BL       __aeabi_memset
   1900          	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   \   000000F4   0x2500             MOVS     R5,#+0
   \   000000F6   0x9801             LDR      R0,[SP, #+4]
   \   000000F8   0xE001             B        ??create_name_22
   \                     ??create_name_23: (+1)
   \   000000FA   0x1C6D             ADDS     R5,R5,#+1
   \   000000FC   0x1C80             ADDS     R0,R0,#+2
   \                     ??create_name_22: (+1)
   \   000000FE   0x8801             LDRH     R1,[R0, #+0]
   \   00000100   0x2920             CMP      R1,#+32
   \   00000102   0xD0FA             BEQ      ??create_name_23
   \   00000104   0x292E             CMP      R1,#+46
   \   00000106   0xD0F8             BEQ      ??create_name_23
   1901          	if (si) cf |= NS_LOSS | NS_LFN;
   \   00000108   0x2D00             CMP      R5,#+0
   \   0000010A   0xD002             BEQ      ??create_name_24
   \   0000010C   0x0020             MOVS     R0,R4
   \   0000010E   0x2403             MOVS     R4,#+3
   \   00000110   0x4304             ORRS     R4,R4,R0
   \                     ??create_name_24: (+1)
   \   00000112   0x9801             LDR      R0,[SP, #+4]
   \   00000114   0x0079             LSLS     R1,R7,#+1
   \   00000116   0x1840             ADDS     R0,R0,R1
   \   00000118   0x1E80             SUBS     R0,R0,#+2
   \   0000011A   0x8800             LDRH     R0,[R0, #+0]
   \   0000011C   0x282E             CMP      R0,#+46
   \   0000011E   0xD001             BEQ      ??create_name_25
   1902          	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   \   00000120   0x1E7F             SUBS     R7,R7,#+1
   \   00000122   0xD1F6             BNE      ??create_name_24
   1903          
   1904          	b = i = 0; ni = 8;
   \                     ??create_name_25: (+1)
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0x9000             STR      R0,[SP, #+0]
   \   00000128   0x2600             MOVS     R6,#+0
   \   0000012A   0x2008             MOVS     R0,#+8
   \   0000012C   0x9003             STR      R0,[SP, #+12]
   \   0000012E   0xE003             B        ??create_name_26
   1905          	for (;;) {
   1906          		w = lfn[si++];					/* Get an LFN character */
   1907          		if (!w) break;					/* Break on end of the LFN */
   1908          		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   1909          			cf |= NS_LOSS | NS_LFN; continue;
   \                     ??create_name_27: (+1)
   \   00000130   0x0020             MOVS     R0,R4
   \   00000132   0x2403             MOVS     R4,#+3
   \   00000134   0x4304             ORRS     R4,R4,R0
   \   00000136   0xB2E4             UXTB     R4,R4
   1910          		}
   \                     ??create_name_26: (+1)
   \   00000138   0x9801             LDR      R0,[SP, #+4]
   \   0000013A   0x0069             LSLS     R1,R5,#+1
   \   0000013C   0x5A40             LDRH     R0,[R0, R1]
   \   0000013E   0x1C6D             ADDS     R5,R5,#+1
   \   00000140   0x2800             CMP      R0,#+0
   \   00000142   0xD011             BEQ      ??create_name_28
   \   00000144   0x2820             CMP      R0,#+32
   \   00000146   0xD0F3             BEQ      ??create_name_27
   \   00000148   0x282E             CMP      R0,#+46
   \   0000014A   0xD101             BNE      ??create_name_29
   \   0000014C   0x42BD             CMP      R5,R7
   \   0000014E   0xD1EF             BNE      ??create_name_27
   1911          
   1912          		if (i >= ni || si == di) {		/* Extension or end of SFN */
   \                     ??create_name_29: (+1)
   \   00000150   0x9900             LDR      R1,[SP, #+0]
   \   00000152   0x9A03             LDR      R2,[SP, #+12]
   \   00000154   0x4291             CMP      R1,R2
   \   00000156   0xD201             BCS      ??create_name_30
   \   00000158   0x42BD             CMP      R5,R7
   \   0000015A   0xD143             BNE      ??create_name_31
   1913          			if (ni == 11) {				/* Long extension */
   \                     ??create_name_30: (+1)
   \   0000015C   0x2A0B             CMP      R2,#+11
   \   0000015E   0xD132             BNE      ??create_name_32
   1914          				cf |= NS_LOSS | NS_LFN; break;
   \   00000160   0x0020             MOVS     R0,R4
   \   00000162   0x2403             MOVS     R4,#+3
   \   00000164   0x4304             ORRS     R4,R4,R0
   \   00000166   0xB2E4             UXTB     R4,R4
   1915          			}
   1916          			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   1917          			if (si > di) break;			/* No extension */
   1918          			si = di; i = 8; ni = 11;	/* Enter extension section */
   1919          			b <<= 2; continue;
   1920          		}
   1921          
   1922          		if (w >= 0x80) {				/* Non ASCII character */
   1923          #ifdef _EXCVT
   1924          			w = ff_convert(w, 0);		/* Unicode -> OEM code */
   1925          			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
   1926          #else
   1927          			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
   1928          #endif
   1929          			cf |= NS_LFN;				/* Force create LFN entry */
   1930          		}
   1931          
   1932          		if (_DF1S && w >= 0x100) {		/* Is this DBC? (always false at SBCS cfg) */
   1933          			if (i >= ni - 1) {
   1934          				cf |= NS_LOSS | NS_LFN; i = ni; continue;
   1935          			}
   1936          			dp->fn[i++] = (BYTE)(w >> 8);
   1937          		} else {						/* SBC */
   1938          			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
   1939          				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
   1940          			} else {
   1941          				if (IsUpper(w)) {		/* ASCII large capital */
   1942          					b |= 2;
   1943          				} else {
   1944          					if (IsLower(w)) {	/* ASCII small capital */
   1945          						b |= 1; w -= 0x20;
   1946          					}
   1947          				}
   1948          			}
   1949          		}
   1950          		dp->fn[i++] = (BYTE)w;
   1951          	}
   1952          
   1953          	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
   \                     ??create_name_28: (+1)
   \   00000168   0x9805             LDR      R0,[SP, #+20]
   \   0000016A   0x6980             LDR      R0,[R0, #+24]
   \   0000016C   0x7801             LDRB     R1,[R0, #+0]
   \   0000016E   0x29E5             CMP      R1,#+229
   \   00000170   0xD101             BNE      ??create_name_33
   \   00000172   0x2105             MOVS     R1,#+5
   \   00000174   0x7001             STRB     R1,[R0, #+0]
   1954          
   1955          	if (ni == 8) b <<= 2;
   \                     ??create_name_33: (+1)
   \   00000176   0x9803             LDR      R0,[SP, #+12]
   \   00000178   0x2808             CMP      R0,#+8
   \   0000017A   0xD100             BNE      ??create_name_34
   \   0000017C   0x00B6             LSLS     R6,R6,#+2
   1956          	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
   \                     ??create_name_34: (+1)
   \   0000017E   0x200C             MOVS     R0,#+12
   \   00000180   0x210C             MOVS     R1,#+12
   \   00000182   0x4031             ANDS     R1,R1,R6
   \   00000184   0x290C             CMP      R1,#+12
   \   00000186   0xD003             BEQ      ??create_name_35
   \   00000188   0x07B1             LSLS     R1,R6,#+30
   \   0000018A   0x0F89             LSRS     R1,R1,#+30
   \   0000018C   0x2903             CMP      R1,#+3
   \   0000018E   0xD103             BNE      ??create_name_36
   1957          		cf |= NS_LFN;
   \                     ??create_name_35: (+1)
   \   00000190   0x0021             MOVS     R1,R4
   \   00000192   0x2402             MOVS     R4,#+2
   \   00000194   0x430C             ORRS     R4,R4,R1
   \   00000196   0xB2E4             UXTB     R4,R4
   1958          	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
   \                     ??create_name_36: (+1)
   \   00000198   0x07A1             LSLS     R1,R4,#+30
   \   0000019A   0xD40E             BMI      ??create_name_37
   1959          		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   \   0000019C   0x07B1             LSLS     R1,R6,#+30
   \   0000019E   0x0F89             LSRS     R1,R1,#+30
   \   000001A0   0x2901             CMP      R1,#+1
   \   000001A2   0xD103             BNE      ??create_name_38
   \   000001A4   0x0021             MOVS     R1,R4
   \   000001A6   0x2410             MOVS     R4,#+16
   \   000001A8   0x430C             ORRS     R4,R4,R1
   \   000001AA   0xB2E4             UXTB     R4,R4
   1960          		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   \                     ??create_name_38: (+1)
   \   000001AC   0x4030             ANDS     R0,R0,R6
   \   000001AE   0x2804             CMP      R0,#+4
   \   000001B0   0xD103             BNE      ??create_name_37
   \   000001B2   0x0020             MOVS     R0,R4
   \   000001B4   0x2408             MOVS     R4,#+8
   \   000001B6   0x4304             ORRS     R4,R4,R0
   \   000001B8   0xB2E4             UXTB     R4,R4
   1961          	}
   1962          
   1963          	dp->fn[NSFLAG] = cf;	/* SFN is created */
   \                     ??create_name_37: (+1)
   \   000001BA   0x9805             LDR      R0,[SP, #+20]
   \   000001BC   0x6980             LDR      R0,[R0, #+24]
   \   000001BE   0x72C4             STRB     R4,[R0, #+11]
   1964          
   1965          	return FR_OK;
   \                     ??create_name_18: (+1)
   \   000001C0   0x2000             MOVS     R0,#+0
   \                     ??create_name_21: (+1)
   \   000001C2   0xB007             ADD      SP,SP,#+28
   \   000001C4   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??create_name_32: (+1)
   \   000001C6   0x42BD             CMP      R5,R7
   \   000001C8   0xD003             BEQ      ??create_name_39
   \   000001CA   0x0020             MOVS     R0,R4
   \   000001CC   0x2403             MOVS     R4,#+3
   \   000001CE   0x4304             ORRS     R4,R4,R0
   \   000001D0   0xB2E4             UXTB     R4,R4
   \                     ??create_name_39: (+1)
   \   000001D2   0x42AF             CMP      R7,R5
   \   000001D4   0xD3C8             BCC      ??create_name_28
   \   000001D6   0x003D             MOVS     R5,R7
   \   000001D8   0x2008             MOVS     R0,#+8
   \   000001DA   0x9000             STR      R0,[SP, #+0]
   \   000001DC   0x200B             MOVS     R0,#+11
   \   000001DE   0x9003             STR      R0,[SP, #+12]
   \   000001E0   0x00B6             LSLS     R6,R6,#+2
   \   000001E2   0xE7A9             B        ??create_name_26
   \                     ??create_name_31: (+1)
   \   000001E4   0x2880             CMP      R0,#+128
   \   000001E6   0xDB0F             BLT      ??create_name_40
   \   000001E8   0x2100             MOVS     R1,#+0
   \   000001EA   0x.... 0x....      BL       ff_convert
   \   000001EE   0x2800             CMP      R0,#+0
   \   000001F0   0xD004             BEQ      ??create_name_41
   \   000001F2   0xBF00             Nop      
   \   000001F4   0x....             ADR.N    R1,ExCvt
   \   000001F6   0x1808             ADDS     R0,R1,R0
   \   000001F8   0x3880             SUBS     R0,R0,#+128
   \   000001FA   0x7800             LDRB     R0,[R0, #+0]
   \                     ??create_name_41: (+1)
   \   000001FC   0x0021             MOVS     R1,R4
   \   000001FE   0x2402             MOVS     R4,#+2
   \   00000200   0x430C             ORRS     R4,R4,R1
   \   00000202   0xB2E4             UXTB     R4,R4
   \   00000204   0x2800             CMP      R0,#+0
   \   00000206   0xD00B             BEQ      ??create_name_42
   \                     ??create_name_40: (+1)
   \   00000208   0x9002             STR      R0,[SP, #+8]
   \   0000020A   0xBF00             Nop      
   \   0000020C   0x....             ADR.N    R1,?_1
   \   0000020E   0xE000             B        ??create_name_43
   \                     ??create_name_44: (+1)
   \   00000210   0x1C49             ADDS     R1,R1,#+1
   \                     ??create_name_43: (+1)
   \   00000212   0x780A             LDRB     R2,[R1, #+0]
   \   00000214   0x0013             MOVS     R3,R2
   \   00000216   0xD001             BEQ      ??create_name_45
   \   00000218   0x4282             CMP      R2,R0
   \   0000021A   0xD1F9             BNE      ??create_name_44
   \                     ??create_name_45: (+1)
   \   0000021C   0x2A00             CMP      R2,#+0
   \   0000021E   0xD005             BEQ      ??create_name_46
   \                     ??create_name_42: (+1)
   \   00000220   0x205F             MOVS     R0,#+95
   \   00000222   0x0021             MOVS     R1,R4
   \   00000224   0x2403             MOVS     R4,#+3
   \   00000226   0x430C             ORRS     R4,R4,R1
   \   00000228   0xB2E4             UXTB     R4,R4
   \   0000022A   0xE00F             B        ??create_name_47
   \                     ??create_name_46: (+1)
   \   0000022C   0x0001             MOVS     R1,R0
   \   0000022E   0x3941             SUBS     R1,R1,#+65
   \   00000230   0x291A             CMP      R1,#+26
   \   00000232   0xD203             BCS      ??create_name_48
   \   00000234   0x0031             MOVS     R1,R6
   \   00000236   0x2602             MOVS     R6,#+2
   \   00000238   0x430E             ORRS     R6,R6,R1
   \   0000023A   0xE007             B        ??create_name_47
   \                     ??create_name_48: (+1)
   \   0000023C   0x0001             MOVS     R1,R0
   \   0000023E   0x3961             SUBS     R1,R1,#+97
   \   00000240   0x291A             CMP      R1,#+26
   \   00000242   0xD203             BCS      ??create_name_47
   \   00000244   0x0031             MOVS     R1,R6
   \   00000246   0x2601             MOVS     R6,#+1
   \   00000248   0x430E             ORRS     R6,R6,R1
   \   0000024A   0x3820             SUBS     R0,R0,#+32
   \                     ??create_name_47: (+1)
   \   0000024C   0x9905             LDR      R1,[SP, #+20]
   \   0000024E   0x6989             LDR      R1,[R1, #+24]
   \   00000250   0x9A00             LDR      R2,[SP, #+0]
   \   00000252   0x5488             STRB     R0,[R1, R2]
   \   00000254   0x9800             LDR      R0,[SP, #+0]
   \   00000256   0x1C40             ADDS     R0,R0,#+1
   \   00000258   0x9000             STR      R0,[SP, #+0]
   \   0000025A   0xE76D             B        ??create_name_26
   1966          
   1967          
   1968          #else	/* Non-LFN configuration */
   1969          	BYTE b, c, d, *sfn;
   1970          	UINT ni, si, i;
   1971          	const char *p;
   1972          
   1973          	/* Create file name in directory form */
   1974          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Skip duplicated separator */
   1975          	sfn = dp->fn;
   1976          	mem_set(sfn, ' ', 11);
   1977          	si = i = b = 0; ni = 8;
   1978          #if _FS_RPATH
   1979          	if (p[si] == '.') { /* Is this a dot entry? */
   1980          		for (;;) {
   1981          			c = (BYTE)p[si++];
   1982          			if (c != '.' || si >= 3) break;
   1983          			sfn[i++] = c;
   1984          		}
   1985          		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
   1986          		*path = &p[si];									/* Return pointer to the next segment */
   1987          		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
   1988          		return FR_OK;
   1989          	}
   1990          #endif
   1991          	for (;;) {
   1992          		c = (BYTE)p[si++];
   1993          		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
   1994          		if (c == '.' || i >= ni) {
   1995          			if (ni != 8 || c != '.') return FR_INVALID_NAME;
   1996          			i = 8; ni = 11;
   1997          			b <<= 2; continue;
   1998          		}
   1999          		if (c >= 0x80) {				/* Extended character? */
   2000          			b |= 3;						/* Eliminate NT flag */
   2001          #ifdef _EXCVT
   2002          			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
   2003          #else
   2004          #if !_DF1S
   2005          			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
   2006          #endif
   2007          #endif
   2008          		}
   2009          		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
   2010          			d = (BYTE)p[si++];			/* Get 2nd byte */
   2011          			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
   2012          				return FR_INVALID_NAME;
   2013          			sfn[i++] = c;
   2014          			sfn[i++] = d;
   2015          		} else {						/* SBC */
   2016          			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
   2017          				return FR_INVALID_NAME;
   2018          			if (IsUpper(c)) {			/* ASCII large capital? */
   2019          				b |= 2;
   2020          			} else {
   2021          				if (IsLower(c)) {		/* ASCII small capital? */
   2022          					b |= 1; c -= 0x20;
   2023          				}
   2024          			}
   2025          			sfn[i++] = c;
   2026          		}
   2027          	}
   2028          	*path = &p[si];						/* Return pointer to the next segment */
   2029          	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   2030          
   2031          	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
   2032          	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
   2033          
   2034          	if (ni == 8) b <<= 2;
   2035          	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
   2036          	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
   2037          
   2038          	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
   2039          
   2040          	return FR_OK;
   2041          #endif
   2042          }
   2043          
   2044          
   2045          
   2046          
   2047          /*-----------------------------------------------------------------------*/
   2048          /* Follow a file path                                                    */
   2049          /*-----------------------------------------------------------------------*/
   2050          

   \                                 In section .text, align 2, keep-with-next
   2051          static
   2052          FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
   2053          	FATFS_DIR* dp,			/* Directory object to return last directory and found object */
   2054          	const TCHAR* path	/* Full-path string to find a file or directory */
   2055          )
   2056          {
   \                     _Z11follow_pathP9FATFS_DIRPKc: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2057          	FRESULT res;
   2058          	BYTE *dir, ns;
   2059          
   2060          
   2061          #if _FS_RPATH
   2062          	if (*path == '/' || *path == '\\') {	/* There is a heading separator */
   \   00000004   0x7808             LDRB     R0,[R1, #+0]
   \   00000006   0x282F             CMP      R0,#+47
   \   00000008   0xD001             BEQ      ??follow_path_0
   \   0000000A   0x285C             CMP      R0,#+92
   \   0000000C   0xD103             BNE      ??follow_path_1
   2063          		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
   \                     ??follow_path_0: (+1)
   \   0000000E   0x1C48             ADDS     R0,R1,#+1
   \   00000010   0x9001             STR      R0,[SP, #+4]
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE001             B        ??follow_path_2
   2064          	} else {								/* No heading separator */
   2065          		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
   \                     ??follow_path_1: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6940             LDR      R0,[R0, #+20]
   \                     ??follow_path_2: (+1)
   \   0000001A   0x60A0             STR      R0,[R4, #+8]
   2066          	}
   2067          #else
   2068          	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
   2069          		path++;
   2070          	dp->sclust = 0;							/* Always start from the root directory */
   2071          #endif
   2072          
   2073          	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
   \   0000001C   0x9801             LDR      R0,[SP, #+4]
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2820             CMP      R0,#+32
   \   00000022   0xD216             BCS      ??follow_path_3
   2074          		res = dir_sdi(dp, 0);
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       _Z7dir_sdiP9FATFS_DIRj
   2075          		dp->dir = 0;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6161             STR      R1,[R4, #+20]
   \   00000030   0xBD16             POP      {R1,R2,R4,PC}
   2076          	} else {								/* Follow path */
   2077          		for (;;) {
   2078          			res = create_name(dp, &path);	/* Get a segment name of the path */
   2079          			if (res != FR_OK) break;
   2080          			res = dir_find(dp);				/* Find an object with the sagment name */
   2081          			ns = dp->fn[NSFLAG];
   2082          			if (res != FR_OK) {				/* Failed to find the object */
   2083          				if (res == FR_NO_FILE) {	/* Object is not found */
   2084          					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
   2085          						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
   2086          						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
   2087          						res = FR_OK;					/* Ended at the root directroy. Function completed. */
   2088          					} else {							/* Could not find the object */
   2089          						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
   2090          					}
   2091          				}
   2092          				break;
   2093          			}
   2094          			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
   2095          			dir = dp->dir;						/* Follow the sub-directory */
   2096          			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
   2097          				res = FR_NO_PATH; break;
   2098          			}
   2099          			dp->sclust = ld_clust(dp->fs, dir);
   \                     ??follow_path_4: (+1)
   \   00000032   0x7EC1             LDRB     R1,[R0, #+27]
   \   00000034   0x0209             LSLS     R1,R1,#+8
   \   00000036   0x7E82             LDRB     R2,[R0, #+26]
   \   00000038   0x4311             ORRS     R1,R1,R2
   \   0000003A   0x6822             LDR      R2,[R4, #+0]
   \   0000003C   0x7812             LDRB     R2,[R2, #+0]
   \   0000003E   0x2A03             CMP      R2,#+3
   \   00000040   0xD106             BNE      ??follow_path_5
   \   00000042   0x000A             MOVS     R2,R1
   \   00000044   0x7D41             LDRB     R1,[R0, #+21]
   \   00000046   0x0209             LSLS     R1,R1,#+8
   \   00000048   0x7D00             LDRB     R0,[R0, #+20]
   \   0000004A   0x4301             ORRS     R1,R1,R0
   \   0000004C   0x0409             LSLS     R1,R1,#+16
   \   0000004E   0x4311             ORRS     R1,R1,R2
   \                     ??follow_path_5: (+1)
   \   00000050   0x60A1             STR      R1,[R4, #+8]
   \                     ??follow_path_3: (+1)
   \   00000052   0xA901             ADD      R1,SP,#+4
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       _Z11create_nameP9FATFS_DIRPPKc
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD11D             BNE      ??follow_path_6
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       _Z8dir_findP9FATFS_DIR
   \   00000064   0x69A1             LDR      R1,[R4, #+24]
   \   00000066   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD00F             BEQ      ??follow_path_7
   \   0000006C   0x2804             CMP      R0,#+4
   \   0000006E   0xD114             BNE      ??follow_path_6
   \   00000070   0x000A             MOVS     R2,R1
   \   00000072   0x2304             MOVS     R3,#+4
   \   00000074   0x401A             ANDS     R2,R2,R3
   \   00000076   0x0689             LSLS     R1,R1,#+26
   \   00000078   0xD505             BPL      ??follow_path_8
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x60A0             STR      R0,[R4, #+8]
   \   0000007E   0x6160             STR      R0,[R4, #+20]
   \   00000080   0x2A00             CMP      R2,#+0
   \   00000082   0xD0E6             BEQ      ??follow_path_3
   \   00000084   0xBD16             POP      {R1,R2,R4,PC}
   \                     ??follow_path_8: (+1)
   \   00000086   0x2A00             CMP      R2,#+0
   \   00000088   0xD107             BNE      ??follow_path_6
   \   0000008A   0xE005             B        ??follow_path_9
   \                     ??follow_path_7: (+1)
   \   0000008C   0x0749             LSLS     R1,R1,#+29
   \   0000008E   0xD404             BMI      ??follow_path_6
   \   00000090   0x6960             LDR      R0,[R4, #+20]
   \   00000092   0x7AC1             LDRB     R1,[R0, #+11]
   \   00000094   0x06C9             LSLS     R1,R1,#+27
   \   00000096   0xD4CC             BMI      ??follow_path_4
   \                     ??follow_path_9: (+1)
   \   00000098   0x2005             MOVS     R0,#+5
   2100          		}
   2101          	}
   2102          
   2103          	return res;
   \                     ??follow_path_6: (+1)
   \   0000009A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   2104          }
   2105          
   2106          
   2107          
   2108          
   2109          /*-----------------------------------------------------------------------*/
   2110          /* Get logical drive number from path name                               */
   2111          /*-----------------------------------------------------------------------*/
   2112          

   \                                 In section .text, align 2, keep-with-next
   2113          static
   2114          int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
   2115          	const TCHAR** path	/* Pointer to pointer to the path name */
   2116          )
   2117          {
   \                     _Z12get_ldnumberPPKc: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   2118          	const TCHAR *tp, *tt;
   2119          	UINT i;
   2120          	int vol = -1;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x43C0             MVNS     R0,R0            ;; #-1
   2121          #if _STR_VOLUME_ID		/* Find string drive id */
   2122          	static const char* const str[] = {_VOLUME_STRS};
   2123          	const char *sp;
   2124          	char c;
   2125          	TCHAR tc;
   2126          #endif
   2127          
   2128          
   2129          	if (*path) {	/* If the pointer is not a null */
   \   00000006   0x680A             LDR      R2,[R1, #+0]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD100             BNE      ??get_ldnumber_0
   \   0000000C   0x4770             BX       LR
   2130          		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
   \                     ??get_ldnumber_0: (+1)
   \   0000000E   0xB410             PUSH     {R4}
   \   00000010   0x0013             MOVS     R3,R2
   \   00000012   0xE000             B        ??get_ldnumber_1
   \                     ??get_ldnumber_2: (+1)
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \                     ??get_ldnumber_1: (+1)
   \   00000016   0x781C             LDRB     R4,[R3, #+0]
   \   00000018   0x2C20             CMP      R4,#+32
   \   0000001A   0xD301             BCC      ??get_ldnumber_3
   \   0000001C   0x2C3A             CMP      R4,#+58
   \   0000001E   0xD1F9             BNE      ??get_ldnumber_2
   2131          		if (*tt == ':') {	/* If a ':' is exist in the path name */
   \                     ??get_ldnumber_3: (+1)
   \   00000020   0x2C3A             CMP      R4,#+58
   \   00000022   0xD10C             BNE      ??get_ldnumber_4
   2132          			tp = *path;
   2133          			i = *tp++ - '0'; 
   \   00000024   0x7814             LDRB     R4,[R2, #+0]
   \   00000026   0x3C30             SUBS     R4,R4,#+48
   \   00000028   0x1C52             ADDS     R2,R2,#+1
   2134          			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
   \   0000002A   0x2C0A             CMP      R4,#+10
   \   0000002C   0xD209             BCS      ??get_ldnumber_5
   \   0000002E   0x429A             CMP      R2,R3
   \   00000030   0xD107             BNE      ??get_ldnumber_5
   2135          				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
   \   00000032   0x2C04             CMP      R4,#+4
   \   00000034   0xD205             BCS      ??get_ldnumber_5
   2136          					vol = (int)i;
   \   00000036   0x0020             MOVS     R0,R4
   2137          					*path = ++tt;
   \   00000038   0x1C5A             ADDS     R2,R3,#+1
   \   0000003A   0x600A             STR      R2,[R1, #+0]
   \   0000003C   0xE001             B        ??get_ldnumber_5
   2138          				}
   2139          			}
   2140          #if _STR_VOLUME_ID
   2141          			 else {	/* No numeric drive number, find string drive id */
   2142          				i = 0; tt++;
   2143          				do {
   2144          					sp = str[i]; tp = *path;
   2145          					do {	/* Compare a string drive id with path name */
   2146          						c = *sp++; tc = *tp++;
   2147          						if (IsLower(tc)) tc -= 0x20;
   2148          					} while (c && (TCHAR)c == tc);
   2149          				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
   2150          				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
   2151          					vol = (int)i;
   2152          					*path = tt;
   2153          				}
   2154          			}
   2155          #endif
   2156          			return vol;
   2157          		}
   2158          #if _FS_RPATH && _VOLUMES >= 2
   2159          		vol = CurrVol;	/* Current drive */
   \                     ??get_ldnumber_4: (+1)
   \   0000003E   0x....             LDR      R0,??DataTable17
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   2160          #else
   2161          		vol = 0;		/* Drive 0 */
   2162          #endif
   2163          	}
   2164          	return vol;
   \                     ??get_ldnumber_5: (+1)
   \   00000042   0xBC10             POP      {R4}
   \   00000044   0x4770             BX       LR               ;; return
   2165          }
   2166          
   2167          
   2168          
   2169          
   2170          /*-----------------------------------------------------------------------*/
   2171          /* Load a sector and check if it is an FAT boot sector                   */
   2172          /*-----------------------------------------------------------------------*/
   2173          

   \                                 In section .text, align 2, keep-with-next
   2174          static
   2175          BYTE check_fs (	/* 0:Valid FAT-BS, 1:Valid BS but not FAT, 2:Not a BS, 3:Disk error */
   2176          	FATFS* fs,	/* File system object */
   2177          	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
   2178          )
   2179          {
   \                     _Z8check_fsP5FATFSm: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2180          	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x7120             STRB     R0,[R4, #+4]
   \   00000008   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000000A   0x6320             STR      R0,[R4, #+48]
   2181          	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ      ??check_fs_0
   2182          		return 3;
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0xBD10             POP      {R4,PC}
   2183          
   2184          	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
   \                     ??check_fs_0: (+1)
   \   0000001A   0x6B60             LDR      R0,[R4, #+52]
   \   0000001C   0x21FF             MOVS     R1,#+255
   \   0000001E   0x0049             LSLS     R1,R1,#+1        ;; #+510
   \   00000020   0x1841             ADDS     R1,R0,R1
   \   00000022   0x784A             LDRB     R2,[R1, #+1]
   \   00000024   0x0212             LSLS     R2,R2,#+8
   \   00000026   0x7809             LDRB     R1,[R1, #+0]
   \   00000028   0x430A             ORRS     R2,R2,R1
   \   0000002A   0x....             LDR      R1,??DataTable17_1  ;; 0xaa55
   \   0000002C   0x428A             CMP      R2,R1
   \   0000002E   0xD001             BEQ      ??check_fs_1
   2185          		return 2;
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0xBD10             POP      {R4,PC}
   2186          
   2187          	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
   \                     ??check_fs_1: (+1)
   \   00000034   0x3036             ADDS     R0,R0,#+54
   \   00000036   0x....             LDR      R1,??DataTable17_2  ;; 0x544146
   \   00000038   0x7882             LDRB     R2,[R0, #+2]
   \   0000003A   0x0412             LSLS     R2,R2,#+16
   \   0000003C   0x7843             LDRB     R3,[R0, #+1]
   \   0000003E   0x021B             LSLS     R3,R3,#+8
   \   00000040   0x4313             ORRS     R3,R3,R2
   \   00000042   0x7802             LDRB     R2,[R0, #+0]
   \   00000044   0x431A             ORRS     R2,R2,R3
   \   00000046   0x428A             CMP      R2,R1
   \   00000048   0xD008             BEQ      ??check_fs_2
   2188          		return 0;
   2189          	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   \   0000004A   0x7F82             LDRB     R2,[R0, #+30]
   \   0000004C   0x0412             LSLS     R2,R2,#+16
   \   0000004E   0x7F43             LDRB     R3,[R0, #+29]
   \   00000050   0x021B             LSLS     R3,R3,#+8
   \   00000052   0x4313             ORRS     R3,R3,R2
   \   00000054   0x7F00             LDRB     R0,[R0, #+28]
   \   00000056   0x4318             ORRS     R0,R0,R3
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD101             BNE      ??check_fs_3
   2190          		return 0;
   \                     ??check_fs_2: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xBD10             POP      {R4,PC}
   2191          
   2192          	return 1;
   \                     ??check_fs_3: (+1)
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0xBD10             POP      {R4,PC}          ;; return
   2193          }
   2194          
   2195          
   2196          
   2197          
   2198          /*-----------------------------------------------------------------------*/
   2199          /* Find logical drive and check if the volume is mounted                 */
   2200          /*-----------------------------------------------------------------------*/
   2201          

   \                                 In section .text, align 4, keep-with-next
   2202          static
   2203          FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
   2204          	FATFS** rfs,		/* Pointer to pointer to the found file system object */
   2205          	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
   2206          	BYTE wmode			/* !=0: Check write protection for write access */
   2207          )
   2208          {
   \                     _Z11find_volumePP5FATFSPPKch: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x0008             MOVS     R0,R1
   \   00000008   0x0014             MOVS     R4,R2
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6039             STR      R1,[R7, #+0]
   2209          	BYTE fmt, *pt;
   2210          	int vol;
   2211          	DSTATUS stat;
   2212          	DWORD bsect, fasize, tsect, sysect, nclst, szbfat, br[4];
   2213          	WORD nrsv;
   2214          	FATFS *fs;
   2215          	UINT i;
   2216          
   2217          
   2218          	/* Get logical drive number from the path name */
   2219          	*rfs = 0;
   2220          	vol = get_ldnumber(path);
   \   0000000E   0x.... 0x....      BL       _Z12get_ldnumberPPKc
   \   00000012   0x0006             MOVS     R6,R0
   2221          	if (vol < 0) return FR_INVALID_DRIVE;
   \   00000014   0xD501             BPL      ??find_volume_0
   \   00000016   0x200B             MOVS     R0,#+11
   \   00000018   0xE195             B        ??find_volume_1
   \                     ??find_volume_0: (+1)
   \   0000001A   0x488D             LDR      R0,??find_volume_2
   \   0000001C   0x00B1             LSLS     R1,R6,#+2
   \   0000001E   0x1840             ADDS     R0,R0,R1
   \   00000020   0x6845             LDR      R5,[R0, #+4]
   2222          
   2223          	/* Check if the file system object is valid or not */
   2224          	fs = FatFs[vol];					/* Get pointer to the file system object */
   2225          	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD101             BNE      ??find_volume_3
   \   00000026   0x200C             MOVS     R0,#+12
   \   00000028   0xE18D             B        ??find_volume_1
   2226          
   2227          	ENTER_FF(fs);						/* Lock the volume */
   2228          	*rfs = fs;							/* Return pointer to the file system object */
   \                     ??find_volume_3: (+1)
   \   0000002A   0x603D             STR      R5,[R7, #+0]
   2229          
   2230          	if (fs->fs_type) {					/* If the volume has been mounted */
   \   0000002C   0x7828             LDRB     R0,[R5, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD00A             BEQ      ??find_volume_4
   2231          		stat = disk_status(fs->drv);
   \   00000032   0x7868             LDRB     R0,[R5, #+1]
   \   00000034   0x.... 0x....      BL       disk_status
   2232          		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
   \   00000038   0x07C1             LSLS     R1,R0,#+31
   \   0000003A   0xD405             BMI      ??find_volume_4
   2233          			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD001             BEQ      ??find_volume_5
   \   00000040   0x0740             LSLS     R0,R0,#+29
   \   00000042   0xD40F             BMI      ??find_volume_6
   2234          				return FR_WRITE_PROTECTED;
   2235          			return FR_OK;				/* The file system object is valid */
   \                     ??find_volume_5: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE17E             B        ??find_volume_1
   2236          		}
   2237          	}
   2238          
   2239          	/* The file system object is not valid. */
   2240          	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
   2241          
   2242          	fs->fs_type = 0;					/* Clear the file system object */
   \                     ??find_volume_4: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x7028             STRB     R0,[R5, #+0]
   2243          	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
   \   0000004C   0x706E             STRB     R6,[R5, #+1]
   2244          	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
   \   0000004E   0x7868             LDRB     R0,[R5, #+1]
   \   00000050   0x.... 0x....      BL       disk_initialize
   2245          	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
   \   00000054   0x07C1             LSLS     R1,R0,#+31
   \   00000056   0xD501             BPL      ??find_volume_7
   2246          		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
   \   00000058   0x2003             MOVS     R0,#+3
   \   0000005A   0xE174             B        ??find_volume_1
   2247          	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
   \                     ??find_volume_7: (+1)
   \   0000005C   0x2C00             CMP      R4,#+0
   \   0000005E   0xD003             BEQ      ??find_volume_8
   \   00000060   0x0740             LSLS     R0,R0,#+29
   \   00000062   0xD501             BPL      ??find_volume_8
   2248          		return FR_WRITE_PROTECTED;
   \                     ??find_volume_6: (+1)
   \   00000064   0x200A             MOVS     R0,#+10
   \   00000066   0xE16E             B        ??find_volume_1
   2249          #if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
   2250          	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
   2251          		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
   \                     ??find_volume_8: (+1)
   \   00000068   0x002A             MOVS     R2,R5
   \   0000006A   0x320A             ADDS     R2,R2,#+10
   \   0000006C   0x2102             MOVS     R1,#+2
   \   0000006E   0x7868             LDRB     R0,[R5, #+1]
   \   00000070   0x.... 0x....      BL       disk_ioctl
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD145             BNE      ??find_volume_9
   \   00000078   0x8968             LDRH     R0,[R5, #+10]
   \   0000007A   0x....             LDR      R1,??DataTable18  ;; 0xfffffe00
   \   0000007C   0x1841             ADDS     R1,R0,R1
   \   0000007E   0x....             LDR      R2,??DataTable18_1  ;; 0xe01
   \   00000080   0x4291             CMP      R1,R2
   \   00000082   0xD23F             BCS      ??find_volume_9
   2252          #endif
   2253          #if _FS_HEAPBUF
   2254          	if (!fs->win) {
   \   00000084   0x6B69             LDR      R1,[R5, #+52]
   \   00000086   0x2900             CMP      R1,#+0
   \   00000088   0xD106             BNE      ??find_volume_10
   2255          		fs->win = (BYTE*)ff_memalloc(SS(fs));	/* Allocate buffer to back window if necessary */
   \   0000008A   0x.... 0x....      BL       ff_memalloc
   \   0000008E   0x6368             STR      R0,[R5, #+52]
   2256          		if (!fs->win)
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD101             BNE      ??find_volume_10
   2257          			return FR_NOT_ENOUGH_CORE;
   \   00000094   0x2011             MOVS     R0,#+17
   \   00000096   0xE156             B        ??find_volume_1
   2258          	}
   2259          #endif
   2260          	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
   2261          	bsect = 0;
   \                     ??find_volume_10: (+1)
   \   00000098   0x2700             MOVS     R7,#+0
   2262          	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0x0028             MOVS     R0,R5
   \   0000009E   0x.... 0x....      BL       _Z8check_fsP5FATFSm
   \   000000A2   0x0004             MOVS     R4,R0
   2263          	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
   \   000000A4   0x2C01             CMP      R4,#+1
   \   000000A6   0xD12B             BNE      ??find_volume_11
   2264          		for (i = 0; i < 4; i++) {			/* Get partition offset */
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xA907             ADD      R1,SP,#+28
   \   000000AC   0x6B6A             LDR      R2,[R5, #+52]
   \   000000AE   0x23DF             MOVS     R3,#+223
   \   000000B0   0x005B             LSLS     R3,R3,#+1        ;; #+446
   \   000000B2   0x18D2             ADDS     R2,R2,R3
   2265          			pt = fs->win + MBR_Table + i * SZ_PTE;
   2266          			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
   \                     ??find_volume_12: (+1)
   \   000000B4   0x7913             LDRB     R3,[R2, #+4]
   \   000000B6   0x2B00             CMP      R3,#+0
   \   000000B8   0xD009             BEQ      ??find_volume_13
   \   000000BA   0x7AD3             LDRB     R3,[R2, #+11]
   \   000000BC   0x061B             LSLS     R3,R3,#+24
   \   000000BE   0x7A94             LDRB     R4,[R2, #+10]
   \   000000C0   0x0424             LSLS     R4,R4,#+16
   \   000000C2   0x431C             ORRS     R4,R4,R3
   \   000000C4   0x7A53             LDRB     R3,[R2, #+9]
   \   000000C6   0x021E             LSLS     R6,R3,#+8
   \   000000C8   0x4326             ORRS     R6,R6,R4
   \   000000CA   0x7A13             LDRB     R3,[R2, #+8]
   \   000000CC   0x4333             ORRS     R3,R3,R6
   \                     ??find_volume_13: (+1)
   \   000000CE   0x600B             STR      R3,[R1, #+0]
   2267          		}
   \   000000D0   0x1C40             ADDS     R0,R0,#+1
   \   000000D2   0x3210             ADDS     R2,R2,#+16
   \   000000D4   0x1D09             ADDS     R1,R1,#+4
   \   000000D6   0x2804             CMP      R0,#+4
   \   000000D8   0xD3EC             BCC      ??find_volume_12
   2268          		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
   \   000000DA   0x9702             STR      R7,[SP, #+8]
   2269          		if (i) i--;
   \   000000DC   0xAE07             ADD      R6,SP,#+28
   2270          		do {								/* Find an FAT volume */
   2271          			bsect = br[i];
   \                     ??find_volume_14: (+1)
   \   000000DE   0x6837             LDR      R7,[R6, #+0]
   2272          			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
   \   000000E0   0x2F00             CMP      R7,#+0
   \   000000E2   0xD004             BEQ      ??find_volume_15
   \   000000E4   0x0039             MOVS     R1,R7
   \   000000E6   0x0028             MOVS     R0,R5
   \   000000E8   0x.... 0x....      BL       _Z8check_fsP5FATFSm
   \   000000EC   0xE000             B        ??find_volume_16
   \                     ??find_volume_15: (+1)
   \   000000EE   0x2002             MOVS     R0,#+2
   \                     ??find_volume_16: (+1)
   \   000000F0   0x0004             MOVS     R4,R0
   2273          		} while (!LD2PT(vol) && fmt && ++i < 4);
   \   000000F2   0xD005             BEQ      ??find_volume_11
   \   000000F4   0x9802             LDR      R0,[SP, #+8]
   \   000000F6   0x1C40             ADDS     R0,R0,#+1
   \   000000F8   0x9002             STR      R0,[SP, #+8]
   \   000000FA   0x1D36             ADDS     R6,R6,#+4
   \   000000FC   0x2804             CMP      R0,#+4
   \   000000FE   0xD3EE             BCC      ??find_volume_14
   2274          	}
   2275          	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
   \                     ??find_volume_11: (+1)
   \   00000100   0x2C03             CMP      R4,#+3
   \   00000102   0xD101             BNE      ??find_volume_17
   \                     ??find_volume_9: (+1)
   \   00000104   0x2001             MOVS     R0,#+1
   \   00000106   0xE11E             B        ??find_volume_1
   2276          	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
   \                     ??find_volume_17: (+1)
   \   00000108   0x2C00             CMP      R4,#+0
   \   0000010A   0xD000             BEQ      .+4
   \   0000010C   0xE0BD             B        ??find_volume_18
   2277          
   2278          	/* An FAT volume is found. Following code initializes the file system object */
   2279          
   2280          	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
   \   0000010E   0x6B68             LDR      R0,[R5, #+52]
   \   00000110   0x9006             STR      R0,[SP, #+24]
   \   00000112   0x4606             MOV      R6,R0
   \   00000114   0x360B             ADDS     R6,R6,#+11
   \   00000116   0x8968             LDRH     R0,[R5, #+10]
   \   00000118   0x4669             MOV      R1,SP
   \   0000011A   0x8188             STRH     R0,[R1, #+12]
   \   0000011C   0x7870             LDRB     R0,[R6, #+1]
   \   0000011E   0x0200             LSLS     R0,R0,#+8
   \   00000120   0x7831             LDRB     R1,[R6, #+0]
   \   00000122   0x4308             ORRS     R0,R0,R1
   \   00000124   0x4669             MOV      R1,SP
   \   00000126   0x8989             LDRH     R1,[R1, #+12]
   \   00000128   0x4288             CMP      R0,R1
   \   0000012A   0xD000             BEQ      .+4
   \   0000012C   0xE0AD             B        ??find_volume_18
   2281          		return FR_NO_FILESYSTEM;
   2282          
   2283          	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
   \   0000012E   0x7B30             LDRB     R0,[R6, #+12]
   \   00000130   0x0200             LSLS     R0,R0,#+8
   \   00000132   0x7AF1             LDRB     R1,[R6, #+11]
   \   00000134   0x4308             ORRS     R0,R0,R1
   \   00000136   0x9001             STR      R0,[SP, #+4]
   2284          	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
   \   00000138   0xD10A             BNE      ??find_volume_19
   \   0000013A   0x7F30             LDRB     R0,[R6, #+28]
   \   0000013C   0x0600             LSLS     R0,R0,#+24
   \   0000013E   0x7EF1             LDRB     R1,[R6, #+27]
   \   00000140   0x0409             LSLS     R1,R1,#+16
   \   00000142   0x4301             ORRS     R1,R1,R0
   \   00000144   0x7EB0             LDRB     R0,[R6, #+26]
   \   00000146   0x0200             LSLS     R0,R0,#+8
   \   00000148   0x4308             ORRS     R0,R0,R1
   \   0000014A   0x7E71             LDRB     R1,[R6, #+25]
   \   0000014C   0x4301             ORRS     R1,R1,R0
   \   0000014E   0x9101             STR      R1,[SP, #+4]
   2285          	fs->fsize = fasize;
   \                     ??find_volume_19: (+1)
   \   00000150   0x9801             LDR      R0,[SP, #+4]
   \   00000152   0x61E8             STR      R0,[R5, #+28]
   2286          
   2287          	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
   \   00000154   0x7970             LDRB     R0,[R6, #+5]
   \   00000156   0x70E8             STRB     R0,[R5, #+3]
   2288          	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
   \   00000158   0x2801             CMP      R0,#+1
   \   0000015A   0xD002             BEQ      ??find_volume_20
   \   0000015C   0x2802             CMP      R0,#+2
   \   0000015E   0xD000             BEQ      .+4
   \   00000160   0xE093             B        ??find_volume_18
   2289          		return FR_NO_FILESYSTEM;
   2290          	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
   \                     ??find_volume_20: (+1)
   \   00000162   0x9901             LDR      R1,[SP, #+4]
   \   00000164   0x4341             MULS     R1,R0,R1
   \   00000166   0x9101             STR      R1,[SP, #+4]
   2291          
   2292          	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
   \   00000168   0x78B0             LDRB     R0,[R6, #+2]
   \   0000016A   0x4669             MOV      R1,SP
   \   0000016C   0x7088             STRB     R0,[R1, #+2]
   \   0000016E   0x78B0             LDRB     R0,[R6, #+2]
   \   00000170   0x70A8             STRB     R0,[R5, #+2]
   2293          	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
   \   00000172   0x4668             MOV      R0,SP
   \   00000174   0x7880             LDRB     R0,[R0, #+2]
   \   00000176   0x2800             CMP      R0,#+0
   \   00000178   0xD100             BNE      .+4
   \   0000017A   0xE086             B        ??find_volume_18
   \   0000017C   0x4668             MOV      R0,SP
   \   0000017E   0x7880             LDRB     R0,[R0, #+2]
   \   00000180   0x1E41             SUBS     R1,R0,#+1
   \   00000182   0x4208             TST      R0,R1
   \   00000184   0xD000             BEQ      .+4
   \   00000186   0xE080             B        ??find_volume_18
   2294          		return FR_NO_FILESYSTEM;
   2295          
   2296          	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
   \   00000188   0x79F0             LDRB     R0,[R6, #+7]
   \   0000018A   0x0200             LSLS     R0,R0,#+8
   \   0000018C   0x79B1             LDRB     R1,[R6, #+6]
   \   0000018E   0x4308             ORRS     R0,R0,R1
   \   00000190   0x4669             MOV      R1,SP
   \   00000192   0x8008             STRH     R0,[R1, #+0]
   \   00000194   0x4668             MOV      R0,SP
   \   00000196   0x8800             LDRH     R0,[R0, #+0]
   \   00000198   0x8128             STRH     R0,[R5, #+8]
   \   0000019A   0x4668             MOV      R0,SP
   \   0000019C   0x8980             LDRH     R0,[R0, #+12]
   \   0000019E   0x0940             LSRS     R0,R0,#+5
   \   000001A0   0x9002             STR      R0,[SP, #+8]
   \   000001A2   0x4668             MOV      R0,SP
   \   000001A4   0x8800             LDRH     R0,[R0, #+0]
   \   000001A6   0x9902             LDR      R1,[SP, #+8]
   \   000001A8   0x.... 0x....      BL       __aeabi_idivmod
   \   000001AC   0x2900             CMP      R1,#+0
   \   000001AE   0xD16C             BNE      ??find_volume_18
   2297          	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
   2298          		return FR_NO_FILESYSTEM;
   2299          
   2300          	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
   \   000001B0   0x7A70             LDRB     R0,[R6, #+9]
   \   000001B2   0x0204             LSLS     R4,R0,#+8
   \   000001B4   0x7A30             LDRB     R0,[R6, #+8]
   \   000001B6   0x4304             ORRS     R4,R4,R0
   2301          	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
   \   000001B8   0xD109             BNE      ??find_volume_21
   \   000001BA   0x7E30             LDRB     R0,[R6, #+24]
   \   000001BC   0x0600             LSLS     R0,R0,#+24
   \   000001BE   0x7DF1             LDRB     R1,[R6, #+23]
   \   000001C0   0x0409             LSLS     R1,R1,#+16
   \   000001C2   0x4301             ORRS     R1,R1,R0
   \   000001C4   0x7DB0             LDRB     R0,[R6, #+22]
   \   000001C6   0x0200             LSLS     R0,R0,#+8
   \   000001C8   0x4308             ORRS     R0,R0,R1
   \   000001CA   0x7D74             LDRB     R4,[R6, #+21]
   \   000001CC   0x4304             ORRS     R4,R4,R0
   2302          
   2303          	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
   \                     ??find_volume_21: (+1)
   \   000001CE   0x7930             LDRB     R0,[R6, #+4]
   \   000001D0   0x0200             LSLS     R0,R0,#+8
   \   000001D2   0x78F1             LDRB     R1,[R6, #+3]
   \   000001D4   0x4308             ORRS     R0,R0,R1
   \   000001D6   0x9005             STR      R0,[SP, #+20]
   2304          	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
   \   000001D8   0xD057             BEQ      ??find_volume_18
   2305          
   2306          	/* Determine the FAT sub type */
   2307          	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + FATFS_DIR */
   \   000001DA   0x9901             LDR      R1,[SP, #+4]
   \   000001DC   0x1846             ADDS     R6,R0,R1
   \   000001DE   0x4668             MOV      R0,SP
   \   000001E0   0x8800             LDRH     R0,[R0, #+0]
   \   000001E2   0x9902             LDR      R1,[SP, #+8]
   \   000001E4   0x.... 0x....      BL       __aeabi_idiv
   \   000001E8   0x1830             ADDS     R0,R6,R0
   \   000001EA   0x9004             STR      R0,[SP, #+16]
   2308          	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   \   000001EC   0x4284             CMP      R4,R0
   \   000001EE   0xD34C             BCC      ??find_volume_18
   2309          	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
   \   000001F0   0x1A20             SUBS     R0,R4,R0
   \   000001F2   0x4669             MOV      R1,SP
   \   000001F4   0x7889             LDRB     R1,[R1, #+2]
   \   000001F6   0x.... 0x....      BL       __aeabi_uidiv
   2310          	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
   \   000001FA   0x2800             CMP      R0,#+0
   \   000001FC   0xD045             BEQ      ??find_volume_18
   2311          	fmt = FS_FAT12;
   \   000001FE   0x2101             MOVS     R1,#+1
   \   00000200   0x2401             MOVS     R4,#+1
   2312          	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   \   00000202   0x....             LDR      R2,??DataTable19  ;; 0xff6
   \   00000204   0x4290             CMP      R0,R2
   \   00000206   0xD300             BCC      ??find_volume_22
   \   00000208   0x2402             MOVS     R4,#+2
   2313          	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   \                     ??find_volume_22: (+1)
   \   0000020A   0x....             LDR      R2,??DataTable19_1  ;; 0xfff6
   \   0000020C   0x4290             CMP      R0,R2
   \   0000020E   0xD300             BCC      ??find_volume_23
   \   00000210   0x2403             MOVS     R4,#+3
   2314          
   2315          	/* Boundaries and Limits */
   2316          	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   \                     ??find_volume_23: (+1)
   \   00000212   0x1C80             ADDS     R0,R0,#+2
   \   00000214   0x61A8             STR      R0,[R5, #+24]
   2317          	fs->volbase = bsect;								/* Volume start sector */
   \   00000216   0x622F             STR      R7,[R5, #+32]
   2318          	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   \   00000218   0x9805             LDR      R0,[SP, #+20]
   \   0000021A   0x1838             ADDS     R0,R7,R0
   \   0000021C   0x6268             STR      R0,[R5, #+36]
   2319          	fs->database = bsect + sysect;						/* Data start sector */
   \   0000021E   0x9804             LDR      R0,[SP, #+16]
   \   00000220   0x1838             ADDS     R0,R7,R0
   \   00000222   0x62E8             STR      R0,[R5, #+44]
   2320          	if (fmt == FS_FAT32) {
   \   00000224   0x2C03             CMP      R4,#+3
   \   00000226   0x4668             MOV      R0,SP
   \   00000228   0x8800             LDRH     R0,[R0, #+0]
   \   0000022A   0xD113             BNE      ??find_volume_24
   2321          		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   \   0000022C   0x2800             CMP      R0,#+0
   \   0000022E   0xD12C             BNE      ??find_volume_18
   2322          		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
   \   00000230   0x9806             LDR      R0,[SP, #+24]
   \   00000232   0x302C             ADDS     R0,R0,#+44
   \   00000234   0x78C1             LDRB     R1,[R0, #+3]
   \   00000236   0x0609             LSLS     R1,R1,#+24
   \   00000238   0x7882             LDRB     R2,[R0, #+2]
   \   0000023A   0x0412             LSLS     R2,R2,#+16
   \   0000023C   0x430A             ORRS     R2,R2,R1
   \   0000023E   0x7841             LDRB     R1,[R0, #+1]
   \   00000240   0x0209             LSLS     R1,R1,#+8
   \   00000242   0x4311             ORRS     R1,R1,R2
   \   00000244   0x7800             LDRB     R0,[R0, #+0]
   \   00000246   0x4308             ORRS     R0,R0,R1
   2323          		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
   \   00000248   0x69A9             LDR      R1,[R5, #+24]
   \   0000024A   0x0089             LSLS     R1,R1,#+2
   \   0000024C   0xE011             B        ??find_volume_25
   \   0000024E   0xBF00             Nop      
   \                     ??find_volume_2:
   \   00000250   0x........         DC32     CurrVol
   2324          	} else {
   2325          		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
   \                     ??find_volume_24: (+1)
   \   00000254   0x2800             CMP      R0,#+0
   \   00000256   0xD018             BEQ      ??find_volume_18
   2326          		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
   \   00000258   0x6A68             LDR      R0,[R5, #+36]
   \   0000025A   0x9A01             LDR      R2,[SP, #+4]
   \   0000025C   0x1880             ADDS     R0,R0,R2
   2327          		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
   2328          			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   \   0000025E   0x69AA             LDR      R2,[R5, #+24]
   \   00000260   0x2C02             CMP      R4,#+2
   \   00000262   0xD101             BNE      ??find_volume_26
   \   00000264   0x0051             LSLS     R1,R2,#+1
   \   00000266   0xE004             B        ??find_volume_25
   \                     ??find_volume_26: (+1)
   \   00000268   0x0053             LSLS     R3,R2,#+1
   \   0000026A   0x189B             ADDS     R3,R3,R2
   \   0000026C   0x085B             LSRS     R3,R3,#+1
   \   0000026E   0x4011             ANDS     R1,R1,R2
   \   00000270   0x1859             ADDS     R1,R3,R1
   \                     ??find_volume_25: (+1)
   \   00000272   0x62A8             STR      R0,[R5, #+40]
   2329          	}
   2330          	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
   \   00000274   0x4668             MOV      R0,SP
   \   00000276   0x8980             LDRH     R0,[R0, #+12]
   \   00000278   0x1E40             SUBS     R0,R0,#+1
   \   0000027A   0x1808             ADDS     R0,R1,R0
   \   0000027C   0x4669             MOV      R1,SP
   \   0000027E   0x8989             LDRH     R1,[R1, #+12]
   \   00000280   0x.... 0x....      BL       __aeabi_uidiv
   \   00000284   0x69E9             LDR      R1,[R5, #+28]
   \   00000286   0x4281             CMP      R1,R0
   \   00000288   0xD201             BCS      ??find_volume_27
   2331          		return FR_NO_FILESYSTEM;
   \                     ??find_volume_18: (+1)
   \   0000028A   0x200D             MOVS     R0,#+13
   \   0000028C   0xE05B             B        ??find_volume_1
   2332          
   2333          #if !_FS_READONLY
   2334          	/* Initialize cluster allocation information */
   2335          	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
   \                     ??find_volume_27: (+1)
   \   0000028E   0x2000             MOVS     R0,#+0
   \   00000290   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000292   0x6128             STR      R0,[R5, #+16]
   \   00000294   0x60E8             STR      R0,[R5, #+12]
   2336          
   2337          	/* Get fsinfo if available */
   2338          	fs->fsi_flag = 0x80;
   \   00000296   0x2080             MOVS     R0,#+128
   \   00000298   0x7168             STRB     R0,[R5, #+5]
   2339          #if (_FS_NOFSINFO & 3) != 3
   2340          	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
   2341          		&& LD_WORD(fs->win + BPB_FSInfo) == 1
   2342          		&& move_window(fs, bsect + 1) == FR_OK)
   \   0000029A   0x2C03             CMP      R4,#+3
   \   0000029C   0xD14A             BNE      ??find_volume_28
   \   0000029E   0x9806             LDR      R0,[SP, #+24]
   \   000002A0   0x302C             ADDS     R0,R0,#+44
   \   000002A2   0x7941             LDRB     R1,[R0, #+5]
   \   000002A4   0x0209             LSLS     R1,R1,#+8
   \   000002A6   0x7900             LDRB     R0,[R0, #+4]
   \   000002A8   0x4301             ORRS     R1,R1,R0
   \   000002AA   0x2901             CMP      R1,#+1
   \   000002AC   0xD142             BNE      ??find_volume_28
   \   000002AE   0x1C79             ADDS     R1,R7,#+1
   \   000002B0   0x0028             MOVS     R0,R5
   \   000002B2   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   000002B6   0x2800             CMP      R0,#+0
   \   000002B8   0xD13C             BNE      ??find_volume_28
   2343          	{
   2344          		fs->fsi_flag = 0;
   \   000002BA   0x7168             STRB     R0,[R5, #+5]
   2345          		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
   2346          			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
   2347          			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
   \   000002BC   0x6B68             LDR      R0,[R5, #+52]
   \   000002BE   0x21F2             MOVS     R1,#+242
   \   000002C0   0x0049             LSLS     R1,R1,#+1        ;; #+484
   \   000002C2   0x1841             ADDS     R1,R0,R1
   \   000002C4   0x7ECA             LDRB     R2,[R1, #+27]
   \   000002C6   0x0212             LSLS     R2,R2,#+8
   \   000002C8   0x7E8B             LDRB     R3,[R1, #+26]
   \   000002CA   0x431A             ORRS     R2,R2,R3
   \   000002CC   0x....             LDR      R3,??DataTable20  ;; 0xaa55
   \   000002CE   0x429A             CMP      R2,R3
   \   000002D0   0xD130             BNE      ??find_volume_28
   \   000002D2   0x1C42             ADDS     R2,R0,#+1
   \   000002D4   0x7893             LDRB     R3,[R2, #+2]
   \   000002D6   0x061E             LSLS     R6,R3,#+24
   \   000002D8   0x7853             LDRB     R3,[R2, #+1]
   \   000002DA   0x041B             LSLS     R3,R3,#+16
   \   000002DC   0x4333             ORRS     R3,R3,R6
   \   000002DE   0x7812             LDRB     R2,[R2, #+0]
   \   000002E0   0x0212             LSLS     R2,R2,#+8
   \   000002E2   0x431A             ORRS     R2,R2,R3
   \   000002E4   0x7800             LDRB     R0,[R0, #+0]
   \   000002E6   0x4310             ORRS     R0,R0,R2
   \   000002E8   0x....             LDR      R2,??DataTable20_1  ;; 0x41615252
   \   000002EA   0x4290             CMP      R0,R2
   \   000002EC   0xD122             BNE      ??find_volume_28
   \   000002EE   0x78C8             LDRB     R0,[R1, #+3]
   \   000002F0   0x0600             LSLS     R0,R0,#+24
   \   000002F2   0x788A             LDRB     R2,[R1, #+2]
   \   000002F4   0x0412             LSLS     R2,R2,#+16
   \   000002F6   0x4302             ORRS     R2,R2,R0
   \   000002F8   0x7848             LDRB     R0,[R1, #+1]
   \   000002FA   0x0200             LSLS     R0,R0,#+8
   \   000002FC   0x4310             ORRS     R0,R0,R2
   \   000002FE   0x780A             LDRB     R2,[R1, #+0]
   \   00000300   0x4302             ORRS     R2,R2,R0
   \   00000302   0x....             LDR      R0,??DataTable20_2  ;; 0x61417272
   \   00000304   0x4282             CMP      R2,R0
   \   00000306   0xD115             BNE      ??find_volume_28
   2348          		{
   2349          #if (_FS_NOFSINFO & 1) == 0
   2350          			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
   \   00000308   0x79C8             LDRB     R0,[R1, #+7]
   \   0000030A   0x0600             LSLS     R0,R0,#+24
   \   0000030C   0x798A             LDRB     R2,[R1, #+6]
   \   0000030E   0x0412             LSLS     R2,R2,#+16
   \   00000310   0x4302             ORRS     R2,R2,R0
   \   00000312   0x7948             LDRB     R0,[R1, #+5]
   \   00000314   0x0200             LSLS     R0,R0,#+8
   \   00000316   0x4310             ORRS     R0,R0,R2
   \   00000318   0x790A             LDRB     R2,[R1, #+4]
   \   0000031A   0x4302             ORRS     R2,R2,R0
   \   0000031C   0x612A             STR      R2,[R5, #+16]
   2351          #endif
   2352          #if (_FS_NOFSINFO & 2) == 0
   2353          			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
   \   0000031E   0x7AC8             LDRB     R0,[R1, #+11]
   \   00000320   0x0600             LSLS     R0,R0,#+24
   \   00000322   0x7A8A             LDRB     R2,[R1, #+10]
   \   00000324   0x0412             LSLS     R2,R2,#+16
   \   00000326   0x4302             ORRS     R2,R2,R0
   \   00000328   0x7A48             LDRB     R0,[R1, #+9]
   \   0000032A   0x0200             LSLS     R0,R0,#+8
   \   0000032C   0x4310             ORRS     R0,R0,R2
   \   0000032E   0x7A09             LDRB     R1,[R1, #+8]
   \   00000330   0x4301             ORRS     R1,R1,R0
   \   00000332   0x60E9             STR      R1,[R5, #+12]
   2354          #endif
   2355          		}
   2356          	}
   2357          #endif
   2358          #endif
   2359          	fs->fs_type = fmt;	/* FAT sub-type */
   \                     ??find_volume_28: (+1)
   \   00000334   0x702C             STRB     R4,[R5, #+0]
   2360          	fs->id = ++Fsid;	/* File system mount ID */
   \   00000336   0x....             LDR      R0,??DataTable20_3
   \   00000338   0x8840             LDRH     R0,[R0, #+2]
   \   0000033A   0x1C40             ADDS     R0,R0,#+1
   \   0000033C   0x....             LDR      R1,??DataTable20_3
   \   0000033E   0x8048             STRH     R0,[R1, #+2]
   \   00000340   0x80E8             STRH     R0,[R5, #+6]
   2361          #if _FS_RPATH
   2362          	fs->cdir = 0;		/* Set current directory to root */
   \   00000342   0x2000             MOVS     R0,#+0
   \   00000344   0x6168             STR      R0,[R5, #+20]
   2363          #endif
   2364          #if _FS_LOCK			/* Clear file lock semaphores */
   2365          	clear_lock(fs);
   2366          #endif
   2367          
   2368          	return FR_OK;
   \                     ??find_volume_1: (+1)
   \   00000346   0xB00B             ADD      SP,SP,#+44
   \   00000348   0xBDF0             POP      {R4-R7,PC}       ;; return
   2369          }
   2370          
   2371          
   2372          
   2373          
   2374          /*-----------------------------------------------------------------------*/
   2375          /* Check if the file/directory object is valid or not                    */
   2376          /*-----------------------------------------------------------------------*/
   2377          

   \                                 In section .text, align 2, keep-with-next
   2378          static
   2379          FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
   2380          	void* obj		/* Pointer to the object FIL/FATFS_DIR to check validity */
   2381          )
   2382          {
   \                     _Z8validatePv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2383          	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/FATFS_DIR structure is identical */
   2384          
   2385          
   2386          	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD00E             BEQ      ??validate_0
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD00B             BEQ      ??validate_0
   \   0000000C   0x780A             LDRB     R2,[R1, #+0]
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD008             BEQ      ??validate_0
   \   00000012   0x88CA             LDRH     R2,[R1, #+6]
   \   00000014   0x8880             LDRH     R0,[R0, #+4]
   \   00000016   0x4282             CMP      R2,R0
   \   00000018   0xD104             BNE      ??validate_0
   \   0000001A   0x7848             LDRB     R0,[R1, #+1]
   \   0000001C   0x.... 0x....      BL       disk_status
   \   00000020   0x07C0             LSLS     R0,R0,#+31
   \   00000022   0xD501             BPL      ??validate_1
   2387          		return FR_INVALID_OBJECT;
   \                     ??validate_0: (+1)
   \   00000024   0x2009             MOVS     R0,#+9
   \   00000026   0xBD02             POP      {R1,PC}
   2388          
   2389          	ENTER_FF(fil->fs);		/* Lock file system */
   2390          
   2391          	return FR_OK;
   \                     ??validate_1: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD02             POP      {R1,PC}          ;; return
   2392          }
   2393          
   2394          
   2395          
   2396          
   2397          /*--------------------------------------------------------------------------
   2398          
   2399             Public Functions
   2400          
   2401          ---------------------------------------------------------------------------*/
   2402          
   2403          
   2404          
   2405          /*-----------------------------------------------------------------------*/
   2406          /* Mount/Unmount a Logical Drive                                         */
   2407          /*-----------------------------------------------------------------------*/
   2408          

   \                                 In section .text, align 2, keep-with-next
   2409          FRESULT f_mount (
   2410          	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
   2411          	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
   2412          	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
   2413          )
   2414          {
   \                     f_mount: (+1)
   \   00000000   0xB533             PUSH     {R0,R1,R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0014             MOVS     R4,R2
   2415          	FATFS *cfs;
   2416          	int vol;
   2417          	FRESULT res;
   2418          	const TCHAR *rp = path;
   2419          
   2420          
   2421          	vol = get_ldnumber(&rp);
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD017             BEQ      ??f_mount_0
   \   0000000C   0xE000             B        ??f_mount_1
   \                     ??f_mount_2: (+1)
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \                     ??f_mount_1: (+1)
   \   00000010   0x7801             LDRB     R1,[R0, #+0]
   \   00000012   0x2920             CMP      R1,#+32
   \   00000014   0xD301             BCC      ??f_mount_3
   \   00000016   0x293A             CMP      R1,#+58
   \   00000018   0xD1F9             BNE      ??f_mount_2
   \                     ??f_mount_3: (+1)
   \   0000001A   0x293A             CMP      R1,#+58
   \   0000001C   0xD10A             BNE      ??f_mount_4
   \   0000001E   0x9902             LDR      R1,[SP, #+8]
   \   00000020   0x780A             LDRB     R2,[R1, #+0]
   \   00000022   0x3A30             SUBS     R2,R2,#+48
   \   00000024   0x1C49             ADDS     R1,R1,#+1
   \   00000026   0x2A0A             CMP      R2,#+10
   \   00000028   0xD208             BCS      ??f_mount_0
   \   0000002A   0x4281             CMP      R1,R0
   \   0000002C   0xD106             BNE      ??f_mount_0
   \   0000002E   0x2A04             CMP      R2,#+4
   \   00000030   0xD204             BCS      ??f_mount_0
   \   00000032   0xE001             B        ??f_mount_5
   \                     ??f_mount_4: (+1)
   \   00000034   0x....             LDR      R0,??DataTable20_3
   \   00000036   0x7802             LDRB     R2,[R0, #+0]
   2422          	if (vol < 0) return FR_INVALID_DRIVE;
   \                     ??f_mount_5: (+1)
   \   00000038   0x2A00             CMP      R2,#+0
   \   0000003A   0xD501             BPL      ??f_mount_6
   \                     ??f_mount_0: (+1)
   \   0000003C   0x200B             MOVS     R0,#+11
   \   0000003E   0xE020             B        ??f_mount_7
   \                     ??f_mount_6: (+1)
   \   00000040   0x....             LDR      R0,??DataTable20_3
   \   00000042   0x0091             LSLS     R1,R2,#+2
   \   00000044   0x1845             ADDS     R5,R0,R1
   \   00000046   0x6868             LDR      R0,[R5, #+4]
   2423          	cfs = FatFs[vol];					/* Pointer to fs object */
   2424          
   2425          	if (cfs) {
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD004             BEQ      ??f_mount_8
   2426          #if _FS_LOCK
   2427          		clear_lock(cfs);
   2428          #endif
   2429          #if _FS_REENTRANT						/* Discard sync object of the current volume */
   2430          		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
   2431          #endif
   2432          		cfs->fs_type = 0;				/* Clear old fs object */
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x7001             STRB     R1,[R0, #+0]
   2433          #if _FS_HEAPBUF
   2434          		ff_memfree(cfs->win);			/* Clean up window buffer */
   \   00000050   0x6B40             LDR      R0,[R0, #+52]
   \   00000052   0x.... 0x....      BL       ff_memfree
   2435          #endif
   2436          	}
   2437          
   2438          	if (fs) {
   \                     ??f_mount_8: (+1)
   \   00000056   0x9801             LDR      R0,[SP, #+4]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD004             BEQ      ??f_mount_9
   2439          		fs->fs_type = 0;				/* Clear new fs object */
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x9A01             LDR      R2,[SP, #+4]
   \   00000060   0x7010             STRB     R0,[R2, #+0]
   2440          #if _FS_REENTRANT						/* Create sync object for the new volume */
   2441          		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
   2442          #endif
   2443          #if _FS_HEAPBUF
   2444          		fs->win = 0;					/* NULL buffer to prevent use of uninitialized buffer */
   \   00000062   0x9901             LDR      R1,[SP, #+4]
   \   00000064   0x6348             STR      R0,[R1, #+52]
   2445          #endif
   2446          	}
   2447          	FatFs[vol] = fs;					/* Register new fs object */
   \                     ??f_mount_9: (+1)
   \   00000066   0x9801             LDR      R0,[SP, #+4]
   \   00000068   0x6068             STR      R0,[R5, #+4]
   2448          
   2449          	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
   \   0000006A   0x9801             LDR      R0,[SP, #+4]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD001             BEQ      ??f_mount_10
   \   00000070   0x2C01             CMP      R4,#+1
   \   00000072   0xD001             BEQ      ??f_mount_11
   \                     ??f_mount_10: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xE004             B        ??f_mount_7
   2450          
   2451          	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
   2452          	LEAVE_FF(fs, res);
   \                     ??f_mount_11: (+1)
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0xA902             ADD      R1,SP,#+8
   \   0000007C   0xA801             ADD      R0,SP,#+4
   \   0000007E   0x.... 0x....      BL       _Z11find_volumePP5FATFSPPKch
   \                     ??f_mount_7: (+1)
   \   00000082   0xB003             ADD      SP,SP,#+12
   \   00000084   0xBD30             POP      {R4,R5,PC}       ;; return
   2453          }
   2454          
   2455          
   2456          
   2457          
   2458          /*-----------------------------------------------------------------------*/
   2459          /* Open or Create a File                                                 */
   2460          /*-----------------------------------------------------------------------*/
   2461          

   \                                 In section .text, align 2, keep-with-next
   2462          FRESULT f_open (
   2463          	FIL* fp,			/* Pointer to the blank file object */
   2464          	const TCHAR* path,	/* Pointer to the file name */
   2465          	BYTE mode			/* Access mode and file open mode flags */
   2466          )
   2467          {
   \                     f_open: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   2468          	FRESULT res;
   2469          	FATFS_DIR dj;
   2470          	BYTE *dir;
   2471          	DEFINE_NAMEBUF;
   2472          #if !_FS_READONLY
   2473          	DWORD dw, cl;
   2474          #endif
   2475          
   2476          
   2477          	if (!fp) return FR_INVALID_OBJECT;
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD101             BNE      ??f_open_0
   \   00000008   0x2009             MOVS     R0,#+9
   \   0000000A   0xE09A             B        ??f_open_1
   \                     ??f_open_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x990D             LDR      R1,[SP, #+52]
   \   00000010   0x6008             STR      R0,[R1, #+0]
   2478          	fp->fs = 0;			/* Clear file object */
   2479          
   2480          	/* Get logical drive number */
   2481          #if !_FS_READONLY
   2482          	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   \   00000012   0x06D6             LSLS     R6,R2,#+27
   \   00000014   0x0EF6             LSRS     R6,R6,#+27
   2483          	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
   \   00000016   0x22FE             MOVS     R2,#+254
   \   00000018   0x4032             ANDS     R2,R2,R6
   \   0000001A   0xA90E             ADD      R1,SP,#+56
   \   0000001C   0xA801             ADD      R0,SP,#+4
   \   0000001E   0x.... 0x....      BL       _Z11find_volumePP5FATFSPPKch
   \   00000022   0x0004             MOVS     R4,R0
   2484          #else
   2485          	mode &= FA_READ;
   2486          	res = find_volume(&dj.fs, &path, 0);
   2487          #endif
   2488          	if (res == FR_OK) {
   \   00000024   0xD000             BEQ      .+4
   \   00000026   0xE08B             B        ??f_open_2
   2489          		INIT_BUF(dj);
   \   00000028   0xA80A             ADD      R0,SP,#+40
   \   0000002A   0x9007             STR      R0,[SP, #+28]
   \   0000002C   0x....             LDR      R0,??DataTable20_4
   \   0000002E   0x9008             STR      R0,[SP, #+32]
   2490          		res = follow_path(&dj, path);	/* Follow the file path */
   \   00000030   0x990E             LDR      R1,[SP, #+56]
   \   00000032   0xA801             ADD      R0,SP,#+4
   \   00000034   0x.... 0x....      BL       _Z11follow_pathP9FATFS_DIRPKc
   \   00000038   0x0004             MOVS     R4,R0
   2491          		dir = dj.dir;
   \   0000003A   0x9D06             LDR      R5,[SP, #+24]
   2492          #if !_FS_READONLY	/* R/W configuration */
   2493          		if (res == FR_OK) {
   \   0000003C   0xD102             BNE      ??f_open_3
   2494          			if (!dir)	/* Default directory itself */
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD100             BNE      ??f_open_3
   2495          				res = FR_INVALID_NAME;
   \   00000042   0x2406             MOVS     R4,#+6
   2496          #if _FS_LOCK
   2497          			else
   2498          				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   2499          #endif
   2500          		}
   2501          		/* Create or Open a file */
   2502          		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   \                     ??f_open_3: (+1)
   \   00000044   0x201C             MOVS     R0,#+28
   \   00000046   0x4206             TST      R6,R0
   \   00000048   0xD100             BNE      .+4
   \   0000004A   0xE084             B        ??f_open_4
   2503          			if (res != FR_OK) {					/* No file, create new */
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0xD07A             BEQ      ??f_open_5
   2504          				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
   \   00000050   0x2C04             CMP      R4,#+4
   \   00000052   0xD103             BNE      ??f_open_6
   2505          #if _FS_LOCK
   2506          					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
   2507          #else
   2508          					res = dir_register(&dj);
   \   00000054   0xA801             ADD      R0,SP,#+4
   \   00000056   0x.... 0x....      BL       _Z12dir_registerP9FATFS_DIR
   \   0000005A   0x0004             MOVS     R4,R0
   2509          #endif
   2510          				mode |= FA_CREATE_ALWAYS;		/* File is created */
   \                     ??f_open_6: (+1)
   \   0000005C   0x0030             MOVS     R0,R6
   \   0000005E   0x2608             MOVS     R6,#+8
   \   00000060   0x4306             ORRS     R6,R6,R0
   2511          				dir = dj.dir;					/* New entry */
   \   00000062   0x9D06             LDR      R5,[SP, #+24]
   2512          			}
   2513          			else {								/* Any object is already existing */
   2514          				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or FATFS_DIR) */
   2515          					res = FR_DENIED;
   2516          				} else {
   2517          					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
   2518          						res = FR_EXIST;
   2519          				}
   2520          			}
   2521          			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0xD13A             BNE      ??f_open_7
   \                     ??f_open_8: (+1)
   \   00000068   0x0730             LSLS     R0,R6,#+28
   \   0000006A   0xD53F             BPL      ??f_open_9
   2522          				dw = GET_FATTIME();
   \   0000006C   0x.... 0x....      BL       get_fattime
   \   00000070   0x9000             STR      R0,[SP, #+0]
   2523          				ST_DWORD(dir + DIR_CrtTime, dw);/* Set created time */
   \   00000072   0x73A8             STRB     R0,[R5, #+14]
   \   00000074   0x9800             LDR      R0,[SP, #+0]
   \   00000076   0x0400             LSLS     R0,R0,#+16
   \   00000078   0x0E00             LSRS     R0,R0,#+24
   \   0000007A   0x73E8             STRB     R0,[R5, #+15]
   \   0000007C   0x9900             LDR      R1,[SP, #+0]
   \   0000007E   0x0C09             LSRS     R1,R1,#+16
   \   00000080   0x7429             STRB     R1,[R5, #+16]
   \   00000082   0x9A00             LDR      R2,[SP, #+0]
   \   00000084   0x0E12             LSRS     R2,R2,#+24
   \   00000086   0x746A             STRB     R2,[R5, #+17]
   2524          				ST_DWORD(dir + DIR_WrtTime, dw);/* Set modified time */
   \   00000088   0x9B00             LDR      R3,[SP, #+0]
   \   0000008A   0x75AB             STRB     R3,[R5, #+22]
   \   0000008C   0x75E8             STRB     R0,[R5, #+23]
   \   0000008E   0x7629             STRB     R1,[R5, #+24]
   \   00000090   0x766A             STRB     R2,[R5, #+25]
   2525          				dir[DIR_Attr] = 0;				/* Reset attribute */
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x72E8             STRB     R0,[R5, #+11]
   2526          				ST_DWORD(dir + DIR_FileSize, 0);/* Reset file size */
   \   00000096   0x7728             STRB     R0,[R5, #+28]
   \   00000098   0x7768             STRB     R0,[R5, #+29]
   \   0000009A   0x77A8             STRB     R0,[R5, #+30]
   \   0000009C   0x77E8             STRB     R0,[R5, #+31]
   2527          				cl = ld_clust(dj.fs, dir);		/* Get cluster chain */
   \   0000009E   0x0029             MOVS     R1,R5
   \   000000A0   0x9801             LDR      R0,[SP, #+4]
   \   000000A2   0x.... 0x....      BL       _Z8ld_clustP5FATFSPKh
   \   000000A6   0x0007             MOVS     R7,R0
   2528          				st_clust(dir, 0);				/* Reset cluster */
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x76A8             STRB     R0,[R5, #+26]
   \   000000AC   0x76E8             STRB     R0,[R5, #+27]
   \   000000AE   0x7528             STRB     R0,[R5, #+20]
   \   000000B0   0x7568             STRB     R0,[R5, #+21]
   2529          				dj.fs->wflag = 1;
   \   000000B2   0x2001             MOVS     R0,#+1
   \   000000B4   0x9901             LDR      R1,[SP, #+4]
   \   000000B6   0x7108             STRB     R0,[R1, #+4]
   2530          				if (cl) {						/* Remove the cluster chain if exist */
   \   000000B8   0x2F00             CMP      R7,#+0
   \   000000BA   0xD012             BEQ      ??f_open_10
   2531          					dw = dj.fs->winsect;
   \   000000BC   0x9801             LDR      R0,[SP, #+4]
   \   000000BE   0x6B00             LDR      R0,[R0, #+48]
   \   000000C0   0x9000             STR      R0,[SP, #+0]
   2532          					res = remove_chain(dj.fs, cl);
   \   000000C2   0x0039             MOVS     R1,R7
   \   000000C4   0x9801             LDR      R0,[SP, #+4]
   \   000000C6   0x.... 0x....      BL       _Z12remove_chainP5FATFSm
   \   000000CA   0x0004             MOVS     R4,R0
   2533          					if (res == FR_OK) {
   \   000000CC   0xD107             BNE      ??f_open_7
   2534          						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
   \   000000CE   0x1E7F             SUBS     R7,R7,#+1
   \   000000D0   0x9801             LDR      R0,[SP, #+4]
   \   000000D2   0x60C7             STR      R7,[R0, #+12]
   2535          						res = move_window(dj.fs, dw);
   \   000000D4   0x9900             LDR      R1,[SP, #+0]
   \   000000D6   0x9801             LDR      R0,[SP, #+4]
   \   000000D8   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   000000DC   0x0004             MOVS     R4,R0
   2536          					}
   2537          				}
   2538          			}
   2539          		}
   2540          		else {	/* Open an existing file */
   2541          			if (res == FR_OK) {					/* Following succeeded */
   2542          				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
   2543          					res = FR_NO_FILE;
   2544          				} else {
   2545          					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   2546          						res = FR_DENIED;
   2547          				}
   2548          			}
   2549          		}
   2550          		if (res == FR_OK) {
   \                     ??f_open_7: (+1)
   \   000000DE   0x0020             MOVS     R0,R4
   \   000000E0   0xD12E             BNE      ??f_open_2
   2551          			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
   \                     ??f_open_10: (+1)
   \   000000E2   0x0730             LSLS     R0,R6,#+28
   \   000000E4   0xD502             BPL      ??f_open_9
   2552          				mode |= FA__WRITTEN;
   \   000000E6   0x0030             MOVS     R0,R6
   \   000000E8   0x2620             MOVS     R6,#+32
   \   000000EA   0x4306             ORRS     R6,R6,R0
   2553          			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
   \                     ??f_open_9: (+1)
   \   000000EC   0x9801             LDR      R0,[SP, #+4]
   \   000000EE   0x6B00             LDR      R0,[R0, #+48]
   \   000000F0   0x990D             LDR      R1,[SP, #+52]
   \   000000F2   0x61C8             STR      R0,[R1, #+28]
   2554          			fp->dir_ptr = dir;
   \   000000F4   0x980D             LDR      R0,[SP, #+52]
   \   000000F6   0x6205             STR      R5,[R0, #+32]
   2555          #if _FS_LOCK
   2556          			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   2557          			if (!fp->lockid) res = FR_INT_ERR;
   2558          #endif
   2559          		}
   2560          
   2561          #else				/* R/O configuration */
   2562          		if (res == FR_OK) {					/* Follow succeeded */
   2563          			dir = dj.dir;
   2564          			if (!dir) {						/* Current directory itself */
   2565          				res = FR_INVALID_NAME;
   2566          			} else {
   2567          				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
   2568          					res = FR_NO_FILE;
   2569          			}
   2570          		}
   2571          #endif
   2572          		FREE_BUF();
   2573          
   2574          		if (res == FR_OK) {
   2575          			fp->flag = mode;					/* File access mode */
   \   000000F8   0x980D             LDR      R0,[SP, #+52]
   \   000000FA   0x7186             STRB     R6,[R0, #+6]
   2576          			fp->err = 0;						/* Clear error flag */
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x990D             LDR      R1,[SP, #+52]
   \   00000100   0x71C8             STRB     R0,[R1, #+7]
   2577          			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
   \   00000102   0x0029             MOVS     R1,R5
   \   00000104   0x9801             LDR      R0,[SP, #+4]
   \   00000106   0x.... 0x....      BL       _Z8ld_clustP5FATFSPKh
   \   0000010A   0x990D             LDR      R1,[SP, #+52]
   \   0000010C   0x6108             STR      R0,[R1, #+16]
   2578          			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
   \   0000010E   0x7FE8             LDRB     R0,[R5, #+31]
   \   00000110   0x0600             LSLS     R0,R0,#+24
   \   00000112   0x7FA9             LDRB     R1,[R5, #+30]
   \   00000114   0x0409             LSLS     R1,R1,#+16
   \   00000116   0x4301             ORRS     R1,R1,R0
   \   00000118   0x7F68             LDRB     R0,[R5, #+29]
   \   0000011A   0x0200             LSLS     R0,R0,#+8
   \   0000011C   0x4308             ORRS     R0,R0,R1
   \   0000011E   0x7F29             LDRB     R1,[R5, #+28]
   \   00000120   0x4301             ORRS     R1,R1,R0
   \   00000122   0x980D             LDR      R0,[SP, #+52]
   \   00000124   0x60C1             STR      R1,[R0, #+12]
   2579          			fp->fptr = 0;						/* File pointer */
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0x990D             LDR      R1,[SP, #+52]
   \   0000012A   0x6088             STR      R0,[R1, #+8]
   2580          			fp->dsect = 0;
   \   0000012C   0x990D             LDR      R1,[SP, #+52]
   \   0000012E   0x6188             STR      R0,[R1, #+24]
   2581          #if _USE_FASTSEEK
   2582          			fp->cltbl = 0;						/* Normal seek mode */
   2583          #endif
   2584          			fp->fs = dj.fs;	 					/* Validate file object */
   \   00000130   0x9801             LDR      R0,[SP, #+4]
   \   00000132   0x990D             LDR      R1,[SP, #+52]
   \   00000134   0x6008             STR      R0,[R1, #+0]
   2585          			fp->id = fp->fs->id;
   \   00000136   0x980D             LDR      R0,[SP, #+52]
   \   00000138   0x6800             LDR      R0,[R0, #+0]
   \   0000013A   0x88C0             LDRH     R0,[R0, #+6]
   \   0000013C   0x990D             LDR      R1,[SP, #+52]
   \   0000013E   0x8088             STRH     R0,[R1, #+4]
   2586          #if !_FS_TINY && _FS_HEAPBUF
   2587          			fp->buf = (BYTE*)ff_memalloc(SS(dj.fs));	/* Allocate buffer if necessary */
   2588          			if (!fp->buf)
   2589          				return FR_NOT_ENOUGH_CORE;
   2590          #endif
   2591          		}
   2592          	}
   2593          
   2594          	LEAVE_FF(dj.fs, res);
   \                     ??f_open_2: (+1)
   \   00000140   0x0020             MOVS     R0,R4
   \                     ??f_open_1: (+1)
   \   00000142   0xB00F             ADD      SP,SP,#+60
   \   00000144   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??f_open_5: (+1)
   \   00000146   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000148   0x2111             MOVS     R1,#+17
   \   0000014A   0x4208             TST      R0,R1
   \   0000014C   0xD10E             BNE      ??f_open_11
   \   0000014E   0x0770             LSLS     R0,R6,#+29
   \   00000150   0xD58A             BPL      ??f_open_8
   \   00000152   0x2408             MOVS     R4,#+8
   \   00000154   0xE7F4             B        ??f_open_2
   \                     ??f_open_4: (+1)
   \   00000156   0x0020             MOVS     R0,R4
   \   00000158   0xD1C1             BNE      ??f_open_7
   \   0000015A   0x7AE8             LDRB     R0,[R5, #+11]
   \   0000015C   0x06C1             LSLS     R1,R0,#+27
   \   0000015E   0xD501             BPL      ??f_open_12
   \   00000160   0x2404             MOVS     R4,#+4
   \   00000162   0xE7ED             B        ??f_open_2
   \                     ??f_open_12: (+1)
   \   00000164   0x07B1             LSLS     R1,R6,#+30
   \   00000166   0xD5BC             BPL      ??f_open_10
   \   00000168   0x07C0             LSLS     R0,R0,#+31
   \   0000016A   0xD5BA             BPL      ??f_open_10
   \                     ??f_open_11: (+1)
   \   0000016C   0x2407             MOVS     R4,#+7
   \   0000016E   0xE7E7             B        ??f_open_2
   2595          }
   2596          
   2597          
   2598          
   2599          
   2600          /*-----------------------------------------------------------------------*/
   2601          /* Read File                                                             */
   2602          /*-----------------------------------------------------------------------*/
   2603          

   \                                 In section .text, align 2, keep-with-next
   2604          FRESULT f_read (
   2605          	FIL* fp, 		/* Pointer to the file object */
   2606          	void* buff,		/* Pointer to data buffer */
   2607          	UINT btr,		/* Number of bytes to read */
   2608          	UINT* br		/* Pointer to number of bytes read */
   2609          )
   2610          {
   \                     f_read: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0015             MOVS     R5,R2
   2611          	FRESULT res;
   2612          	DWORD clst, sect, remain;
   2613          	UINT rcnt, cc;
   2614          	BYTE csect, *rbuff = (BYTE*)buff;
   \   00000008   0x9101             STR      R1,[SP, #+4]
   2615          
   2616          
   2617          	*br = 0;	/* Clear read byte counter */
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9904             LDR      R1,[SP, #+16]
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   2618          
   2619          	res = validate(fp);							/* Check validity */
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       _Z8validatePv
   2620          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000016   0x0001             MOVS     R1,R0
   \   00000018   0xD000             BEQ      .+4
   \   0000001A   0xE0C2             B        ??f_read_0
   2621          	if (fp->err)								/* Check error */
   \   0000001C   0x79E0             LDRB     R0,[R4, #+7]
   \   0000001E   0x0001             MOVS     R1,R0
   \   00000020   0xD000             BEQ      .+4
   \   00000022   0xE0BE             B        ??f_read_0
   2622          		LEAVE_FF(fp->fs, (FRESULT)fp->err);
   2623          	if (!(fp->flag & FA_READ)) 					/* Check access mode */
   \   00000024   0x79A0             LDRB     R0,[R4, #+6]
   \   00000026   0x07C0             LSLS     R0,R0,#+31
   \   00000028   0xD401             BMI      ??f_read_1
   2624          		LEAVE_FF(fp->fs, FR_DENIED);
   \   0000002A   0x2007             MOVS     R0,#+7
   \   0000002C   0xE0B9             B        ??f_read_0
   2625          	remain = fp->fsize - fp->fptr;
   \                     ??f_read_1: (+1)
   \   0000002E   0x68E0             LDR      R0,[R4, #+12]
   \   00000030   0x68A1             LDR      R1,[R4, #+8]
   \   00000032   0x1A40             SUBS     R0,R0,R1
   2626          	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
   \   00000034   0x42A8             CMP      R0,R5
   \   00000036   0xD900             BLS      .+4
   \   00000038   0xE091             B        ??f_read_2
   \   0000003A   0x0005             MOVS     R5,R0
   \   0000003C   0xE08F             B        ??f_read_2
   2627          
   2628          	for ( ;  btr;								/* Repeat until all data read */
   2629          		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
   2630          		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
   2631          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   2632          			if (!csect) {						/* On the cluster boundary? */
   2633          				if (fp->fptr == 0) {			/* On the top of the file? */
   2634          					clst = fp->sclust;			/* Follow from the origin */
   2635          				} else {						/* Middle or end of the file */
   2636          #if _USE_FASTSEEK
   2637          					if (fp->cltbl)
   2638          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   2639          					else
   2640          #endif
   2641          						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
   \                     ??f_read_3: (+1)
   \   0000003E   0x6961             LDR      R1,[R4, #+20]
   \   00000040   0x0030             MOVS     R0,R6
   \   00000042   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   2642          				}
   2643          				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
   \                     ??f_read_4: (+1)
   \   00000046   0x2802             CMP      R0,#+2
   \   00000048   0xD314             BCC      ??f_read_5
   2644          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000004E   0x4288             CMP      R0,R1
   \   00000050   0xD100             BNE      .+4
   \   00000052   0xE0A2             B        ??f_read_6
   2645          				fp->clust = clst;				/* Update current cluster */
   \   00000054   0x6160             STR      R0,[R4, #+20]
   2646          			}
   2647          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   \                     ??f_read_7: (+1)
   \   00000056   0x6827             LDR      R7,[R4, #+0]
   \   00000058   0x6960             LDR      R0,[R4, #+20]
   \   0000005A   0x1E80             SUBS     R0,R0,#+2
   \   0000005C   0x0039             MOVS     R1,R7
   \   0000005E   0x3118             ADDS     R1,R1,#+24
   \   00000060   0x680B             LDR      R3,[R1, #+0]
   \   00000062   0x1E9B             SUBS     R3,R3,#+2
   \   00000064   0x4298             CMP      R0,R3
   \   00000066   0xD205             BCS      ??f_read_5
   \   00000068   0x78BA             LDRB     R2,[R7, #+2]
   \   0000006A   0x9203             STR      R2,[SP, #+12]
   \   0000006C   0x4350             MULS     R0,R2,R0
   \   0000006E   0x6949             LDR      R1,[R1, #+20]
   \   00000070   0x1840             ADDS     R0,R0,R1
   2648          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   \   00000072   0xD101             BNE      ??f_read_8
   \                     ??f_read_5: (+1)
   \   00000074   0x2002             MOVS     R0,#+2
   \   00000076   0xE091             B.N      ??f_read_9
   2649          			sect += csect;
   \                     ??f_read_8: (+1)
   \   00000078   0x9900             LDR      R1,[SP, #+0]
   \   0000007A   0x1840             ADDS     R0,R0,R1
   \   0000007C   0x9002             STR      R0,[SP, #+8]
   2650          			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
   \   0000007E   0x0028             MOVS     R0,R5
   \   00000080   0x8979             LDRH     R1,[R7, #+10]
   \   00000082   0x.... 0x....      BL       __aeabi_uidiv
   \   00000086   0x0006             MOVS     R6,R0
   2651          			if (cc) {							/* Read maximum contiguous sectors directly */
   \   00000088   0xD029             BEQ      ??f_read_10
   2652          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   \   0000008A   0x9803             LDR      R0,[SP, #+12]
   \   0000008C   0x9900             LDR      R1,[SP, #+0]
   \   0000008E   0x1989             ADDS     R1,R1,R6
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xD201             BCS      ??f_read_11
   2653          					cc = fp->fs->csize - csect;
   \   00000094   0x9900             LDR      R1,[SP, #+0]
   \   00000096   0x1A46             SUBS     R6,R0,R1
   2654          				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
   \                     ??f_read_11: (+1)
   \   00000098   0x0033             MOVS     R3,R6
   \   0000009A   0x9A02             LDR      R2,[SP, #+8]
   \   0000009C   0x9901             LDR      R1,[SP, #+4]
   \   0000009E   0x7878             LDRB     R0,[R7, #+1]
   \   000000A0   0x.... 0x....      BL       disk_read
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD178             BNE      ??f_read_6
   2655          					ABORT(fp->fs, FR_DISK_ERR);
   2656          #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
   2657          #if _FS_TINY
   2658          				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x7901             LDRB     R1,[R0, #+4]
   \   000000AC   0x2900             CMP      R1,#+0
   \   000000AE   0xD011             BEQ      ??f_read_12
   \   000000B0   0x6B01             LDR      R1,[R0, #+48]
   \   000000B2   0x9A02             LDR      R2,[SP, #+8]
   \   000000B4   0x1A8A             SUBS     R2,R1,R2
   \   000000B6   0x42B2             CMP      R2,R6
   \   000000B8   0xD20C             BCS      ??f_read_12
   \   000000BA   0x8941             LDRH     R1,[R0, #+10]
   \   000000BC   0x9B01             LDR      R3,[SP, #+4]
   \   000000BE   0x434A             MULS     R2,R1,R2
   \   000000C0   0x189A             ADDS     R2,R3,R2
   \   000000C2   0x6B40             LDR      R0,[R0, #+52]
   \   000000C4   0x2900             CMP      R1,#+0
   \   000000C6   0xD005             BEQ      ??f_read_12
   \                     ??f_read_13: (+1)
   \   000000C8   0x7803             LDRB     R3,[R0, #+0]
   \   000000CA   0x7013             STRB     R3,[R2, #+0]
   \   000000CC   0x1C40             ADDS     R0,R0,#+1
   \   000000CE   0x1C52             ADDS     R2,R2,#+1
   \   000000D0   0x1E49             SUBS     R1,R1,#+1
   \   000000D2   0xD1F9             BNE      ??f_read_13
   2659          					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
   2660          #else
   2661          				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
   2662          					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
   2663          #endif
   2664          #endif
   2665          				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
   \                     ??f_read_12: (+1)
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x8940             LDRH     R0,[R0, #+10]
   \   000000D8   0x4346             MULS     R6,R0,R6
   \   000000DA   0x0037             MOVS     R7,R6
   2666          				continue;
   \   000000DC   0xE033             B        ??f_read_14
   2667          			}
   2668          #if !_FS_TINY
   2669          			if (fp->dsect != sect) {			/* Load data sector if not in cache */
   2670          #if !_FS_READONLY
   2671          				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   2672          					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2673          						ABORT(fp->fs, FR_DISK_ERR);
   2674          					fp->flag &= ~FA__DIRTY;
   2675          				}
   2676          #endif
   2677          				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
   2678          					ABORT(fp->fs, FR_DISK_ERR);
   2679          			}
   2680          #endif
   2681          			fp->dsect = sect;
   \                     ??f_read_10: (+1)
   \   000000DE   0x9802             LDR      R0,[SP, #+8]
   \   000000E0   0x61A0             STR      R0,[R4, #+24]
   2682          		}
   2683          		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
   \                     ??f_read_15: (+1)
   \   000000E2   0x6826             LDR      R6,[R4, #+0]
   \   000000E4   0x8977             LDRH     R7,[R6, #+10]
   \   000000E6   0x68A0             LDR      R0,[R4, #+8]
   \   000000E8   0x0039             MOVS     R1,R7
   \   000000EA   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000EE   0x1A78             SUBS     R0,R7,R1
   2684          		if (rcnt > btr) rcnt = btr;
   \   000000F0   0x002F             MOVS     R7,R5
   \   000000F2   0x4285             CMP      R5,R0
   \   000000F4   0xD900             BLS      ??f_read_16
   \   000000F6   0x0007             MOVS     R7,R0
   2685          #if _FS_TINY
   2686          		if (move_window(fp->fs, fp->dsect) != FR_OK)		/* Move sector window */
   \                     ??f_read_16: (+1)
   \   000000F8   0x69A0             LDR      R0,[R4, #+24]
   \   000000FA   0x9000             STR      R0,[SP, #+0]
   \   000000FC   0x6B31             LDR      R1,[R6, #+48]
   \   000000FE   0x4288             CMP      R0,R1
   \   00000100   0xD00E             BEQ      ??f_read_17
   \   00000102   0x0030             MOVS     R0,R6
   \   00000104   0x.... 0x....      BL       _Z11sync_windowP5FATFS
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD146             BNE      ??f_read_6
   \   0000010C   0x2301             MOVS     R3,#+1
   \   0000010E   0x9A00             LDR      R2,[SP, #+0]
   \   00000110   0x6B71             LDR      R1,[R6, #+52]
   \   00000112   0x7870             LDRB     R0,[R6, #+1]
   \   00000114   0x.... 0x....      BL       disk_read
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD13B             BNE      ??f_read_18
   \   0000011C   0x9800             LDR      R0,[SP, #+0]
   \   0000011E   0x6330             STR      R0,[R6, #+48]
   2687          			ABORT(fp->fs, FR_DISK_ERR);
   2688          		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   \                     ??f_read_17: (+1)
   \   00000120   0x9E01             LDR      R6,[SP, #+4]
   \   00000122   0x6821             LDR      R1,[R4, #+0]
   \   00000124   0x6B48             LDR      R0,[R1, #+52]
   \   00000126   0x9000             STR      R0,[SP, #+0]
   \   00000128   0x68A0             LDR      R0,[R4, #+8]
   \   0000012A   0x8949             LDRH     R1,[R1, #+10]
   \   0000012C   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000130   0x9800             LDR      R0,[SP, #+0]
   \   00000132   0x1840             ADDS     R0,R0,R1
   \   00000134   0x2F00             CMP      R7,#+0
   \   00000136   0xD006             BEQ      ??f_read_14
   \   00000138   0x0039             MOVS     R1,R7
   \                     ??f_read_19: (+1)
   \   0000013A   0x7802             LDRB     R2,[R0, #+0]
   \   0000013C   0x7032             STRB     R2,[R6, #+0]
   \   0000013E   0x1C40             ADDS     R0,R0,#+1
   \   00000140   0x1C76             ADDS     R6,R6,#+1
   \   00000142   0x1E49             SUBS     R1,R1,#+1
   \   00000144   0xD1F9             BNE      ??f_read_19
   \                     ??f_read_14: (+1)
   \   00000146   0x9801             LDR      R0,[SP, #+4]
   \   00000148   0x19C0             ADDS     R0,R0,R7
   \   0000014A   0x9001             STR      R0,[SP, #+4]
   \   0000014C   0x68A0             LDR      R0,[R4, #+8]
   \   0000014E   0x19C0             ADDS     R0,R0,R7
   \   00000150   0x60A0             STR      R0,[R4, #+8]
   \   00000152   0x9804             LDR      R0,[SP, #+16]
   \   00000154   0x6800             LDR      R0,[R0, #+0]
   \   00000156   0x19C0             ADDS     R0,R0,R7
   \   00000158   0x9904             LDR      R1,[SP, #+16]
   \   0000015A   0x6008             STR      R0,[R1, #+0]
   \   0000015C   0x1BED             SUBS     R5,R5,R7
   \                     ??f_read_2: (+1)
   \   0000015E   0x2D00             CMP      R5,#+0
   \   00000160   0xD01E             BEQ      ??f_read_20
   \   00000162   0x6826             LDR      R6,[R4, #+0]
   \   00000164   0x68A7             LDR      R7,[R4, #+8]
   \   00000166   0x0038             MOVS     R0,R7
   \   00000168   0x8971             LDRH     R1,[R6, #+10]
   \   0000016A   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000016E   0x2900             CMP      R1,#+0
   \   00000170   0xD1B7             BNE      ??f_read_15
   \   00000172   0x0038             MOVS     R0,R7
   \   00000174   0x8971             LDRH     R1,[R6, #+10]
   \   00000176   0x.... 0x....      BL       __aeabi_uidiv
   \   0000017A   0x78B1             LDRB     R1,[R6, #+2]
   \   0000017C   0x1E49             SUBS     R1,R1,#+1
   \   0000017E   0x4001             ANDS     R1,R1,R0
   \   00000180   0xB2C9             UXTB     R1,R1
   \   00000182   0x2900             CMP      R1,#+0
   \   00000184   0x9100             STR      R1,[SP, #+0]
   \   00000186   0xD000             BEQ      .+4
   \   00000188   0xE765             B        ??f_read_7
   \   0000018A   0x2F00             CMP      R7,#+0
   \   0000018C   0xD000             BEQ      .+4
   \   0000018E   0xE756             B        ??f_read_3
   \   00000190   0x6920             LDR      R0,[R4, #+16]
   \   00000192   0xE758             B        ??f_read_4
   \                     ??f_read_18: (+1)
   \   00000194   0x2000             MOVS     R0,#+0
   \   00000196   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000198   0x6330             STR      R0,[R6, #+48]
   \                     ??f_read_6: (+1)
   \   0000019A   0x2001             MOVS     R0,#+1
   \                     ??f_read_9: (+1)
   \   0000019C   0x71E0             STRB     R0,[R4, #+7]
   \   0000019E   0xE000             B        ??f_read_0
   2689          #else
   2690          		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   2691          #endif
   2692          	}
   2693          
   2694          	LEAVE_FF(fp->fs, FR_OK);
   \                     ??f_read_20: (+1)
   \   000001A0   0x2000             MOVS     R0,#+0
   \                     ??f_read_0: (+1)
   \   000001A2   0xB005             ADD      SP,SP,#+20
   \   000001A4   0xBDF0             POP      {R4-R7,PC}       ;; return
   2695          }
   2696          
   2697          
   2698          
   2699          
   2700          #if !_FS_READONLY
   2701          /*-----------------------------------------------------------------------*/
   2702          /* Write File                                                            */
   2703          /*-----------------------------------------------------------------------*/
   2704          

   \                                 In section .text, align 2, keep-with-next
   2705          FRESULT f_write (
   2706          	FIL* fp,			/* Pointer to the file object */
   2707          	const void *buff,	/* Pointer to the data to be written */
   2708          	UINT btw,			/* Number of bytes to write */
   2709          	UINT* bw			/* Pointer to number of bytes written */
   2710          )
   2711          {
   \                     f_write: (+1)
   \   00000000   0xB5FC             PUSH     {R2-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   2712          	FRESULT res;
   2713          	DWORD clst, sect;
   2714          	UINT wcnt, cc;
   2715          	const BYTE *wbuff = (const BYTE*)buff;
   \   00000006   0x9100             STR      R1,[SP, #+0]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x7308             STRB     R0,[R1, #+12]
   2716          	BYTE csect;
   2717          	bool need_sync = false;
   2718          
   2719          	*bw = 0;	/* Clear write byte counter */
   \   0000000E   0x9906             LDR      R1,[SP, #+24]
   \   00000010   0x6008             STR      R0,[R1, #+0]
   2720          
   2721          	res = validate(fp);						/* Check validity */
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       _Z8validatePv
   2722          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000018   0x0001             MOVS     R1,R0
   \   0000001A   0xD11F             BNE      ??f_write_0
   2723          	if (fp->err)							/* Check error */
   \   0000001C   0x79E0             LDRB     R0,[R4, #+7]
   \   0000001E   0x0001             MOVS     R1,R0
   \   00000020   0xD11C             BNE      ??f_write_0
   2724          		LEAVE_FF(fp->fs, (FRESULT)fp->err);
   \   00000022   0x79A0             LDRB     R0,[R4, #+6]
   \   00000024   0x0780             LSLS     R0,R0,#+30
   \   00000026   0xD401             BMI      ??f_write_1
   2725          	if (!(fp->flag & FA_WRITE))				/* Check access mode */
   2726          		LEAVE_FF(fp->fs, FR_DENIED);
   \   00000028   0x2007             MOVS     R0,#+7
   \   0000002A   0xE017             B        ??f_write_0
   2727          	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
   \                     ??f_write_1: (+1)
   \   0000002C   0x68A0             LDR      R0,[R4, #+8]
   \   0000002E   0x9905             LDR      R1,[SP, #+20]
   \   00000030   0x1841             ADDS     R1,R0,R1
   \   00000032   0x4281             CMP      R1,R0
   \   00000034   0xD300             BCC      .+4
   \   00000036   0xE0D3             B        ??f_write_2
   2728          
   2729          	for ( ;  btw;							/* Repeat until all data written */
   2730          		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
   2731          		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
   2732          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   2733          			if (!csect) {					/* On the cluster boundary? */
   2734          				if (fp->fptr == 0) {		/* On the top of the file? */
   2735          					clst = fp->sclust;		/* Follow from the origin */
   2736          					if (clst == 0)			/* When no cluster is allocated, */
   2737          						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
   2738          				} else {					/* Middle or end of the file */
   2739          #if _USE_FASTSEEK
   2740          					if (fp->cltbl)
   2741          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   2742          					else
   2743          #endif
   2744          						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
   2745          				}
   2746          				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
   2747          				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   2748          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2749          				fp->clust = clst;			/* Update current cluster */
   2750          				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
   2751          				
   2752          #if FLUSH_ON_NEW_CLUSTER
   2753                          // We do not need to flush for the first cluster
   2754                          if (fp->fptr != 0) {
   2755                              need_sync = true;
   2756                          }
   2757          #endif
   2758          			}
   2759          #if _FS_TINY
   2760          			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
   2761          				ABORT(fp->fs, FR_DISK_ERR);
   2762          #else
   2763          			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
   2764          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2765          					ABORT(fp->fs, FR_DISK_ERR);
   2766          				fp->flag &= ~FA__DIRTY;
   2767          			}
   2768          #endif
   2769          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   2770          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2771          			sect += csect;
   2772          			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
   2773          			if (cc) {						/* Write maximum contiguous sectors directly */
   2774          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   2775          					cc = fp->fs->csize - csect;
   2776          				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
   2777          					ABORT(fp->fs, FR_DISK_ERR);
   2778          #if _FS_MINIMIZE <= 2
   2779          #if _FS_TINY
   2780          				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
   2781          					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
   2782          					fp->fs->wflag = 0;
   2783          				}
   2784          #else
   2785          				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
   2786          					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
   2787          					fp->flag &= ~FA__DIRTY;
   2788          				}
   2789          #endif
   2790          #endif
   2791          				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
   2792          #if FLUSH_ON_NEW_SECTOR
   2793                          need_sync = true;
   2794          #endif
   2795          				continue;
   2796          			}
   2797          #if _FS_TINY
   2798          			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
   2799          				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
   2800          				fp->fs->winsect = sect;
   2801          			}
   2802          #else
   2803          			if (fp->dsect != sect) {		/* Fill sector cache with file data */
   2804          				if (fp->fptr < fp->fsize &&
   2805          					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
   2806          						ABORT(fp->fs, FR_DISK_ERR);
   2807          			}
   2808          #endif
   2809          			fp->dsect = sect;
   2810          		}
   2811          		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
   2812          		if (wcnt > btw) wcnt = btw;
   2813          #if _FS_TINY
   2814          		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
   2815          			ABORT(fp->fs, FR_DISK_ERR);
   2816          		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   2817          		fp->fs->wflag = 1;
   2818          #else
   2819          		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   2820          		fp->flag |= FA__DIRTY;
   2821          #endif
   2822          	}
   2823          
   2824          	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
   \                     ??f_write_3: (+1)
   \   00000038   0x68E0             LDR      R0,[R4, #+12]
   \   0000003A   0x68A1             LDR      R1,[R4, #+8]
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD200             BCS      ??f_write_4
   \   00000040   0x0008             MOVS     R0,R1
   \                     ??f_write_4: (+1)
   \   00000042   0x60E0             STR      R0,[R4, #+12]
   2825          	fp->flag |= FA__WRITTEN;						/* Set file change flag */
   \   00000044   0x79A0             LDRB     R0,[R4, #+6]
   \   00000046   0x2120             MOVS     R1,#+32
   \   00000048   0x4301             ORRS     R1,R1,R0
   \   0000004A   0x71A1             STRB     R1,[R4, #+6]
   2826          
   2827          	if (need_sync) {
   \   0000004C   0x4668             MOV      R0,SP
   \   0000004E   0x7B00             LDRB     R0,[R0, #+12]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD002             BEQ      ??f_write_5
   2828                  f_sync (fp);
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       f_sync
   2829              }
   2830          
   2831          	LEAVE_FF(fp->fs, FR_OK);
   \                     ??f_write_5: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \                     ??f_write_0: (+1)
   \   0000005C   0xB007             ADD      SP,SP,#+28
   \   0000005E   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??f_write_6: (+1)
   \   00000060   0x2801             CMP      R0,#+1
   \   00000062   0xD102             BNE      ??f_write_7
   \   00000064   0x2500             MOVS     R5,#+0
   \   00000066   0x43ED             MVNS     R5,R5            ;; #-1
   \   00000068   0xE000             B        ??f_write_8
   \                     ??f_write_7: (+1)
   \   0000006A   0x2501             MOVS     R5,#+1
   \                     ??f_write_8: (+1)
   \   0000006C   0x0028             MOVS     R0,R5
   \   0000006E   0xE00D             B        ??f_write_9
   \                     ??f_write_10: (+1)
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD00B             BEQ      ??f_write_11
   \   00000078   0x2801             CMP      R0,#+1
   \   0000007A   0xD009             BEQ      ??f_write_11
   \   0000007C   0x42BD             CMP      R5,R7
   \   0000007E   0xD000             BEQ      .+4
   \   00000080   0xE0D6             B        ??f_write_12
   \   00000082   0xE7D9             B        ??f_write_3
   \                     ??f_write_13: (+1)
   \   00000084   0x6961             LDR      R1,[R4, #+20]
   \   00000086   0x0030             MOVS     R0,R6
   \   00000088   0x.... 0x....      BL       _Z12create_chainP5FATFSm
   \                     ??f_write_9: (+1)
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD0D3             BEQ      ??f_write_3
   \                     ??f_write_11: (+1)
   \   00000090   0x2801             CMP      R0,#+1
   \   00000092   0xD022             BEQ      ??f_write_14
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000098   0x4288             CMP      R0,R1
   \   0000009A   0xD100             BNE      .+4
   \   0000009C   0xE0F0             B        ??f_write_15
   \   0000009E   0x6160             STR      R0,[R4, #+20]
   \   000000A0   0x6921             LDR      R1,[R4, #+16]
   \   000000A2   0x2900             CMP      R1,#+0
   \   000000A4   0xD100             BNE      ??f_write_16
   \   000000A6   0x6120             STR      R0,[R4, #+16]
   \                     ??f_write_16: (+1)
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x6B01             LDR      R1,[R0, #+48]
   \   000000AC   0x69A2             LDR      R2,[R4, #+24]
   \   000000AE   0x4291             CMP      R1,R2
   \   000000B0   0xD104             BNE      ??f_write_17
   \   000000B2   0x.... 0x....      BL       _Z11sync_windowP5FATFS
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD000             BEQ      .+4
   \   000000BA   0xE0E1             B        ??f_write_15
   \                     ??f_write_17: (+1)
   \   000000BC   0x6827             LDR      R7,[R4, #+0]
   \   000000BE   0x6961             LDR      R1,[R4, #+20]
   \   000000C0   0x1E89             SUBS     R1,R1,#+2
   \   000000C2   0x0038             MOVS     R0,R7
   \   000000C4   0x3018             ADDS     R0,R0,#+24
   \   000000C6   0x6803             LDR      R3,[R0, #+0]
   \   000000C8   0x1E9B             SUBS     R3,R3,#+2
   \   000000CA   0x4299             CMP      R1,R3
   \   000000CC   0xD205             BCS      ??f_write_14
   \   000000CE   0x78BA             LDRB     R2,[R7, #+2]
   \   000000D0   0x9202             STR      R2,[SP, #+8]
   \   000000D2   0x4351             MULS     R1,R2,R1
   \   000000D4   0x6940             LDR      R0,[R0, #+20]
   \   000000D6   0x1808             ADDS     R0,R1,R0
   \   000000D8   0xD102             BNE      ??f_write_18
   \                     ??f_write_14: (+1)
   \   000000DA   0x2002             MOVS     R0,#+2
   \                     ??f_write_19: (+1)
   \   000000DC   0x71E0             STRB     R0,[R4, #+7]
   \   000000DE   0xE7BD             B        ??f_write_0
   \                     ??f_write_18: (+1)
   \   000000E0   0x9901             LDR      R1,[SP, #+4]
   \   000000E2   0x1846             ADDS     R6,R0,R1
   \   000000E4   0x9805             LDR      R0,[SP, #+20]
   \   000000E6   0x8979             LDRH     R1,[R7, #+10]
   \   000000E8   0x.... 0x....      BL       __aeabi_uidiv
   \   000000EC   0x0005             MOVS     R5,R0
   \   000000EE   0xD02B             BEQ      ??f_write_20
   \   000000F0   0x9802             LDR      R0,[SP, #+8]
   \   000000F2   0x9901             LDR      R1,[SP, #+4]
   \   000000F4   0x1949             ADDS     R1,R1,R5
   \   000000F6   0x4288             CMP      R0,R1
   \   000000F8   0xD201             BCS      ??f_write_21
   \   000000FA   0x9901             LDR      R1,[SP, #+4]
   \   000000FC   0x1A45             SUBS     R5,R0,R1
   \                     ??f_write_21: (+1)
   \   000000FE   0x002B             MOVS     R3,R5
   \   00000100   0x0032             MOVS     R2,R6
   \   00000102   0x9900             LDR      R1,[SP, #+0]
   \   00000104   0x7878             LDRB     R0,[R7, #+1]
   \   00000106   0x.... 0x....      BL       disk_write
   \   0000010A   0x2800             CMP      R0,#+0
   \   0000010C   0xD000             BEQ      .+4
   \   0000010E   0xE0B7             B        ??f_write_15
   \   00000110   0x6821             LDR      R1,[R4, #+0]
   \   00000112   0x6B08             LDR      R0,[R1, #+48]
   \   00000114   0x1B82             SUBS     R2,R0,R6
   \   00000116   0x42AA             CMP      R2,R5
   \   00000118   0xD20F             BCS      ??f_write_22
   \   0000011A   0x8948             LDRH     R0,[R1, #+10]
   \   0000011C   0x6B49             LDR      R1,[R1, #+52]
   \   0000011E   0x9B00             LDR      R3,[SP, #+0]
   \   00000120   0x4342             MULS     R2,R0,R2
   \   00000122   0x189A             ADDS     R2,R3,R2
   \   00000124   0x2800             CMP      R0,#+0
   \   00000126   0xD005             BEQ      ??f_write_23
   \                     ??f_write_24: (+1)
   \   00000128   0x7813             LDRB     R3,[R2, #+0]
   \   0000012A   0x700B             STRB     R3,[R1, #+0]
   \   0000012C   0x1C52             ADDS     R2,R2,#+1
   \   0000012E   0x1C49             ADDS     R1,R1,#+1
   \   00000130   0x1E40             SUBS     R0,R0,#+1
   \   00000132   0xD1F9             BNE      ??f_write_24
   \                     ??f_write_23: (+1)
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0x6821             LDR      R1,[R4, #+0]
   \   00000138   0x7108             STRB     R0,[R1, #+4]
   \                     ??f_write_22: (+1)
   \   0000013A   0x6820             LDR      R0,[R4, #+0]
   \   0000013C   0x8940             LDRH     R0,[R0, #+10]
   \   0000013E   0x4345             MULS     R5,R0,R5
   \   00000140   0x2001             MOVS     R0,#+1
   \   00000142   0x4669             MOV      R1,SP
   \   00000144   0x7308             STRB     R0,[R1, #+12]
   \   00000146   0xE03D             B        ??f_write_25
   \                     ??f_write_20: (+1)
   \   00000148   0x68A0             LDR      R0,[R4, #+8]
   \   0000014A   0x68E1             LDR      R1,[R4, #+12]
   \   0000014C   0x4288             CMP      R0,R1
   \   0000014E   0xD307             BCC      ??f_write_26
   \   00000150   0x0038             MOVS     R0,R7
   \   00000152   0x.... 0x....      BL       _Z11sync_windowP5FATFS
   \   00000156   0x2800             CMP      R0,#+0
   \   00000158   0xD000             BEQ      .+4
   \   0000015A   0xE091             B        ??f_write_15
   \   0000015C   0x6820             LDR      R0,[R4, #+0]
   \   0000015E   0x6306             STR      R6,[R0, #+48]
   \                     ??f_write_26: (+1)
   \   00000160   0x61A6             STR      R6,[R4, #+24]
   \                     ??f_write_27: (+1)
   \   00000162   0x6826             LDR      R6,[R4, #+0]
   \   00000164   0x8975             LDRH     R5,[R6, #+10]
   \   00000166   0x68A0             LDR      R0,[R4, #+8]
   \   00000168   0x0029             MOVS     R1,R5
   \   0000016A   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000016E   0x1A68             SUBS     R0,R5,R1
   \   00000170   0x9D05             LDR      R5,[SP, #+20]
   \   00000172   0x4285             CMP      R5,R0
   \   00000174   0xD900             BLS      ??f_write_28
   \   00000176   0x0005             MOVS     R5,R0
   \                     ??f_write_28: (+1)
   \   00000178   0x69A7             LDR      R7,[R4, #+24]
   \   0000017A   0x6B30             LDR      R0,[R6, #+48]
   \   0000017C   0x4287             CMP      R7,R0
   \   0000017E   0xD00D             BEQ      ??f_write_29
   \   00000180   0x0030             MOVS     R0,R6
   \   00000182   0x.... 0x....      BL       _Z11sync_windowP5FATFS
   \   00000186   0x2800             CMP      R0,#+0
   \   00000188   0xD17A             BNE      ??f_write_15
   \   0000018A   0x2301             MOVS     R3,#+1
   \   0000018C   0x003A             MOVS     R2,R7
   \   0000018E   0x6B71             LDR      R1,[R6, #+52]
   \   00000190   0x7870             LDRB     R0,[R6, #+1]
   \   00000192   0x.... 0x....      BL       disk_read
   \   00000196   0x2800             CMP      R0,#+0
   \   00000198   0xD16F             BNE      ??f_write_30
   \   0000019A   0x6337             STR      R7,[R6, #+48]
   \                     ??f_write_29: (+1)
   \   0000019C   0x6821             LDR      R1,[R4, #+0]
   \   0000019E   0x6B4E             LDR      R6,[R1, #+52]
   \   000001A0   0x68A0             LDR      R0,[R4, #+8]
   \   000001A2   0x8949             LDRH     R1,[R1, #+10]
   \   000001A4   0x.... 0x....      BL       __aeabi_uidivmod
   \   000001A8   0x1870             ADDS     R0,R6,R1
   \   000001AA   0x9900             LDR      R1,[SP, #+0]
   \   000001AC   0x2D00             CMP      R5,#+0
   \   000001AE   0xD006             BEQ      ??f_write_31
   \   000001B0   0x002A             MOVS     R2,R5
   \                     ??f_write_32: (+1)
   \   000001B2   0x780B             LDRB     R3,[R1, #+0]
   \   000001B4   0x7003             STRB     R3,[R0, #+0]
   \   000001B6   0x1C49             ADDS     R1,R1,#+1
   \   000001B8   0x1C40             ADDS     R0,R0,#+1
   \   000001BA   0x1E52             SUBS     R2,R2,#+1
   \   000001BC   0xD1F9             BNE      ??f_write_32
   \                     ??f_write_31: (+1)
   \   000001BE   0x2001             MOVS     R0,#+1
   \   000001C0   0x6821             LDR      R1,[R4, #+0]
   \   000001C2   0x7108             STRB     R0,[R1, #+4]
   \                     ??f_write_25: (+1)
   \   000001C4   0x9800             LDR      R0,[SP, #+0]
   \   000001C6   0x1940             ADDS     R0,R0,R5
   \   000001C8   0x9000             STR      R0,[SP, #+0]
   \   000001CA   0x68A0             LDR      R0,[R4, #+8]
   \   000001CC   0x1940             ADDS     R0,R0,R5
   \   000001CE   0x60A0             STR      R0,[R4, #+8]
   \   000001D0   0x9806             LDR      R0,[SP, #+24]
   \   000001D2   0x6800             LDR      R0,[R0, #+0]
   \   000001D4   0x1940             ADDS     R0,R0,R5
   \   000001D6   0x9906             LDR      R1,[SP, #+24]
   \   000001D8   0x6008             STR      R0,[R1, #+0]
   \   000001DA   0x9805             LDR      R0,[SP, #+20]
   \   000001DC   0x1B40             SUBS     R0,R0,R5
   \   000001DE   0x9005             STR      R0,[SP, #+20]
   \                     ??f_write_2: (+1)
   \   000001E0   0x9805             LDR      R0,[SP, #+20]
   \   000001E2   0x2800             CMP      R0,#+0
   \   000001E4   0xD100             BNE      .+4
   \   000001E6   0xE727             B        ??f_write_3
   \   000001E8   0x6826             LDR      R6,[R4, #+0]
   \   000001EA   0x8977             LDRH     R7,[R6, #+10]
   \   000001EC   0x68A5             LDR      R5,[R4, #+8]
   \   000001EE   0x0028             MOVS     R0,R5
   \   000001F0   0x0039             MOVS     R1,R7
   \   000001F2   0x.... 0x....      BL       __aeabi_uidivmod
   \   000001F6   0x2900             CMP      R1,#+0
   \   000001F8   0xD1B3             BNE      ??f_write_27
   \   000001FA   0x0028             MOVS     R0,R5
   \   000001FC   0x0039             MOVS     R1,R7
   \   000001FE   0x.... 0x....      BL       __aeabi_uidiv
   \   00000202   0x78B1             LDRB     R1,[R6, #+2]
   \   00000204   0x1E49             SUBS     R1,R1,#+1
   \   00000206   0x4001             ANDS     R1,R1,R0
   \   00000208   0xB2C9             UXTB     R1,R1
   \   0000020A   0x2900             CMP      R1,#+0
   \   0000020C   0x9101             STR      R1,[SP, #+4]
   \   0000020E   0xD000             BEQ      .+4
   \   00000210   0xE74A             B        ??f_write_16
   \   00000212   0x2D00             CMP      R5,#+0
   \   00000214   0xD000             BEQ      .+4
   \   00000216   0xE735             B        ??f_write_13
   \   00000218   0x6920             LDR      R0,[R4, #+16]
   \   0000021A   0x2800             CMP      R0,#+0
   \   0000021C   0xD000             BEQ      .+4
   \   0000021E   0xE735             B        ??f_write_9
   \   00000220   0x68F7             LDR      R7,[R6, #+12]
   \   00000222   0x2F00             CMP      R7,#+0
   \   00000224   0xD002             BEQ      ??f_write_33
   \   00000226   0x69B0             LDR      R0,[R6, #+24]
   \   00000228   0x4287             CMP      R7,R0
   \   0000022A   0xD300             BCC      ??f_write_34
   \                     ??f_write_33: (+1)
   \   0000022C   0x2701             MOVS     R7,#+1
   \                     ??f_write_34: (+1)
   \   0000022E   0x003D             MOVS     R5,R7
   \                     ??f_write_12: (+1)
   \   00000230   0x1C6D             ADDS     R5,R5,#+1
   \   00000232   0x69B0             LDR      R0,[R6, #+24]
   \   00000234   0x4285             CMP      R5,R0
   \   00000236   0xD303             BCC      ??f_write_35
   \   00000238   0x2502             MOVS     R5,#+2
   \   0000023A   0x2F02             CMP      R7,#+2
   \   0000023C   0xD200             BCS      .+4
   \   0000023E   0xE6FB             B        ??f_write_3
   \                     ??f_write_35: (+1)
   \   00000240   0x0029             MOVS     R1,R5
   \   00000242   0x0030             MOVS     R0,R6
   \   00000244   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   \   00000248   0x2800             CMP      R0,#+0
   \   0000024A   0xD000             BEQ      .+4
   \   0000024C   0xE710             B        ??f_write_10
   \   0000024E   0x....             LDR      R2,??DataTable23  ;; 0xfffffff
   \   00000250   0x0029             MOVS     R1,R5
   \   00000252   0x0030             MOVS     R0,R6
   \   00000254   0x.... 0x....      BL       _Z7put_fatP5FATFSmm
   \   00000258   0x2800             CMP      R0,#+0
   \   0000025A   0xD000             BEQ      .+4
   \   0000025C   0xE700             B        ??f_write_6
   \   0000025E   0x60F5             STR      R5,[R6, #+12]
   \   00000260   0x6930             LDR      R0,[R6, #+16]
   \   00000262   0x2100             MOVS     R1,#+0
   \   00000264   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000266   0x4288             CMP      R0,R1
   \   00000268   0xD100             BNE      .+4
   \   0000026A   0xE6FF             B        ??f_write_8
   \   0000026C   0x1E40             SUBS     R0,R0,#+1
   \   0000026E   0x6130             STR      R0,[R6, #+16]
   \   00000270   0x7970             LDRB     R0,[R6, #+5]
   \   00000272   0x2101             MOVS     R1,#+1
   \   00000274   0x4301             ORRS     R1,R1,R0
   \   00000276   0x7171             STRB     R1,[R6, #+5]
   \   00000278   0xE6F8             B        ??f_write_8
   \                     ??f_write_30: (+1)
   \   0000027A   0x2000             MOVS     R0,#+0
   \   0000027C   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000027E   0x6330             STR      R0,[R6, #+48]
   \                     ??f_write_15: (+1)
   \   00000280   0x2001             MOVS     R0,#+1
   \   00000282   0xE72B             B.N      ??f_write_19
   2832          }
   2833          
   2834          
   2835          
   2836          
   2837          /*-----------------------------------------------------------------------*/
   2838          /* Synchronize the File                                                  */
   2839          /*-----------------------------------------------------------------------*/
   2840          

   \                                 In section .text, align 2, keep-with-next
   2841          FRESULT f_sync (
   2842          	FIL* fp		/* Pointer to the file object */
   2843          )
   2844          {
   \                     f_sync: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2845          	FRESULT res;
   2846          	DWORD tm;
   2847          	BYTE *dir;
   2848          
   2849          
   2850          	res = validate(fp);					/* Check validity of the object */
   \   00000004   0x.... 0x....      BL       _Z8validatePv
   2851          	if (res == FR_OK) {
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0xD134             BNE      ??f_sync_0
   2852          		if (fp->flag & FA__WRITTEN) {	/* Is there any change to the file? */
   \   0000000C   0x2620             MOVS     R6,#+32
   \   0000000E   0x79A1             LDRB     R1,[R4, #+6]
   \   00000010   0x4231             TST      R1,R6
   \   00000012   0xD030             BEQ      ??f_sync_0
   2853          #if !_FS_TINY
   2854          			if (fp->flag & FA__DIRTY) {	/* Write-back cached data if needed */
   2855          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2856          					LEAVE_FF(fp->fs, FR_DISK_ERR);
   2857          				fp->flag &= ~FA__DIRTY;
   2858          			}
   2859          #endif
   2860          			/* Update the directory entry */
   2861          			res = move_window(fp->fs, fp->dir_sect);
   \   00000014   0x69E1             LDR      R1,[R4, #+28]
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   2862          			if (res == FR_OK) {
   \   0000001C   0x0001             MOVS     R1,R0
   \   0000001E   0xD12A             BNE      ??f_sync_0
   2863          				dir = fp->dir_ptr;
   \   00000020   0x6A25             LDR      R5,[R4, #+32]
   2864          				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
   \   00000022   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000024   0x4306             ORRS     R6,R6,R0
   \   00000026   0x72EE             STRB     R6,[R5, #+11]
   2865          				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
   \   00000028   0x68E0             LDR      R0,[R4, #+12]
   \   0000002A   0x7728             STRB     R0,[R5, #+28]
   \   0000002C   0x68E0             LDR      R0,[R4, #+12]
   \   0000002E   0x0400             LSLS     R0,R0,#+16
   \   00000030   0x0E00             LSRS     R0,R0,#+24
   \   00000032   0x7768             STRB     R0,[R5, #+29]
   \   00000034   0x68E0             LDR      R0,[R4, #+12]
   \   00000036   0x0C00             LSRS     R0,R0,#+16
   \   00000038   0x77A8             STRB     R0,[R5, #+30]
   \   0000003A   0x68E0             LDR      R0,[R4, #+12]
   \   0000003C   0x0E00             LSRS     R0,R0,#+24
   \   0000003E   0x77E8             STRB     R0,[R5, #+31]
   2866          				st_clust(dir, fp->sclust);					/* Update start cluster */
   \   00000040   0x6921             LDR      R1,[R4, #+16]
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0x.... 0x....      BL       _Z8st_clustPhm
   2867          				tm = GET_FATTIME();							/* Update modified time */
   \   00000048   0x.... 0x....      BL       get_fattime
   2868          				ST_DWORD(dir + DIR_WrtTime, tm);
   \   0000004C   0x75A8             STRB     R0,[R5, #+22]
   \   0000004E   0x0401             LSLS     R1,R0,#+16
   \   00000050   0x0E09             LSRS     R1,R1,#+24
   \   00000052   0x75E9             STRB     R1,[R5, #+23]
   \   00000054   0x0C01             LSRS     R1,R0,#+16
   \   00000056   0x7629             STRB     R1,[R5, #+24]
   \   00000058   0x0E00             LSRS     R0,R0,#+24
   \   0000005A   0x7668             STRB     R0,[R5, #+25]
   2869          				ST_WORD(dir + DIR_LstAccDate, 0);
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x74A8             STRB     R0,[R5, #+18]
   \   00000060   0x74E8             STRB     R0,[R5, #+19]
   2870          				fp->flag &= ~FA__WRITTEN;
   \   00000062   0x79A0             LDRB     R0,[R4, #+6]
   \   00000064   0x21DF             MOVS     R1,#+223
   \   00000066   0x4001             ANDS     R1,R1,R0
   \   00000068   0x71A1             STRB     R1,[R4, #+6]
   2871          				fp->fs->wflag = 1;
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x6821             LDR      R1,[R4, #+0]
   \   0000006E   0x7108             STRB     R0,[R1, #+4]
   2872          				res = sync_fs(fp->fs);
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x.... 0x....      BL       _Z7sync_fsP5FATFS
   2873          			}
   2874          		}
   2875          	}
   2876          
   2877          	LEAVE_FF(fp->fs, res);
   \                     ??f_sync_0: (+1)
   \   00000076   0xBD70             POP      {R4-R6,PC}       ;; return
   2878          }
   2879          
   2880          #endif /* !_FS_READONLY */
   2881          
   2882          
   2883          
   2884          
   2885          /*-----------------------------------------------------------------------*/
   2886          /* Close File                                                            */
   2887          /*-----------------------------------------------------------------------*/
   2888          

   \                                 In section .text, align 2, keep-with-next
   2889          FRESULT f_close (
   2890          	FIL *fp		/* Pointer to the file object to be closed */
   2891          )
   2892          {
   \                     f_close: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2893          	FRESULT res;
   2894          
   2895          
   2896          #if !_FS_READONLY
   2897          	res = f_sync(fp);					/* Flush cached data */
   \   00000004   0x.... 0x....      BL       f_sync
   2898          	if (res == FR_OK)
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0xD106             BNE      ??f_close_0
   2899          #endif
   2900          	{
   2901          		res = validate(fp);				/* Lock volume */
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       _Z8validatePv
   2902          		if (res == FR_OK) {
   \   00000012   0x0001             MOVS     R1,R0
   \   00000014   0xD101             BNE      ??f_close_0
   2903          #if _FS_REENTRANT
   2904          			FATFS *fs = fp->fs;
   2905          #endif
   2906          #if _FS_LOCK
   2907          			res = dec_lock(fp->lockid);	/* Decrement file open counter */
   2908          			if (res == FR_OK)
   2909          #endif
   2910          				fp->fs = 0;				/* Invalidate file object */
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6021             STR      R1,[R4, #+0]
   2911          #if _FS_REENTRANT
   2912          			unlock_fs(fs, FR_OK);		/* Unlock volume */
   2913          #endif
   2914          #if !_FS_TINY && _FS_HEAPBUF
   2915          			ff_memfree(fp->buf);		/* Deallocate buffer */
   2916          #endif
   2917          		}
   2918          	}
   2919          	return res;
   \                     ??f_close_0: (+1)
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
   2920          }
   2921          
   2922          
   2923          
   2924          
   2925          /*-----------------------------------------------------------------------*/
   2926          /* Change Current Directory or Current Drive, Get Current Directory      */
   2927          /*-----------------------------------------------------------------------*/
   2928          
   2929          #if _FS_RPATH >= 1
   2930          #if _VOLUMES >= 2

   \                                 In section .text, align 2, keep-with-next
   2931          FRESULT f_chdrive (
   2932          	const TCHAR* path		/* Drive number */
   2933          )
   2934          {
   2935          	int vol;
   2936          
   2937          
   2938          	vol = get_ldnumber(&path);
   \                     f_chdrive: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD017             BEQ      ??f_chdrive_0
   \   00000004   0x0001             MOVS     R1,R0
   \   00000006   0xE000             B        ??f_chdrive_1
   \                     ??f_chdrive_2: (+1)
   \   00000008   0x1C49             ADDS     R1,R1,#+1
   \                     ??f_chdrive_1: (+1)
   \   0000000A   0x780A             LDRB     R2,[R1, #+0]
   \   0000000C   0x2A20             CMP      R2,#+32
   \   0000000E   0xD301             BCC      ??f_chdrive_3
   \   00000010   0x2A3A             CMP      R2,#+58
   \   00000012   0xD1F9             BNE      ??f_chdrive_2
   \                     ??f_chdrive_3: (+1)
   \   00000014   0x2A3A             CMP      R2,#+58
   \   00000016   0xD109             BNE      ??f_chdrive_4
   \   00000018   0x7802             LDRB     R2,[R0, #+0]
   \   0000001A   0x3A30             SUBS     R2,R2,#+48
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x2A0A             CMP      R2,#+10
   \   00000020   0xD208             BCS      ??f_chdrive_0
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD106             BNE      ??f_chdrive_0
   \   00000026   0x2A04             CMP      R2,#+4
   \   00000028   0xD204             BCS      ??f_chdrive_0
   \   0000002A   0xE001             B        ??f_chdrive_5
   \                     ??f_chdrive_4: (+1)
   \   0000002C   0x....             LDR      R0,??DataTable26
   \   0000002E   0x7802             LDRB     R2,[R0, #+0]
   2939          	if (vol < 0) return FR_INVALID_DRIVE;
   \                     ??f_chdrive_5: (+1)
   \   00000030   0x2A00             CMP      R2,#+0
   \   00000032   0xD501             BPL      ??f_chdrive_6
   \                     ??f_chdrive_0: (+1)
   \   00000034   0x200B             MOVS     R0,#+11
   \   00000036   0x4770             BX       LR
   2940          
   2941          	CurrVol = (BYTE)vol;
   \                     ??f_chdrive_6: (+1)
   \   00000038   0x....             LDR      R0,??DataTable26
   \   0000003A   0x7002             STRB     R2,[R0, #+0]
   2942          
   2943          	return FR_OK;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x4770             BX       LR               ;; return
   2944          }
   2945          #endif
   2946          
   2947          

   \                                 In section .text, align 2, keep-with-next
   2948          FRESULT f_chdir (
   2949          	const TCHAR* path	/* Pointer to the directory path */
   2950          )
   2951          {
   \                     f_chdir: (+1)
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   2952          	FRESULT res;
   2953          	FATFS_DIR dj;
   2954          	DEFINE_NAMEBUF;
   2955          
   2956          
   2957          	/* Get logical drive number */
   2958          	res = find_volume(&dj.fs, &path, 0);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xA90D             ADD      R1,SP,#+52
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       _Z11find_volumePP5FATFSPPKch
   \   0000000E   0x0004             MOVS     R4,R0
   2959          	if (res == FR_OK) {
   \   00000010   0xD11A             BNE      ??f_chdir_0
   2960          		INIT_BUF(dj);
   \   00000012   0xA809             ADD      R0,SP,#+36
   \   00000014   0x9006             STR      R0,[SP, #+24]
   \   00000016   0x....             LDR      R0,??DataTable26_1
   \   00000018   0x9007             STR      R0,[SP, #+28]
   2961          		res = follow_path(&dj, path);		/* Follow the path */
   \   0000001A   0x990D             LDR      R1,[SP, #+52]
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x.... 0x....      BL       _Z11follow_pathP9FATFS_DIRPKc
   \   00000022   0x0004             MOVS     R4,R0
   2962          		FREE_BUF();
   2963          		if (res == FR_OK) {					/* Follow completed */
   \   00000024   0xD10D             BNE      ??f_chdir_1
   2964          			if (!dj.dir) {
   \   00000026   0x9905             LDR      R1,[SP, #+20]
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD101             BNE      ??f_chdir_2
   \   0000002C   0x9802             LDR      R0,[SP, #+8]
   \   0000002E   0xE005             B.N      ??f_chdir_3
   2965          				dj.fs->cdir = dj.sclust;	/* Start directory itself */
   2966          			} else {
   2967          				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
   \                     ??f_chdir_2: (+1)
   \   00000030   0x7AC8             LDRB     R0,[R1, #+11]
   \   00000032   0x06C0             LSLS     R0,R0,#+27
   \   00000034   0xD507             BPL      ??f_chdir_4
   2968          					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0x.... 0x....      BL       _Z8ld_clustP5FATFSPKh
   \                     ??f_chdir_3: (+1)
   \   0000003C   0x9900             LDR      R1,[SP, #+0]
   \   0000003E   0x6148             STR      R0,[R1, #+20]
   \   00000040   0xE002             B        ??f_chdir_0
   2969          				else
   2970          					res = FR_NO_PATH;		/* Reached but a file */
   2971          			}
   2972          		}
   2973          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_chdir_1: (+1)
   \   00000042   0x2C04             CMP      R4,#+4
   \   00000044   0xD100             BNE      ??f_chdir_0
   \                     ??f_chdir_4: (+1)
   \   00000046   0x2405             MOVS     R4,#+5
   2974          	}
   2975          
   2976          	LEAVE_FF(dj.fs, res);
   \                     ??f_chdir_0: (+1)
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0xB00E             ADD      SP,SP,#+56
   \   0000004C   0xBD10             POP      {R4,PC}          ;; return
   2977          }
   2978          
   2979          
   2980          #if _FS_RPATH >= 2
   2981          FRESULT f_getcwd (
   2982          	TCHAR* buff,	/* Pointer to the directory path */
   2983          	UINT len		/* Size of path */
   2984          )
   2985          {
   2986          	FRESULT res;
   2987          	FATFS_DIR dj;
   2988          	UINT i, n;
   2989          	DWORD ccl;
   2990          	TCHAR *tp;
   2991          	FILINFO fno;
   2992          	DEFINE_NAMEBUF;
   2993          
   2994          
   2995          	*buff = 0;
   2996          	/* Get logical drive number */
   2997          	res = find_volume(&dj.fs, (const TCHAR**)&buff, 0);	/* Get current volume */
   2998          	if (res == FR_OK) {
   2999          		INIT_BUF(dj);
   3000          		i = len;			/* Bottom of buffer (directory stack base) */
   3001          		dj.sclust = dj.fs->cdir;			/* Start to follow upper directory from current directory */
   3002          		while ((ccl = dj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
   3003          			res = dir_sdi(&dj, 1);			/* Get parent directory */
   3004          			if (res != FR_OK) break;
   3005          			res = dir_read(&dj, 0);
   3006          			if (res != FR_OK) break;
   3007          			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent directory */
   3008          			res = dir_sdi(&dj, 0);
   3009          			if (res != FR_OK) break;
   3010          			do {							/* Find the entry links to the child directory */
   3011          				res = dir_read(&dj, 0);
   3012          				if (res != FR_OK) break;
   3013          				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
   3014          				res = dir_next(&dj, 0);	
   3015          			} while (res == FR_OK);
   3016          			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
   3017          			if (res != FR_OK) break;
   3018          #if _USE_LFN
   3019          			fno.lfname = buff;
   3020          			fno.lfsize = i;
   3021          #endif
   3022          			get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
   3023          			tp = fno.fname;
   3024          #if _USE_LFN
   3025          			if (*buff) tp = buff;
   3026          #endif
   3027          			for (n = 0; tp[n]; n++) ;
   3028          			if (i < n + 3) {
   3029          				res = FR_NOT_ENOUGH_CORE; break;
   3030          			}
   3031          			while (n) buff[--i] = tp[--n];
   3032          			buff[--i] = '/';
   3033          		}
   3034          		tp = buff;
   3035          		if (res == FR_OK) {
   3036          #if _VOLUMES >= 2
   3037          			*tp++ = '0' + CurrVol;			/* Put drive number */
   3038          			*tp++ = ':';
   3039          #endif
   3040          			if (i == len) {					/* Root-directory */
   3041          				*tp++ = '/';
   3042          			} else {						/* Sub-directroy */
   3043          				do		/* Add stacked path str */
   3044          					*tp++ = buff[i++];
   3045          				while (i < len);
   3046          			}
   3047          		}
   3048          		*tp = 0;
   3049          		FREE_BUF();
   3050          	}
   3051          
   3052          	LEAVE_FF(dj.fs, res);
   3053          }
   3054          #endif /* _FS_RPATH >= 2 */
   3055          #endif /* _FS_RPATH >= 1 */
   3056          
   3057          
   3058          
   3059          #if _FS_MINIMIZE <= 2
   3060          /*-----------------------------------------------------------------------*/
   3061          /* Seek File R/W Pointer                                                 */
   3062          /*-----------------------------------------------------------------------*/
   3063          

   \                                 In section .text, align 2, keep-with-next
   3064          FRESULT f_lseek (
   3065          	FIL* fp,		/* Pointer to the file object */
   3066          	DWORD ofs		/* File pointer from top of file */
   3067          )
   3068          {
   \                     f_lseek: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   3069          	FRESULT res;
   3070          	DWORD clst, bcs, nsect, ifptr;
   3071          #if _USE_FASTSEEK
   3072          	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
   3073          #endif
   3074          
   3075          
   3076          	res = validate(fp);					/* Check validity of the object */
   \   00000008   0x.... 0x....      BL       _Z8validatePv
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x7108             STRB     R0,[R1, #+4]
   3077          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x7900             LDRB     R0,[R0, #+4]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD000             BEQ      .+4
   \   00000018   0xE093             B        ??f_lseek_0
   3078          	if (fp->err)						/* Check error */
   \   0000001A   0x79E0             LDRB     R0,[R4, #+7]
   \   0000001C   0x0001             MOVS     R1,R0
   \   0000001E   0xD000             BEQ      .+4
   \   00000020   0xE091             B        ??f_lseek_1
   3079          		LEAVE_FF(fp->fs, (FRESULT)fp->err);
   3080          
   3081          #if _USE_FASTSEEK
   3082          	if (fp->cltbl) {	/* Fast seek */
   3083          		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
   3084          			tbl = fp->cltbl;
   3085          			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
   3086          			cl = fp->sclust;			/* Top of the chain */
   3087          			if (cl) {
   3088          				do {
   3089          					/* Get a fragment */
   3090          					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
   3091          					do {
   3092          						pcl = cl; ncl++;
   3093          						cl = get_fat(fp->fs, cl);
   3094          						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
   3095          						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3096          					} while (cl == pcl + 1);
   3097          					if (ulen <= tlen) {		/* Store the length and top of the fragment */
   3098          						*tbl++ = ncl; *tbl++ = tcl;
   3099          					}
   3100          				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
   3101          			}
   3102          			*fp->cltbl = ulen;	/* Number of items used */
   3103          			if (ulen <= tlen)
   3104          				*tbl = 0;		/* Terminate table */
   3105          			else
   3106          				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
   3107          
   3108          		} else {						/* Fast seek */
   3109          			if (ofs > fp->fsize)		/* Clip offset at the file size */
   3110          				ofs = fp->fsize;
   3111          			fp->fptr = ofs;				/* Set file pointer */
   3112          			if (ofs) {
   3113          				fp->clust = clmt_clust(fp, ofs - 1);
   3114          				dsc = clust2sect(fp->fs, fp->clust);
   3115          				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
   3116          				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
   3117          				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
   3118          #if !_FS_TINY
   3119          #if !_FS_READONLY
   3120          					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   3121          						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   3122          							ABORT(fp->fs, FR_DISK_ERR);
   3123          						fp->flag &= ~FA__DIRTY;
   3124          					}
   3125          #endif
   3126          					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
   3127          						ABORT(fp->fs, FR_DISK_ERR);
   3128          #endif
   3129          					fp->dsect = dsc;
   3130          				}
   3131          			}
   3132          		}
   3133          	} else
   3134          #endif
   3135          
   3136          	/* Normal Seek */
   3137          	{
   3138          		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
   3139          #if !_FS_READONLY
   3140          			 && !(fp->flag & FA_WRITE)
   3141          #endif
   3142          			) ofs = fp->fsize;
   \   00000022   0x68E0             LDR      R0,[R4, #+12]
   \   00000024   0x42A8             CMP      R0,R5
   \   00000026   0xD203             BCS      ??f_lseek_2
   \   00000028   0x79A1             LDRB     R1,[R4, #+6]
   \   0000002A   0x0789             LSLS     R1,R1,#+30
   \   0000002C   0xD400             BMI      ??f_lseek_2
   \   0000002E   0x0005             MOVS     R5,R0
   3143          
   3144          		ifptr = fp->fptr;
   \                     ??f_lseek_2: (+1)
   \   00000030   0x68A7             LDR      R7,[R4, #+8]
   3145          		fp->fptr = nsect = 0;
   \   00000032   0x2600             MOVS     R6,#+0
   \   00000034   0x60A6             STR      R6,[R4, #+8]
   3146          		if (ofs) {
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD06F             BEQ      ??f_lseek_3
   3147          			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x9003             STR      R0,[SP, #+12]
   \   0000003E   0x7880             LDRB     R0,[R0, #+2]
   \   00000040   0x9903             LDR      R1,[SP, #+12]
   \   00000042   0x8949             LDRH     R1,[R1, #+10]
   \   00000044   0x4348             MULS     R0,R1,R0
   \   00000046   0x9002             STR      R0,[SP, #+8]
   3148          			if (ifptr > 0 &&
   3149          				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
   \   00000048   0x2F00             CMP      R7,#+0
   \   0000004A   0xD014             BEQ      ??f_lseek_4
   \   0000004C   0x1E7F             SUBS     R7,R7,#+1
   \   0000004E   0x0038             MOVS     R0,R7
   \   00000050   0x9902             LDR      R1,[SP, #+8]
   \   00000052   0x.... 0x....      BL       __aeabi_uidiv
   \   00000056   0x9000             STR      R0,[SP, #+0]
   \   00000058   0x1E68             SUBS     R0,R5,#+1
   \   0000005A   0x9902             LDR      R1,[SP, #+8]
   \   0000005C   0x.... 0x....      BL       __aeabi_uidiv
   \   00000060   0x0001             MOVS     R1,R0
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   \   00000064   0x4281             CMP      R1,R0
   \   00000066   0xD306             BCC      ??f_lseek_4
   3150          				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
   \   00000068   0x9802             LDR      R0,[SP, #+8]
   \   0000006A   0x1E40             SUBS     R0,R0,#+1
   \   0000006C   0x4387             BICS     R7,R7,R0
   \   0000006E   0x60A7             STR      R7,[R4, #+8]
   3151          				ofs -= fp->fptr;
   \   00000070   0x1BED             SUBS     R5,R5,R7
   3152          				clst = fp->clust;
   \   00000072   0x6967             LDR      R7,[R4, #+20]
   \   00000074   0xE00F             B        ??f_lseek_5
   3153          			} else {									/* When seek to back cluster, */
   3154          				clst = fp->sclust;						/* start from the first cluster */
   \                     ??f_lseek_4: (+1)
   \   00000076   0x6927             LDR      R7,[R4, #+16]
   3155          #if !_FS_READONLY
   3156          				if (clst == 0) {						/* If no cluster chain, create a new chain */
   \   00000078   0x2F00             CMP      R7,#+0
   \   0000007A   0xD10B             BNE      ??f_lseek_6
   3157          					clst = create_chain(fp->fs, 0);
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0x9803             LDR      R0,[SP, #+12]
   \   00000080   0x.... 0x....      BL       _Z12create_chainP5FATFSm
   \   00000084   0x0007             MOVS     R7,R0
   3158          					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   \   00000086   0x2F01             CMP      R7,#+1
   \   00000088   0xD034             BEQ      ??f_lseek_7
   3159          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000008E   0x4287             CMP      R7,R0
   \   00000090   0xD03A             BEQ      ??f_lseek_8
   3160          					fp->sclust = clst;
   \   00000092   0x6127             STR      R7,[R4, #+16]
   3161          				}
   3162          #endif
   3163          				fp->clust = clst;
   \                     ??f_lseek_6: (+1)
   \   00000094   0x6167             STR      R7,[R4, #+20]
   3164          			}
   3165          			if (clst != 0) {
   \                     ??f_lseek_5: (+1)
   \   00000096   0x2F00             CMP      R7,#+0
   \   00000098   0xD10D             BNE      ??f_lseek_9
   \   0000009A   0xE03E             B        ??f_lseek_3
   3166          				while (ofs > bcs) {						/* Cluster following loop */
   3167          #if !_FS_READONLY
   3168          					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
   3169          						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
   3170          						if (clst == 0) {				/* When disk gets full, clip file size */
   3171          							ofs = bcs; break;
   3172          						}
   3173          					} else
   3174          #endif
   3175          						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
   3176          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3177          					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
   \                     ??f_lseek_10: (+1)
   \   0000009C   0x2F02             CMP      R7,#+2
   \   0000009E   0xD329             BCC      ??f_lseek_7
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6980             LDR      R0,[R0, #+24]
   \   000000A4   0x4287             CMP      R7,R0
   \   000000A6   0xD225             BCS      ??f_lseek_7
   3178          					fp->clust = clst;
   \   000000A8   0x6167             STR      R7,[R4, #+20]
   3179          					fp->fptr += bcs;
   \   000000AA   0x68A0             LDR      R0,[R4, #+8]
   \   000000AC   0x9902             LDR      R1,[SP, #+8]
   \   000000AE   0x1840             ADDS     R0,R0,R1
   \   000000B0   0x60A0             STR      R0,[R4, #+8]
   3180          					ofs -= bcs;
   \   000000B2   0x9802             LDR      R0,[SP, #+8]
   \   000000B4   0x1A2D             SUBS     R5,R5,R0
   \                     ??f_lseek_9: (+1)
   \   000000B6   0x9802             LDR      R0,[SP, #+8]
   \   000000B8   0x42A8             CMP      R0,R5
   \   000000BA   0xD209             BCS      ??f_lseek_11
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x79A1             LDRB     R1,[R4, #+6]
   \   000000C0   0x0789             LSLS     R1,R1,#+30
   \   000000C2   0xD519             BPL      ??f_lseek_12
   \   000000C4   0x0039             MOVS     R1,R7
   \   000000C6   0x.... 0x....      BL       _Z12create_chainP5FATFSm
   \   000000CA   0x0007             MOVS     R7,R0
   \   000000CC   0xD118             BNE      ??f_lseek_13
   \   000000CE   0x9D02             LDR      R5,[SP, #+8]
   3181          				}
   3182          				fp->fptr += ofs;
   \                     ??f_lseek_11: (+1)
   \   000000D0   0x68A0             LDR      R0,[R4, #+8]
   \   000000D2   0x1940             ADDS     R0,R0,R5
   \   000000D4   0x60A0             STR      R0,[R4, #+8]
   3183          				if (ofs % SS(fp->fs)) {
   \   000000D6   0x6820             LDR      R0,[R4, #+0]
   \   000000D8   0x9000             STR      R0,[SP, #+0]
   \   000000DA   0x0028             MOVS     R0,R5
   \   000000DC   0x9900             LDR      R1,[SP, #+0]
   \   000000DE   0x8949             LDRH     R1,[R1, #+10]
   \   000000E0   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000E4   0x2900             CMP      R1,#+0
   \   000000E6   0xD018             BEQ      ??f_lseek_3
   3184          					nsect = clust2sect(fp->fs, clst);	/* Current sector */
   \   000000E8   0x0039             MOVS     R1,R7
   \   000000EA   0x9800             LDR      R0,[SP, #+0]
   \   000000EC   0x.... 0x....      BL       _Z10clust2sectP5FATFSm
   \   000000F0   0x0006             MOVS     R6,R0
   3185          					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
   \   000000F2   0xD10C             BNE      ??f_lseek_14
   \                     ??f_lseek_7: (+1)
   \   000000F4   0x2002             MOVS     R0,#+2
   \   000000F6   0xE008             B.N      ??f_lseek_15
   \                     ??f_lseek_12: (+1)
   \   000000F8   0x0039             MOVS     R1,R7
   \   000000FA   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   \   000000FE   0x0007             MOVS     R7,R0
   \                     ??f_lseek_13: (+1)
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000104   0x4287             CMP      R7,R0
   \   00000106   0xD1C9             BNE      ??f_lseek_10
   \                     ??f_lseek_8: (+1)
   \   00000108   0x2001             MOVS     R0,#+1
   \                     ??f_lseek_15: (+1)
   \   0000010A   0x71E0             STRB     R0,[R4, #+7]
   \   0000010C   0xE01B             B        ??f_lseek_1
   3186          					nsect += ofs / SS(fp->fs);
   \                     ??f_lseek_14: (+1)
   \   0000010E   0x0028             MOVS     R0,R5
   \   00000110   0x6821             LDR      R1,[R4, #+0]
   \   00000112   0x8949             LDRH     R1,[R1, #+10]
   \   00000114   0x.... 0x....      BL       __aeabi_uidiv
   \   00000118   0x1836             ADDS     R6,R6,R0
   3187          				}
   3188          			}
   3189          		}
   3190          		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
   \                     ??f_lseek_3: (+1)
   \   0000011A   0x68A5             LDR      R5,[R4, #+8]
   \   0000011C   0x0028             MOVS     R0,R5
   \   0000011E   0x6821             LDR      R1,[R4, #+0]
   \   00000120   0x8949             LDRH     R1,[R1, #+10]
   \   00000122   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000126   0x2900             CMP      R1,#+0
   \   00000128   0xD003             BEQ      ??f_lseek_16
   \   0000012A   0x69A0             LDR      R0,[R4, #+24]
   \   0000012C   0x4286             CMP      R6,R0
   \   0000012E   0xD000             BEQ      ??f_lseek_16
   3191          #if !_FS_TINY
   3192          #if !_FS_READONLY
   3193          			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
   3194          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   3195          					ABORT(fp->fs, FR_DISK_ERR);
   3196          				fp->flag &= ~FA__DIRTY;
   3197          			}
   3198          #endif
   3199          			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
   3200          				ABORT(fp->fs, FR_DISK_ERR);
   3201          #endif
   3202          			fp->dsect = nsect;
   \   00000130   0x61A6             STR      R6,[R4, #+24]
   3203          		}
   3204          #if !_FS_READONLY
   3205          		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
   \                     ??f_lseek_16: (+1)
   \   00000132   0x68E0             LDR      R0,[R4, #+12]
   \   00000134   0x42A8             CMP      R0,R5
   \   00000136   0xD204             BCS      ??f_lseek_0
   3206          			fp->fsize = fp->fptr;
   \   00000138   0x60E5             STR      R5,[R4, #+12]
   3207          			fp->flag |= FA__WRITTEN;
   \   0000013A   0x79A0             LDRB     R0,[R4, #+6]
   \   0000013C   0x2120             MOVS     R1,#+32
   \   0000013E   0x4301             ORRS     R1,R1,R0
   \   00000140   0x71A1             STRB     R1,[R4, #+6]
   3208          		}
   3209          #endif
   3210          	}
   3211          
   3212          	LEAVE_FF(fp->fs, res);
   \                     ??f_lseek_0: (+1)
   \   00000142   0x4668             MOV      R0,SP
   \   00000144   0x7900             LDRB     R0,[R0, #+4]
   \                     ??f_lseek_1: (+1)
   \   00000146   0xB005             ADD      SP,SP,#+20
   \   00000148   0xBDF0             POP      {R4-R7,PC}       ;; return
   3213          }
   3214          
   3215          
   3216          
   3217          #if _FS_MINIMIZE <= 1
   3218          /*-----------------------------------------------------------------------*/
   3219          /* Create a Directory Object                                             */
   3220          /*-----------------------------------------------------------------------*/
   3221          

   \                                 In section .text, align 2, keep-with-next
   3222          FRESULT f_opendir (
   3223          	FATFS_DIR* dp,			/* Pointer to directory object to create */
   3224          	const TCHAR* path	/* Pointer to the directory path */
   3225          )
   3226          {
   \                     f_opendir: (+1)
   \   00000000   0xB512             PUSH     {R1,R4,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   3227          	FRESULT res;
   3228          	FATFS* fs;
   3229          	DEFINE_NAMEBUF;
   3230          
   3231          
   3232          	if (!dp) return FR_INVALID_OBJECT;
   \   00000006   0xD101             BNE      ??f_opendir_0
   \   00000008   0x2009             MOVS     R0,#+9
   \   0000000A   0xE02B             B        ??f_opendir_1
   3233          
   3234          	/* Get logical drive number */
   3235          	res = find_volume(&fs, &path, 0);
   \                     ??f_opendir_0: (+1)
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0xA905             ADD      R1,SP,#+20
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x.... 0x....      BL       _Z11find_volumePP5FATFSPPKch
   3236          	if (res == FR_OK) {
   \   00000016   0x0001             MOVS     R1,R0
   \   00000018   0xD120             BNE      ??f_opendir_2
   3237          		dp->fs = fs;
   \   0000001A   0x9800             LDR      R0,[SP, #+0]
   \   0000001C   0x6020             STR      R0,[R4, #+0]
   3238          		INIT_BUF(*dp);
   \   0000001E   0xA801             ADD      R0,SP,#+4
   \   00000020   0x61A0             STR      R0,[R4, #+24]
   \   00000022   0x....             LDR      R0,??DataTable26_1
   \   00000024   0x61E0             STR      R0,[R4, #+28]
   3239          		res = follow_path(dp, path);			/* Follow the path to the directory */
   \   00000026   0x9905             LDR      R1,[SP, #+20]
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       _Z11follow_pathP9FATFS_DIRPKc
   3240          		FREE_BUF();
   3241          		if (res == FR_OK) {						/* Follow completed */
   \   0000002E   0x0001             MOVS     R1,R0
   \   00000030   0xD110             BNE      ??f_opendir_3
   3242          			if (dp->dir) {						/* It is not the origin directory itself */
   \   00000032   0x6961             LDR      R1,[R4, #+20]
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD006             BEQ      ??f_opendir_4
   3243          				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
   \   00000038   0x7AC8             LDRB     R0,[R1, #+11]
   \   0000003A   0x06C0             LSLS     R0,R0,#+27
   \   0000003C   0xD50C             BPL      ??f_opendir_5
   3244          					dp->sclust = ld_clust(fs, dp->dir);
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x.... 0x....      BL       _Z8ld_clustP5FATFSPKh
   \   00000044   0x60A0             STR      R0,[R4, #+8]
   3245          				else							/* The object is a file */
   3246          					res = FR_NO_PATH;
   3247          			}
   3248          			if (res == FR_OK) {
   3249          				dp->id = fs->id;
   \                     ??f_opendir_4: (+1)
   \   00000046   0x9800             LDR      R0,[SP, #+0]
   \   00000048   0x88C0             LDRH     R0,[R0, #+6]
   \   0000004A   0x80A0             STRH     R0,[R4, #+4]
   3250          				res = dir_sdi(dp, 0);			/* Rewind directory */
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       _Z7dir_sdiP9FATFS_DIRj
   3251          #if _FS_LOCK
   3252          				if (res == FR_OK) {
   3253          					if (dp->sclust) {
   3254          						dp->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
   3255          						if (!dp->lockid)
   3256          							res = FR_TOO_MANY_OPEN_FILES;
   3257          					} else {
   3258          						dp->lockid = 0;	/* Root directory need not to be locked */
   3259          					}
   3260          				}
   3261          #endif
   3262          			}
   3263          		}
   3264          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_opendir_3: (+1)
   \   00000054   0x2804             CMP      R0,#+4
   \   00000056   0xD101             BNE      ??f_opendir_2
   \                     ??f_opendir_5: (+1)
   \   00000058   0x2005             MOVS     R0,#+5
   \   0000005A   0xE001             B        ??f_opendir_6
   3265          	}
   3266          	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
   \                     ??f_opendir_2: (+1)
   \   0000005C   0x0001             MOVS     R1,R0
   \   0000005E   0xD001             BEQ      ??f_opendir_1
   \                     ??f_opendir_6: (+1)
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x6021             STR      R1,[R4, #+0]
   3267          
   3268          	LEAVE_FF(fs, res);
   \                     ??f_opendir_1: (+1)
   \   00000064   0xB006             ADD      SP,SP,#+24
   \   00000066   0xBD10             POP      {R4,PC}          ;; return
   3269          }
   3270          
   3271          
   3272          
   3273          
   3274          /*-----------------------------------------------------------------------*/
   3275          /* Close Directory                                                       */
   3276          /*-----------------------------------------------------------------------*/
   3277          

   \                                 In section .text, align 2, keep-with-next
   3278          FRESULT f_closedir (
   3279          	FATFS_DIR *dp		/* Pointer to the directory object to be closed */
   3280          )
   3281          {
   \                     f_closedir: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3282          	FRESULT res;
   3283          
   3284          
   3285          	res = validate(dp);
   \   00000004   0xD012             BEQ      ??f_closedir_0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00F             BEQ      ??f_closedir_0
   \   0000000C   0x7801             LDRB     R1,[R0, #+0]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD00C             BEQ      ??f_closedir_0
   \   00000012   0x88C1             LDRH     R1,[R0, #+6]
   \   00000014   0x88A2             LDRH     R2,[R4, #+4]
   \   00000016   0x4291             CMP      R1,R2
   \   00000018   0xD108             BNE      ??f_closedir_0
   \   0000001A   0x7840             LDRB     R0,[R0, #+1]
   \   0000001C   0x.... 0x....      BL       disk_status
   \   00000020   0x07C0             LSLS     R0,R0,#+31
   \   00000022   0xD403             BMI      ??f_closedir_0
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x2000             MOVS     R0,#+0
   3286          	if (res == FR_OK) {
   3287          #if _FS_REENTRANT
   3288          		FATFS *fs = dp->fs;
   3289          #endif
   3290          #if _FS_LOCK
   3291          		if (dp->lockid)				/* Decrement sub-directory open counter */
   3292          			res = dec_lock(dp->lockid);
   3293          		if (res == FR_OK)
   3294          #endif
   3295          			dp->fs = 0;				/* Invalidate directory object */
   \   00000028   0x6021             STR      R1,[R4, #+0]
   \   0000002A   0xBD10             POP      {R4,PC}
   3296          #if _FS_REENTRANT
   3297          		unlock_fs(fs, FR_OK);		/* Unlock volume */
   3298          #endif
   3299          	}
   \                     ??f_closedir_0: (+1)
   \   0000002C   0x2009             MOVS     R0,#+9
   3300          	return res;
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   3301          }
   3302          
   3303          
   3304          
   3305          
   3306          /*-----------------------------------------------------------------------*/
   3307          /* Read Directory Entries in Sequence                                    */
   3308          /*-----------------------------------------------------------------------*/
   3309          

   \                                 In section .text, align 2, keep-with-next
   3310          FRESULT f_readdir (
   3311          	FATFS_DIR* dp,			/* Pointer to the open directory object */
   3312          	FILINFO* fno		/* Pointer to file information to return */
   3313          )
   3314          {
   \                     f_readdir: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   3315          	FRESULT res;
   3316          	DEFINE_NAMEBUF;
   3317          
   3318          
   3319          	res = validate(dp);						/* Check validity of the object */
   \   00000008   0x.... 0x....      BL       _Z8validatePv
   3320          	if (res == FR_OK) {
   \   0000000C   0x0001             MOVS     R1,R0
   \   0000000E   0xD121             BNE      ??f_readdir_0
   3321          		if (!fno) {
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD104             BNE      ??f_readdir_1
   3322          			res = dir_sdi(dp, 0);			/* Rewind the directory object */
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       _Z7dir_sdiP9FATFS_DIRj
   \   0000001C   0xE01A             B        ??f_readdir_0
   3323          		} else {
   3324          			INIT_BUF(*dp);
   \                     ??f_readdir_1: (+1)
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0x61A0             STR      R0,[R4, #+24]
   \   00000022   0x....             LDR      R0,??DataTable26_1
   \   00000024   0x61E0             STR      R0,[R4, #+28]
   3325          			res = dir_read(dp, 0);			/* Read an item */
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       _Z8dir_readP9FATFS_DIRi
   3326          			if (res == FR_NO_FILE) {		/* Reached end of directory */
   \   0000002E   0x2804             CMP      R0,#+4
   \   00000030   0xD102             BNE      ??f_readdir_2
   3327          				dp->sect = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6120             STR      R0,[R4, #+16]
   3328          				res = FR_OK;
   \   00000036   0xE001             B        ??f_readdir_3
   3329          			}
   3330          			if (res == FR_OK) {				/* A valid entry is found */
   \                     ??f_readdir_2: (+1)
   \   00000038   0x0001             MOVS     R1,R0
   \   0000003A   0xD10B             BNE      ??f_readdir_0
   3331          				get_fileinfo(dp, fno);		/* Get the object information */
   \                     ??f_readdir_3: (+1)
   \   0000003C   0x0029             MOVS     R1,R5
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       _Z12get_fileinfoP9FATFS_DIRP7FILINFO
   3332          				res = dir_next(dp, 0);		/* Increment index for next */
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       _Z8dir_nextP9FATFS_DIRi
   3333          				if (res == FR_NO_FILE) {
   \   0000004C   0x2804             CMP      R0,#+4
   \   0000004E   0xD101             BNE      ??f_readdir_0
   3334          					dp->sect = 0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x6120             STR      R0,[R4, #+16]
   3335          					res = FR_OK;
   3336          				}
   3337          			}
   3338          			FREE_BUF();
   3339          		}
   3340          	}
   3341          
   3342          	LEAVE_FF(dp->fs, res);
   \                     ??f_readdir_0: (+1)
   \   00000054   0xB003             ADD      SP,SP,#+12
   \   00000056   0xBD30             POP      {R4,R5,PC}       ;; return
   3343          }
   3344          
   3345          
   3346          
   3347          #if _USE_FIND
   3348          /*-----------------------------------------------------------------------*/
   3349          /* Find next file                                                        */
   3350          /*-----------------------------------------------------------------------*/
   3351          
   3352          FRESULT f_findnext (
   3353          	FATFS_DIR* dp,		/* Pointer to the open directory object */
   3354          	FILINFO* fno	/* Pointer to the file information structure */
   3355          )
   3356          {
   3357          	FRESULT res;
   3358          
   3359          
   3360          	for (;;) {
   3361          		res = f_readdir(dp, fno);		/* Get a directory item */
   3362          		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
   3363          #if _USE_LFN
   3364          		if (fno->lfname && pattern_matching(dp->pat, fno->lfname, 0, 0)) break;	/* Test for LFN if exist */
   3365          #endif
   3366          		if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;	/* Test for SFN */
   3367          	}
   3368          	return res;
   3369          
   3370          }
   3371          
   3372          
   3373          
   3374          /*-----------------------------------------------------------------------*/
   3375          /* Find first file                                                       */
   3376          /*-----------------------------------------------------------------------*/
   3377          
   3378          FRESULT f_findfirst (
   3379          	FATFS_DIR* dp,				/* Pointer to the blank directory object */
   3380          	FILINFO* fno,			/* Pointer to the file information structure */
   3381          	const TCHAR* path,		/* Pointer to the directory to open */
   3382          	const TCHAR* pattern	/* Pointer to the matching pattern */
   3383          )
   3384          {
   3385          	FRESULT res;
   3386          
   3387          
   3388          	dp->pat = pattern;		/* Save pointer to pattern string */
   3389          	res = f_opendir(dp, path);		/* Open the target directory */
   3390          	if (res == FR_OK)
   3391          		res = f_findnext(dp, fno);	/* Find the first item */
   3392          	return res;
   3393          }
   3394          
   3395          #endif	/* _USE_FIND */
   3396          
   3397          
   3398          
   3399          #if _FS_MINIMIZE == 0
   3400          /*-----------------------------------------------------------------------*/
   3401          /* Get File Status                                                       */
   3402          /*-----------------------------------------------------------------------*/
   3403          

   \                                 In section .text, align 2, keep-with-next
   3404          FRESULT f_stat (
   3405          	const TCHAR* path,	/* Pointer to the file path */
   3406          	FILINFO* fno		/* Pointer to file information to return */
   3407          )
   3408          {
   \                     f_stat: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x000C             MOVS     R4,R1
   3409          	FRESULT res;
   3410          	FATFS_DIR dj;
   3411          	DEFINE_NAMEBUF;
   3412          
   3413          
   3414          	/* Get logical drive number */
   3415          	res = find_volume(&dj.fs, &path, 0);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xA90C             ADD      R1,SP,#+48
   \   0000000A   0xA803             ADD      R0,SP,#+12
   \   0000000C   0x.... 0x....      BL       _Z11find_volumePP5FATFSPPKch
   \   00000010   0x0005             MOVS     R5,R0
   3416          	if (res == FR_OK) {
   \   00000012   0xD114             BNE      ??f_stat_0
   3417          		INIT_BUF(dj);
   \   00000014   0x4668             MOV      R0,SP
   \   00000016   0x9009             STR      R0,[SP, #+36]
   \   00000018   0x....             LDR      R0,??DataTable26_1
   \   0000001A   0x900A             STR      R0,[SP, #+40]
   3418          		res = follow_path(&dj, path);	/* Follow the file path */
   \   0000001C   0x990C             LDR      R1,[SP, #+48]
   \   0000001E   0xA803             ADD      R0,SP,#+12
   \   00000020   0x.... 0x....      BL       _Z11follow_pathP9FATFS_DIRPKc
   \   00000024   0x0005             MOVS     R5,R0
   3419          		if (res == FR_OK) {				/* Follow completed */
   \   00000026   0xD10A             BNE      ??f_stat_0
   3420          			if (dj.dir) {		/* Found an object */
   \   00000028   0x9808             LDR      R0,[SP, #+32]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD006             BEQ      ??f_stat_1
   3421          				if (fno) get_fileinfo(&dj, fno);
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD005             BEQ      ??f_stat_0
   \   00000032   0x0021             MOVS     R1,R4
   \   00000034   0xA803             ADD      R0,SP,#+12
   \   00000036   0x.... 0x....      BL       _Z12get_fileinfoP9FATFS_DIRP7FILINFO
   \   0000003A   0xE000             B        ??f_stat_0
   3422          			} else {			/* It is root directory */
   3423          				res = FR_INVALID_NAME;
   \                     ??f_stat_1: (+1)
   \   0000003C   0x2506             MOVS     R5,#+6
   3424          			}
   3425          		}
   3426          		FREE_BUF();
   3427          	}
   3428          
   3429          	LEAVE_FF(dj.fs, res);
   \                     ??f_stat_0: (+1)
   \   0000003E   0x0028             MOVS     R0,R5
   \   00000040   0xB00D             ADD      SP,SP,#+52
   \   00000042   0xBD30             POP      {R4,R5,PC}       ;; return
   3430          }
   3431          
   3432          
   3433          
   3434          #if !_FS_READONLY
   3435          /*-----------------------------------------------------------------------*/
   3436          /* Get Number of Free Clusters                                           */
   3437          /*-----------------------------------------------------------------------*/
   3438          

   \                                 In section .text, align 2, keep-with-next
   3439          FRESULT f_getfree (
   3440          	const TCHAR* path,	/* Path name of the logical drive number */
   3441          	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
   3442          	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
   3443          )
   3444          {
   \                     f_getfree: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0014             MOVS     R4,R2
   3445          	FRESULT res;
   3446          	FATFS *fs;
   3447          	DWORD nfree, clst, sect, stat;
   3448          	UINT i;
   3449          	BYTE fat, *p;
   3450          
   3451          
   3452          	/* Get logical drive number */
   3453          	res = find_volume(fatfs, &path, 0);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xA903             ADD      R1,SP,#+12
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       _Z11find_volumePP5FATFSPPKch
   \   00000010   0x0006             MOVS     R6,R0
   3454          	fs = *fatfs;
   \   00000012   0x6827             LDR      R7,[R4, #+0]
   3455          	if (res == FR_OK) {
   \   00000014   0xD16C             BNE      ??f_getfree_0
   3456          		/* If free_clust is valid, return it without full cluster scan */
   3457          		if (fs->free_clust <= fs->n_fatent - 2) {
   \   00000016   0x6938             LDR      R0,[R7, #+16]
   \   00000018   0x69BD             LDR      R5,[R7, #+24]
   \   0000001A   0x1EA9             SUBS     R1,R5,#+2
   \   0000001C   0x4281             CMP      R1,R0
   \   0000001E   0xD302             BCC      ??f_getfree_1
   3458          			*nclst = fs->free_clust;
   \   00000020   0x9904             LDR      R1,[SP, #+16]
   \   00000022   0x6008             STR      R0,[R1, #+0]
   \   00000024   0xE064             B        ??f_getfree_0
   3459          		} else {
   3460          			/* Get number of free clusters */
   3461          			fat = fs->fs_type;
   \                     ??f_getfree_1: (+1)
   \   00000026   0x7838             LDRB     R0,[R7, #+0]
   \   00000028   0x9002             STR      R0,[SP, #+8]
   \   0000002A   0x2400             MOVS     R4,#+0
   3462          			nfree = 0;
   3463          			if (fat == FS_FAT12) {	/* Sector unalighed entries: Search FAT via regular routine. */
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD116             BNE      ??f_getfree_2
   \   00000030   0x2502             MOVS     R5,#+2
   3464          				clst = 2;
   3465          				do {
   3466          					stat = get_fat(fs, clst);
   \                     ??f_getfree_3: (+1)
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0x0038             MOVS     R0,R7
   \   00000036   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   3467          					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD101             BNE      ??f_getfree_4
   \   00000042   0x2601             MOVS     R6,#+1
   \   00000044   0xE04D             B        ??f_getfree_5
   3468          					if (stat == 1) { res = FR_INT_ERR; break; }
   \                     ??f_getfree_4: (+1)
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD101             BNE      ??f_getfree_6
   \   0000004A   0x2602             MOVS     R6,#+2
   \   0000004C   0xE049             B        ??f_getfree_5
   3469          					if (stat == 0) nfree++;
   \                     ??f_getfree_6: (+1)
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD100             BNE      ??f_getfree_7
   \   00000052   0x1C64             ADDS     R4,R4,#+1
   3470          				} while (++clst < fs->n_fatent);
   \                     ??f_getfree_7: (+1)
   \   00000054   0x1C6D             ADDS     R5,R5,#+1
   \   00000056   0x69B8             LDR      R0,[R7, #+24]
   \   00000058   0x4285             CMP      R5,R0
   \   0000005A   0xD3EA             BCC      ??f_getfree_3
   \   0000005C   0xE041             B        ??f_getfree_5
   3471          			} else {				/* Sector alighed entries: Accelerate the FAT search. */
   3472          				clst = fs->n_fatent; sect = fs->fatbase;
   \                     ??f_getfree_2: (+1)
   \   0000005E   0x6A78             LDR      R0,[R7, #+36]
   \   00000060   0x9001             STR      R0,[SP, #+4]
   3473          				i = 0; p = 0;
   \   00000062   0xE001             B        ??f_getfree_8
   3474          				do {
   3475          					if (!i) {
   \                     ??f_getfree_9: (+1)
   \   00000064   0x2A00             CMP      R2,#+0
   \   00000066   0xD11F             BNE      ??f_getfree_10
   3476          						res = move_window(fs, sect++);
   \                     ??f_getfree_8: (+1)
   \   00000068   0x9801             LDR      R0,[SP, #+4]
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   \   0000006C   0x2600             MOVS     R6,#+0
   \   0000006E   0x6B39             LDR      R1,[R7, #+48]
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xD012             BEQ      ??f_getfree_11
   \   00000074   0x0038             MOVS     R0,R7
   \   00000076   0x.... 0x....      BL       _Z11sync_windowP5FATFS
   \   0000007A   0x0006             MOVS     R6,R0
   \   0000007C   0xD10D             BNE      ??f_getfree_11
   \   0000007E   0x2301             MOVS     R3,#+1
   \   00000080   0x9A00             LDR      R2,[SP, #+0]
   \   00000082   0x6B79             LDR      R1,[R7, #+52]
   \   00000084   0x7878             LDRB     R0,[R7, #+1]
   \   00000086   0x.... 0x....      BL       disk_read
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD003             BEQ      ??f_getfree_12
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000092   0x9000             STR      R0,[SP, #+0]
   \   00000094   0x2601             MOVS     R6,#+1
   \                     ??f_getfree_12: (+1)
   \   00000096   0x9800             LDR      R0,[SP, #+0]
   \   00000098   0x6338             STR      R0,[R7, #+48]
   \                     ??f_getfree_11: (+1)
   \   0000009A   0x9801             LDR      R0,[SP, #+4]
   \   0000009C   0x1C40             ADDS     R0,R0,#+1
   \   0000009E   0x9001             STR      R0,[SP, #+4]
   3477          						if (res != FR_OK) break;
   \   000000A0   0x0030             MOVS     R0,R6
   \   000000A2   0xD11E             BNE      ??f_getfree_5
   3478          						p = fs->win;
   \   000000A4   0x6B79             LDR      R1,[R7, #+52]
   3479          						i = SS(fs);
   \   000000A6   0x897A             LDRH     R2,[R7, #+10]
   3480          					}
   3481          					if (fat == FS_FAT16) {
   \                     ??f_getfree_10: (+1)
   \   000000A8   0x9802             LDR      R0,[SP, #+8]
   \   000000AA   0x2802             CMP      R0,#+2
   \   000000AC   0xD108             BNE      ??f_getfree_13
   3482          						if (LD_WORD(p) == 0) nfree++;
   \   000000AE   0x7848             LDRB     R0,[R1, #+1]
   \   000000B0   0x0200             LSLS     R0,R0,#+8
   \   000000B2   0x780B             LDRB     R3,[R1, #+0]
   \   000000B4   0x4318             ORRS     R0,R0,R3
   \   000000B6   0xD100             BNE      ??f_getfree_14
   \   000000B8   0x1C64             ADDS     R4,R4,#+1
   3483          						p += 2; i -= 2;
   \                     ??f_getfree_14: (+1)
   \   000000BA   0x1C89             ADDS     R1,R1,#+2
   \   000000BC   0x1E92             SUBS     R2,R2,#+2
   \   000000BE   0xE00E             B        ??f_getfree_15
   3484          					} else {
   3485          						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) nfree++;
   \                     ??f_getfree_13: (+1)
   \   000000C0   0x78C8             LDRB     R0,[R1, #+3]
   \   000000C2   0x0603             LSLS     R3,R0,#+24
   \   000000C4   0x7888             LDRB     R0,[R1, #+2]
   \   000000C6   0x0400             LSLS     R0,R0,#+16
   \   000000C8   0x4318             ORRS     R0,R0,R3
   \   000000CA   0x784B             LDRB     R3,[R1, #+1]
   \   000000CC   0x021B             LSLS     R3,R3,#+8
   \   000000CE   0x4303             ORRS     R3,R3,R0
   \   000000D0   0x7808             LDRB     R0,[R1, #+0]
   \   000000D2   0x4318             ORRS     R0,R0,R3
   \   000000D4   0x0100             LSLS     R0,R0,#+4
   \   000000D6   0xD100             BNE      ??f_getfree_16
   \   000000D8   0x1C64             ADDS     R4,R4,#+1
   3486          						p += 4; i -= 4;
   \                     ??f_getfree_16: (+1)
   \   000000DA   0x1D09             ADDS     R1,R1,#+4
   \   000000DC   0x1F12             SUBS     R2,R2,#+4
   3487          					}
   3488          				} while (--clst);
   \                     ??f_getfree_15: (+1)
   \   000000DE   0x1E6D             SUBS     R5,R5,#+1
   \   000000E0   0xD1C0             BNE      ??f_getfree_9
   3489          			}
   3490          			fs->free_clust = nfree;	/* free_clust is valid */
   \                     ??f_getfree_5: (+1)
   \   000000E2   0x613C             STR      R4,[R7, #+16]
   3491          			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
   \   000000E4   0x7978             LDRB     R0,[R7, #+5]
   \   000000E6   0x2101             MOVS     R1,#+1
   \   000000E8   0x4301             ORRS     R1,R1,R0
   \   000000EA   0x7179             STRB     R1,[R7, #+5]
   3492          			*nclst = nfree;			/* Return the free clusters */
   \   000000EC   0x9804             LDR      R0,[SP, #+16]
   \   000000EE   0x6004             STR      R4,[R0, #+0]
   3493          		}
   3494          	}
   3495          	LEAVE_FF(fs, res);
   \                     ??f_getfree_0: (+1)
   \   000000F0   0x0030             MOVS     R0,R6
   \   000000F2   0xB005             ADD      SP,SP,#+20
   \   000000F4   0xBDF0             POP      {R4-R7,PC}       ;; return
   3496          }
   3497          
   3498          
   3499          
   3500          
   3501          /*-----------------------------------------------------------------------*/
   3502          /* Truncate File                                                         */
   3503          /*-----------------------------------------------------------------------*/
   3504          

   \                                 In section .text, align 2, keep-with-next
   3505          FRESULT f_truncate (
   3506          	FIL* fp		/* Pointer to the file object */
   3507          )
   3508          {
   \                     f_truncate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3509          	FRESULT res;
   3510          	DWORD ncl;
   3511          
   3512          
   3513          	res = validate(fp);						/* Check validity of the object */
   \   00000004   0x.... 0x....      BL       _Z8validatePv
   \   00000008   0x0005             MOVS     R5,R0
   3514          	if (res == FR_OK) {
   \   0000000A   0xD103             BNE      ??f_truncate_0
   3515          		if (fp->err) {						/* Check error */
   \   0000000C   0x79E0             LDRB     R0,[R4, #+7]
   \   0000000E   0x0001             MOVS     R1,R0
   \   00000010   0xD015             BEQ      ??f_truncate_1
   3516          			res = (FRESULT)fp->err;
   \   00000012   0x0005             MOVS     R5,R0
   3517          		} else {
   3518          			if (!(fp->flag & FA_WRITE))		/* Check access mode */
   3519          				res = FR_DENIED;
   3520          		}
   3521          	}
   3522          	if (res == FR_OK) {
   \                     ??f_truncate_0: (+1)
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0xD139             BNE      ??f_truncate_2
   3523          		if (fp->fsize > fp->fptr) {
   \                     ??f_truncate_3: (+1)
   \   00000018   0x68A1             LDR      R1,[R4, #+8]
   \   0000001A   0x68E0             LDR      R0,[R4, #+12]
   \   0000001C   0x4281             CMP      R1,R0
   \   0000001E   0xD235             BCS      ??f_truncate_2
   3524          			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
   \   00000020   0x60E1             STR      R1,[R4, #+12]
   3525          			fp->flag |= FA__WRITTEN;
   \   00000022   0x79A0             LDRB     R0,[R4, #+6]
   \   00000024   0x2220             MOVS     R2,#+32
   \   00000026   0x4302             ORRS     R2,R2,R0
   \   00000028   0x71A2             STRB     R2,[R4, #+6]
   3526          			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD10B             BNE      ??f_truncate_4
   3527          				res = remove_chain(fp->fs, fp->sclust);
   \   00000030   0x6921             LDR      R1,[R4, #+16]
   \   00000032   0x.... 0x....      BL       _Z12remove_chainP5FATFSm
   \   00000036   0x0005             MOVS     R5,R0
   3528          				fp->sclust = 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x6120             STR      R0,[R4, #+16]
   \   0000003C   0xE023             B        ??f_truncate_5
   3529          			} else {				/* When truncate a part of the file, remove remaining clusters */
   \                     ??f_truncate_1: (+1)
   \   0000003E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000040   0x0780             LSLS     R0,R0,#+30
   \   00000042   0xD4E9             BMI      ??f_truncate_3
   \   00000044   0x2507             MOVS     R5,#+7
   \   00000046   0xE021             B        ??f_truncate_2
   3530          				ncl = get_fat(fp->fs, fp->clust);
   \                     ??f_truncate_4: (+1)
   \   00000048   0x6961             LDR      R1,[R4, #+20]
   \   0000004A   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   \   0000004E   0x0006             MOVS     R6,R0
   3531          				res = FR_OK;
   3532          				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000054   0x4286             CMP      R6,R0
   \   00000056   0xD101             BNE      ??f_truncate_6
   \   00000058   0x2501             MOVS     R5,#+1
   \   0000005A   0xE016             B        ??f_truncate_7
   3533          				if (ncl == 1) res = FR_INT_ERR;
   \                     ??f_truncate_6: (+1)
   \   0000005C   0x2E01             CMP      R6,#+1
   \   0000005E   0xD101             BNE      ??f_truncate_8
   \   00000060   0x2502             MOVS     R5,#+2
   \   00000062   0xE012             B        ??f_truncate_7
   3534          				if (res == FR_OK && ncl < fp->fs->n_fatent) {
   \                     ??f_truncate_8: (+1)
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0xD10E             BNE      ??f_truncate_5
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6981             LDR      R1,[R0, #+24]
   \   0000006C   0x428E             CMP      R6,R1
   \   0000006E   0xD20D             BCS      ??f_truncate_2
   3535          					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
   \   00000070   0x....             LDR      R2,??DataTable30  ;; 0xfffffff
   \   00000072   0x6961             LDR      R1,[R4, #+20]
   \   00000074   0x.... 0x....      BL       _Z7put_fatP5FATFSmm
   \   00000078   0x0005             MOVS     R5,R0
   3536          					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
   \   0000007A   0xD104             BNE      ??f_truncate_5
   \   0000007C   0x0031             MOVS     R1,R6
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x.... 0x....      BL       _Z12remove_chainP5FATFSm
   \   00000084   0x0005             MOVS     R5,R0
   3537          				}
   3538          			}
   3539          #if !_FS_TINY
   3540          			if (res == FR_OK && (fp->flag & FA__DIRTY)) {
   3541          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   3542          					res = FR_DISK_ERR;
   3543          				else
   3544          					fp->flag &= ~FA__DIRTY;
   3545          			}
   3546          #endif
   3547          		}
   3548          		if (res != FR_OK) fp->err = (FRESULT)res;
   \                     ??f_truncate_5: (+1)
   \   00000086   0x0028             MOVS     R0,R5
   \   00000088   0xD000             BEQ      ??f_truncate_2
   \                     ??f_truncate_7: (+1)
   \   0000008A   0x71E5             STRB     R5,[R4, #+7]
   3549          	}
   3550          
   3551          	LEAVE_FF(fp->fs, res);
   \                     ??f_truncate_2: (+1)
   \   0000008C   0x0028             MOVS     R0,R5
   \   0000008E   0xBD70             POP      {R4-R6,PC}       ;; return
   3552          }
   3553          
   3554          
   3555          
   3556          
   3557          /*-----------------------------------------------------------------------*/
   3558          /* Delete a File or Directory                                            */
   3559          /*-----------------------------------------------------------------------*/
   3560          

   \                                 In section .text, align 2, keep-with-next
   3561          FRESULT f_unlink (
   3562          	const TCHAR* path		/* Pointer to the file or directory path */
   3563          )
   3564          {
   \                     f_unlink: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB096             SUB      SP,SP,#+88
   3565          	FRESULT res;
   3566          	FATFS_DIR dj, sdj;
   3567          	BYTE *dir;
   3568          	DWORD dclst = 0;
   3569          	DEFINE_NAMEBUF;
   3570          
   3571          
   3572          	/* Get logical drive number */
   3573          	res = find_volume(&dj.fs, &path, 1);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xA916             ADD      R1,SP,#+88
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       _Z11find_volumePP5FATFSPPKch
   3574          	if (res == FR_OK) {
   \   0000000E   0x0001             MOVS     R1,R0
   \   00000010   0xD148             BNE      ??f_unlink_0
   3575          		INIT_BUF(dj);
   \   00000012   0xA809             ADD      R0,SP,#+36
   \   00000014   0x9006             STR      R0,[SP, #+24]
   \   00000016   0x....             LDR      R0,??DataTable30_1
   \   00000018   0x9007             STR      R0,[SP, #+28]
   3576          		res = follow_path(&dj, path);		/* Follow the file path */
   \   0000001A   0x9916             LDR      R1,[SP, #+88]
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x.... 0x....      BL       _Z11follow_pathP9FATFS_DIRPKc
   3577          		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
   \   00000022   0x0001             MOVS     R1,R0
   \   00000024   0xD13E             BNE      ??f_unlink_0
   \   00000026   0x9806             LDR      R0,[SP, #+24]
   \   00000028   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000002A   0x0680             LSLS     R0,R0,#+26
   \   0000002C   0xD402             BMI      ??f_unlink_1
   3578          			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
   3579          #if _FS_LOCK
   3580          		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open object */
   3581          #endif
   3582          		if (res == FR_OK) {					/* The object is accessible */
   3583          			dir = dj.dir;
   \   0000002E   0x9D05             LDR      R5,[SP, #+20]
   3584          			if (!dir) {
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD101             BNE      ??f_unlink_2
   3585          				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
   \                     ??f_unlink_1: (+1)
   \   00000034   0x2006             MOVS     R0,#+6
   \   00000036   0xE035             B        ??f_unlink_0
   3586          			} else {
   3587          				if (dir[DIR_Attr] & AM_RDO)
   \                     ??f_unlink_2: (+1)
   \   00000038   0x7AE8             LDRB     R0,[R5, #+11]
   \   0000003A   0x07C0             LSLS     R0,R0,#+31
   \   0000003C   0xD41E             BMI      ??f_unlink_3
   3588          					res = FR_DENIED;		/* Cannot remove R/O object */
   3589          			}
   3590          			if (res == FR_OK) {
   3591          				dclst = ld_clust(dj.fs, dir);
   \   0000003E   0x0029             MOVS     R1,R5
   \   00000040   0x9800             LDR      R0,[SP, #+0]
   \   00000042   0x.... 0x....      BL       _Z8ld_clustP5FATFSPKh
   \   00000046   0x0004             MOVS     R4,R0
   3592          				if (dclst && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-directory ? */
   \   00000048   0xD01C             BEQ      ??f_unlink_4
   \   0000004A   0x7AE8             LDRB     R0,[R5, #+11]
   \   0000004C   0x06C0             LSLS     R0,R0,#+27
   \   0000004E   0xD519             BPL      ??f_unlink_4
   3593          #if _FS_RPATH
   3594          					if (dclst == dj.fs->cdir) {		 		/* Is it the current directory? */
   \   00000050   0x9800             LDR      R0,[SP, #+0]
   \   00000052   0x6940             LDR      R0,[R0, #+20]
   \   00000054   0x4284             CMP      R4,R0
   \   00000056   0xD011             BEQ      ??f_unlink_3
   3595          						res = FR_DENIED;
   3596          					} else
   3597          #endif
   3598          					{
   3599          						mem_cpy(&sdj, &dj, sizeof (FATFS_DIR));	/* Open the sub-directory */
   \   00000058   0x2224             MOVS     R2,#+36
   \   0000005A   0x4669             MOV      R1,SP
   \   0000005C   0xA80C             ADD      R0,SP,#+48
   \   0000005E   0x.... 0x....      BL       __aeabi_memcpy4
   3600          						sdj.sclust = dclst;
   \   00000062   0x940E             STR      R4,[SP, #+56]
   3601          						res = dir_sdi(&sdj, 2);
   \   00000064   0x2102             MOVS     R1,#+2
   \   00000066   0xA80C             ADD      R0,SP,#+48
   \   00000068   0x.... 0x....      BL       _Z7dir_sdiP9FATFS_DIRj
   3602          						if (res == FR_OK) {
   \   0000006C   0x0001             MOVS     R1,R0
   \   0000006E   0xD119             BNE      ??f_unlink_0
   3603          							res = dir_read(&sdj, 0);			/* Read an item (excluding dot entries) */
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0xA80C             ADD      R0,SP,#+48
   \   00000074   0x.... 0x....      BL       _Z8dir_readP9FATFS_DIRi
   3604          							if (res == FR_OK) res = FR_DENIED;	/* Not empty? (cannot remove) */
   \   00000078   0x0001             MOVS     R1,R0
   \   0000007A   0xD101             BNE      ??f_unlink_5
   \                     ??f_unlink_3: (+1)
   \   0000007C   0x2007             MOVS     R0,#+7
   \   0000007E   0xE011             B        ??f_unlink_0
   3605          							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? (can remove) */
   \                     ??f_unlink_5: (+1)
   \   00000080   0x2804             CMP      R0,#+4
   \   00000082   0xD10F             BNE      ??f_unlink_0
   3606          						}
   3607          					}
   3608          				}
   3609          			}
   3610          			if (res == FR_OK) {
   3611          				res = dir_remove(&dj);		/* Remove the directory entry */
   \                     ??f_unlink_4: (+1)
   \   00000084   0x4668             MOV      R0,SP
   \   00000086   0x.... 0x....      BL       _Z10dir_removeP9FATFS_DIR
   3612          				if (res == FR_OK && dclst)	/* Remove the cluster chain if exist */
   \   0000008A   0x0001             MOVS     R1,R0
   \   0000008C   0xD105             BNE      ??f_unlink_6
   \   0000008E   0x2C00             CMP      R4,#+0
   \   00000090   0xD005             BEQ      ??f_unlink_7
   3613          					res = remove_chain(dj.fs, dclst);
   \   00000092   0x0021             MOVS     R1,R4
   \   00000094   0x9800             LDR      R0,[SP, #+0]
   \   00000096   0x.... 0x....      BL       _Z12remove_chainP5FATFSm
   3614          				if (res == FR_OK) res = sync_fs(dj.fs);
   \                     ??f_unlink_6: (+1)
   \   0000009A   0x0001             MOVS     R1,R0
   \   0000009C   0xD102             BNE      ??f_unlink_0
   \                     ??f_unlink_7: (+1)
   \   0000009E   0x9800             LDR      R0,[SP, #+0]
   \   000000A0   0x.... 0x....      BL       _Z7sync_fsP5FATFS
   3615          			}
   3616          		}
   3617          		FREE_BUF();
   3618          	}
   3619          
   3620          	LEAVE_FF(dj.fs, res);
   \                     ??f_unlink_0: (+1)
   \   000000A4   0xB017             ADD      SP,SP,#+92
   \   000000A6   0xBD30             POP      {R4,R5,PC}       ;; return
   3621          }
   3622          
   3623          
   3624          
   3625          
   3626          /*-----------------------------------------------------------------------*/
   3627          /* Create a Directory                                                    */
   3628          /*-----------------------------------------------------------------------*/
   3629          

   \                                 In section .text, align 2, keep-with-next
   3630          FRESULT f_mkdir (
   3631          	const TCHAR* path		/* Pointer to the directory path */
   3632          )
   3633          {
   \                     f_mkdir: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB08E             SUB      SP,SP,#+56
   3634          	FRESULT res;
   3635          	FATFS_DIR dj;
   3636          	BYTE *dir, n;
   3637          	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
   \   00000004   0x.... 0x....      BL       get_fattime
   \   00000008   0x9000             STR      R0,[SP, #+0]
   3638          	DEFINE_NAMEBUF;
   3639          
   3640          
   3641          	/* Get logical drive number */
   3642          	res = find_volume(&dj.fs, &path, 1);
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0xA90E             ADD      R1,SP,#+56
   \   0000000E   0xA802             ADD      R0,SP,#+8
   \   00000010   0x.... 0x....      BL       _Z11find_volumePP5FATFSPPKch
   \   00000014   0x0005             MOVS     R5,R0
   3643          	if (res == FR_OK) {
   \   00000016   0xD000             BEQ      .+4
   \   00000018   0xE0B2             B        ??f_mkdir_0
   3644          		INIT_BUF(dj);
   \   0000001A   0xA80B             ADD      R0,SP,#+44
   \   0000001C   0x9008             STR      R0,[SP, #+32]
   \   0000001E   0x....             LDR      R0,??DataTable30_1
   \   00000020   0x9009             STR      R0,[SP, #+36]
   3645          		res = follow_path(&dj, path);			/* Follow the file path */
   \   00000022   0x990E             LDR      R1,[SP, #+56]
   \   00000024   0xA802             ADD      R0,SP,#+8
   \   00000026   0x.... 0x....      BL       _Z11follow_pathP9FATFS_DIRPKc
   \   0000002A   0x0005             MOVS     R5,R0
   3646          		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
   \   0000002C   0xD101             BNE      ??f_mkdir_1
   \   0000002E   0x2508             MOVS     R5,#+8
   \   00000030   0xE0A6             B        ??f_mkdir_0
   3647          		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
   \                     ??f_mkdir_1: (+1)
   \   00000032   0x2D04             CMP      R5,#+4
   \   00000034   0xD000             BEQ      .+4
   \   00000036   0xE0A3             B        ??f_mkdir_0
   \   00000038   0x9808             LDR      R0,[SP, #+32]
   \   0000003A   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000003C   0x0680             LSLS     R0,R0,#+26
   \   0000003E   0xD501             BPL      ??f_mkdir_2
   3648          			res = FR_INVALID_NAME;
   \   00000040   0x2506             MOVS     R5,#+6
   \   00000042   0xE09D             B        ??f_mkdir_0
   3649          		if (res == FR_NO_FILE) {				/* Can create a new directory */
   3650          			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
   \                     ??f_mkdir_2: (+1)
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x9802             LDR      R0,[SP, #+8]
   \   00000048   0x.... 0x....      BL       _Z12create_chainP5FATFSm
   \   0000004C   0x9001             STR      R0,[SP, #+4]
   3651          			res = FR_OK;
   3652          			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD101             BNE      ??f_mkdir_3
   \   00000052   0x2507             MOVS     R5,#+7
   \   00000054   0xE075             B        ??f_mkdir_4
   3653          			if (dcl == 1) res = FR_INT_ERR;
   \                     ??f_mkdir_3: (+1)
   \   00000056   0x2801             CMP      R0,#+1
   \   00000058   0xD101             BNE      ??f_mkdir_5
   \   0000005A   0x2502             MOVS     R5,#+2
   \   0000005C   0xE071             B        ??f_mkdir_4
   3654          			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \                     ??f_mkdir_5: (+1)
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD101             BNE      ??f_mkdir_6
   \   00000066   0x2501             MOVS     R5,#+1
   \   00000068   0xE06B             B        ??f_mkdir_4
   3655          			if (res == FR_OK)					/* Flush FAT */
   3656          				res = sync_window(dj.fs);
   \                     ??f_mkdir_6: (+1)
   \   0000006A   0x9802             LDR      R0,[SP, #+8]
   \   0000006C   0x.... 0x....      BL       _Z11sync_windowP5FATFS
   \   00000070   0x0005             MOVS     R5,R0
   3657          			if (res == FR_OK) {					/* Initialize the new directory table */
   \   00000072   0xD15E             BNE      ??f_mkdir_7
   3658          				dsc = clust2sect(dj.fs, dcl);
   \   00000074   0x9901             LDR      R1,[SP, #+4]
   \   00000076   0x9802             LDR      R0,[SP, #+8]
   \   00000078   0x.... 0x....      BL       _Z10clust2sectP5FATFSm
   \   0000007C   0x0006             MOVS     R6,R0
   3659          				dir = dj.fs->win;
   \   0000007E   0x9802             LDR      R0,[SP, #+8]
   \   00000080   0x6B44             LDR      R4,[R0, #+52]
   3660          				mem_set(dir, 0, SS(dj.fs));
   \   00000082   0x8941             LDRH     R1,[R0, #+10]
   \   00000084   0x2900             CMP      R1,#+0
   \   00000086   0xD002             BEQ      ??f_mkdir_8
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       __aeabi_memclr
   3661          				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
   \                     ??f_mkdir_8: (+1)
   \   0000008E   0x2220             MOVS     R2,#+32
   \   00000090   0x210B             MOVS     R1,#+11
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       __aeabi_memset
   3662          				dir[DIR_Name] = '.';
   \   00000098   0x252E             MOVS     R5,#+46
   \   0000009A   0x7025             STRB     R5,[R4, #+0]
   3663          				dir[DIR_Attr] = AM_DIR;
   \   0000009C   0x2010             MOVS     R0,#+16
   \   0000009E   0x72E0             STRB     R0,[R4, #+11]
   3664          				ST_DWORD(dir + DIR_WrtTime, tm);
   \   000000A0   0x9800             LDR      R0,[SP, #+0]
   \   000000A2   0x75A0             STRB     R0,[R4, #+22]
   \   000000A4   0x9800             LDR      R0,[SP, #+0]
   \   000000A6   0x0400             LSLS     R0,R0,#+16
   \   000000A8   0x0E00             LSRS     R0,R0,#+24
   \   000000AA   0x75E0             STRB     R0,[R4, #+23]
   \   000000AC   0x9800             LDR      R0,[SP, #+0]
   \   000000AE   0x0C00             LSRS     R0,R0,#+16
   \   000000B0   0x7620             STRB     R0,[R4, #+24]
   \   000000B2   0x9800             LDR      R0,[SP, #+0]
   \   000000B4   0x0E00             LSRS     R0,R0,#+24
   \   000000B6   0x7660             STRB     R0,[R4, #+25]
   3665          				st_clust(dir, dcl);
   \   000000B8   0x9901             LDR      R1,[SP, #+4]
   \   000000BA   0x0020             MOVS     R0,R4
   \   000000BC   0x.... 0x....      BL       _Z8st_clustPhm
   3666          				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
   \   000000C0   0x0020             MOVS     R0,R4
   \   000000C2   0x3020             ADDS     R0,R0,#+32
   \   000000C4   0x0021             MOVS     R1,R4
   \   000000C6   0x2208             MOVS     R2,#+8
   \                     ??f_mkdir_9: (+1)
   \   000000C8   0x780B             LDRB     R3,[R1, #+0]
   \   000000CA   0x7003             STRB     R3,[R0, #+0]
   \   000000CC   0x784B             LDRB     R3,[R1, #+1]
   \   000000CE   0x7043             STRB     R3,[R0, #+1]
   \   000000D0   0x788B             LDRB     R3,[R1, #+2]
   \   000000D2   0x7083             STRB     R3,[R0, #+2]
   \   000000D4   0x78CB             LDRB     R3,[R1, #+3]
   \   000000D6   0x70C3             STRB     R3,[R0, #+3]
   \   000000D8   0x1D09             ADDS     R1,R1,#+4
   \   000000DA   0x1D00             ADDS     R0,R0,#+4
   \   000000DC   0x1E52             SUBS     R2,R2,#+1
   \   000000DE   0xD1F3             BNE      ??f_mkdir_9
   3667          				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
   \   000000E0   0x2021             MOVS     R0,#+33
   \   000000E2   0x5425             STRB     R5,[R4, R0]
   \   000000E4   0x9904             LDR      R1,[SP, #+16]
   3668          				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
   \   000000E6   0x9802             LDR      R0,[SP, #+8]
   \   000000E8   0x7800             LDRB     R0,[R0, #+0]
   \   000000EA   0x2803             CMP      R0,#+3
   \   000000EC   0xD104             BNE      ??f_mkdir_10
   \   000000EE   0x9802             LDR      R0,[SP, #+8]
   \   000000F0   0x6A80             LDR      R0,[R0, #+40]
   \   000000F2   0x4281             CMP      R1,R0
   \   000000F4   0xD100             BNE      ??f_mkdir_10
   3669          					pcl = 0;
   \   000000F6   0x2100             MOVS     R1,#+0
   3670          				st_clust(dir + SZ_DIRE, pcl);
   \                     ??f_mkdir_10: (+1)
   \   000000F8   0x0020             MOVS     R0,R4
   \   000000FA   0x3020             ADDS     R0,R0,#+32
   \   000000FC   0x.... 0x....      BL       _Z8st_clustPhm
   3671          				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
   \   00000100   0x9802             LDR      R0,[SP, #+8]
   \   00000102   0x7887             LDRB     R7,[R0, #+2]
   \   00000104   0x0038             MOVS     R0,R7
   \   00000106   0xD016             BEQ      ??f_mkdir_11
   3672          					dj.fs->winsect = dsc++;
   \                     ??f_mkdir_12: (+1)
   \   00000108   0x9802             LDR      R0,[SP, #+8]
   \   0000010A   0x6306             STR      R6,[R0, #+48]
   \   0000010C   0x1C76             ADDS     R6,R6,#+1
   3673          					dj.fs->wflag = 1;
   \   0000010E   0x2001             MOVS     R0,#+1
   \   00000110   0x9902             LDR      R1,[SP, #+8]
   \   00000112   0x7108             STRB     R0,[R1, #+4]
   3674          					res = sync_window(dj.fs);
   \   00000114   0x9802             LDR      R0,[SP, #+8]
   \   00000116   0x.... 0x....      BL       _Z11sync_windowP5FATFS
   \   0000011A   0x0005             MOVS     R5,R0
   3675          					if (res != FR_OK) break;
   \   0000011C   0xD109             BNE      ??f_mkdir_7
   3676          					mem_set(dir, 0, SS(dj.fs));
   \   0000011E   0x9802             LDR      R0,[SP, #+8]
   \   00000120   0x8941             LDRH     R1,[R0, #+10]
   \   00000122   0x2900             CMP      R1,#+0
   \   00000124   0xD002             BEQ      ??f_mkdir_13
   \   00000126   0x0020             MOVS     R0,R4
   \   00000128   0x.... 0x....      BL       __aeabi_memclr
   3677          				}
   \                     ??f_mkdir_13: (+1)
   \   0000012C   0x1E7F             SUBS     R7,R7,#+1
   \   0000012E   0xD002             BEQ      ??f_mkdir_11
   \   00000130   0xE7EA             B        ??f_mkdir_12
   3678          			}
   3679          			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
   \                     ??f_mkdir_7: (+1)
   \   00000132   0x0028             MOVS     R0,R5
   \   00000134   0xD103             BNE      ??f_mkdir_14
   \                     ??f_mkdir_11: (+1)
   \   00000136   0xA802             ADD      R0,SP,#+8
   \   00000138   0x.... 0x....      BL       _Z12dir_registerP9FATFS_DIR
   \   0000013C   0x0005             MOVS     R5,R0
   3680          			if (res != FR_OK) {
   \                     ??f_mkdir_14: (+1)
   \   0000013E   0x0028             MOVS     R0,R5
   \   00000140   0xD004             BEQ      ??f_mkdir_15
   3681          				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
   \                     ??f_mkdir_4: (+1)
   \   00000142   0x9901             LDR      R1,[SP, #+4]
   \   00000144   0x9802             LDR      R0,[SP, #+8]
   \   00000146   0x.... 0x....      BL       _Z12remove_chainP5FATFSm
   \   0000014A   0xE019             B        ??f_mkdir_0
   3682          			} else {
   3683          				dir = dj.dir;
   \                     ??f_mkdir_15: (+1)
   \   0000014C   0x9C07             LDR      R4,[SP, #+28]
   3684          				dir[DIR_Attr] = AM_DIR;				/* Attribute */
   \   0000014E   0x2010             MOVS     R0,#+16
   \   00000150   0x72E0             STRB     R0,[R4, #+11]
   3685          				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
   \   00000152   0x9800             LDR      R0,[SP, #+0]
   \   00000154   0x75A0             STRB     R0,[R4, #+22]
   \   00000156   0x9800             LDR      R0,[SP, #+0]
   \   00000158   0x0400             LSLS     R0,R0,#+16
   \   0000015A   0x0E00             LSRS     R0,R0,#+24
   \   0000015C   0x75E0             STRB     R0,[R4, #+23]
   \   0000015E   0x9800             LDR      R0,[SP, #+0]
   \   00000160   0x0C00             LSRS     R0,R0,#+16
   \   00000162   0x7620             STRB     R0,[R4, #+24]
   \   00000164   0x9800             LDR      R0,[SP, #+0]
   \   00000166   0x0E00             LSRS     R0,R0,#+24
   \   00000168   0x7660             STRB     R0,[R4, #+25]
   3686          				st_clust(dir, dcl);					/* Table start cluster */
   \   0000016A   0x9901             LDR      R1,[SP, #+4]
   \   0000016C   0x0020             MOVS     R0,R4
   \   0000016E   0x.... 0x....      BL       _Z8st_clustPhm
   3687          				dj.fs->wflag = 1;
   \   00000172   0x2001             MOVS     R0,#+1
   \   00000174   0x9902             LDR      R1,[SP, #+8]
   \   00000176   0x7108             STRB     R0,[R1, #+4]
   3688          				res = sync_fs(dj.fs);
   \   00000178   0x9802             LDR      R0,[SP, #+8]
   \   0000017A   0x.... 0x....      BL       _Z7sync_fsP5FATFS
   \   0000017E   0x0005             MOVS     R5,R0
   3689          			}
   3690          		}
   3691          		FREE_BUF();
   3692          	}
   3693          
   3694          	LEAVE_FF(dj.fs, res);
   \                     ??f_mkdir_0: (+1)
   \   00000180   0x0028             MOVS     R0,R5
   \   00000182   0xB00F             ADD      SP,SP,#+60
   \   00000184   0xBDF0             POP      {R4-R7,PC}       ;; return
   3695          }
   3696          
   3697          
   3698          
   3699          
   3700          /*-----------------------------------------------------------------------*/
   3701          /* Change Attribute                                                      */
   3702          /*-----------------------------------------------------------------------*/
   3703          

   \                                 In section .text, align 2, keep-with-next
   3704          FRESULT f_chmod (
   3705          	const TCHAR* path,	/* Pointer to the file path */
   3706          	BYTE attr,			/* Attribute bits */
   3707          	BYTE mask			/* Attribute mask to change */
   3708          )
   3709          {
   \                     f_chmod: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
   3710          	FRESULT res;
   3711          	FATFS_DIR dj;
   3712          	BYTE *dir;
   3713          	DEFINE_NAMEBUF;
   3714          
   3715          
   3716          	res = find_volume(&dj.fs, &path, 1);	/* Get logical drive number */
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xA90C             ADD      R1,SP,#+48
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x.... 0x....      BL       _Z11find_volumePP5FATFSPPKch
   3717          	if (res == FR_OK) {
   \   00000012   0x0001             MOVS     R1,R0
   \   00000014   0xD120             BNE      ??f_chmod_0
   3718          		INIT_BUF(dj);
   \   00000016   0xA809             ADD      R0,SP,#+36
   \   00000018   0x9006             STR      R0,[SP, #+24]
   \   0000001A   0x....             LDR      R0,??DataTable30_1
   \   0000001C   0x9007             STR      R0,[SP, #+28]
   3719          		res = follow_path(&dj, path);		/* Follow the file path */
   \   0000001E   0x990C             LDR      R1,[SP, #+48]
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x.... 0x....      BL       _Z11follow_pathP9FATFS_DIRPKc
   3720          		FREE_BUF();
   3721          		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
   \   00000026   0x0001             MOVS     R1,R0
   \   00000028   0xD116             BNE      ??f_chmod_0
   \   0000002A   0x9806             LDR      R0,[SP, #+24]
   \   0000002C   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000002E   0x0680             LSLS     R0,R0,#+26
   \   00000030   0xD402             BMI      ??f_chmod_1
   3722          			res = FR_INVALID_NAME;
   3723          		if (res == FR_OK) {
   3724          			dir = dj.dir;
   \   00000032   0x9805             LDR      R0,[SP, #+20]
   3725          			if (!dir) {						/* Is it a root directory? */
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD101             BNE      ??f_chmod_2
   3726          				res = FR_INVALID_NAME;
   \                     ??f_chmod_1: (+1)
   \   00000038   0x2006             MOVS     R0,#+6
   \   0000003A   0xE00D             B        ??f_chmod_0
   3727          			} else {						/* File or sub directory */
   3728          				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
   \                     ??f_chmod_2: (+1)
   \   0000003C   0x0029             MOVS     R1,R5
   \   0000003E   0x2527             MOVS     R5,#+39
   \   00000040   0x400D             ANDS     R5,R5,R1
   3729          				dir[DIR_Attr] = (attr & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
   \   00000042   0x402C             ANDS     R4,R4,R5
   \   00000044   0x7AC1             LDRB     R1,[R0, #+11]
   \   00000046   0x43A9             BICS     R1,R1,R5
   \   00000048   0x4321             ORRS     R1,R1,R4
   \   0000004A   0x72C1             STRB     R1,[R0, #+11]
   3730          				dj.fs->wflag = 1;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x9900             LDR      R1,[SP, #+0]
   \   00000050   0x7108             STRB     R0,[R1, #+4]
   3731          				res = sync_fs(dj.fs);
   \   00000052   0x9800             LDR      R0,[SP, #+0]
   \   00000054   0x.... 0x....      BL       _Z7sync_fsP5FATFS
   3732          			}
   3733          		}
   3734          	}
   3735          
   3736          	LEAVE_FF(dj.fs, res);
   \                     ??f_chmod_0: (+1)
   \   00000058   0xB00D             ADD      SP,SP,#+52
   \   0000005A   0xBD30             POP      {R4,R5,PC}       ;; return
   3737          }
   3738          
   3739          
   3740          
   3741          
   3742          /*-----------------------------------------------------------------------*/
   3743          /* Rename File/Directory                                                 */
   3744          /*-----------------------------------------------------------------------*/
   3745          

   \                                 In section .text, align 2, keep-with-next
   3746          FRESULT f_rename (
   3747          	const TCHAR* path_old,	/* Pointer to the object to be renamed */
   3748          	const TCHAR* path_new	/* Pointer to the new name */
   3749          )
   3750          {
   \                     f_rename: (+1)
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB09B             SUB      SP,SP,#+108
   \   00000004   0x000C             MOVS     R4,R1
   3751          	FRESULT res;
   3752          	FATFS_DIR djo, djn;
   3753          	BYTE buf[21], *dir;
   3754          	DWORD dw;
   3755          	DEFINE_NAMEBUF;
   3756          
   3757          
   3758          	/* Get logical drive number of the source object */
   3759          	res = find_volume(&djo.fs, &path_old, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA91B             ADD      R1,SP,#+108
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       _Z11find_volumePP5FATFSPPKch
   3760          	if (res == FR_OK) {
   \   00000010   0x0001             MOVS     R1,R0
   \   00000012   0xD000             BEQ      .+4
   \   00000014   0xE09C             B        ??f_rename_0
   3761          		djn.fs = djo.fs;
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x9012             STR      R0,[SP, #+72]
   3762          		INIT_BUF(djo);
   \   0000001A   0xA809             ADD      R0,SP,#+36
   \   0000001C   0x9006             STR      R0,[SP, #+24]
   \   0000001E   0x....             LDR      R6,??DataTable32
   \   00000020   0x0030             MOVS     R0,R6
   \   00000022   0x3014             ADDS     R0,R0,#+20
   \   00000024   0x9007             STR      R0,[SP, #+28]
   3763          		res = follow_path(&djo, path_old);		/* Check old object */
   \   00000026   0x991B             LDR      R1,[SP, #+108]
   \   00000028   0x4668             MOV      R0,SP
   \   0000002A   0x.... 0x....      BL       _Z11follow_pathP9FATFS_DIRPKc
   3764          		if (_FS_RPATH && res == FR_OK && (djo.fn[NSFLAG] & NS_DOT))
   \   0000002E   0x0001             MOVS     R1,R0
   \   00000030   0xD000             BEQ      .+4
   \   00000032   0xE08D             B        ??f_rename_0
   \   00000034   0x2520             MOVS     R5,#+32
   \   00000036   0x9806             LDR      R0,[SP, #+24]
   \   00000038   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000003A   0x4228             TST      R0,R5
   \   0000003C   0xD001             BEQ      ??f_rename_1
   3765          			res = FR_INVALID_NAME;
   \   0000003E   0x2006             MOVS     R0,#+6
   \   00000040   0xE086             B        ??f_rename_0
   3766          #if _FS_LOCK
   3767          		if (res == FR_OK) res = chk_lock(&djo, 2);
   3768          #endif
   3769          		if (res == FR_OK) {						/* Old object is found */
   3770          			if (!djo.dir) {						/* Is root dir? */
   \                     ??f_rename_1: (+1)
   \   00000042   0x9905             LDR      R1,[SP, #+20]
   \   00000044   0x2900             CMP      R1,#+0
   \   00000046   0xD101             BNE      ??f_rename_2
   3771          				res = FR_NO_FILE;
   \   00000048   0x2004             MOVS     R0,#+4
   \   0000004A   0xE081             B        ??f_rename_0
   3772          			} else {
   3773          				mem_cpy(buf, djo.dir + DIR_Attr, 21);	/* Save information about object except name */
   \                     ??f_rename_2: (+1)
   \   0000004C   0xA80C             ADD      R0,SP,#+48
   \   0000004E   0x310B             ADDS     R1,R1,#+11
   \   00000050   0x2207             MOVS     R2,#+7
   \                     ??f_rename_3: (+1)
   \   00000052   0x780B             LDRB     R3,[R1, #+0]
   \   00000054   0x7003             STRB     R3,[R0, #+0]
   \   00000056   0x784B             LDRB     R3,[R1, #+1]
   \   00000058   0x7043             STRB     R3,[R0, #+1]
   \   0000005A   0x788B             LDRB     R3,[R1, #+2]
   \   0000005C   0x7083             STRB     R3,[R0, #+2]
   \   0000005E   0x1CC9             ADDS     R1,R1,#+3
   \   00000060   0x1CC0             ADDS     R0,R0,#+3
   \   00000062   0x1E52             SUBS     R2,R2,#+1
   \   00000064   0xD1F5             BNE      ??f_rename_3
   3774          				mem_cpy(&djn, &djo, sizeof (FATFS_DIR));		/* Duplicate the directory object */
   \   00000066   0x2224             MOVS     R2,#+36
   \   00000068   0x4669             MOV      R1,SP
   \   0000006A   0xA812             ADD      R0,SP,#+72
   \   0000006C   0x.... 0x....      BL       __aeabi_memcpy4
   3775          				if (get_ldnumber(&path_new) >= 0)		/* Snip drive number off and ignore it */
   \   00000070   0x2C00             CMP      R4,#+0
   \   00000072   0xD01F             BEQ      ??f_rename_4
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0xE000             B        ??f_rename_5
   \                     ??f_rename_6: (+1)
   \   00000078   0x1C40             ADDS     R0,R0,#+1
   \                     ??f_rename_5: (+1)
   \   0000007A   0x7801             LDRB     R1,[R0, #+0]
   \   0000007C   0x2920             CMP      R1,#+32
   \   0000007E   0xD301             BCC      ??f_rename_7
   \   00000080   0x293A             CMP      R1,#+58
   \   00000082   0xD1F9             BNE      ??f_rename_6
   \                     ??f_rename_7: (+1)
   \   00000084   0x293A             CMP      R1,#+58
   \   00000086   0xD10A             BNE      ??f_rename_8
   \   00000088   0x7821             LDRB     R1,[R4, #+0]
   \   0000008A   0x3930             SUBS     R1,R1,#+48
   \   0000008C   0x1C62             ADDS     R2,R4,#+1
   \   0000008E   0x290A             CMP      R1,#+10
   \   00000090   0xD210             BCS      ??f_rename_4
   \   00000092   0x4282             CMP      R2,R0
   \   00000094   0xD10E             BNE      ??f_rename_4
   \   00000096   0x2904             CMP      R1,#+4
   \   00000098   0xD20C             BCS      ??f_rename_4
   \   0000009A   0x1C44             ADDS     R4,R0,#+1
   \   0000009C   0xE000             B        ??f_rename_9
   \                     ??f_rename_8: (+1)
   \   0000009E   0x7831             LDRB     R1,[R6, #+0]
   \                     ??f_rename_9: (+1)
   \   000000A0   0x2900             CMP      R1,#+0
   \   000000A2   0xD407             BMI      ??f_rename_4
   3776          					res = follow_path(&djn, path_new);	/* and make sure if new object name is not conflicting */
   \   000000A4   0x0021             MOVS     R1,R4
   \   000000A6   0xA812             ADD      R0,SP,#+72
   \   000000A8   0x.... 0x....      BL       _Z11follow_pathP9FATFS_DIRPKc
   3777          				else
   3778          					res = FR_INVALID_DRIVE;
   3779          				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
   \   000000AC   0x0001             MOVS     R1,R0
   \   000000AE   0xD103             BNE      ??f_rename_10
   \   000000B0   0x2008             MOVS     R0,#+8
   \   000000B2   0xE04D             B        ??f_rename_0
   \                     ??f_rename_4: (+1)
   \   000000B4   0x200B             MOVS     R0,#+11
   \   000000B6   0xE04B             B        ??f_rename_0
   3780          				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
   \                     ??f_rename_10: (+1)
   \   000000B8   0x2804             CMP      R0,#+4
   \   000000BA   0xD149             BNE      ??f_rename_0
   3781          					res = dir_register(&djn);			/* Register the new entry */
   \   000000BC   0xA812             ADD      R0,SP,#+72
   \   000000BE   0x.... 0x....      BL       _Z12dir_registerP9FATFS_DIR
   3782          					if (res == FR_OK) {
   \   000000C2   0x0001             MOVS     R1,R0
   \   000000C4   0xD144             BNE      ??f_rename_0
   3783          /* Start of critical section where any interruption can cause a cross-link */
   3784          						dir = djn.dir;					/* Copy information about object except name */
   \   000000C6   0x9A17             LDR      R2,[SP, #+92]
   3785          						mem_cpy(dir + 13, buf + 2, 19);
   \   000000C8   0x0013             MOVS     R3,R2
   \   000000CA   0xA80C             ADD      R0,SP,#+48
   \   000000CC   0x7881             LDRB     R1,[R0, #+2]
   \   000000CE   0x7359             STRB     R1,[R3, #+13]
   \   000000D0   0xA90C             ADD      R1,SP,#+48
   \   000000D2   0x1CC9             ADDS     R1,R1,#+3
   \   000000D4   0x330E             ADDS     R3,R3,#+14
   \   000000D6   0x2406             MOVS     R4,#+6
   \                     ??f_rename_11: (+1)
   \   000000D8   0x780E             LDRB     R6,[R1, #+0]
   \   000000DA   0x701E             STRB     R6,[R3, #+0]
   \   000000DC   0x784E             LDRB     R6,[R1, #+1]
   \   000000DE   0x705E             STRB     R6,[R3, #+1]
   \   000000E0   0x788E             LDRB     R6,[R1, #+2]
   \   000000E2   0x709E             STRB     R6,[R3, #+2]
   \   000000E4   0x1CC9             ADDS     R1,R1,#+3
   \   000000E6   0x1CDB             ADDS     R3,R3,#+3
   \   000000E8   0x1E64             SUBS     R4,R4,#+1
   \   000000EA   0xD1F5             BNE      ??f_rename_11
   3786          						dir[DIR_Attr] = buf[0] | AM_ARC;
   \   000000EC   0x7800             LDRB     R0,[R0, #+0]
   \   000000EE   0x4305             ORRS     R5,R5,R0
   \   000000F0   0x72D5             STRB     R5,[R2, #+11]
   3787          						djo.fs->wflag = 1;
   \   000000F2   0x2401             MOVS     R4,#+1
   \   000000F4   0x9900             LDR      R1,[SP, #+0]
   \   000000F6   0x710C             STRB     R4,[R1, #+4]
   3788          						if ((dir[DIR_Attr] & AM_DIR) && djo.sclust != djn.sclust) {	/* Update .. entry in the sub-directory if needed */
   \   000000F8   0x7AD0             LDRB     R0,[R2, #+11]
   \   000000FA   0x06C0             LSLS     R0,R0,#+27
   \   000000FC   0xD520             BPL      ??f_rename_12
   \   000000FE   0x9802             LDR      R0,[SP, #+8]
   \   00000100   0x9914             LDR      R1,[SP, #+80]
   \   00000102   0x4288             CMP      R0,R1
   \   00000104   0xD01C             BEQ      ??f_rename_12
   3789          							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
   \   00000106   0x0011             MOVS     R1,R2
   \   00000108   0x9800             LDR      R0,[SP, #+0]
   \   0000010A   0x.... 0x....      BL       _Z8ld_clustP5FATFSPKh
   \   0000010E   0x0001             MOVS     R1,R0
   \   00000110   0x9800             LDR      R0,[SP, #+0]
   \   00000112   0x.... 0x....      BL       _Z10clust2sectP5FATFSm
   \   00000116   0x0001             MOVS     R1,R0
   3790          							if (!dw) {
   \   00000118   0xD101             BNE      ??f_rename_13
   3791          								res = FR_INT_ERR;
   \   0000011A   0x2002             MOVS     R0,#+2
   \   0000011C   0xE018             B        ??f_rename_0
   3792          							} else {
   3793          								res = move_window(djo.fs, dw);
   \                     ??f_rename_13: (+1)
   \   0000011E   0x9800             LDR      R0,[SP, #+0]
   \   00000120   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   3794          								dir = djo.fs->win + SZ_DIRE * 1;	/* Ptr to .. entry */
   \   00000124   0x9900             LDR      R1,[SP, #+0]
   \   00000126   0x6B4A             LDR      R2,[R1, #+52]
   \   00000128   0x3220             ADDS     R2,R2,#+32
   3795          								if (res == FR_OK && dir[1] == '.') {
   \   0000012A   0x0001             MOVS     R1,R0
   \   0000012C   0xD110             BNE      ??f_rename_0
   \   0000012E   0x7850             LDRB     R0,[R2, #+1]
   \   00000130   0x282E             CMP      R0,#+46
   \   00000132   0xD105             BNE      ??f_rename_12
   3796          									st_clust(dir, djn.sclust);
   \   00000134   0x9914             LDR      R1,[SP, #+80]
   \   00000136   0x0010             MOVS     R0,R2
   \   00000138   0x.... 0x....      BL       _Z8st_clustPhm
   3797          									djo.fs->wflag = 1;
   \   0000013C   0x9800             LDR      R0,[SP, #+0]
   \   0000013E   0x7104             STRB     R4,[R0, #+4]
   3798          								}
   3799          							}
   3800          						}
   3801          						if (res == FR_OK) {
   3802          							res = dir_remove(&djo);		/* Remove old entry */
   \                     ??f_rename_12: (+1)
   \   00000140   0x4668             MOV      R0,SP
   \   00000142   0x.... 0x....      BL       _Z10dir_removeP9FATFS_DIR
   3803          							if (res == FR_OK)
   \   00000146   0x0001             MOVS     R1,R0
   \   00000148   0xD102             BNE      ??f_rename_0
   3804          								res = sync_fs(djo.fs);
   \   0000014A   0x9800             LDR      R0,[SP, #+0]
   \   0000014C   0x.... 0x....      BL       _Z7sync_fsP5FATFS
   3805          						}
   3806          /* End of critical section */
   3807          					}
   3808          				}
   3809          			}
   3810          		}
   3811          		FREE_BUF();
   3812          	}
   3813          
   3814          	LEAVE_FF(djo.fs, res);
   \                     ??f_rename_0: (+1)
   \   00000150   0xB01C             ADD      SP,SP,#+112
   \   00000152   0xBD70             POP      {R4-R6,PC}       ;; return
   3815          }
   3816          
   3817          
   3818          
   3819          
   3820          /*-----------------------------------------------------------------------*/
   3821          /* Change Timestamp                                                      */
   3822          /*-----------------------------------------------------------------------*/
   3823          

   \                                 In section .text, align 2, keep-with-next
   3824          FRESULT f_utime (
   3825          	const TCHAR* path,	/* Pointer to the file/directory name */
   3826          	const FILINFO* fno	/* Pointer to the time stamp to be set */
   3827          )
   3828          {
   \                     f_utime: (+1)
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x000C             MOVS     R4,R1
   3829          	FRESULT res;
   3830          	FATFS_DIR dj;
   3831          	BYTE *dir;
   3832          	DEFINE_NAMEBUF;
   3833          
   3834          
   3835          	/* Get logical drive number */
   3836          	res = find_volume(&dj.fs, &path, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA90D             ADD      R1,SP,#+52
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       _Z11find_volumePP5FATFSPPKch
   3837          	if (res == FR_OK) {
   \   00000010   0x0001             MOVS     R1,R0
   \   00000012   0xD122             BNE      ??f_utime_0
   3838          		INIT_BUF(dj);
   \   00000014   0xA809             ADD      R0,SP,#+36
   \   00000016   0x9006             STR      R0,[SP, #+24]
   \   00000018   0x....             LDR      R0,??DataTable32_1
   \   0000001A   0x9007             STR      R0,[SP, #+28]
   3839          		res = follow_path(&dj, path);	/* Follow the file path */
   \   0000001C   0x990D             LDR      R1,[SP, #+52]
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0x.... 0x....      BL       _Z11follow_pathP9FATFS_DIRPKc
   3840          		FREE_BUF();
   3841          		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
   \   00000024   0x0001             MOVS     R1,R0
   \   00000026   0xD118             BNE      ??f_utime_0
   \   00000028   0x9806             LDR      R0,[SP, #+24]
   \   0000002A   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000002C   0x0680             LSLS     R0,R0,#+26
   \   0000002E   0xD402             BMI      ??f_utime_1
   3842          			res = FR_INVALID_NAME;
   3843          		if (res == FR_OK) {
   3844          			dir = dj.dir;
   \   00000030   0x9805             LDR      R0,[SP, #+20]
   3845          			if (!dir) {					/* Root directory */
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD101             BNE      ??f_utime_2
   3846          				res = FR_INVALID_NAME;
   \                     ??f_utime_1: (+1)
   \   00000036   0x2006             MOVS     R0,#+6
   \   00000038   0xE00F             B        ??f_utime_0
   3847          			} else {					/* File or sub-directory */
   3848          				ST_WORD(dir + DIR_WrtTime, fno->ftime);
   \                     ??f_utime_2: (+1)
   \   0000003A   0x88E1             LDRH     R1,[R4, #+6]
   \   0000003C   0x7581             STRB     R1,[R0, #+22]
   \   0000003E   0x88E1             LDRH     R1,[R4, #+6]
   \   00000040   0x0A09             LSRS     R1,R1,#+8
   \   00000042   0x75C1             STRB     R1,[R0, #+23]
   3849          				ST_WORD(dir + DIR_WrtDate, fno->fdate);
   \   00000044   0x88A1             LDRH     R1,[R4, #+4]
   \   00000046   0x7601             STRB     R1,[R0, #+24]
   \   00000048   0x88A1             LDRH     R1,[R4, #+4]
   \   0000004A   0x0A09             LSRS     R1,R1,#+8
   \   0000004C   0x7641             STRB     R1,[R0, #+25]
   3850          				dj.fs->wflag = 1;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x9900             LDR      R1,[SP, #+0]
   \   00000052   0x7108             STRB     R0,[R1, #+4]
   3851          				res = sync_fs(dj.fs);
   \   00000054   0x9800             LDR      R0,[SP, #+0]
   \   00000056   0x.... 0x....      BL       _Z7sync_fsP5FATFS
   3852          			}
   3853          		}
   3854          	}
   3855          
   3856          	LEAVE_FF(dj.fs, res);
   \                     ??f_utime_0: (+1)
   \   0000005A   0xB00E             ADD      SP,SP,#+56
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
   3857          }
   3858          
   3859          #endif /* !_FS_READONLY */
   3860          #endif /* _FS_MINIMIZE == 0 */
   3861          #endif /* _FS_MINIMIZE <= 1 */
   3862          #endif /* _FS_MINIMIZE <= 2 */
   3863          
   3864          
   3865          
   3866          
   3867          #if _USE_LABEL
   3868          /*-----------------------------------------------------------------------*/
   3869          /* Get volume label                                                      */
   3870          /*-----------------------------------------------------------------------*/
   3871          
   3872          FRESULT f_getlabel (
   3873          	const TCHAR* path,	/* Path name of the logical drive number */
   3874          	TCHAR* label,		/* Pointer to a buffer to return the volume label */
   3875          	DWORD* vsn			/* Pointer to a variable to return the volume serial number */
   3876          )
   3877          {
   3878          	FRESULT res;
   3879          	FATFS_DIR dj;
   3880          	UINT i, j;
   3881          #if _USE_LFN && _LFN_UNICODE
   3882          	WCHAR w;
   3883          #endif
   3884          
   3885          
   3886          	/* Get logical drive number */
   3887          	res = find_volume(&dj.fs, &path, 0);
   3888          
   3889          	/* Get volume label */
   3890          	if (res == FR_OK && label) {
   3891          		dj.sclust = 0;					/* Open root directory */
   3892          		res = dir_sdi(&dj, 0);
   3893          		if (res == FR_OK) {
   3894          			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
   3895          			if (res == FR_OK) {			/* A volume label is exist */
   3896          #if _USE_LFN && _LFN_UNICODE
   3897          				i = j = 0;
   3898          				do {
   3899          					w = (i < 11) ? dj.dir[i++] : ' ';
   3900          					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
   3901          						w = w << 8 | dj.dir[i++];
   3902          					label[j++] = ff_convert(w, 1);	/* OEM -> Unicode */
   3903          				} while (j < 11);
   3904          #else
   3905          				mem_cpy(label, dj.dir, 11);
   3906          #endif
   3907          				j = 11;
   3908          				do {
   3909          					label[j] = 0;
   3910          					if (!j) break;
   3911          				} while (label[--j] == ' ');
   3912          			}
   3913          			if (res == FR_NO_FILE) {	/* No label, return nul string */
   3914          				label[0] = 0;
   3915          				res = FR_OK;
   3916          			}
   3917          		}
   3918          	}
   3919          
   3920          	/* Get volume serial number */
   3921          	if (res == FR_OK && vsn) {
   3922          		res = move_window(dj.fs, dj.fs->volbase);
   3923          		if (res == FR_OK) {
   3924          			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
   3925          			*vsn = LD_DWORD(&dj.fs->win[i]);
   3926          		}
   3927          	}
   3928          
   3929          	LEAVE_FF(dj.fs, res);
   3930          }
   3931          
   3932          
   3933          
   3934          #if !_FS_READONLY
   3935          /*-----------------------------------------------------------------------*/
   3936          /* Set volume label                                                      */
   3937          /*-----------------------------------------------------------------------*/
   3938          
   3939          FRESULT f_setlabel (
   3940          	const TCHAR* label	/* Pointer to the volume label to set */
   3941          )
   3942          {
   3943          	FRESULT res;
   3944          	FATFS_DIR dj;
   3945          	BYTE vn[11];
   3946          	UINT i, j, sl;
   3947          	WCHAR w;
   3948          	DWORD tm;
   3949          
   3950          
   3951          	/* Get logical drive number */
   3952          	res = find_volume(&dj.fs, &label, 1);
   3953          	if (res) LEAVE_FF(dj.fs, res);
   3954          
   3955          	/* Create a volume label in directory form */
   3956          	vn[0] = 0;
   3957          	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
   3958          	for ( ; sl && label[sl - 1] == ' '; sl--) ;	/* Remove trailing spaces */
   3959          	if (sl) {	/* Create volume label in directory form */
   3960          		i = j = 0;
   3961          		do {
   3962          #if _USE_LFN && _LFN_UNICODE
   3963          			w = ff_convert(ff_wtoupper(label[i++]), 0);
   3964          #else
   3965          			w = (BYTE)label[i++];
   3966          			if (IsDBCS1(w))
   3967          				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
   3968          #if _USE_LFN
   3969          			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
   3970          #else
   3971          			if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
   3972          #ifdef _EXCVT
   3973          			if (w >= 0x80) w = ExCvt[w - 0x80];	/* To upper extended characters (SBCS cfg) */
   3974          #else
   3975          			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
   3976          #endif
   3977          #endif
   3978          #endif
   3979          			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
   3980          				LEAVE_FF(dj.fs, FR_INVALID_NAME);
   3981          			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
   3982          			vn[j++] = (BYTE)w;
   3983          		} while (i < sl);
   3984          		while (j < 11) vn[j++] = ' ';	/* Fill remaining name field */
   3985          		if (vn[0] == DDEM) LEAVE_FF(dj.fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
   3986          	}
   3987          
   3988          	/* Set volume label */
   3989          	dj.sclust = 0;					/* Open root directory */
   3990          	res = dir_sdi(&dj, 0);
   3991          	if (res == FR_OK) {
   3992          		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
   3993          		if (res == FR_OK) {			/* A volume label is found */
   3994          			if (vn[0]) {
   3995          				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
   3996          				tm = GET_FATTIME();
   3997          				ST_DWORD(dj.dir + DIR_WrtTime, tm);
   3998          			} else {
   3999          				dj.dir[0] = DDEM;			/* Remove the volume label */
   4000          			}
   4001          			dj.fs->wflag = 1;
   4002          			res = sync_fs(dj.fs);
   4003          		} else {					/* No volume label is found or error */
   4004          			if (res == FR_NO_FILE) {
   4005          				res = FR_OK;
   4006          				if (vn[0]) {				/* Create volume label as new */
   4007          					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
   4008          					if (res == FR_OK) {
   4009          						mem_set(dj.dir, 0, SZ_DIRE);	/* Set volume label */
   4010          						mem_cpy(dj.dir, vn, 11);
   4011          						dj.dir[DIR_Attr] = AM_VOL;
   4012          						tm = GET_FATTIME();
   4013          						ST_DWORD(dj.dir + DIR_WrtTime, tm);
   4014          						dj.fs->wflag = 1;
   4015          						res = sync_fs(dj.fs);
   4016          					}
   4017          				}
   4018          			}
   4019          		}
   4020          	}
   4021          
   4022          	LEAVE_FF(dj.fs, res);
   4023          }
   4024          
   4025          #endif /* !_FS_READONLY */
   4026          #endif /* _USE_LABEL */
   4027          
   4028          
   4029          
   4030          /*-----------------------------------------------------------------------*/
   4031          /* Forward data to the stream directly (available on only tiny cfg)      */
   4032          /*-----------------------------------------------------------------------*/
   4033          #if _USE_FORWARD && _FS_TINY
   4034          
   4035          FRESULT f_forward (
   4036          	FIL* fp, 						/* Pointer to the file object */
   4037          	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
   4038          	UINT btf,						/* Number of bytes to forward */
   4039          	UINT* bf						/* Pointer to number of bytes forwarded */
   4040          )
   4041          {
   4042          	FRESULT res;
   4043          	DWORD remain, clst, sect;
   4044          	UINT rcnt;
   4045          	BYTE csect;
   4046          
   4047          
   4048          	*bf = 0;	/* Clear transfer byte counter */
   4049          
   4050          	res = validate(fp);								/* Check validity of the object */
   4051          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   4052          	if (fp->err)									/* Check error */
   4053          		LEAVE_FF(fp->fs, (FRESULT)fp->err);
   4054          	if (!(fp->flag & FA_READ))						/* Check access mode */
   4055          		LEAVE_FF(fp->fs, FR_DENIED);
   4056          
   4057          	remain = fp->fsize - fp->fptr;
   4058          	if (btf > remain) btf = (UINT)remain;			/* Truncate btf by remaining bytes */
   4059          
   4060          	for ( ;  btf && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
   4061          		fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {
   4062          		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   4063          		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
   4064          			if (!csect) {							/* On the cluster boundary? */
   4065          				clst = (fp->fptr == 0) ?			/* On the top of the file? */
   4066          					fp->sclust : get_fat(fp->fs, fp->clust);
   4067          				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
   4068          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   4069          				fp->clust = clst;					/* Update current cluster */
   4070          			}
   4071          		}
   4072          		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
   4073          		if (!sect) ABORT(fp->fs, FR_INT_ERR);
   4074          		sect += csect;
   4075          		if (move_window(fp->fs, sect) != FR_OK)		/* Move sector window */
   4076          			ABORT(fp->fs, FR_DISK_ERR);
   4077          		fp->dsect = sect;
   4078          		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
   4079          		if (rcnt > btf) rcnt = btf;
   4080          		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
   4081          		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
   4082          	}
   4083          
   4084          	LEAVE_FF(fp->fs, FR_OK);
   4085          }
   4086          #endif /* _USE_FORWARD */
   4087          
   4088          
   4089          
   4090          #if _USE_MKFS && !_FS_READONLY
   4091          /*-----------------------------------------------------------------------*/
   4092          /* Create file system on the logical drive                               */
   4093          /*-----------------------------------------------------------------------*/
   4094          #define N_ROOTDIR	512		/* Number of root directory entries for FAT12/16 */
   4095          #define N_FATS		1		/* Number of FATs (1 or 2) */
   4096          
   4097          

   \                                 In section .text, align 4, keep-with-next
   4098          FRESULT f_mkfs (
   4099          	const TCHAR* path,	/* Logical drive number */
   4100          	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
   4101          	UINT au				/* Size of allocation unit in unit of byte or sector */
   4102          )
   4103          {
   \                     f_mkfs: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   \   00000002   0xB08E             SUB      SP,SP,#+56
   \   00000004   0x000C             MOVS     R4,R1
   4104          	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
   4105          	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
   4106          	int vol;
   4107          	BYTE fmt, md, sys, *tbl, pdrv, part;
   4108          	DWORD n_clst, vs, n, wsect;
   4109          	UINT i;
   4110          	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
   4111          	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
   4112          	FATFS *fs;
   4113          	DSTATUS stat;
   4114          #if _USE_TRIM
   4115          	DWORD eb[2];
   4116          #endif
   4117          
   4118          
   4119          	/* Check mounted drive and clear work area */
   4120          	if (sfd > 1) return FR_INVALID_PARAMETER;
   \   00000006   0x2C02             CMP      R4,#+2
   \   00000008   0xDB01             BLT      ??f_mkfs_0
   \   0000000A   0x2013             MOVS     R0,#+19
   \   0000000C   0xE372             B        ??f_mkfs_1
   4121          	vol = get_ldnumber(&path);
   \                     ??f_mkfs_0: (+1)
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD017             BEQ      ??f_mkfs_2
   \   00000012   0x0002             MOVS     R2,R0
   \   00000014   0xE000             B        ??f_mkfs_3
   \                     ??f_mkfs_4: (+1)
   \   00000016   0x1C52             ADDS     R2,R2,#+1
   \                     ??f_mkfs_3: (+1)
   \   00000018   0x7811             LDRB     R1,[R2, #+0]
   \   0000001A   0x2920             CMP      R1,#+32
   \   0000001C   0xD301             BCC      ??f_mkfs_5
   \   0000001E   0x293A             CMP      R1,#+58
   \   00000020   0xD1F9             BNE      ??f_mkfs_4
   \                     ??f_mkfs_5: (+1)
   \   00000022   0x293A             CMP      R1,#+58
   \   00000024   0xD109             BNE      ??f_mkfs_6
   \   00000026   0x7801             LDRB     R1,[R0, #+0]
   \   00000028   0x3930             SUBS     R1,R1,#+48
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0x290A             CMP      R1,#+10
   \   0000002E   0xD208             BCS      ??f_mkfs_2
   \   00000030   0x4290             CMP      R0,R2
   \   00000032   0xD106             BNE      ??f_mkfs_2
   \   00000034   0x2904             CMP      R1,#+4
   \   00000036   0xD204             BCS      ??f_mkfs_2
   \   00000038   0xE001             B        ??f_mkfs_7
   \                     ??f_mkfs_6: (+1)
   \   0000003A   0x488A             LDR      R0,??f_mkfs_8
   \   0000003C   0x7801             LDRB     R1,[R0, #+0]
   4122          	if (vol < 0) return FR_INVALID_DRIVE;
   \                     ??f_mkfs_7: (+1)
   \   0000003E   0x2900             CMP      R1,#+0
   \   00000040   0xD501             BPL      ??f_mkfs_9
   \                     ??f_mkfs_2: (+1)
   \   00000042   0x200B             MOVS     R0,#+11
   \   00000044   0xE356             B        ??f_mkfs_1
   4123          	fs = FatFs[vol];
   \                     ??f_mkfs_9: (+1)
   \   00000046   0x4887             LDR      R0,??f_mkfs_8
   \   00000048   0x008A             LSLS     R2,R1,#+2
   \   0000004A   0x1880             ADDS     R0,R0,R2
   \   0000004C   0x6840             LDR      R0,[R0, #+4]
   \   0000004E   0x9002             STR      R0,[SP, #+8]
   4124          	if (!fs) return FR_NOT_ENABLED;
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD101             BNE      ??f_mkfs_10
   \   00000054   0x200C             MOVS     R0,#+12
   \   00000056   0xE34D             B        ??f_mkfs_1
   \                     ??f_mkfs_10: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x9A02             LDR      R2,[SP, #+8]
   \   0000005C   0x7010             STRB     R0,[R2, #+0]
   4125          	fs->fs_type = 0;
   4126          	pdrv = LD2PD(vol);	/* Physical drive */
   \   0000005E   0x4668             MOV      R0,SP
   \   00000060   0x7401             STRB     R1,[R0, #+16]
   4127          	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/
   4128          
   4129          	/* Get disk statics */
   4130          	stat = disk_initialize(pdrv);
   \   00000062   0x7C00             LDRB     R0,[R0, #+16]
   \   00000064   0x.... 0x....      BL       disk_initialize
   4131          	if (stat & STA_NOINIT) return FR_NOT_READY;
   \   00000068   0x07C1             LSLS     R1,R0,#+31
   \   0000006A   0xD501             BPL      ??f_mkfs_11
   \   0000006C   0x2003             MOVS     R0,#+3
   \   0000006E   0xE341             B        ??f_mkfs_1
   4132          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   \                     ??f_mkfs_11: (+1)
   \   00000070   0x2704             MOVS     R7,#+4
   \   00000072   0x4238             TST      R0,R7
   \   00000074   0xD001             BEQ      ??f_mkfs_12
   \   00000076   0x200A             MOVS     R0,#+10
   \   00000078   0xE33C             B        ??f_mkfs_1
   4133          #if _MAX_SS != _MIN_SS		/* Get disk sector size */
   4134          	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS || SS(fs) < _MIN_SS)
   \                     ??f_mkfs_12: (+1)
   \   0000007A   0x9A02             LDR      R2,[SP, #+8]
   \   0000007C   0x320A             ADDS     R2,R2,#+10
   \   0000007E   0x2102             MOVS     R1,#+2
   \   00000080   0x4668             MOV      R0,SP
   \   00000082   0x7C00             LDRB     R0,[R0, #+16]
   \   00000084   0x.... 0x....      BL       disk_ioctl
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD000             BEQ      .+4
   \   0000008C   0xE2B7             B        ??f_mkfs_13
   \   0000008E   0x9802             LDR      R0,[SP, #+8]
   \   00000090   0x8940             LDRH     R0,[R0, #+10]
   \   00000092   0x4975             LDR      R1,??f_mkfs_8+0x4  ;; 0xfffffe00
   \   00000094   0x1841             ADDS     R1,R0,R1
   \   00000096   0x4A75             LDR      R2,??f_mkfs_8+0x8  ;; 0xe01
   \   00000098   0x4291             CMP      R1,R2
   \   0000009A   0xD300             BCC      .+4
   \   0000009C   0xE2AF             B        ??f_mkfs_13
   4135          		return FR_DISK_ERR;
   4136          #endif
   4137          #if _FS_HEAPBUF
   4138          	if (!fs->win) {
   \   0000009E   0x9902             LDR      R1,[SP, #+8]
   \   000000A0   0x6B49             LDR      R1,[R1, #+52]
   \   000000A2   0x2900             CMP      R1,#+0
   \   000000A4   0xD107             BNE      ??f_mkfs_14
   4139          		fs->win = (BYTE*)ff_memalloc(SS(fs));	/* Allocate buffer to back window if necessary */
   \   000000A6   0x.... 0x....      BL       ff_memalloc
   \   000000AA   0x9902             LDR      R1,[SP, #+8]
   \   000000AC   0x6348             STR      R0,[R1, #+52]
   4140          		if (!fs->win)
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD101             BNE      ??f_mkfs_14
   4141          			return FR_NOT_ENOUGH_CORE;
   \   000000B2   0x2011             MOVS     R0,#+17
   \   000000B4   0xE31E             B        ??f_mkfs_1
   4142          	}
   4143          #endif
   4144          	if (_MULTI_PARTITION && part) {
   4145          		/* Get partition information from partition table in the MBR */
   4146          		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   4147          		if (LD_WORD(fs->win + BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
   4148          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   4149          		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
   4150          		b_vol = LD_DWORD(tbl + 8);	/* Volume start sector */
   4151          		n_vol = LD_DWORD(tbl + 12);	/* Volume size */
   4152          	} else {
   4153          		/* Create a partition in this function */
   4154          		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < ((sfd) ? 64 : 128))
   \                     ??f_mkfs_14: (+1)
   \   000000B6   0xAA01             ADD      R2,SP,#+4
   \   000000B8   0x2101             MOVS     R1,#+1
   \   000000BA   0x4668             MOV      R0,SP
   \   000000BC   0x7C00             LDRB     R0,[R0, #+16]
   \   000000BE   0x.... 0x....      BL       disk_ioctl
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD000             BEQ      .+4
   \   000000C6   0xE29A             B        ??f_mkfs_13
   \   000000C8   0x0020             MOVS     R0,R4
   \   000000CA   0xD001             BEQ      ??f_mkfs_15
   \   000000CC   0x2040             MOVS     R0,#+64
   \   000000CE   0xE000             B        ??f_mkfs_16
   \                     ??f_mkfs_15: (+1)
   \   000000D0   0x2080             MOVS     R0,#+128
   \                     ??f_mkfs_16: (+1)
   \   000000D2   0x9901             LDR      R1,[SP, #+4]
   \   000000D4   0x4281             CMP      R1,R0
   \   000000D6   0xD200             BCS      .+4
   \   000000D8   0xE291             B        ??f_mkfs_13
   4155          			return FR_DISK_ERR;
   4156          		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0xD001             BEQ      ??f_mkfs_17
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xE000             B        ??f_mkfs_18
   \                     ??f_mkfs_17: (+1)
   \   000000E2   0x203F             MOVS     R0,#+63
   \                     ??f_mkfs_18: (+1)
   \   000000E4   0x9006             STR      R0,[SP, #+24]
   4157          		n_vol -= b_vol;				/* Volume size */
   \   000000E6   0x4608             MOV      R0,R1
   \   000000E8   0x9906             LDR      R1,[SP, #+24]
   \   000000EA   0x1A40             SUBS     R0,R0,R1
   \   000000EC   0x9001             STR      R0,[SP, #+4]
   4158          	}
   4159          
   4160          	if (au & (au - 1)) au = 0;
   \   000000EE   0x980E             LDR      R0,[SP, #+56]
   \   000000F0   0x1E41             SUBS     R1,R0,#+1
   \   000000F2   0x4001             ANDS     R1,R1,R0
   \   000000F4   0xD102             BNE      ??f_mkfs_19
   4161          	if (!au) {						/* AU auto selection */
   \   000000F6   0x980E             LDR      R0,[SP, #+56]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD116             BNE      ??f_mkfs_20
   4162          		vs = n_vol / (2000 / (SS(fs) / 512));
   \                     ??f_mkfs_19: (+1)
   \   000000FC   0x20FA             MOVS     R0,#+250
   \   000000FE   0x00C0             LSLS     R0,R0,#+3        ;; #+2000
   \   00000100   0x9902             LDR      R1,[SP, #+8]
   \   00000102   0x8949             LDRH     R1,[R1, #+10]
   \   00000104   0x0A49             LSRS     R1,R1,#+9
   \   00000106   0x.... 0x....      BL       __aeabi_idiv
   \   0000010A   0x0001             MOVS     R1,R0
   \   0000010C   0x9801             LDR      R0,[SP, #+4]
   \   0000010E   0x.... 0x....      BL       __aeabi_uidiv
   4163          		for (i = 0; vs < vst[i]; i++) ;
   \   00000112   0x2500             MOVS     R5,#+0
   \   00000114   0x4956             LDR      R1,??f_mkfs_8+0xC
   \   00000116   0xE001             B        ??f_mkfs_21
   \                     ??f_mkfs_22: (+1)
   \   00000118   0x1C6D             ADDS     R5,R5,#+1
   \   0000011A   0x1C89             ADDS     R1,R1,#+2
   \                     ??f_mkfs_21: (+1)
   \   0000011C   0x880A             LDRH     R2,[R1, #+0]
   \   0000011E   0x4290             CMP      R0,R2
   \   00000120   0xD3FA             BCC      ??f_mkfs_22
   4164          		au = cst[i];
   \   00000122   0x4854             LDR      R0,??f_mkfs_8+0x10
   \   00000124   0x0069             LSLS     R1,R5,#+1
   \   00000126   0x5A40             LDRH     R0,[R0, R1]
   \   00000128   0x900E             STR      R0,[SP, #+56]
   4165          	}
   4166          	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
   \                     ??f_mkfs_20: (+1)
   \   0000012A   0x980E             LDR      R0,[SP, #+56]
   \   0000012C   0x01F9             LSLS     R1,R7,#+7
   \   0000012E   0x4288             CMP      R0,R1
   \   00000130   0xD304             BCC      ??f_mkfs_23
   \   00000132   0x9902             LDR      R1,[SP, #+8]
   \   00000134   0x8949             LDRH     R1,[R1, #+10]
   \   00000136   0x.... 0x....      BL       __aeabi_uidiv
   \   0000013A   0x900E             STR      R0,[SP, #+56]
   \                     ??f_mkfs_23: (+1)
   \   0000013C   0x980E             LDR      R0,[SP, #+56]
   \   0000013E   0x2800             CMP      R0,#+0
   \   00000140   0xD101             BNE      ??f_mkfs_24
   4167          	if (!au) au = 1;
   \   00000142   0x2001             MOVS     R0,#+1
   \   00000144   0xE002             B        ??f_mkfs_25
   4168          	if (au > 128) au = 128;
   \                     ??f_mkfs_24: (+1)
   \   00000146   0x2881             CMP      R0,#+129
   \   00000148   0xD301             BCC      ??f_mkfs_26
   \   0000014A   0x2080             MOVS     R0,#+128
   \                     ??f_mkfs_25: (+1)
   \   0000014C   0x900E             STR      R0,[SP, #+56]
   4169          
   4170          	/* Pre-compute number of clusters and FAT sub-type */
   4171          	n_clst = n_vol / au;
   \                     ??f_mkfs_26: (+1)
   \   0000014E   0x9801             LDR      R0,[SP, #+4]
   \   00000150   0x990E             LDR      R1,[SP, #+56]
   \   00000152   0x.... 0x....      BL       __aeabi_uidiv
   \   00000156   0x0006             MOVS     R6,R0
   4172          	fmt = FS_FAT12;
   \   00000158   0x2001             MOVS     R0,#+1
   \   0000015A   0x9003             STR      R0,[SP, #+12]
   \   0000015C   0x48CA             LDR      R0,??f_mkfs_27   ;; 0xff6
   \   0000015E   0x4286             CMP      R6,R0
   \   00000160   0xD301             BCC      ??f_mkfs_28
   4173          	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
   \   00000162   0x2002             MOVS     R0,#+2
   \   00000164   0x9003             STR      R0,[SP, #+12]
   \                     ??f_mkfs_28: (+1)
   \   00000166   0x48C9             LDR      R0,??f_mkfs_27+0x4  ;; 0xfff6
   \   00000168   0x4286             CMP      R6,R0
   \   0000016A   0xD302             BCC      ??f_mkfs_29
   4174          	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
   \   0000016C   0x2003             MOVS     R0,#+3
   \   0000016E   0x9003             STR      R0,[SP, #+12]
   \   00000170   0xE002             B        ??f_mkfs_30
   4175          
   4176          	/* Determine offset and size of FAT structure */
   4177          	if (fmt == FS_FAT32) {
   \                     ??f_mkfs_29: (+1)
   \   00000172   0x9803             LDR      R0,[SP, #+12]
   \   00000174   0x2803             CMP      R0,#+3
   \   00000176   0xD10C             BNE      ??f_mkfs_31
   4178          		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
   \                     ??f_mkfs_30: (+1)
   \   00000178   0x9802             LDR      R0,[SP, #+8]
   \   0000017A   0x8945             LDRH     R5,[R0, #+10]
   \   0000017C   0x00B0             LSLS     R0,R6,#+2
   \   0000017E   0x1940             ADDS     R0,R0,R5
   \   00000180   0x1DC0             ADDS     R0,R0,#+7
   \   00000182   0x0029             MOVS     R1,R5
   \   00000184   0x.... 0x....      BL       __aeabi_uidiv
   \   00000188   0x9005             STR      R0,[SP, #+20]
   4179          		n_rsv = 32;
   \   0000018A   0x2020             MOVS     R0,#+32
   \   0000018C   0x9007             STR      R0,[SP, #+28]
   4180          		n_dir = 0;
   \   0000018E   0x2000             MOVS     R0,#+0
   \   00000190   0xE017             B        ??f_mkfs_32
   4181          	} else {
   4182          		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
   \                     ??f_mkfs_31: (+1)
   \   00000192   0x2801             CMP      R0,#+1
   \   00000194   0xD105             BNE      ??f_mkfs_33
   \   00000196   0x0070             LSLS     R0,R6,#+1
   \   00000198   0x1980             ADDS     R0,R0,R6
   \   0000019A   0x1C40             ADDS     R0,R0,#+1
   \   0000019C   0x0840             LSRS     R0,R0,#+1
   \   0000019E   0x1CC0             ADDS     R0,R0,#+3
   \   000001A0   0xE001             B        ??f_mkfs_34
   \                     ??f_mkfs_33: (+1)
   \   000001A2   0x0070             LSLS     R0,R6,#+1
   \   000001A4   0x1D00             ADDS     R0,R0,#+4
   4183          		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
   \                     ??f_mkfs_34: (+1)
   \   000001A6   0x9902             LDR      R1,[SP, #+8]
   \   000001A8   0x894D             LDRH     R5,[R1, #+10]
   \   000001AA   0x1940             ADDS     R0,R0,R5
   \   000001AC   0x1E40             SUBS     R0,R0,#+1
   \   000001AE   0x0029             MOVS     R1,R5
   \   000001B0   0x.... 0x....      BL       __aeabi_uidiv
   \   000001B4   0x9005             STR      R0,[SP, #+20]
   4184          		n_rsv = 1;
   \   000001B6   0x2001             MOVS     R0,#+1
   \   000001B8   0x9007             STR      R0,[SP, #+28]
   4185          		n_dir = (DWORD)N_ROOTDIR * SZ_DIRE / SS(fs);
   \   000001BA   0x0380             LSLS     R0,R0,#+14
   \   000001BC   0x0029             MOVS     R1,R5
   \   000001BE   0x.... 0x....      BL       __aeabi_uidiv
   \                     ??f_mkfs_32: (+1)
   \   000001C2   0x9009             STR      R0,[SP, #+36]
   4186          	}
   4187          	b_fat = b_vol + n_rsv;				/* FAT area start sector */
   \   000001C4   0x9806             LDR      R0,[SP, #+24]
   \   000001C6   0x9907             LDR      R1,[SP, #+28]
   \   000001C8   0x1840             ADDS     R0,R0,R1
   \   000001CA   0x9008             STR      R0,[SP, #+32]
   4188          	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
   4189          	b_data = b_dir + n_dir;				/* Data area start sector */
   \   000001CC   0x9905             LDR      R1,[SP, #+20]
   \   000001CE   0x1840             ADDS     R0,R0,R1
   \   000001D0   0x9909             LDR      R1,[SP, #+36]
   \   000001D2   0x1845             ADDS     R5,R0,R1
   4190          	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
   \   000001D4   0x9801             LDR      R0,[SP, #+4]
   \   000001D6   0x990E             LDR      R1,[SP, #+56]
   \   000001D8   0x1869             ADDS     R1,R5,R1
   \   000001DA   0x9A06             LDR      R2,[SP, #+24]
   \   000001DC   0x1A89             SUBS     R1,R1,R2
   \   000001DE   0x4288             CMP      R0,R1
   \   000001E0   0xD33E             BCC      ??f_mkfs_35
   4191          
   4192          	/* Align data start sector to erase block boundary (for flash memory media) */
   4193          	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
   \   000001E2   0x466A             MOV      R2,SP
   \   000001E4   0x2103             MOVS     R1,#+3
   \   000001E6   0x4668             MOV      R0,SP
   \   000001E8   0x7C00             LDRB     R0,[R0, #+16]
   \   000001EA   0x.... 0x....      BL       disk_ioctl
   \   000001EE   0x2800             CMP      R0,#+0
   \   000001F0   0xD105             BNE      ??f_mkfs_36
   \   000001F2   0x9800             LDR      R0,[SP, #+0]
   \   000001F4   0x2800             CMP      R0,#+0
   \   000001F6   0xD002             BEQ      ??f_mkfs_36
   \   000001F8   0x49A5             LDR      R1,??f_mkfs_27+0x8  ;; 0x8001
   \   000001FA   0x4288             CMP      R0,R1
   \   000001FC   0xD301             BCC      ??f_mkfs_37
   \                     ??f_mkfs_36: (+1)
   \   000001FE   0x2001             MOVS     R0,#+1
   \   00000200   0x9000             STR      R0,[SP, #+0]
   4194          	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
   4195          	n = (n - b_data) / N_FATS;
   \                     ??f_mkfs_37: (+1)
   \   00000202   0x9800             LDR      R0,[SP, #+0]
   \   00000204   0x1828             ADDS     R0,R5,R0
   \   00000206   0x1E40             SUBS     R0,R0,#+1
   \   00000208   0x9900             LDR      R1,[SP, #+0]
   \   0000020A   0x1E49             SUBS     R1,R1,#+1
   \   0000020C   0x4388             BICS     R0,R0,R1
   \   0000020E   0x1B40             SUBS     R0,R0,R5
   \   00000210   0x9000             STR      R0,[SP, #+0]
   4196          	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
   \   00000212   0x9803             LDR      R0,[SP, #+12]
   \   00000214   0x2803             CMP      R0,#+3
   \   00000216   0xD108             BNE      ??f_mkfs_38
   4197          		n_rsv += n;
   \   00000218   0x9807             LDR      R0,[SP, #+28]
   \   0000021A   0x9900             LDR      R1,[SP, #+0]
   \   0000021C   0x1840             ADDS     R0,R0,R1
   \   0000021E   0x9007             STR      R0,[SP, #+28]
   4198          		b_fat += n;
   \   00000220   0x9808             LDR      R0,[SP, #+32]
   \   00000222   0x9900             LDR      R1,[SP, #+0]
   \   00000224   0x1840             ADDS     R0,R0,R1
   \   00000226   0x9008             STR      R0,[SP, #+32]
   \   00000228   0xE003             B        ??f_mkfs_39
   4199          	} else {					/* FAT12/16: Expand FAT size */
   4200          		n_fat += n;
   \                     ??f_mkfs_38: (+1)
   \   0000022A   0x9805             LDR      R0,[SP, #+20]
   \   0000022C   0x9900             LDR      R1,[SP, #+0]
   \   0000022E   0x1840             ADDS     R0,R0,R1
   \   00000230   0x9005             STR      R0,[SP, #+20]
   4201          	}
   4202          
   4203          	/* Determine number of clusters and final check of validity of the FAT sub-type */
   4204          	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
   \                     ??f_mkfs_39: (+1)
   \   00000232   0x9801             LDR      R0,[SP, #+4]
   \   00000234   0x9907             LDR      R1,[SP, #+28]
   \   00000236   0x1A40             SUBS     R0,R0,R1
   \   00000238   0x9905             LDR      R1,[SP, #+20]
   \   0000023A   0x1A40             SUBS     R0,R0,R1
   \   0000023C   0x9909             LDR      R1,[SP, #+36]
   \   0000023E   0x1A40             SUBS     R0,R0,R1
   \   00000240   0x990E             LDR      R1,[SP, #+56]
   \   00000242   0x.... 0x....      BL       __aeabi_uidiv
   \   00000246   0x0006             MOVS     R6,R0
   4205          	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
   4206          		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
   \   00000248   0x9803             LDR      R0,[SP, #+12]
   \   0000024A   0x2802             CMP      R0,#+2
   \   0000024C   0xD102             BNE      ??f_mkfs_40
   \   0000024E   0x488E             LDR      R0,??f_mkfs_27   ;; 0xff6
   \   00000250   0x4286             CMP      R6,R0
   \   00000252   0xD305             BCC      ??f_mkfs_35
   \                     ??f_mkfs_40: (+1)
   \   00000254   0x9803             LDR      R0,[SP, #+12]
   \   00000256   0x2803             CMP      R0,#+3
   \   00000258   0xD10E             BNE      ??f_mkfs_41
   \   0000025A   0x488C             LDR      R0,??f_mkfs_27+0x4  ;; 0xfff6
   \   0000025C   0x4286             CMP      R6,R0
   \   0000025E   0xD20B             BCS      ??f_mkfs_41
   4207          		return FR_MKFS_ABORTED;
   \                     ??f_mkfs_35: (+1)
   \   00000260   0x200E             MOVS     R0,#+14
   \   00000262   0xE247             B        ??f_mkfs_1
   \                     ??f_mkfs_8:
   \   00000264   0x........         DC32     CurrVol
   \   00000268   0xFFFFFE00         DC32     0xfffffe00
   \   0000026C   0x00000E01         DC32     0xe01
   \   00000270   0x........         DC32     `f_mkfs::vst`
   \   00000274   0x........         DC32     `f_mkfs::cst`
   4208          
   4209          	/* Determine system ID in the partition table */
   4210          	if (fmt == FS_FAT32) {
   \                     ??f_mkfs_41: (+1)
   \   00000278   0x9803             LDR      R0,[SP, #+12]
   \   0000027A   0x2803             CMP      R0,#+3
   \   0000027C   0xD101             BNE      ??f_mkfs_42
   4211          		sys = 0x0C;		/* FAT32X */
   \   0000027E   0x270C             MOVS     R7,#+12
   \   00000280   0xE00C             B        ??f_mkfs_43
   4212          	} else {
   4213          		if (fmt == FS_FAT12 && n_vol < 0x10000) {
   \                     ??f_mkfs_42: (+1)
   \   00000282   0x03B8             LSLS     R0,R7,#+14
   \   00000284   0x9903             LDR      R1,[SP, #+12]
   \   00000286   0x2901             CMP      R1,#+1
   \   00000288   0xD104             BNE      ??f_mkfs_44
   \   0000028A   0x9901             LDR      R1,[SP, #+4]
   \   0000028C   0x4281             CMP      R1,R0
   \   0000028E   0xD201             BCS      ??f_mkfs_44
   4214          			sys = 0x01;	/* FAT12(<65536) */
   \   00000290   0x2701             MOVS     R7,#+1
   \   00000292   0xE003             B        ??f_mkfs_43
   4215          		} else {
   4216          			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
   \                     ??f_mkfs_44: (+1)
   \   00000294   0x9901             LDR      R1,[SP, #+4]
   \   00000296   0x4281             CMP      R1,R0
   \   00000298   0xD300             BCC      ??f_mkfs_43
   \   0000029A   0x2706             MOVS     R7,#+6
   4217          		}
   4218          	}
   4219          
   4220          	if (_MULTI_PARTITION && part) {
   4221          		/* Update system ID in the partition table */
   4222          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   4223          		tbl[4] = sys;
   4224          		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to teh MBR */
   4225          			return FR_DISK_ERR;
   4226          		md = 0xF8;
   4227          	} else {
   4228          		if (sfd) {	/* No partition table (SFD) */
   \                     ??f_mkfs_43: (+1)
   \   0000029C   0x2C00             CMP      R4,#+0
   \   0000029E   0xD001             BEQ      ??f_mkfs_45
   4229          			md = 0xF0;
   \   000002A0   0x20F0             MOVS     R0,#+240
   \   000002A2   0xE04D             B        ??f_mkfs_46
   4230          		} else {	/* Create partition table (FDISK) */
   4231          			mem_set(fs->win, 0, SS(fs));
   \                     ??f_mkfs_45: (+1)
   \   000002A4   0x9802             LDR      R0,[SP, #+8]
   \   000002A6   0x8941             LDRH     R1,[R0, #+10]
   \   000002A8   0x0008             MOVS     R0,R1
   \   000002AA   0xD003             BEQ      ??f_mkfs_47
   \   000002AC   0x9802             LDR      R0,[SP, #+8]
   \   000002AE   0x6B40             LDR      R0,[R0, #+52]
   \   000002B0   0x.... 0x....      BL       __aeabi_memclr
   4232          			tbl = fs->win + MBR_Table;	/* Create partition table for single partition in the drive */
   \                     ??f_mkfs_47: (+1)
   \   000002B4   0x9802             LDR      R0,[SP, #+8]
   \   000002B6   0x6B40             LDR      R0,[R0, #+52]
   \   000002B8   0x21DF             MOVS     R1,#+223
   \   000002BA   0x0049             LSLS     R1,R1,#+1        ;; #+446
   \   000002BC   0x1844             ADDS     R4,R0,R1
   4233          			tbl[1] = 1;						/* Partition start head */
   \   000002BE   0x2001             MOVS     R0,#+1
   \   000002C0   0x7060             STRB     R0,[R4, #+1]
   4234          			tbl[2] = 1;						/* Partition start sector */
   \   000002C2   0x70A0             STRB     R0,[R4, #+2]
   4235          			tbl[3] = 0;						/* Partition start cylinder */
   \   000002C4   0x2000             MOVS     R0,#+0
   \   000002C6   0x70E0             STRB     R0,[R4, #+3]
   4236          			tbl[4] = sys;					/* System type */
   \   000002C8   0x7127             STRB     R7,[R4, #+4]
   4237          			tbl[5] = 254;					/* Partition end head */
   \   000002CA   0x20FE             MOVS     R0,#+254
   \   000002CC   0x7160             STRB     R0,[R4, #+5]
   4238          			n = (b_vol + n_vol) / 63 / 255;
   \   000002CE   0x253F             MOVS     R5,#+63
   \   000002D0   0x9806             LDR      R0,[SP, #+24]
   \   000002D2   0x9901             LDR      R1,[SP, #+4]
   \   000002D4   0x1840             ADDS     R0,R0,R1
   \   000002D6   0x213F             MOVS     R1,#+63
   \   000002D8   0x.... 0x....      BL       __aeabi_uidiv
   \   000002DC   0x21FF             MOVS     R1,#+255
   \   000002DE   0x.... 0x....      BL       __aeabi_uidiv
   \   000002E2   0x9000             STR      R0,[SP, #+0]
   4239          			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
   \   000002E4   0x0880             LSRS     R0,R0,#+2
   \   000002E6   0x213F             MOVS     R1,#+63
   \   000002E8   0x4301             ORRS     R1,R1,R0
   \   000002EA   0x71A1             STRB     R1,[R4, #+6]
   4240          			tbl[7] = (BYTE)n;				/* End cylinder */
   \   000002EC   0x9800             LDR      R0,[SP, #+0]
   \   000002EE   0x71E0             STRB     R0,[R4, #+7]
   4241          			ST_DWORD(tbl + 8, 63);			/* Partition start in LBA */
   \   000002F0   0x7225             STRB     R5,[R4, #+8]
   \   000002F2   0x2000             MOVS     R0,#+0
   \   000002F4   0x7260             STRB     R0,[R4, #+9]
   \   000002F6   0x72A0             STRB     R0,[R4, #+10]
   \   000002F8   0x72E0             STRB     R0,[R4, #+11]
   4242          			ST_DWORD(tbl + 12, n_vol);		/* Partition size in LBA */
   \   000002FA   0x9801             LDR      R0,[SP, #+4]
   \   000002FC   0x7320             STRB     R0,[R4, #+12]
   \   000002FE   0x9801             LDR      R0,[SP, #+4]
   \   00000300   0x0400             LSLS     R0,R0,#+16
   \   00000302   0x0E00             LSRS     R0,R0,#+24
   \   00000304   0x7360             STRB     R0,[R4, #+13]
   \   00000306   0x9801             LDR      R0,[SP, #+4]
   \   00000308   0x0C00             LSRS     R0,R0,#+16
   \   0000030A   0x73A0             STRB     R0,[R4, #+14]
   \   0000030C   0x9801             LDR      R0,[SP, #+4]
   \   0000030E   0x0E00             LSRS     R0,R0,#+24
   \   00000310   0x73E0             STRB     R0,[R4, #+15]
   4243          			ST_WORD(fs->win + BS_55AA, 0xAA55);	/* MBR signature */
   \   00000312   0x2055             MOVS     R0,#+85
   \   00000314   0x9902             LDR      R1,[SP, #+8]
   \   00000316   0x6B49             LDR      R1,[R1, #+52]
   \   00000318   0x22FF             MOVS     R2,#+255
   \   0000031A   0x0052             LSLS     R2,R2,#+1        ;; #+510
   \   0000031C   0x5488             STRB     R0,[R1, R2]
   \   0000031E   0x20AA             MOVS     R0,#+170
   \   00000320   0x9902             LDR      R1,[SP, #+8]
   \   00000322   0x6B49             LDR      R1,[R1, #+52]
   \   00000324   0x1C52             ADDS     R2,R2,#+1
   \   00000326   0x5488             STRB     R0,[R1, R2]
   4244          			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR */
   \   00000328   0x2301             MOVS     R3,#+1
   \   0000032A   0x2200             MOVS     R2,#+0
   \   0000032C   0x9802             LDR      R0,[SP, #+8]
   \   0000032E   0x6B41             LDR      R1,[R0, #+52]
   \   00000330   0x4668             MOV      R0,SP
   \   00000332   0x7C00             LDRB     R0,[R0, #+16]
   \   00000334   0x.... 0x....      BL       disk_write
   \   00000338   0x2800             CMP      R0,#+0
   \   0000033A   0xD000             BEQ      .+4
   \   0000033C   0xE15F             B        ??f_mkfs_13
   4245          				return FR_DISK_ERR;
   4246          			md = 0xF8;
   \   0000033E   0x20F8             MOVS     R0,#+248
   \                     ??f_mkfs_46: (+1)
   \   00000340   0x900A             STR      R0,[SP, #+40]
   4247          		}
   4248          	}
   4249          
   4250          	/* Create BPB in the VBR */
   4251          	tbl = fs->win;							/* Clear sector */
   \   00000342   0x9802             LDR      R0,[SP, #+8]
   \   00000344   0x6B44             LDR      R4,[R0, #+52]
   4252          	mem_set(tbl, 0, SS(fs));
   \   00000346   0x8941             LDRH     R1,[R0, #+10]
   \   00000348   0x2900             CMP      R1,#+0
   \   0000034A   0xD002             BEQ      ??f_mkfs_48
   \   0000034C   0x0020             MOVS     R0,R4
   \   0000034E   0x.... 0x....      BL       __aeabi_memclr
   4253          	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
   \                     ??f_mkfs_48: (+1)
   \   00000352   0x20EB             MOVS     R0,#+235
   \   00000354   0x7020             STRB     R0,[R4, #+0]
   \   00000356   0x484F             LDR      R0,??f_mkfs_27+0xC
   \   00000358   0x1C61             ADDS     R1,R4,#+1
   \   0000035A   0x2205             MOVS     R2,#+5
   \                     ??f_mkfs_49: (+1)
   \   0000035C   0x7803             LDRB     R3,[R0, #+0]
   \   0000035E   0x700B             STRB     R3,[R1, #+0]
   \   00000360   0x7843             LDRB     R3,[R0, #+1]
   \   00000362   0x704B             STRB     R3,[R1, #+1]
   \   00000364   0x1C80             ADDS     R0,R0,#+2
   \   00000366   0x1C89             ADDS     R1,R1,#+2
   \   00000368   0x1E52             SUBS     R2,R2,#+1
   \   0000036A   0xD1F7             BNE      ??f_mkfs_49
   4254          	i = SS(fs);								/* Sector size */
   \   0000036C   0x9802             LDR      R0,[SP, #+8]
   \   0000036E   0x8945             LDRH     R5,[R0, #+10]
   4255          	ST_WORD(tbl + BPB_BytsPerSec, i);
   \   00000370   0x72E5             STRB     R5,[R4, #+11]
   \   00000372   0x0A28             LSRS     R0,R5,#+8
   \   00000374   0x7320             STRB     R0,[R4, #+12]
   4256          	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
   \   00000376   0x980E             LDR      R0,[SP, #+56]
   \   00000378   0x7360             STRB     R0,[R4, #+13]
   4257          	ST_WORD(tbl + BPB_RsvdSecCnt, n_rsv);	/* Reserved sectors */
   \   0000037A   0x9807             LDR      R0,[SP, #+28]
   \   0000037C   0x73A0             STRB     R0,[R4, #+14]
   \   0000037E   0x9807             LDR      R0,[SP, #+28]
   \   00000380   0x0400             LSLS     R0,R0,#+16
   \   00000382   0x0E00             LSRS     R0,R0,#+24
   \   00000384   0x73E0             STRB     R0,[R4, #+15]
   4258          	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
   \   00000386   0x2001             MOVS     R0,#+1
   \   00000388   0x7420             STRB     R0,[R4, #+16]
   4259          	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
   \   0000038A   0x9803             LDR      R0,[SP, #+12]
   \   0000038C   0x2803             CMP      R0,#+3
   \   0000038E   0xD101             BNE      ??f_mkfs_50
   \   00000390   0x2000             MOVS     R0,#+0
   \   00000392   0xE000             B        ??f_mkfs_51
   \                     ??f_mkfs_50: (+1)
   \   00000394   0x2002             MOVS     R0,#+2
   4260          	ST_WORD(tbl + BPB_RootEntCnt, i);
   \                     ??f_mkfs_51: (+1)
   \   00000396   0x2100             MOVS     R1,#+0
   \   00000398   0x7461             STRB     R1,[R4, #+17]
   \   0000039A   0x74A0             STRB     R0,[R4, #+18]
   4261          	if (n_vol < 0x10000) {					/* Number of total sectors */
   \   0000039C   0x0025             MOVS     R5,R4
   \   0000039E   0x3521             ADDS     R5,R5,#+33
   \   000003A0   0x9801             LDR      R0,[SP, #+4]
   \   000003A2   0x2180             MOVS     R1,#+128
   \   000003A4   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   000003A6   0x4288             CMP      R0,R1
   \   000003A8   0xD205             BCS      ??f_mkfs_52
   4262          		ST_WORD(tbl + BPB_TotSec16, n_vol);
   \   000003AA   0x74E0             STRB     R0,[R4, #+19]
   \   000003AC   0x9801             LDR      R0,[SP, #+4]
   \   000003AE   0x0400             LSLS     R0,R0,#+16
   \   000003B0   0x0E00             LSRS     R0,R0,#+24
   \   000003B2   0x7520             STRB     R0,[R4, #+20]
   \   000003B4   0xE00B             B        ??f_mkfs_53
   4263          	} else {
   4264          		ST_DWORD(tbl + BPB_TotSec32, n_vol);
   \                     ??f_mkfs_52: (+1)
   \   000003B6   0x2120             MOVS     R1,#+32
   \   000003B8   0x5460             STRB     R0,[R4, R1]
   \   000003BA   0x9801             LDR      R0,[SP, #+4]
   \   000003BC   0x0400             LSLS     R0,R0,#+16
   \   000003BE   0x0E00             LSRS     R0,R0,#+24
   \   000003C0   0x7028             STRB     R0,[R5, #+0]
   \   000003C2   0x9801             LDR      R0,[SP, #+4]
   \   000003C4   0x0C00             LSRS     R0,R0,#+16
   \   000003C6   0x7068             STRB     R0,[R5, #+1]
   \   000003C8   0x9801             LDR      R0,[SP, #+4]
   \   000003CA   0x0E00             LSRS     R0,R0,#+24
   \   000003CC   0x70A8             STRB     R0,[R5, #+2]
   4265          	}
   4266          	tbl[BPB_Media] = md;					/* Media descriptor */
   \                     ??f_mkfs_53: (+1)
   \   000003CE   0x980A             LDR      R0,[SP, #+40]
   \   000003D0   0x7560             STRB     R0,[R4, #+21]
   4267          	ST_WORD(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
   \   000003D2   0x203F             MOVS     R0,#+63
   \   000003D4   0x7620             STRB     R0,[R4, #+24]
   \   000003D6   0x2000             MOVS     R0,#+0
   \   000003D8   0x7660             STRB     R0,[R4, #+25]
   \   000003DA   0x20FF             MOVS     R0,#+255
   \   000003DC   0x76A0             STRB     R0,[R4, #+26]
   4268          	ST_WORD(tbl + BPB_NumHeads, 255);		/* Number of heads */
   \   000003DE   0x2000             MOVS     R0,#+0
   \   000003E0   0x76E0             STRB     R0,[R4, #+27]
   4269          	ST_DWORD(tbl + BPB_HiddSec, b_vol);		/* Hidden sectors */
   \   000003E2   0x9806             LDR      R0,[SP, #+24]
   \   000003E4   0x7720             STRB     R0,[R4, #+28]
   \   000003E6   0x2000             MOVS     R0,#+0
   \   000003E8   0x7760             STRB     R0,[R4, #+29]
   \   000003EA   0x77A0             STRB     R0,[R4, #+30]
   \   000003EC   0x77E0             STRB     R0,[R4, #+31]
   4270          	n = GET_FATTIME();						/* Use current time as VSN */
   \   000003EE   0x.... 0x....      BL       get_fattime
   \   000003F2   0x9000             STR      R0,[SP, #+0]
   4271          	if (fmt == FS_FAT32) {
   \   000003F4   0x9805             LDR      R0,[SP, #+20]
   \   000003F6   0x0400             LSLS     R0,R0,#+16
   \   000003F8   0x0E00             LSRS     R0,R0,#+24
   \   000003FA   0x4669             MOV      R1,SP
   \   000003FC   0x7448             STRB     R0,[R1, #+17]
   \   000003FE   0x214E             MOVS     R1,#+78
   \   00000400   0x2006             MOVS     R0,#+6
   \   00000402   0x2280             MOVS     R2,#+128
   \   00000404   0x9B03             LDR      R3,[SP, #+12]
   \   00000406   0x2B03             CMP      R3,#+3
   \   00000408   0x9B00             LDR      R3,[SP, #+0]
   \   0000040A   0xD145             BNE      ??f_mkfs_54
   \   0000040C   0x0027             MOVS     R7,R4
   \   0000040E   0x3742             ADDS     R7,R7,#+66
   \   00000410   0x707B             STRB     R3,[R7, #+1]
   4272          		ST_DWORD(tbl + BS_VolID32, n);		/* VSN */
   \   00000412   0x9B00             LDR      R3,[SP, #+0]
   \   00000414   0x041B             LSLS     R3,R3,#+16
   \   00000416   0x0E1B             LSRS     R3,R3,#+24
   \   00000418   0x0027             MOVS     R7,R4
   \   0000041A   0x3742             ADDS     R7,R7,#+66
   \   0000041C   0x70BB             STRB     R3,[R7, #+2]
   \   0000041E   0x9B00             LDR      R3,[SP, #+0]
   \   00000420   0x0C1B             LSRS     R3,R3,#+16
   \   00000422   0x0027             MOVS     R7,R4
   \   00000424   0x3742             ADDS     R7,R7,#+66
   \   00000426   0x70FB             STRB     R3,[R7, #+3]
   \   00000428   0x9B00             LDR      R3,[SP, #+0]
   \   0000042A   0x0E1B             LSRS     R3,R3,#+24
   \   0000042C   0x0027             MOVS     R7,R4
   \   0000042E   0x3742             ADDS     R7,R7,#+66
   \   00000430   0x713B             STRB     R3,[R7, #+4]
   4273          		ST_DWORD(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
   \   00000432   0x9B05             LDR      R3,[SP, #+20]
   \   00000434   0x70EB             STRB     R3,[R5, #+3]
   \   00000436   0x466B             MOV      R3,SP
   \   00000438   0x7C5B             LDRB     R3,[R3, #+17]
   \   0000043A   0x712B             STRB     R3,[R5, #+4]
   \   0000043C   0x9B05             LDR      R3,[SP, #+20]
   \   0000043E   0x0C1B             LSRS     R3,R3,#+16
   \   00000440   0x716B             STRB     R3,[R5, #+5]
   \   00000442   0x9B05             LDR      R3,[SP, #+20]
   \   00000444   0x0E1B             LSRS     R3,R3,#+24
   \   00000446   0x71AB             STRB     R3,[R5, #+6]
   4274          		ST_DWORD(tbl + BPB_RootClus, 2);	/* Root directory start cluster (2) */
   \   00000448   0x2302             MOVS     R3,#+2
   \   0000044A   0x72EB             STRB     R3,[R5, #+11]
   \   0000044C   0x2300             MOVS     R3,#+0
   \   0000044E   0x732B             STRB     R3,[R5, #+12]
   \   00000450   0x736B             STRB     R3,[R5, #+13]
   \   00000452   0x73AB             STRB     R3,[R5, #+14]
   4275          		ST_WORD(tbl + BPB_FSInfo, 1);		/* FSINFO record offset (VBR + 1) */
   \   00000454   0x2301             MOVS     R3,#+1
   \   00000456   0x73EB             STRB     R3,[R5, #+15]
   \   00000458   0x2300             MOVS     R3,#+0
   \   0000045A   0x742B             STRB     R3,[R5, #+16]
   4276          		ST_WORD(tbl + BPB_BkBootSec, 6);	/* Backup boot record offset (VBR + 6) */
   \   0000045C   0x7468             STRB     R0,[R5, #+17]
   \   0000045E   0x74AB             STRB     R3,[R5, #+18]
   4277          		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
   \   00000460   0x77EA             STRB     R2,[R5, #+31]
   4278          		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
   \   00000462   0x2229             MOVS     R2,#+41
   \   00000464   0x2342             MOVS     R3,#+66
   \   00000466   0x54E2             STRB     R2,[R4, R3]
   4279          		mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
   \   00000468   0x0022             MOVS     R2,R4
   \   0000046A   0x3247             ADDS     R2,R2,#+71
   \   0000046C   0x7011             STRB     R1,[R2, #+0]
   \   0000046E   0x....             LDR      R1,??DataTable33
   \   00000470   0x1C52             ADDS     R2,R2,#+1
   \                     ??f_mkfs_55: (+1)
   \   00000472   0x780B             LDRB     R3,[R1, #+0]
   \   00000474   0x7013             STRB     R3,[R2, #+0]
   \   00000476   0x784B             LDRB     R3,[R1, #+1]
   \   00000478   0x7053             STRB     R3,[R2, #+1]
   \   0000047A   0x788B             LDRB     R3,[R1, #+2]
   \   0000047C   0x7093             STRB     R3,[R2, #+2]
   \   0000047E   0x1CC9             ADDS     R1,R1,#+3
   \   00000480   0x1CD2             ADDS     R2,R2,#+3
   \   00000482   0x1E40             SUBS     R0,R0,#+1
   \   00000484   0xD02A             BEQ      ??f_mkfs_56
   \   00000486   0xE7F4             B        ??f_mkfs_55
   \                     ??f_mkfs_27:
   \   00000488   0x00000FF6         DC32     0xff6
   \   0000048C   0x0000FFF6         DC32     0xfff6
   \   00000490   0x00008001         DC32     0x8001
   \   00000494   0x........         DC32     ?_2+0x1
   4280          	} else {
   4281          		ST_DWORD(tbl + BS_VolID, n);		/* VSN */
   \                     ??f_mkfs_54: (+1)
   \   00000498   0x71AB             STRB     R3,[R5, #+6]
   \   0000049A   0x9B00             LDR      R3,[SP, #+0]
   \   0000049C   0x041B             LSLS     R3,R3,#+16
   \   0000049E   0x0E1B             LSRS     R3,R3,#+24
   \   000004A0   0x71EB             STRB     R3,[R5, #+7]
   \   000004A2   0x9B00             LDR      R3,[SP, #+0]
   \   000004A4   0x0C1B             LSRS     R3,R3,#+16
   \   000004A6   0x722B             STRB     R3,[R5, #+8]
   \   000004A8   0x9B00             LDR      R3,[SP, #+0]
   \   000004AA   0x0E1B             LSRS     R3,R3,#+24
   \   000004AC   0x726B             STRB     R3,[R5, #+9]
   4282          		ST_WORD(tbl + BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
   \   000004AE   0x9B05             LDR      R3,[SP, #+20]
   \   000004B0   0x75A3             STRB     R3,[R4, #+22]
   \   000004B2   0x466B             MOV      R3,SP
   \   000004B4   0x7C5B             LDRB     R3,[R3, #+17]
   \   000004B6   0x75E3             STRB     R3,[R4, #+23]
   4283          		tbl[BS_DrvNum] = 0x80;				/* Drive number */
   \   000004B8   0x70EA             STRB     R2,[R5, #+3]
   4284          		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
   \   000004BA   0x2229             MOVS     R2,#+41
   \   000004BC   0x716A             STRB     R2,[R5, #+5]
   4285          		mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
   \   000004BE   0x0022             MOVS     R2,R4
   \   000004C0   0x322B             ADDS     R2,R2,#+43
   \   000004C2   0x7011             STRB     R1,[R2, #+0]
   \   000004C4   0x....             LDR      R1,??DataTable33_1
   \   000004C6   0x1C52             ADDS     R2,R2,#+1
   \                     ??f_mkfs_57: (+1)
   \   000004C8   0x780B             LDRB     R3,[R1, #+0]
   \   000004CA   0x7013             STRB     R3,[R2, #+0]
   \   000004CC   0x784B             LDRB     R3,[R1, #+1]
   \   000004CE   0x7053             STRB     R3,[R2, #+1]
   \   000004D0   0x788B             LDRB     R3,[R1, #+2]
   \   000004D2   0x7093             STRB     R3,[R2, #+2]
   \   000004D4   0x1CC9             ADDS     R1,R1,#+3
   \   000004D6   0x1CD2             ADDS     R2,R2,#+3
   \   000004D8   0x1E40             SUBS     R0,R0,#+1
   \   000004DA   0xD1F5             BNE      ??f_mkfs_57
   \                     ??f_mkfs_56: (+1)
   \   000004DC   0x2055             MOVS     R0,#+85
   \   000004DE   0x21F2             MOVS     R1,#+242
   \   000004E0   0x0049             LSLS     R1,R1,#+1        ;; #+484
   \   000004E2   0x1861             ADDS     R1,R4,R1
   \   000004E4   0x7688             STRB     R0,[R1, #+26]
   \   000004E6   0x20AA             MOVS     R0,#+170
   \   000004E8   0x21F2             MOVS     R1,#+242
   \   000004EA   0x0049             LSLS     R1,R1,#+1        ;; #+484
   \   000004EC   0x1861             ADDS     R1,R4,R1
   \   000004EE   0x76C8             STRB     R0,[R1, #+27]
   4286          	}
   4287          	ST_WORD(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
   4288          	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
   \   000004F0   0x2301             MOVS     R3,#+1
   \   000004F2   0x9A06             LDR      R2,[SP, #+24]
   \   000004F4   0x0021             MOVS     R1,R4
   \   000004F6   0x4668             MOV      R0,SP
   \   000004F8   0x7C00             LDRB     R0,[R0, #+16]
   \   000004FA   0x.... 0x....      BL       disk_write
   \   000004FE   0x2800             CMP      R0,#+0
   \   00000500   0xD17D             BNE      ??f_mkfs_13
   4289          		return FR_DISK_ERR;
   4290          	if (fmt == FS_FAT32)					/* Write it to the backup VBR if needed (VBR + 6) */
   \   00000502   0x9803             LDR      R0,[SP, #+12]
   \   00000504   0x2803             CMP      R0,#+3
   \   00000506   0xD107             BNE      ??f_mkfs_58
   4291          		disk_write(pdrv, tbl, b_vol + 6, 1);
   \   00000508   0x2301             MOVS     R3,#+1
   \   0000050A   0x9A06             LDR      R2,[SP, #+24]
   \   0000050C   0x1D92             ADDS     R2,R2,#+6
   \   0000050E   0x0021             MOVS     R1,R4
   \   00000510   0x4668             MOV      R0,SP
   \   00000512   0x7C00             LDRB     R0,[R0, #+16]
   \   00000514   0x.... 0x....      BL       disk_write
   4292          
   4293          	/* Initialize FAT area */
   4294          	wsect = b_fat;
   \                     ??f_mkfs_58: (+1)
   \   00000518   0x9F08             LDR      R7,[SP, #+32]
   4295          	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
   4296          		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
   \   0000051A   0x9802             LDR      R0,[SP, #+8]
   \   0000051C   0x8941             LDRH     R1,[R0, #+10]
   \   0000051E   0x0008             MOVS     R0,R1
   \   00000520   0xD002             BEQ      ??f_mkfs_59
   \   00000522   0x0020             MOVS     R0,R4
   \   00000524   0x.... 0x....      BL       __aeabi_memclr
   4297          		n = md;								/* Media descriptor byte */
   \                     ??f_mkfs_59: (+1)
   \   00000528   0x980A             LDR      R0,[SP, #+40]
   \   0000052A   0x9000             STR      R0,[SP, #+0]
   4298          		if (fmt != FS_FAT32) {
   \   0000052C   0x9803             LDR      R0,[SP, #+12]
   \   0000052E   0x2803             CMP      R0,#+3
   \   00000530   0xD016             BEQ      ??f_mkfs_60
   4299          			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
   \   00000532   0x9803             LDR      R0,[SP, #+12]
   \   00000534   0x2801             CMP      R0,#+1
   \   00000536   0xD101             BNE      ??f_mkfs_61
   \   00000538   0x....             LDR      R0,??DataTable33_2  ;; 0xffff00
   \   0000053A   0xE001             B        ??f_mkfs_62
   \                     ??f_mkfs_61: (+1)
   \   0000053C   0x20FF             MOVS     R0,#+255
   \   0000053E   0x43C0             MVNS     R0,R0            ;; #-256
   \                     ??f_mkfs_62: (+1)
   \   00000540   0x9900             LDR      R1,[SP, #+0]
   \   00000542   0x4308             ORRS     R0,R0,R1
   \   00000544   0x9000             STR      R0,[SP, #+0]
   4300          			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
   \   00000546   0x9800             LDR      R0,[SP, #+0]
   \   00000548   0x7020             STRB     R0,[R4, #+0]
   \   0000054A   0x9800             LDR      R0,[SP, #+0]
   \   0000054C   0x0400             LSLS     R0,R0,#+16
   \   0000054E   0x0E00             LSRS     R0,R0,#+24
   \   00000550   0x7060             STRB     R0,[R4, #+1]
   \   00000552   0x9800             LDR      R0,[SP, #+0]
   \   00000554   0x0C00             LSRS     R0,R0,#+16
   \   00000556   0x70A0             STRB     R0,[R4, #+2]
   \   00000558   0x9800             LDR      R0,[SP, #+0]
   \   0000055A   0x0E00             LSRS     R0,R0,#+24
   \   0000055C   0x70E0             STRB     R0,[R4, #+3]
   \   0000055E   0xE01A             B        ??f_mkfs_63
   4301          		} else {
   4302          			n |= 0xFFFFFF00;
   \                     ??f_mkfs_60: (+1)
   \   00000560   0x9800             LDR      R0,[SP, #+0]
   \   00000562   0x21FF             MOVS     R1,#+255
   \   00000564   0x43C9             MVNS     R1,R1            ;; #-256
   \   00000566   0x4301             ORRS     R1,R1,R0
   \   00000568   0x9100             STR      R1,[SP, #+0]
   4303          			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
   \   0000056A   0x9800             LDR      R0,[SP, #+0]
   \   0000056C   0x7020             STRB     R0,[R4, #+0]
   \   0000056E   0x9800             LDR      R0,[SP, #+0]
   \   00000570   0x0400             LSLS     R0,R0,#+16
   \   00000572   0x0E00             LSRS     R0,R0,#+24
   \   00000574   0x7060             STRB     R0,[R4, #+1]
   \   00000576   0x9800             LDR      R0,[SP, #+0]
   \   00000578   0x0C00             LSRS     R0,R0,#+16
   \   0000057A   0x70A0             STRB     R0,[R4, #+2]
   \   0000057C   0x9800             LDR      R0,[SP, #+0]
   \   0000057E   0x0E00             LSRS     R0,R0,#+24
   \   00000580   0x70E0             STRB     R0,[R4, #+3]
   4304          			ST_DWORD(tbl + 4, 0xFFFFFFFF);
   \   00000582   0x20FF             MOVS     R0,#+255
   \   00000584   0x7120             STRB     R0,[R4, #+4]
   \   00000586   0x7160             STRB     R0,[R4, #+5]
   \   00000588   0x71A0             STRB     R0,[R4, #+6]
   \   0000058A   0x71E0             STRB     R0,[R4, #+7]
   4305          			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
   \   0000058C   0x7220             STRB     R0,[R4, #+8]
   \   0000058E   0x7260             STRB     R0,[R4, #+9]
   \   00000590   0x72A0             STRB     R0,[R4, #+10]
   \   00000592   0x200F             MOVS     R0,#+15
   \   00000594   0x72E0             STRB     R0,[R4, #+11]
   4306          		}
   4307          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   \                     ??f_mkfs_63: (+1)
   \   00000596   0x2301             MOVS     R3,#+1
   \   00000598   0x003A             MOVS     R2,R7
   \   0000059A   0x0021             MOVS     R1,R4
   \   0000059C   0x4668             MOV      R0,SP
   \   0000059E   0x7C00             LDRB     R0,[R0, #+16]
   \   000005A0   0x.... 0x....      BL       disk_write
   \   000005A4   0x1C7F             ADDS     R7,R7,#+1
   \   000005A6   0x2800             CMP      R0,#+0
   \   000005A8   0xD129             BNE      ??f_mkfs_13
   4308          			return FR_DISK_ERR;
   4309          		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
   \   000005AA   0x9802             LDR      R0,[SP, #+8]
   \   000005AC   0x8941             LDRH     R1,[R0, #+10]
   \   000005AE   0x0008             MOVS     R0,R1
   \   000005B0   0xD002             BEQ      ??f_mkfs_64
   \   000005B2   0x0020             MOVS     R0,R4
   \   000005B4   0x.... 0x....      BL       __aeabi_memclr
   4310          		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
   \                     ??f_mkfs_64: (+1)
   \   000005B8   0x2001             MOVS     R0,#+1
   \   000005BA   0xE00B             B        ??f_mkfs_65
   4311          			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   \                     ??f_mkfs_66: (+1)
   \   000005BC   0x2301             MOVS     R3,#+1
   \   000005BE   0x003A             MOVS     R2,R7
   \   000005C0   0x0021             MOVS     R1,R4
   \   000005C2   0x4668             MOV      R0,SP
   \   000005C4   0x7C00             LDRB     R0,[R0, #+16]
   \   000005C6   0x.... 0x....      BL       disk_write
   \   000005CA   0x1C7F             ADDS     R7,R7,#+1
   \   000005CC   0x2800             CMP      R0,#+0
   \   000005CE   0xD116             BNE      ??f_mkfs_13
   4312          				return FR_DISK_ERR;
   4313          		}
   \   000005D0   0x9800             LDR      R0,[SP, #+0]
   \   000005D2   0x1C40             ADDS     R0,R0,#+1
   \                     ??f_mkfs_65: (+1)
   \   000005D4   0x9000             STR      R0,[SP, #+0]
   \   000005D6   0x9800             LDR      R0,[SP, #+0]
   \   000005D8   0x9905             LDR      R1,[SP, #+20]
   \   000005DA   0x4288             CMP      R0,R1
   \   000005DC   0xD3EE             BCC      ??f_mkfs_66
   4314          	}
   4315          
   4316          	/* Initialize root directory */
   4317          	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
   \   000005DE   0x9803             LDR      R0,[SP, #+12]
   \   000005E0   0x2803             CMP      R0,#+3
   \   000005E2   0xD101             BNE      ??f_mkfs_67
   \   000005E4   0x9D0E             LDR      R5,[SP, #+56]
   \   000005E6   0xE000             B        ??f_mkfs_68
   \                     ??f_mkfs_67: (+1)
   \   000005E8   0x9D09             LDR      R5,[SP, #+36]
   4318          	do {
   4319          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   \                     ??f_mkfs_68: (+1)
   \   000005EA   0x2301             MOVS     R3,#+1
   \   000005EC   0x003A             MOVS     R2,R7
   \   000005EE   0x0021             MOVS     R1,R4
   \   000005F0   0x4668             MOV      R0,SP
   \   000005F2   0x7C00             LDRB     R0,[R0, #+16]
   \   000005F4   0x.... 0x....      BL       disk_write
   \   000005F8   0x1C7F             ADDS     R7,R7,#+1
   \   000005FA   0x2800             CMP      R0,#+0
   \   000005FC   0xD001             BEQ      ??f_mkfs_69
   4320          			return FR_DISK_ERR;
   \                     ??f_mkfs_13: (+1)
   \   000005FE   0x2001             MOVS     R0,#+1
   \   00000600   0xE078             B        ??f_mkfs_1
   4321          	} while (--i);
   \                     ??f_mkfs_69: (+1)
   \   00000602   0x1E6D             SUBS     R5,R5,#+1
   \   00000604   0xD1F1             BNE      ??f_mkfs_68
   4322          
   4323          #if _USE_TRIM	/* Erase data area if needed */
   4324          	{
   4325          		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
   \   00000606   0x970B             STR      R7,[SP, #+44]
   \   00000608   0x9803             LDR      R0,[SP, #+12]
   \   0000060A   0x2803             CMP      R0,#+3
   \   0000060C   0xD101             BNE      ??f_mkfs_70
   \   0000060E   0x2001             MOVS     R0,#+1
   \   00000610   0xE000             B        ??f_mkfs_71
   \                     ??f_mkfs_70: (+1)
   \   00000612   0x2000             MOVS     R0,#+0
   \                     ??f_mkfs_71: (+1)
   \   00000614   0x1A30             SUBS     R0,R6,R0
   \   00000616   0x990E             LDR      R1,[SP, #+56]
   \   00000618   0x4348             MULS     R0,R1,R0
   \   0000061A   0x1838             ADDS     R0,R7,R0
   \   0000061C   0x1E40             SUBS     R0,R0,#+1
   \   0000061E   0x900C             STR      R0,[SP, #+48]
   4326          		disk_ioctl(pdrv, CTRL_TRIM, eb);
   \   00000620   0xAA0B             ADD      R2,SP,#+44
   \   00000622   0x2104             MOVS     R1,#+4
   \   00000624   0x4668             MOV      R0,SP
   \   00000626   0x7C00             LDRB     R0,[R0, #+16]
   \   00000628   0x.... 0x....      BL       disk_ioctl
   4327          	}
   4328          #endif
   4329          
   4330          	/* Create FSINFO if needed */
   4331          	if (fmt == FS_FAT32) {
   \   0000062C   0x9803             LDR      R0,[SP, #+12]
   \   0000062E   0x2803             CMP      R0,#+3
   \   00000630   0xD156             BNE      ??f_mkfs_72
   4332          		ST_DWORD(tbl + FSI_LeadSig, 0x41615252);
   \   00000632   0x2052             MOVS     R0,#+82
   \   00000634   0x7020             STRB     R0,[R4, #+0]
   \   00000636   0x7060             STRB     R0,[R4, #+1]
   \   00000638   0x2061             MOVS     R0,#+97
   \   0000063A   0x70A0             STRB     R0,[R4, #+2]
   \   0000063C   0x2141             MOVS     R1,#+65
   \   0000063E   0x70E1             STRB     R1,[R4, #+3]
   4333          		ST_DWORD(tbl + FSI_StrucSig, 0x61417272);
   \   00000640   0x2272             MOVS     R2,#+114
   \   00000642   0x23F2             MOVS     R3,#+242
   \   00000644   0x005B             LSLS     R3,R3,#+1        ;; #+484
   \   00000646   0x54E2             STRB     R2,[R4, R3]
   \   00000648   0x18E3             ADDS     R3,R4,R3
   \   0000064A   0x705A             STRB     R2,[R3, #+1]
   \   0000064C   0x22F2             MOVS     R2,#+242
   \   0000064E   0x0052             LSLS     R2,R2,#+1        ;; #+484
   \   00000650   0x18A2             ADDS     R2,R4,R2
   \   00000652   0x7091             STRB     R1,[R2, #+2]
   \   00000654   0x21F2             MOVS     R1,#+242
   \   00000656   0x0049             LSLS     R1,R1,#+1        ;; #+484
   \   00000658   0x1861             ADDS     R1,R4,R1
   \   0000065A   0x70C8             STRB     R0,[R1, #+3]
   4334          		ST_DWORD(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
   \   0000065C   0x1E70             SUBS     R0,R6,#+1
   \   0000065E   0x21F2             MOVS     R1,#+242
   \   00000660   0x0049             LSLS     R1,R1,#+1        ;; #+484
   \   00000662   0x1861             ADDS     R1,R4,R1
   \   00000664   0x7108             STRB     R0,[R1, #+4]
   \   00000666   0x0400             LSLS     R0,R0,#+16
   \   00000668   0x0E00             LSRS     R0,R0,#+24
   \   0000066A   0x21F2             MOVS     R1,#+242
   \   0000066C   0x0049             LSLS     R1,R1,#+1        ;; #+484
   \   0000066E   0x1861             ADDS     R1,R4,R1
   \   00000670   0x7148             STRB     R0,[R1, #+5]
   \   00000672   0x1E76             SUBS     R6,R6,#+1
   \   00000674   0x0C30             LSRS     R0,R6,#+16
   \   00000676   0x21F2             MOVS     R1,#+242
   \   00000678   0x0049             LSLS     R1,R1,#+1        ;; #+484
   \   0000067A   0x1861             ADDS     R1,R4,R1
   \   0000067C   0x7188             STRB     R0,[R1, #+6]
   \   0000067E   0x0E30             LSRS     R0,R6,#+24
   \   00000680   0x21F2             MOVS     R1,#+242
   \   00000682   0x0049             LSLS     R1,R1,#+1        ;; #+484
   \   00000684   0x1861             ADDS     R1,R4,R1
   \   00000686   0x71C8             STRB     R0,[R1, #+7]
   4335          		ST_DWORD(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
   \   00000688   0x2002             MOVS     R0,#+2
   \   0000068A   0x21F2             MOVS     R1,#+242
   \   0000068C   0x0049             LSLS     R1,R1,#+1        ;; #+484
   \   0000068E   0x1861             ADDS     R1,R4,R1
   \   00000690   0x7208             STRB     R0,[R1, #+8]
   \   00000692   0x2000             MOVS     R0,#+0
   \   00000694   0x21F2             MOVS     R1,#+242
   \   00000696   0x0049             LSLS     R1,R1,#+1        ;; #+484
   \   00000698   0x1861             ADDS     R1,R4,R1
   \   0000069A   0x7248             STRB     R0,[R1, #+9]
   \   0000069C   0x21F2             MOVS     R1,#+242
   \   0000069E   0x0049             LSLS     R1,R1,#+1        ;; #+484
   \   000006A0   0x1861             ADDS     R1,R4,R1
   \   000006A2   0x7288             STRB     R0,[R1, #+10]
   \   000006A4   0x21F2             MOVS     R1,#+242
   \   000006A6   0x0049             LSLS     R1,R1,#+1        ;; #+484
   \   000006A8   0x1861             ADDS     R1,R4,R1
   \   000006AA   0x72C8             STRB     R0,[R1, #+11]
   4336          		ST_WORD(tbl + BS_55AA, 0xAA55);
   \   000006AC   0x2055             MOVS     R0,#+85
   \   000006AE   0x21F2             MOVS     R1,#+242
   \   000006B0   0x0049             LSLS     R1,R1,#+1        ;; #+484
   \   000006B2   0x1861             ADDS     R1,R4,R1
   \   000006B4   0x7688             STRB     R0,[R1, #+26]
   \   000006B6   0x20AA             MOVS     R0,#+170
   \   000006B8   0x21F2             MOVS     R1,#+242
   \   000006BA   0x0049             LSLS     R1,R1,#+1        ;; #+484
   \   000006BC   0x1861             ADDS     R1,R4,R1
   \   000006BE   0x76C8             STRB     R0,[R1, #+27]
   4337          		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR + 1) */
   \   000006C0   0x2301             MOVS     R3,#+1
   \   000006C2   0x9A06             LDR      R2,[SP, #+24]
   \   000006C4   0x1C52             ADDS     R2,R2,#+1
   \   000006C6   0x0021             MOVS     R1,R4
   \   000006C8   0x4668             MOV      R0,SP
   \   000006CA   0x7C00             LDRB     R0,[R0, #+16]
   \   000006CC   0x.... 0x....      BL       disk_write
   4338          		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR + 7) */
   \   000006D0   0x2301             MOVS     R3,#+1
   \   000006D2   0x9A06             LDR      R2,[SP, #+24]
   \   000006D4   0x1DD2             ADDS     R2,R2,#+7
   \   000006D6   0x0021             MOVS     R1,R4
   \   000006D8   0x4668             MOV      R0,SP
   \   000006DA   0x7C00             LDRB     R0,[R0, #+16]
   \   000006DC   0x.... 0x....      BL       disk_write
   4339          	}
   4340          
   4341          	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
   \                     ??f_mkfs_72: (+1)
   \   000006E0   0x2200             MOVS     R2,#+0
   \   000006E2   0x2100             MOVS     R1,#+0
   \   000006E4   0x4668             MOV      R0,SP
   \   000006E6   0x7C00             LDRB     R0,[R0, #+16]
   \   000006E8   0x.... 0x....      BL       disk_ioctl
   \   000006EC   0x1E40             SUBS     R0,R0,#+1
   \   000006EE   0x4180             SBCS     R0,R0,R0
   \   000006F0   0x43C0             MVNS     R0,R0
   \   000006F2   0x0FC0             LSRS     R0,R0,#+31
   \                     ??f_mkfs_1: (+1)
   \   000006F4   0xB00F             ADD      SP,SP,#+60
   \   000006F6   0xBDF0             POP      {R4-R7,PC}       ;; return
   4342          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     `f_mkfs::vst`:
   \   00000000   0x0400 0x0200      DC16 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 0
   \              0x0100 0x0080
   \              0x0040 0x0020
   \              0x0010 0x0008
   \              0x0004 0x0002
   \              0x0000       
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `f_mkfs::cst`:
   \   00000000   0x8000 0x4000      DC16 32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512
   \              0x2000 0x1000
   \              0x0800 0x4000
   \              0x2000 0x1000
   \              0x0800 0x0400
   \              0x0200       
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x0FFFFFFF         DC32     0xfffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x00011021         DC32     0x11021

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     LfnOfs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x22 0x2A          DC8 "\"*:<>?|\177"
   \              0x3A 0x3C    
   \              0x3E 0x3F    
   \              0x7C 0x7F    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x2B 0x2C          DC8 "+,;=[]"
   \              0x3B 0x3D    
   \              0x5B 0x5D    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     CurrVol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x0000AA55         DC32     0xaa55

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x00544146         DC32     0x544146

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0xFFFFFE00         DC32     0xfffffe00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x00000E01         DC32     0xe01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x00000FF6         DC32     0xff6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x0000FFF6         DC32     0xfff6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x0000AA55         DC32     0xaa55

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x41615252         DC32     0x41615252

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x61417272         DC32     0x61417272

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     CurrVol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x........         DC32     CurrVol+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x0FFFFFFF         DC32     0xfffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x........         DC32     CurrVol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x........         DC32     CurrVol+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x0FFFFFFF         DC32     0xfffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \   00000000   0x........         DC32     CurrVol+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x........         DC32     CurrVol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \   00000000   0x........         DC32     CurrVol+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \   00000000   0x........         DC32     ?_3+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_1:
   \   00000000   0x........         DC32     ?_4+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_2:
   \   00000000   0x00FFFF00         DC32     0xffff00

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0xEB 0xFE          DC8 "\353\376\220MSDOS5.0"
   \              0x90 0x4D    
   \              0x53 0x44    
   \              0x4F 0x53    
   \              0x35 0x2E    
   \              0x30 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x4E 0x4F          DC8 "NO NAME    FAT32   "
   \              0x20 0x4E    
   \              0x41 0x4D    
   \              0x45 0x20    
   \              0x20 0x20    
   \              0x20 0x46    
   \              0x41 0x54    
   \              0x33 0x32    
   \              0x20 0x20    
   \              0x20 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x4E 0x4F          DC8 "NO NAME    FAT     "
   \              0x20 0x4E    
   \              0x41 0x4D    
   \              0x45 0x20    
   \              0x20 0x20    
   \              0x20 0x46    
   \              0x41 0x54    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x00    
   4343          
   4344          
   4345          
   4346          #if _MULTI_PARTITION
   4347          /*-----------------------------------------------------------------------*/
   4348          /* Create partition table on the physical drive                          */
   4349          /*-----------------------------------------------------------------------*/
   4350          
   4351          FRESULT f_fdisk (
   4352          	BYTE pdrv,			/* Physical drive number */
   4353          	const DWORD szt[],	/* Pointer to the size table for each partitions */
   4354          	void* work			/* Pointer to the working buffer */
   4355          )
   4356          {
   4357          	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
   4358          	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
   4359          	DSTATUS stat;
   4360          	DWORD sz_disk, sz_part, s_part;
   4361          
   4362          
   4363          	stat = disk_initialize(pdrv);
   4364          	if (stat & STA_NOINIT) return FR_NOT_READY;
   4365          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   4366          	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
   4367          
   4368          	/* Determine CHS in the table regardless of the drive geometry */
   4369          	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
   4370          	if (n == 256) n--;
   4371          	e_hd = n - 1;
   4372          	sz_cyl = 63 * n;
   4373          	tot_cyl = sz_disk / sz_cyl;
   4374          
   4375          	/* Create partition table */
   4376          	mem_set(buf, 0, _MAX_SS);
   4377          	p = buf + MBR_Table; b_cyl = 0;
   4378          	for (i = 0; i < 4; i++, p += SZ_PTE) {
   4379          		p_cyl = (szt[i] <= 100U) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
   4380          		if (!p_cyl) continue;
   4381          		s_part = (DWORD)sz_cyl * b_cyl;
   4382          		sz_part = (DWORD)sz_cyl * p_cyl;
   4383          		if (i == 0) {	/* Exclude first track of cylinder 0 */
   4384          			s_hd = 1;
   4385          			s_part += 63; sz_part -= 63;
   4386          		} else {
   4387          			s_hd = 0;
   4388          		}
   4389          		e_cyl = b_cyl + p_cyl - 1;
   4390          		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
   4391          
   4392          		/* Set partition table */
   4393          		p[1] = s_hd;						/* Start head */
   4394          		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
   4395          		p[3] = (BYTE)b_cyl;					/* Start cylinder */
   4396          		p[4] = 0x06;						/* System type (temporary setting) */
   4397          		p[5] = e_hd;						/* End head */
   4398          		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
   4399          		p[7] = (BYTE)e_cyl;					/* End cylinder */
   4400          		ST_DWORD(p + 8, s_part);			/* Start sector in LBA */
   4401          		ST_DWORD(p + 12, sz_part);			/* Partition size */
   4402          
   4403          		/* Next partition */
   4404          		b_cyl += p_cyl;
   4405          	}
   4406          	ST_WORD(p, 0xAA55);
   4407          
   4408          	/* Write it to the MBR */
   4409          	return (disk_write(pdrv, buf, 0, 1) != RES_OK || disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) ? FR_DISK_ERR : FR_OK;
   4410          }
   4411          
   4412          
   4413          #endif /* _MULTI_PARTITION */
   4414          #endif /* _USE_MKFS && !_FS_READONLY */
   4415          
   4416          
   4417          
   4418          
   4419          #if _USE_STRFUNC
   4420          /*-----------------------------------------------------------------------*/
   4421          /* Get a string from the file                                            */
   4422          /*-----------------------------------------------------------------------*/
   4423          
   4424          TCHAR* f_gets (
   4425          	TCHAR* buff,	/* Pointer to the string buffer to read */
   4426          	int len,		/* Size of string buffer (characters) */
   4427          	FIL* fp			/* Pointer to the file object */
   4428          )
   4429          {
   4430          	int n = 0;
   4431          	TCHAR c, *p = buff;
   4432          	BYTE s[2];
   4433          	UINT rc;
   4434          
   4435          
   4436          	while (n < len - 1) {	/* Read characters until buffer gets filled */
   4437          #if _USE_LFN && _LFN_UNICODE
   4438          #if _STRF_ENCODE == 3		/* Read a character in UTF-8 */
   4439          		f_read(fp, s, 1, &rc);
   4440          		if (rc != 1) break;
   4441          		c = s[0];
   4442          		if (c >= 0x80) {
   4443          			if (c < 0xC0) continue;	/* Skip stray trailer */
   4444          			if (c < 0xE0) {			/* Two-byte sequence */
   4445          				f_read(fp, s, 1, &rc);
   4446          				if (rc != 1) break;
   4447          				c = (c & 0x1F) << 6 | (s[0] & 0x3F);
   4448          				if (c < 0x80) c = '?';
   4449          			} else {
   4450          				if (c < 0xF0) {		/* Three-byte sequence */
   4451          					f_read(fp, s, 2, &rc);
   4452          					if (rc != 2) break;
   4453          					c = c << 12 | (s[0] & 0x3F) << 6 | (s[1] & 0x3F);
   4454          					if (c < 0x800) c = '?';
   4455          				} else {			/* Reject four-byte sequence */
   4456          					c = '?';
   4457          				}
   4458          			}
   4459          		}
   4460          #elif _STRF_ENCODE == 2		/* Read a character in UTF-16BE */
   4461          		f_read(fp, s, 2, &rc);
   4462          		if (rc != 2) break;
   4463          		c = s[1] + (s[0] << 8);
   4464          #elif _STRF_ENCODE == 1		/* Read a character in UTF-16LE */
   4465          		f_read(fp, s, 2, &rc);
   4466          		if (rc != 2) break;
   4467          		c = s[0] + (s[1] << 8);
   4468          #else						/* Read a character in ANSI/OEM */
   4469          		f_read(fp, s, 1, &rc);
   4470          		if (rc != 1) break;
   4471          		c = s[0];
   4472          		if (IsDBCS1(c)) {
   4473          			f_read(fp, s, 1, &rc);
   4474          			if (rc != 1) break;
   4475          			c = (c << 8) + s[0];
   4476          		}
   4477          		c = ff_convert(c, 1);	/* OEM -> Unicode */
   4478          		if (!c) c = '?';
   4479          #endif
   4480          #else						/* Read a character without conversion */
   4481          		f_read(fp, s, 1, &rc);
   4482          		if (rc != 1) break;
   4483          		c = s[0];
   4484          #endif
   4485          		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
   4486          		*p++ = c;
   4487          		n++;
   4488          		if (c == '\n') break;		/* Break on EOL */
   4489          	}
   4490          	*p = 0;
   4491          	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
   4492          }
   4493          
   4494          
   4495          
   4496          
   4497          #if !_FS_READONLY
   4498          #include <stdarg.h>
   4499          /*-----------------------------------------------------------------------*/
   4500          /* Put a character to the file                                           */
   4501          /*-----------------------------------------------------------------------*/
   4502          
   4503          typedef struct {
   4504          	FIL* fp;
   4505          	int idx, nchr;
   4506          	BYTE buf[64];
   4507          } putbuff;
   4508          
   4509          
   4510          static
   4511          void putc_bfd (
   4512          	putbuff* pb,
   4513          	TCHAR c
   4514          )
   4515          {
   4516          	UINT bw;
   4517          	int i;
   4518          
   4519          
   4520          	if (_USE_STRFUNC == 2 && c == '\n')	 /* LF -> CRLF conversion */
   4521          		putc_bfd(pb, '\r');
   4522          
   4523          	i = pb->idx;	/* Buffer write index (-1:error) */
   4524          	if (i < 0) return;
   4525          
   4526          #if _USE_LFN && _LFN_UNICODE
   4527          #if _STRF_ENCODE == 3			/* Write a character in UTF-8 */
   4528          	if (c < 0x80) {				/* 7-bit */
   4529          		pb->buf[i++] = (BYTE)c;
   4530          	} else {
   4531          		if (c < 0x800) {		/* 11-bit */
   4532          			pb->buf[i++] = (BYTE)(0xC0 | c >> 6);
   4533          		} else {				/* 16-bit */
   4534          			pb->buf[i++] = (BYTE)(0xE0 | c >> 12);
   4535          			pb->buf[i++] = (BYTE)(0x80 | (c >> 6 & 0x3F));
   4536          		}
   4537          		pb->buf[i++] = (BYTE)(0x80 | (c & 0x3F));
   4538          	}
   4539          #elif _STRF_ENCODE == 2			/* Write a character in UTF-16BE */
   4540          	pb->buf[i++] = (BYTE)(c >> 8);
   4541          	pb->buf[i++] = (BYTE)c;
   4542          #elif _STRF_ENCODE == 1			/* Write a character in UTF-16LE */
   4543          	pb->buf[i++] = (BYTE)c;
   4544          	pb->buf[i++] = (BYTE)(c >> 8);
   4545          #else							/* Write a character in ANSI/OEM */
   4546          	c = ff_convert(c, 0);	/* Unicode -> OEM */
   4547          	if (!c) c = '?';
   4548          	if (c >= 0x100)
   4549          		pb->buf[i++] = (BYTE)(c >> 8);
   4550          	pb->buf[i++] = (BYTE)c;
   4551          #endif
   4552          #else							/* Write a character without conversion */
   4553          	pb->buf[i++] = (BYTE)c;
   4554          #endif
   4555          
   4556          	if (i >= (int)(sizeof pb->buf) - 3) {	/* Write buffered characters to the file */
   4557          		f_write(pb->fp, pb->buf, (UINT)i, &bw);
   4558          		i = (bw == (UINT)i) ? 0 : -1;
   4559          	}
   4560          	pb->idx = i;
   4561          	pb->nchr++;
   4562          }
   4563          
   4564          
   4565          
   4566          int f_putc (
   4567          	TCHAR c,	/* A character to be output */
   4568          	FIL* fp		/* Pointer to the file object */
   4569          )
   4570          {
   4571          	putbuff pb;
   4572          	UINT nw;
   4573          
   4574          
   4575          	pb.fp = fp;			/* Initialize output buffer */
   4576          	pb.nchr = pb.idx = 0;
   4577          
   4578          	putc_bfd(&pb, c);	/* Put a character */
   4579          
   4580          	if (   pb.idx >= 0	/* Flush buffered characters to the file */
   4581          		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
   4582          		&& (UINT)pb.idx == nw) return pb.nchr;
   4583          	return EOF;
   4584          }
   4585          
   4586          
   4587          
   4588          
   4589          /*-----------------------------------------------------------------------*/
   4590          /* Put a string to the file                                              */
   4591          /*-----------------------------------------------------------------------*/
   4592          
   4593          int f_puts (
   4594          	const TCHAR* str,	/* Pointer to the string to be output */
   4595          	FIL* fp				/* Pointer to the file object */
   4596          )
   4597          {
   4598          	putbuff pb;
   4599          	UINT nw;
   4600          
   4601          
   4602          	pb.fp = fp;				/* Initialize output buffer */
   4603          	pb.nchr = pb.idx = 0;
   4604          
   4605          	while (*str)			/* Put the string */
   4606          		putc_bfd(&pb, *str++);
   4607          
   4608          	if (   pb.idx >= 0		/* Flush buffered characters to the file */
   4609          		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
   4610          		&& (UINT)pb.idx == nw) return pb.nchr;
   4611          	return EOF;
   4612          }
   4613          
   4614          
   4615          
   4616          
   4617          /*-----------------------------------------------------------------------*/
   4618          /* Put a formatted string to the file                                    */
   4619          /*-----------------------------------------------------------------------*/
   4620          
   4621          int f_printf (
   4622          	FIL* fp,			/* Pointer to the file object */
   4623          	const TCHAR* fmt,	/* Pointer to the format string */
   4624          	...					/* Optional arguments... */
   4625          )
   4626          {
   4627          	va_list arp;
   4628          	BYTE f, r;
   4629          	UINT nw, i, j, w;
   4630          	DWORD v;
   4631          	TCHAR c, d, s[16], *p;
   4632          	putbuff pb;
   4633          
   4634          
   4635          	pb.fp = fp;				/* Initialize output buffer */
   4636          	pb.nchr = pb.idx = 0;
   4637          
   4638          	va_start(arp, fmt);
   4639          
   4640          	for (;;) {
   4641          		c = *fmt++;
   4642          		if (c == 0) break;			/* End of string */
   4643          		if (c != '%') {				/* Non escape character */
   4644          			putc_bfd(&pb, c);
   4645          			continue;
   4646          		}
   4647          		w = f = 0;
   4648          		c = *fmt++;
   4649          		if (c == '0') {				/* Flag: '0' padding */
   4650          			f = 1; c = *fmt++;
   4651          		} else {
   4652          			if (c == '-') {			/* Flag: left justified */
   4653          				f = 2; c = *fmt++;
   4654          			}
   4655          		}
   4656          		while (IsDigit(c)) {		/* Precision */
   4657          			w = w * 10 + c - '0';
   4658          			c = *fmt++;
   4659          		}
   4660          		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
   4661          			f |= 4; c = *fmt++;
   4662          		}
   4663          		if (!c) break;
   4664          		d = c;
   4665          		if (IsLower(d)) d -= 0x20;
   4666          		switch (d) {				/* Type is... */
   4667          		case 'S' :					/* String */
   4668          			p = va_arg(arp, TCHAR*);
   4669          			for (j = 0; p[j]; j++) ;
   4670          			if (!(f & 2)) {
   4671          				while (j++ < w) putc_bfd(&pb, ' ');
   4672          			}
   4673          			while (*p) putc_bfd(&pb, *p++);
   4674          			while (j++ < w) putc_bfd(&pb, ' ');
   4675          			continue;
   4676          		case 'C' :					/* Character */
   4677          			putc_bfd(&pb, (TCHAR)va_arg(arp, int)); continue;
   4678          		case 'B' :					/* Binary */
   4679          			r = 2; break;
   4680          		case 'O' :					/* Octal */
   4681          			r = 8; break;
   4682          		case 'D' :					/* Signed decimal */
   4683          		case 'U' :					/* Unsigned decimal */
   4684          			r = 10; break;
   4685          		case 'X' :					/* Hexdecimal */
   4686          			r = 16; break;
   4687          		default:					/* Unknown type (pass-through) */
   4688          			putc_bfd(&pb, c); continue;
   4689          		}
   4690          
   4691          		/* Get an argument and put it in numeral */
   4692          		v = (f & 4) ? (DWORD)va_arg(arp, long) : ((d == 'D') ? (DWORD)(long)va_arg(arp, int) : (DWORD)va_arg(arp, unsigned int));
   4693          		if (d == 'D' && (v & 0x80000000)) {
   4694          			v = 0 - v;
   4695          			f |= 8;
   4696          		}
   4697          		i = 0;
   4698          		do {
   4699          			d = (TCHAR)(v % r); v /= r;
   4700          			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
   4701          			s[i++] = d + '0';
   4702          		} while (v && i < sizeof s / sizeof s[0]);
   4703          		if (f & 8) s[i++] = '-';
   4704          		j = i; d = (f & 1) ? '0' : ' ';
   4705          		while (!(f & 2) && j++ < w) putc_bfd(&pb, d);
   4706          		do putc_bfd(&pb, s[--i]); while (i);
   4707          		while (j++ < w) putc_bfd(&pb, d);
   4708          	}
   4709          
   4710          	va_end(arp);
   4711          
   4712          	if (   pb.idx >= 0		/* Flush buffered characters to the file */
   4713          		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
   4714          		&& (UINT)pb.idx == nw) return pb.nchr;
   4715          	return EOF;
   4716          }
   4717          
   4718          #endif /* !_FS_READONLY */
   4719          #endif /* _USE_STRFUNC */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   check_fs(FATFS *, DWORD)
         8   -> move_window(FATFS *, DWORD)
       0   clust2sect(FATFS *, DWORD)
      24   create_chain(FATFS *, DWORD)
        24   -> get_fat(FATFS *, DWORD)
        24   -> put_fat(FATFS *, DWORD, DWORD)
      48   create_name(FATFS_DIR *, char const **)
        48   -> __aeabi_memset
        48   -> ff_convert
      48   dir_find(FATFS_DIR *)
        48   -> dir_next(FATFS_DIR *, int)
        48   -> dir_sdi(FATFS_DIR *, UINT)
        48   -> ff_wtoupper
        48   -> move_window(FATFS *, DWORD)
      24   dir_next(FATFS_DIR *, int)
        24   -> __aeabi_memclr
        24   -> clust2sect(FATFS *, DWORD)
        24   -> create_chain(FATFS *, DWORD)
        24   -> get_fat(FATFS *, DWORD)
        24   -> sync_window(FATFS *)
        24 __aeabi_uidiv
        24 __aeabi_uidivmod
      40   dir_read(FATFS_DIR *, int)
        40   -> dir_next(FATFS_DIR *, int)
        40   -> move_window(FATFS *, DWORD)
        40   -> sum_sfn(BYTE const *)
      56   dir_register(FATFS_DIR *)
        56   -> __aeabi_memclr
        56   -> clust2sect(FATFS *, DWORD)
        56   -> create_chain(FATFS *, DWORD)
        56   -> dir_find(FATFS_DIR *)
        56   -> dir_next(FATFS_DIR *, int)
        56   -> dir_sdi(FATFS_DIR *, UINT)
        56   -> disk_read
        56   -> gen_numname(BYTE *, BYTE const *, WCHAR const *, UINT)
        56   -> get_fat(FATFS *, DWORD)
        56   -> move_window(FATFS *, DWORD)
        56   -> sum_sfn(BYTE const *)
        56   -> sync_window(FATFS *)
        56 __aeabi_uidiv
        56 __aeabi_uidivmod
      24   dir_remove(FATFS_DIR *)
        24   -> __aeabi_memclr
        24   -> clust2sect(FATFS *, DWORD)
        24   -> dir_sdi(FATFS_DIR *, UINT)
        24   -> disk_read
        24   -> get_fat(FATFS *, DWORD)
        24   -> sync_window(FATFS *)
        24 __aeabi_uidiv
        24 __aeabi_uidivmod
      24   dir_sdi(FATFS_DIR *, UINT)
        24   -> clust2sect(FATFS *, DWORD)
        24   -> get_fat(FATFS *, DWORD)
        24 __aeabi_uidiv
        24 __aeabi_uidivmod
      64   f_chdir
        64   -> find_volume(FATFS **, char const **, BYTE)
        64   -> follow_path(FATFS_DIR *, char const *)
        64   -> ld_clust(FATFS *, BYTE const *)
       0   f_chdrive
      64   f_chmod
        64   -> find_volume(FATFS **, char const **, BYTE)
        64   -> follow_path(FATFS_DIR *, char const *)
        64   -> sync_fs(FATFS *)
       8   f_close
         8   -> f_sync
         8   -> validate(void *)
       8   f_closedir
         8   -> disk_status
      40   f_getfree
        40   -> disk_read
        40   -> find_volume(FATFS **, char const **, BYTE)
        40   -> get_fat(FATFS *, DWORD)
        40   -> sync_window(FATFS *)
      40   f_lseek
        40   -> clust2sect(FATFS *, DWORD)
        40   -> create_chain(FATFS *, DWORD)
        40   -> get_fat(FATFS *, DWORD)
        40   -> validate(void *)
        40 __aeabi_uidiv
        40 __aeabi_uidivmod
      80   f_mkdir
        80   -> __aeabi_memclr
        80   -> __aeabi_memset
        80   -> clust2sect(FATFS *, DWORD)
        80   -> create_chain(FATFS *, DWORD)
        80   -> dir_register(FATFS_DIR *)
        80   -> find_volume(FATFS **, char const **, BYTE)
        80   -> follow_path(FATFS_DIR *, char const *)
        80   -> get_fattime
        80   -> remove_chain(FATFS *, DWORD)
        80   -> st_clust(BYTE *, DWORD)
        80   -> sync_fs(FATFS *)
        80   -> sync_window(FATFS *)
      80   f_mkfs
        80   -> __aeabi_memclr
        80   -> disk_initialize
        80   -> disk_ioctl
        80   -> disk_write
        80   -> ff_memalloc
        80   -> get_fattime
        80 __aeabi_idiv
        80 __aeabi_uidiv
      24   f_mount
        24   -> ff_memfree
        24   -> find_volume(FATFS **, char const **, BYTE)
      80   f_open
        80   -> dir_register(FATFS_DIR *)
        80   -> find_volume(FATFS **, char const **, BYTE)
        80   -> follow_path(FATFS_DIR *, char const *)
        80   -> get_fattime
        80   -> ld_clust(FATFS *, BYTE const *)
        80   -> move_window(FATFS *, DWORD)
        80   -> remove_chain(FATFS *, DWORD)
      32   f_opendir
        32   -> dir_sdi(FATFS_DIR *, UINT)
        32   -> find_volume(FATFS **, char const **, BYTE)
        32   -> follow_path(FATFS_DIR *, char const *)
        32   -> ld_clust(FATFS *, BYTE const *)
      40   f_read
        40   -> disk_read
        40   -> get_fat(FATFS *, DWORD)
        40   -> sync_window(FATFS *)
        40   -> validate(void *)
        40 __aeabi_uidiv
        40 __aeabi_uidivmod
      24   f_readdir
        24   -> dir_next(FATFS_DIR *, int)
        24   -> dir_read(FATFS_DIR *, int)
        24   -> dir_sdi(FATFS_DIR *, UINT)
        24   -> get_fileinfo(FATFS_DIR *, FILINFO *)
        24   -> validate(void *)
     128   f_rename
       128   -> __aeabi_memcpy4
       128   -> clust2sect(FATFS *, DWORD)
       128   -> dir_register(FATFS_DIR *)
       128   -> dir_remove(FATFS_DIR *)
       128   -> find_volume(FATFS **, char const **, BYTE)
       128   -> follow_path(FATFS_DIR *, char const *)
       128   -> ld_clust(FATFS *, BYTE const *)
       128   -> move_window(FATFS *, DWORD)
       128   -> st_clust(BYTE *, DWORD)
       128   -> sync_fs(FATFS *)
      64   f_stat
        64   -> find_volume(FATFS **, char const **, BYTE)
        64   -> follow_path(FATFS_DIR *, char const *)
        64   -> get_fileinfo(FATFS_DIR *, FILINFO *)
      16   f_sync
        16   -> get_fattime
        16   -> move_window(FATFS *, DWORD)
        16   -> st_clust(BYTE *, DWORD)
        16   -> sync_fs(FATFS *)
        16   -> validate(void *)
      16   f_truncate
        16   -> get_fat(FATFS *, DWORD)
        16   -> put_fat(FATFS *, DWORD, DWORD)
        16   -> remove_chain(FATFS *, DWORD)
        16   -> validate(void *)
     104   f_unlink
       104   -> __aeabi_memcpy4
       104   -> dir_read(FATFS_DIR *, int)
       104   -> dir_remove(FATFS_DIR *)
       104   -> dir_sdi(FATFS_DIR *, UINT)
       104   -> find_volume(FATFS **, char const **, BYTE)
       104   -> follow_path(FATFS_DIR *, char const *)
       104   -> ld_clust(FATFS *, BYTE const *)
       104   -> remove_chain(FATFS *, DWORD)
       104   -> sync_fs(FATFS *)
      64   f_utime
        64   -> find_volume(FATFS **, char const **, BYTE)
        64   -> follow_path(FATFS_DIR *, char const *)
        64   -> sync_fs(FATFS *)
      48   f_write
        48   -> create_chain(FATFS *, DWORD)
        48   -> disk_read
        48   -> disk_write
        48   -> f_sync
        48   -> get_fat(FATFS *, DWORD)
        48   -> put_fat(FATFS *, DWORD, DWORD)
        48   -> sync_window(FATFS *)
        48   -> validate(void *)
        48 __aeabi_uidiv
        48 __aeabi_uidivmod
      64   find_volume(FATFS **, char const **, BYTE)
        64   -> check_fs(FATFS *, DWORD)
        64   -> disk_initialize
        64   -> disk_ioctl
        64   -> disk_status
        64   -> ff_memalloc
        64   -> get_ldnumber(char const **)
        64   -> move_window(FATFS *, DWORD)
        64 __aeabi_idiv
        64 __aeabi_idivmod
        64 __aeabi_uidiv
      16   follow_path(FATFS_DIR *, char const *)
        16   -> create_name(FATFS_DIR *, char const **)
        16   -> dir_find(FATFS_DIR *)
        16   -> dir_sdi(FATFS_DIR *, UINT)
      28   gen_numname(BYTE *, BYTE const *, WCHAR const *, UINT)
      32   get_fat(FATFS *, DWORD)
        32   -> move_window(FATFS *, DWORD)
        32 __aeabi_uidiv
        32 __aeabi_uidivmod
      24   get_fileinfo(FATFS_DIR *, FILINFO *)
        24   -> ff_convert
       4   get_ldnumber(char const **)
       0   ld_clust(FATFS *, BYTE const *)
      16   move_window(FATFS *, DWORD)
        16   -> disk_read
        16   -> sync_window(FATFS *)
      32   put_fat(FATFS *, DWORD, DWORD)
        32   -> move_window(FATFS *, DWORD)
        32 __aeabi_uidiv
        32 __aeabi_uidivmod
      48   remove_chain(FATFS *, DWORD)
        48   -> disk_ioctl
        48   -> get_fat(FATFS *, DWORD)
        48   -> move_window(FATFS *, DWORD)
        48 __aeabi_uidiv
        48 __aeabi_uidivmod
       0   st_clust(BYTE *, DWORD)
       0   sum_sfn(BYTE const *)
      16   sync_fs(FATFS *)
        16   -> __aeabi_memclr
        16   -> disk_ioctl
        16   -> disk_write
        16   -> sync_window(FATFS *)
      24   sync_window(FATFS *)
        24   -> disk_write
       8   validate(void *)
         8   -> disk_status


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable11
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable15
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable23
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable33_2
      12  ?_0
       8  ?_1
      12  ?_2
      20  ?_3
      20  ?_4
     532  CurrVol
          Fsid
          FatFs
          LfnBuf
     128  ExCvt
      16  LfnOfs
     100  check_fs(FATFS *, DWORD)
      24  clust2sect(FATFS *, DWORD)
     174  create_chain(FATFS *, DWORD)
     604  create_name(FATFS_DIR *, char const **)
      24  cst
     386  dir_find(FATFS_DIR *)
     256  dir_next(FATFS_DIR *, int)
     286  dir_read(FATFS_DIR *, int)
     806  dir_register(FATFS_DIR *)
     246  dir_remove(FATFS_DIR *)
     156  dir_sdi(FATFS_DIR *, UINT)
      78  f_chdir
      64  f_chdrive
      92  f_chmod
      28  f_close
      48  f_closedir
     246  f_getfree
     330  f_lseek
     390  f_mkdir
    1784  f_mkfs
     134  f_mount
     368  f_open
     104  f_opendir
     422  f_read
      88  f_readdir
     340  f_rename
      68  f_stat
     120  f_sync
     144  f_truncate
     168  f_unlink
      94  f_utime
     644  f_write
     842  find_volume(FATFS **, char const **, BYTE)
     156  follow_path(FATFS_DIR *, char const *)
     162  gen_numname(BYTE *, BYTE const *, WCHAR const *, UINT)
     260  get_fat(FATFS *, DWORD)
     214  get_fileinfo(FATFS_DIR *, FILINFO *)
      70  get_ldnumber(char const **)
      32  ld_clust(FATFS *, BYTE const *)
      52  move_window(FATFS *, DWORD)
     306  put_fat(FATFS *, DWORD, DWORD)
     446  remove_chain(FATFS *, DWORD)
      18  st_clust(BYTE *, DWORD)
      26  sum_sfn(BYTE const *)
     224  sync_fs(FATFS *)
      80  sync_window(FATFS *)
      44  validate(void *)
      24  vst

 
    532 bytes in section .bss
    100 bytes in section .rodata
 11 996 bytes in section .text
 
 11 996 bytes of CODE  memory
    100 bytes of CONST memory
    532 bytes of DATA  memory

Errors: none
Warnings: none

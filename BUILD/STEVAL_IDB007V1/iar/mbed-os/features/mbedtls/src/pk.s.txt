###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:31
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\features\mbedtls\src\pk.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\pk.d -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\pk.s.txt -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\pk.o
#        .\mbed-os\features\mbedtls\src\pk.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\pk.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\pk.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\features\mbedtls\src\pk.c
      1          /*
      2           *  Public Key abstraction layer
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          
     22          #if !defined(MBEDTLS_CONFIG_FILE)
     23          #include "mbedtls/config.h"
     24          #else
     25          #include MBEDTLS_CONFIG_FILE
     26          #endif
     27          
     28          #if defined(MBEDTLS_PK_C)
     29          #include "mbedtls/pk.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp struct <unnamed> *mbedtls_pk_rsa(struct <unnamed> const)
   \                     mbedtls_pk_rsa: (+1)
   \   00000000   0x0008             MOVS     R0,R1
   \   00000002   0x4770             BX       LR               ;; return
     30          #include "mbedtls/pk_internal.h"
     31          
     32          #include "mbedtls/bignum.h"
     33          
     34          #if defined(MBEDTLS_RSA_C)
     35          #include "mbedtls/rsa.h"
     36          #endif
     37          #if defined(MBEDTLS_ECP_C)
     38          #include "mbedtls/ecp.h"
     39          #endif
     40          #if defined(MBEDTLS_ECDSA_C)
     41          #include "mbedtls/ecdsa.h"
     42          #endif
     43          
     44          #include <limits.h>
     45          
     46          /* Implementation that should never be optimized out by the compiler */
     47          static void mbedtls_zeroize( void *v, size_t n ) {
     48              volatile unsigned char *p = v; while( n-- ) *p++ = 0;
     49          }
     50          
     51          /*
     52           * Initialise a mbedtls_pk_context
     53           */

   \                                 In section .text, align 2, keep-with-next
     54          void mbedtls_pk_init( mbedtls_pk_context *ctx )
     55          {
     56              if( ctx == NULL )
   \                     mbedtls_pk_init: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD002             BEQ      ??mbedtls_pk_init_0
     57                  return;
     58          
     59              ctx->pk_info = NULL;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6001             STR      R1,[R0, #+0]
     60              ctx->pk_ctx = NULL;
   \   00000008   0x6041             STR      R1,[R0, #+4]
     61          }
   \                     ??mbedtls_pk_init_0: (+1)
   \   0000000A   0x4770             BX       LR               ;; return
     62          
     63          /*
     64           * Free (the components of) a mbedtls_pk_context
     65           */

   \                                 In section .text, align 2, keep-with-next
     66          void mbedtls_pk_free( mbedtls_pk_context *ctx )
     67          {
   \                     mbedtls_pk_free: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     68              if( ctx == NULL || ctx->pk_info == NULL )
   \   00000004   0xD009             BEQ      ??mbedtls_pk_free_0
   \   00000006   0x6821             LDR      R1,[R4, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD006             BEQ      ??mbedtls_pk_free_0
     69                  return;
     70          
     71              ctx->pk_info->ctx_free_func( ctx->pk_ctx );
   \   0000000C   0x6860             LDR      R0,[R4, #+4]
   \   0000000E   0x6A89             LDR      R1,[R1, #+40]
   \   00000010   0x4788             BLX      R1
     72          
     73              mbedtls_zeroize( ctx, sizeof( mbedtls_pk_context ) );
   \   00000012   0x2108             MOVS     R1,#+8
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       __aeabi_memclr
     74          }
   \                     ??mbedtls_pk_free_0: (+1)
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
     75          
     76          /*
     77           * Get pk_info structure from type
     78           */

   \                                 In section .text, align 2, keep-with-next
     79          const mbedtls_pk_info_t * mbedtls_pk_info_from_type( mbedtls_pk_type_t pk_type )
     80          {
     81              switch( pk_type ) {
   \                     mbedtls_pk_info_from_type: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD006             BEQ      ??mbedtls_pk_info_from_type_0
   \   00000004   0xD30D             BCC      ??mbedtls_pk_info_from_type_1
   \   00000006   0x2803             CMP      R0,#+3
   \   00000008   0xD007             BEQ      ??mbedtls_pk_info_from_type_2
   \   0000000A   0xD304             BCC      ??mbedtls_pk_info_from_type_3
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD006             BEQ      ??mbedtls_pk_info_from_type_4
   \   00000010   0xE007             B        ??mbedtls_pk_info_from_type_1
     82          #if defined(MBEDTLS_RSA_C)
     83                  case MBEDTLS_PK_RSA:
     84                      return( &mbedtls_rsa_info );
   \                     ??mbedtls_pk_info_from_type_0: (+1)
   \   00000012   0x....             LDR      R0,??DataTable8
   \   00000014   0x4770             BX       LR
     85          #endif
     86          #if defined(MBEDTLS_ECP_C)
     87                  case MBEDTLS_PK_ECKEY:
     88                      return( &mbedtls_eckey_info );
   \                     ??mbedtls_pk_info_from_type_3: (+1)
   \   00000016   0x....             LDR      R0,??DataTable9
   \   00000018   0x4770             BX       LR
     89                  case MBEDTLS_PK_ECKEY_DH:
     90                      return( &mbedtls_eckeydh_info );
   \                     ??mbedtls_pk_info_from_type_2: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable9_1
   \   0000001C   0x4770             BX       LR
     91          #endif
     92          #if defined(MBEDTLS_ECDSA_C)
     93                  case MBEDTLS_PK_ECDSA:
     94                      return( &mbedtls_ecdsa_info );
   \                     ??mbedtls_pk_info_from_type_4: (+1)
   \   0000001E   0x....             LDR      R0,??DataTable9_2
   \   00000020   0x4770             BX       LR
     95          #endif
     96                  /* MBEDTLS_PK_RSA_ALT omitted on purpose */
     97                  default:
     98                      return( NULL );
   \                     ??mbedtls_pk_info_from_type_1: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x4770             BX       LR               ;; return
     99              }
    100          }
    101          
    102          /*
    103           * Initialise context
    104           */

   \                                 In section .text, align 2, keep-with-next
    105          int mbedtls_pk_setup( mbedtls_pk_context *ctx, const mbedtls_pk_info_t *info )
    106          {
   \                     mbedtls_pk_setup: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    107              if( ctx == NULL || info == NULL || ctx->pk_info != NULL )
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD004             BEQ      ??mbedtls_pk_setup_0
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD002             BEQ      ??mbedtls_pk_setup_0
   \   0000000E   0x6828             LDR      R0,[R5, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ      ??mbedtls_pk_setup_1
    108                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \                     ??mbedtls_pk_setup_0: (+1)
   \   00000014   0x....             LDR      R0,??DataTable9_3  ;; 0xffffc180
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}
    109          
    110              if( ( ctx->pk_ctx = info->ctx_alloc_func() ) == NULL )
   \                     ??mbedtls_pk_setup_1: (+1)
   \   00000018   0x6A60             LDR      R0,[R4, #+36]
   \   0000001A   0x4780             BLX      R0
   \   0000001C   0x6068             STR      R0,[R5, #+4]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD101             BNE      ??mbedtls_pk_setup_2
    111                  return( MBEDTLS_ERR_PK_ALLOC_FAILED );
   \   00000022   0x....             LDR      R0,??DataTable10  ;; 0xffffc080
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}
    112          
    113              ctx->pk_info = info;
   \                     ??mbedtls_pk_setup_2: (+1)
   \   00000026   0x602C             STR      R4,[R5, #+0]
    114          
    115              return( 0 );
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    116          }
    117          
    118          #if defined(MBEDTLS_PK_RSA_ALT_SUPPORT)
    119          /*
    120           * Initialize an RSA-alt context
    121           */

   \                                 In section .text, align 2, keep-with-next
    122          int mbedtls_pk_setup_rsa_alt( mbedtls_pk_context *ctx, void * key,
    123                                   mbedtls_pk_rsa_alt_decrypt_func decrypt_func,
    124                                   mbedtls_pk_rsa_alt_sign_func sign_func,
    125                                   mbedtls_pk_rsa_alt_key_len_func key_len_func )
    126          {
   \                     mbedtls_pk_setup_rsa_alt: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0017             MOVS     R7,R2
   \   00000006   0x001D             MOVS     R5,R3
    127              mbedtls_rsa_alt_context *rsa_alt;
    128              const mbedtls_pk_info_t *info = &mbedtls_rsa_alt_info;
    129          
    130              if( ctx == NULL || ctx->pk_info != NULL )
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD002             BEQ      ??mbedtls_pk_setup_rsa_alt_0
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD001             BEQ      ??mbedtls_pk_setup_rsa_alt_1
    131                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \                     ??mbedtls_pk_setup_rsa_alt_0: (+1)
   \   00000012   0x....             LDR      R0,??DataTable9_3  ;; 0xffffc180
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
    132          
    133              if( ( ctx->pk_ctx = info->ctx_alloc_func() ) == NULL )
   \                     ??mbedtls_pk_setup_rsa_alt_1: (+1)
   \   00000016   0x....             LDR      R6,??DataTable10_1
   \   00000018   0x6A70             LDR      R0,[R6, #+36]
   \   0000001A   0x4780             BLX      R0
   \   0000001C   0x6060             STR      R0,[R4, #+4]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD101             BNE      ??mbedtls_pk_setup_rsa_alt_2
    134                  return( MBEDTLS_ERR_PK_ALLOC_FAILED );
   \   00000022   0x....             LDR      R0,??DataTable10  ;; 0xffffc080
   \   00000024   0xBDF2             POP      {R1,R4-R7,PC}
    135          
    136              ctx->pk_info = info;
   \                     ??mbedtls_pk_setup_rsa_alt_2: (+1)
   \   00000026   0x6026             STR      R6,[R4, #+0]
    137          
    138              rsa_alt = (mbedtls_rsa_alt_context *) ctx->pk_ctx;
    139          
    140              rsa_alt->key = key;
   \   00000028   0x9900             LDR      R1,[SP, #+0]
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    141              rsa_alt->decrypt_func = decrypt_func;
   \   0000002C   0x6047             STR      R7,[R0, #+4]
    142              rsa_alt->sign_func = sign_func;
   \   0000002E   0x6085             STR      R5,[R0, #+8]
    143              rsa_alt->key_len_func = key_len_func;
   \   00000030   0x9906             LDR      R1,[SP, #+24]
   \   00000032   0x60C1             STR      R1,[R0, #+12]
    144          
    145              return( 0 );
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    146          }
    147          #endif /* MBEDTLS_PK_RSA_ALT_SUPPORT */
    148          
    149          /*
    150           * Tell if a PK can do the operations of the given type
    151           */

   \                                 In section .text, align 2, keep-with-next
    152          int mbedtls_pk_can_do( const mbedtls_pk_context *ctx, mbedtls_pk_type_t type )
    153          {
   \                     mbedtls_pk_can_do: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    154              /* null or NONE context can't do anything */
    155              if( ctx == NULL || ctx->pk_info == NULL )
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD002             BEQ      ??mbedtls_pk_can_do_0
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD101             BNE      ??mbedtls_pk_can_do_1
    156                  return( 0 );
   \                     ??mbedtls_pk_can_do_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD02             POP      {R1,PC}
    157          
    158              return( ctx->pk_info->can_do( type ) );
   \                     ??mbedtls_pk_can_do_1: (+1)
   \   00000010   0x0008             MOVS     R0,R1
   \   00000012   0x68D1             LDR      R1,[R2, #+12]
   \   00000014   0x4788             BLX      R1
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    159          }
    160          
    161          /*
    162           * Helper for mbedtls_pk_sign and mbedtls_pk_verify
    163           */
    164          static inline int pk_hashlen_helper( mbedtls_md_type_t md_alg, size_t *hash_len )
    165          {
    166              const mbedtls_md_info_t *md_info;
    167          
    168              if( *hash_len != 0 )
    169                  return( 0 );
    170          
    171              if( ( md_info = mbedtls_md_info_from_type( md_alg ) ) == NULL )
    172                  return( -1 );
    173          
    174              *hash_len = mbedtls_md_get_size( md_info );
    175              return( 0 );
    176          }
    177          
    178          /*
    179           * Verify a signature
    180           */

   \                                 In section .text, align 2, keep-with-next
    181          int mbedtls_pk_verify( mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
    182                         const unsigned char *hash, size_t hash_len,
    183                         const unsigned char *sig, size_t sig_len )
    184          {
   \                     mbedtls_pk_verify: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    185              if( ctx == NULL || ctx->pk_info == NULL ||
    186                  pk_hashlen_helper( md_alg, &hash_len ) != 0 )
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD012             BEQ      ??mbedtls_pk_verify_0
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD00F             BEQ      ??mbedtls_pk_verify_0
   \   00000014   0x2B00             CMP      R3,#+0
   \   00000016   0xD107             BNE      ??mbedtls_pk_verify_1
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       mbedtls_md_info_from_type
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD008             BEQ      ??mbedtls_pk_verify_0
   \   00000022   0x.... 0x....      BL       mbedtls_md_get_size
   \   00000026   0x0003             MOVS     R3,R0
   \                     ??mbedtls_pk_verify_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6907             LDR      R7,[R0, #+16]
   \   0000002C   0x0038             MOVS     R0,R7
   \   0000002E   0xD103             BNE      ??mbedtls_pk_verify_2
    187                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
    188          
    189              if( ctx->pk_info->verify_func == NULL )
    190                  return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
   \   00000030   0x....             LDR      R0,??DataTable10_2  ;; 0xffffc100
   \   00000032   0xE009             B        ??mbedtls_pk_verify_3
   \                     ??mbedtls_pk_verify_0: (+1)
   \   00000034   0x....             LDR      R0,??DataTable10_3  ;; 0xffffc180
   \   00000036   0xE007             B        ??mbedtls_pk_verify_3
    191          
    192              return( ctx->pk_info->verify_func( ctx->pk_ctx, md_alg, hash, hash_len,
    193                                                 sig, sig_len ) );
   \                     ??mbedtls_pk_verify_2: (+1)
   \   00000038   0x9809             LDR      R0,[SP, #+36]
   \   0000003A   0x9001             STR      R0,[SP, #+4]
   \   0000003C   0x9808             LDR      R0,[SP, #+32]
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0x0032             MOVS     R2,R6
   \   00000042   0x0029             MOVS     R1,R5
   \   00000044   0x6860             LDR      R0,[R4, #+4]
   \   00000046   0x47B8             BLX      R7
   \                     ??mbedtls_pk_verify_3: (+1)
   \   00000048   0xB003             ADD      SP,SP,#+12
   \   0000004A   0xBDF0             POP      {R4-R7,PC}       ;; return
    194          }
    195          
    196          /*
    197           * Verify a signature with options
    198           */

   \                                 In section .text, align 2, keep-with-next
    199          int mbedtls_pk_verify_ext( mbedtls_pk_type_t type, const void *options,
    200                             mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
    201                             const unsigned char *hash, size_t hash_len,
    202                             const unsigned char *sig, size_t sig_len )
    203          {
   \                     mbedtls_pk_verify_ext: (+1)
   \   00000000   0xB5FA             PUSH     {R1,R3-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x0014             MOVS     R4,R2
    204              if( ctx == NULL || ctx->pk_info == NULL )
   \   00000008   0xD047             BEQ      ??mbedtls_pk_verify_ext_0
   \   0000000A   0x6821             LDR      R1,[R4, #+0]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD044             BEQ      ??mbedtls_pk_verify_ext_0
    205                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
    206          
    207              if( ! mbedtls_pk_can_do( ctx, type ) )
   \   00000010   0x68C9             LDR      R1,[R1, #+12]
   \   00000012   0x4788             BLX      R1
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD101             BNE      ??mbedtls_pk_verify_ext_1
    208                  return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
   \   00000018   0x....             LDR      R0,??DataTable10_2  ;; 0xffffc100
   \   0000001A   0xE04A             B        ??mbedtls_pk_verify_ext_2
   \                     ??mbedtls_pk_verify_ext_1: (+1)
   \   0000001C   0x9F0F             LDR      R7,[SP, #+60]
   \   0000001E   0x9E10             LDR      R6,[SP, #+64]
    209          
    210              if( type == MBEDTLS_PK_RSASSA_PSS )
   \   00000020   0x2D06             CMP      R5,#+6
   \   00000022   0x9807             LDR      R0,[SP, #+28]
   \   00000024   0xD137             BNE      ??mbedtls_pk_verify_ext_3
    211              {
    212          #if defined(MBEDTLS_RSA_C) && defined(MBEDTLS_PKCS1_V21)
    213                  int ret;
    214                  const mbedtls_pk_rsassa_pss_options *pss_opts;
    215          
    216          #if defined(MBEDTLS_HAVE_INT64)
    217                  if( md_alg == MBEDTLS_MD_NONE && UINT_MAX < hash_len )
    218                      return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
    219          #endif /* MBEDTLS_HAVE_INT64 */
    220          
    221                  if( options == NULL )
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD037             BEQ      ??mbedtls_pk_verify_ext_0
    222                      return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
    223          
    224                  pss_opts = (const mbedtls_pk_rsassa_pss_options *) options;
    225          
    226                  if( sig_len < mbedtls_pk_get_len( ctx ) )
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD005             BEQ      ??mbedtls_pk_verify_ext_4
   \   00000030   0x6860             LDR      R0,[R4, #+4]
   \   00000032   0x6889             LDR      R1,[R1, #+8]
   \   00000034   0x4788             BLX      R1
   \   00000036   0x1DC0             ADDS     R0,R0,#+7
   \   00000038   0x08C0             LSRS     R0,R0,#+3
   \   0000003A   0xE000             B        ??mbedtls_pk_verify_ext_5
   \                     ??mbedtls_pk_verify_ext_4: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_pk_verify_ext_5: (+1)
   \   0000003E   0x9911             LDR      R1,[SP, #+68]
   \   00000040   0x4281             CMP      R1,R0
   \   00000042   0xD201             BCS      ??mbedtls_pk_verify_ext_6
    227                      return( MBEDTLS_ERR_RSA_VERIFY_FAILED );
   \   00000044   0x....             LDR      R0,??DataTable10_4  ;; 0xffffbc80
   \   00000046   0xE034             B        ??mbedtls_pk_verify_ext_2
    228          
    229                  ret = mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_pk_rsa( *ctx ),
    230                          NULL, NULL, MBEDTLS_RSA_PUBLIC,
    231                          md_alg, (unsigned int) hash_len, hash,
    232                          pss_opts->mgf1_hash_id,
    233                          pss_opts->expected_salt_len,
    234                          sig );
   \                     ??mbedtls_pk_verify_ext_6: (+1)
   \   00000048   0xCC03             LDM      R4!,{R0,R1}
   \   0000004A   0x3C08             SUBS     R4,R4,#+8
   \   0000004C   0x.... 0x....      BL       mbedtls_pk_rsa
   \   00000050   0x9605             STR      R6,[SP, #+20]
   \   00000052   0x9907             LDR      R1,[SP, #+28]
   \   00000054   0x6849             LDR      R1,[R1, #+4]
   \   00000056   0x9104             STR      R1,[SP, #+16]
   \   00000058   0x9907             LDR      R1,[SP, #+28]
   \   0000005A   0x7809             LDRB     R1,[R1, #+0]
   \   0000005C   0x9103             STR      R1,[SP, #+12]
   \   0000005E   0x990E             LDR      R1,[SP, #+56]
   \   00000060   0x9102             STR      R1,[SP, #+8]
   \   00000062   0x9701             STR      R7,[SP, #+4]
   \   00000064   0xA908             ADD      R1,SP,#+32
   \   00000066   0x7809             LDRB     R1,[R1, #+0]
   \   00000068   0x9100             STR      R1,[SP, #+0]
   \   0000006A   0x2300             MOVS     R3,#+0
   \   0000006C   0x2200             MOVS     R2,#+0
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x.... 0x....      BL       mbedtls_rsa_rsassa_pss_verify_ext
    235                  if( ret != 0 )
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD11C             BNE      ??mbedtls_pk_verify_ext_2
    236                      return( ret );
    237          
    238                  if( sig_len > mbedtls_pk_get_len( ctx ) )
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0x2900             CMP      R1,#+0
   \   0000007C   0xD004             BEQ      ??mbedtls_pk_verify_ext_7
   \   0000007E   0x6860             LDR      R0,[R4, #+4]
   \   00000080   0x6889             LDR      R1,[R1, #+8]
   \   00000082   0x4788             BLX      R1
   \   00000084   0x1DC0             ADDS     R0,R0,#+7
   \   00000086   0x08C0             LSRS     R0,R0,#+3
   \                     ??mbedtls_pk_verify_ext_7: (+1)
   \   00000088   0x9911             LDR      R1,[SP, #+68]
   \   0000008A   0x4288             CMP      R0,R1
   \   0000008C   0xD201             BCS      ??mbedtls_pk_verify_ext_8
    239                      return( MBEDTLS_ERR_PK_SIG_LEN_MISMATCH );
   \   0000008E   0x....             LDR      R0,??DataTable10_5  ;; 0xffffc700
   \   00000090   0xE00F             B        ??mbedtls_pk_verify_ext_2
    240          
    241                  return( 0 );
   \                     ??mbedtls_pk_verify_ext_8: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xE00D             B        ??mbedtls_pk_verify_ext_2
    242          #else
    243                  return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );
    244          #endif /* MBEDTLS_RSA_C && MBEDTLS_PKCS1_V21 */
    245              }
    246          
    247              /* General case: no options */
    248              if( options != NULL )
   \                     ??mbedtls_pk_verify_ext_3: (+1)
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD001             BEQ      ??mbedtls_pk_verify_ext_9
    249                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \                     ??mbedtls_pk_verify_ext_0: (+1)
   \   0000009A   0x....             LDR      R0,??DataTable10_3  ;; 0xffffc180
   \   0000009C   0xE009             B        ??mbedtls_pk_verify_ext_2
    250          
    251              return( mbedtls_pk_verify( ctx, md_alg, hash, hash_len, sig, sig_len ) );
   \                     ??mbedtls_pk_verify_ext_9: (+1)
   \   0000009E   0x9811             LDR      R0,[SP, #+68]
   \   000000A0   0x9001             STR      R0,[SP, #+4]
   \   000000A2   0x9600             STR      R6,[SP, #+0]
   \   000000A4   0x003B             MOVS     R3,R7
   \   000000A6   0x9A0E             LDR      R2,[SP, #+56]
   \   000000A8   0xA808             ADD      R0,SP,#+32
   \   000000AA   0x7801             LDRB     R1,[R0, #+0]
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x.... 0x....      BL       mbedtls_pk_verify
   \                     ??mbedtls_pk_verify_ext_2: (+1)
   \   000000B2   0xB009             ADD      SP,SP,#+36
   \   000000B4   0xBDF0             POP      {R4-R7,PC}       ;; return
    252          }
    253          
    254          /*
    255           * Make a signature
    256           */

   \                                 In section .text, align 2, keep-with-next
    257          int mbedtls_pk_sign( mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
    258                       const unsigned char *hash, size_t hash_len,
    259                       unsigned char *sig, size_t *sig_len,
    260                       int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    261          {
   \                     mbedtls_pk_sign: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    262              if( ctx == NULL || ctx->pk_info == NULL ||
    263                  pk_hashlen_helper( md_alg, &hash_len ) != 0 )
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD012             BEQ      ??mbedtls_pk_sign_0
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD00F             BEQ      ??mbedtls_pk_sign_0
   \   00000014   0x2B00             CMP      R3,#+0
   \   00000016   0xD107             BNE      ??mbedtls_pk_sign_1
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       mbedtls_md_info_from_type
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD008             BEQ      ??mbedtls_pk_sign_0
   \   00000022   0x.... 0x....      BL       mbedtls_md_get_size
   \   00000026   0x0003             MOVS     R3,R0
   \                     ??mbedtls_pk_sign_1: (+1)
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6947             LDR      R7,[R0, #+20]
   \   0000002C   0x0038             MOVS     R0,R7
   \   0000002E   0xD103             BNE      ??mbedtls_pk_sign_2
    264                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
    265          
    266              if( ctx->pk_info->sign_func == NULL )
    267                  return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
   \   00000030   0x....             LDR      R0,??DataTable10_2  ;; 0xffffc100
   \   00000032   0xE00D             B        ??mbedtls_pk_sign_3
   \                     ??mbedtls_pk_sign_0: (+1)
   \   00000034   0x....             LDR      R0,??DataTable10_3  ;; 0xffffc180
   \   00000036   0xE00B             B        ??mbedtls_pk_sign_3
    268          
    269              return( ctx->pk_info->sign_func( ctx->pk_ctx, md_alg, hash, hash_len,
    270                                               sig, sig_len, f_rng, p_rng ) );
   \                     ??mbedtls_pk_sign_2: (+1)
   \   00000038   0x980D             LDR      R0,[SP, #+52]
   \   0000003A   0x9003             STR      R0,[SP, #+12]
   \   0000003C   0x980C             LDR      R0,[SP, #+48]
   \   0000003E   0x9002             STR      R0,[SP, #+8]
   \   00000040   0x980B             LDR      R0,[SP, #+44]
   \   00000042   0x9001             STR      R0,[SP, #+4]
   \   00000044   0x980A             LDR      R0,[SP, #+40]
   \   00000046   0x9000             STR      R0,[SP, #+0]
   \   00000048   0x0032             MOVS     R2,R6
   \   0000004A   0x0029             MOVS     R1,R5
   \   0000004C   0x6860             LDR      R0,[R4, #+4]
   \   0000004E   0x47B8             BLX      R7
   \                     ??mbedtls_pk_sign_3: (+1)
   \   00000050   0xB005             ADD      SP,SP,#+20
   \   00000052   0xBDF0             POP      {R4-R7,PC}       ;; return
    271          }
    272          
    273          /*
    274           * Decrypt message
    275           */

   \                                 In section .text, align 2, keep-with-next
    276          int mbedtls_pk_decrypt( mbedtls_pk_context *ctx,
    277                          const unsigned char *input, size_t ilen,
    278                          unsigned char *output, size_t *olen, size_t osize,
    279                          int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    280          {
   \                     mbedtls_pk_decrypt: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    281              if( ctx == NULL || ctx->pk_info == NULL )
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD002             BEQ      ??mbedtls_pk_decrypt_0
   \   00000008   0x6804             LDR      R4,[R0, #+0]
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE      ??mbedtls_pk_decrypt_1
    282                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \                     ??mbedtls_pk_decrypt_0: (+1)
   \   0000000E   0x....             LDR      R0,??DataTable9_3  ;; 0xffffc180
   \   00000010   0xE00E             B        ??mbedtls_pk_decrypt_2
    283          
    284              if( ctx->pk_info->decrypt_func == NULL )
   \                     ??mbedtls_pk_decrypt_1: (+1)
   \   00000012   0x69A4             LDR      R4,[R4, #+24]
   \   00000014   0x0025             MOVS     R5,R4
   \   00000016   0xD101             BNE      ??mbedtls_pk_decrypt_3
    285                  return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
   \   00000018   0x....             LDR      R0,??DataTable10_2  ;; 0xffffc100
   \   0000001A   0xE009             B        ??mbedtls_pk_decrypt_2
    286          
    287              return( ctx->pk_info->decrypt_func( ctx->pk_ctx, input, ilen,
    288                          output, olen, osize, f_rng, p_rng ) );
   \                     ??mbedtls_pk_decrypt_3: (+1)
   \   0000001C   0x9D0B             LDR      R5,[SP, #+44]
   \   0000001E   0x9503             STR      R5,[SP, #+12]
   \   00000020   0x9D0A             LDR      R5,[SP, #+40]
   \   00000022   0x9502             STR      R5,[SP, #+8]
   \   00000024   0x9D09             LDR      R5,[SP, #+36]
   \   00000026   0x9501             STR      R5,[SP, #+4]
   \   00000028   0x9D08             LDR      R5,[SP, #+32]
   \   0000002A   0x9500             STR      R5,[SP, #+0]
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0x47A0             BLX      R4
   \                     ??mbedtls_pk_decrypt_2: (+1)
   \   00000030   0xB005             ADD      SP,SP,#+20
   \   00000032   0xBD30             POP      {R4,R5,PC}       ;; return
    289          }
    290          
    291          /*
    292           * Encrypt message
    293           */

   \                                 In section .text, align 2, keep-with-next
    294          int mbedtls_pk_encrypt( mbedtls_pk_context *ctx,
    295                          const unsigned char *input, size_t ilen,
    296                          unsigned char *output, size_t *olen, size_t osize,
    297                          int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    298          {
   \                     mbedtls_pk_encrypt: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    299              if( ctx == NULL || ctx->pk_info == NULL )
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD002             BEQ      ??mbedtls_pk_encrypt_0
   \   00000008   0x6804             LDR      R4,[R0, #+0]
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE      ??mbedtls_pk_encrypt_1
    300                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \                     ??mbedtls_pk_encrypt_0: (+1)
   \   0000000E   0x....             LDR      R0,??DataTable9_3  ;; 0xffffc180
   \   00000010   0xE00E             B        ??mbedtls_pk_encrypt_2
    301          
    302              if( ctx->pk_info->encrypt_func == NULL )
   \                     ??mbedtls_pk_encrypt_1: (+1)
   \   00000012   0x69E4             LDR      R4,[R4, #+28]
   \   00000014   0x0025             MOVS     R5,R4
   \   00000016   0xD101             BNE      ??mbedtls_pk_encrypt_3
    303                  return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
   \   00000018   0x....             LDR      R0,??DataTable10_2  ;; 0xffffc100
   \   0000001A   0xE009             B        ??mbedtls_pk_encrypt_2
    304          
    305              return( ctx->pk_info->encrypt_func( ctx->pk_ctx, input, ilen,
    306                          output, olen, osize, f_rng, p_rng ) );
   \                     ??mbedtls_pk_encrypt_3: (+1)
   \   0000001C   0x9D0B             LDR      R5,[SP, #+44]
   \   0000001E   0x9503             STR      R5,[SP, #+12]
   \   00000020   0x9D0A             LDR      R5,[SP, #+40]
   \   00000022   0x9502             STR      R5,[SP, #+8]
   \   00000024   0x9D09             LDR      R5,[SP, #+36]
   \   00000026   0x9501             STR      R5,[SP, #+4]
   \   00000028   0x9D08             LDR      R5,[SP, #+32]
   \   0000002A   0x9500             STR      R5,[SP, #+0]
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0x47A0             BLX      R4
   \                     ??mbedtls_pk_encrypt_2: (+1)
   \   00000030   0xB005             ADD      SP,SP,#+20
   \   00000032   0xBD30             POP      {R4,R5,PC}       ;; return
    307          }
    308          
    309          /*
    310           * Check public-private key pair
    311           */

   \                                 In section .text, align 2, keep-with-next
    312          int mbedtls_pk_check_pair( const mbedtls_pk_context *pub, const mbedtls_pk_context *prv )
    313          {
   \                     mbedtls_pk_check_pair: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    314              if( pub == NULL || pub->pk_info == NULL ||
    315                  prv == NULL || prv->pk_info == NULL ||
    316                  prv->pk_info->check_pair_func == NULL )
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD00A             BEQ      ??mbedtls_pk_check_pair_0
   \   00000006   0x6803             LDR      R3,[R0, #+0]
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD007             BEQ      ??mbedtls_pk_check_pair_0
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD005             BEQ      ??mbedtls_pk_check_pair_0
   \   00000010   0x680C             LDR      R4,[R1, #+0]
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD002             BEQ      ??mbedtls_pk_check_pair_0
   \   00000016   0x6A22             LDR      R2,[R4, #+32]
   \   00000018   0x0015             MOVS     R5,R2
   \   0000001A   0xD101             BNE      ??mbedtls_pk_check_pair_1
    317              {
    318                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \                     ??mbedtls_pk_check_pair_0: (+1)
   \   0000001C   0x....             LDR      R0,??DataTable9_3  ;; 0xffffc180
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}
    319              }
    320          
    321              if( prv->pk_info->type == MBEDTLS_PK_RSA_ALT )
   \                     ??mbedtls_pk_check_pair_1: (+1)
   \   00000020   0x7825             LDRB     R5,[R4, #+0]
   \   00000022   0x2D05             CMP      R5,#+5
   \   00000024   0xD106             BNE      ??mbedtls_pk_check_pair_2
    322              {
    323                  if( pub->pk_info->type != MBEDTLS_PK_RSA )
   \   00000026   0x781B             LDRB     R3,[R3, #+0]
   \   00000028   0x2B01             CMP      R3,#+1
   \   0000002A   0xD105             BNE      ??mbedtls_pk_check_pair_3
    324                      return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
    325              }
    326              else
    327              {
    328                  if( pub->pk_info != prv->pk_info )
    329                      return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
    330              }
    331          
    332              return( prv->pk_info->check_pair_func( pub->pk_ctx, prv->pk_ctx ) );
   \                     ??mbedtls_pk_check_pair_4: (+1)
   \   0000002C   0x6849             LDR      R1,[R1, #+4]
   \   0000002E   0x6840             LDR      R0,[R0, #+4]
   \   00000030   0x4790             BLX      R2
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??mbedtls_pk_check_pair_2: (+1)
   \   00000034   0x42A3             CMP      R3,R4
   \   00000036   0xD0F9             BEQ      ??mbedtls_pk_check_pair_4
   \                     ??mbedtls_pk_check_pair_3: (+1)
   \   00000038   0x....             LDR      R0,??DataTable10_2  ;; 0xffffc100
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}
    333          }
    334          
    335          /*
    336           * Get key size in bits
    337           */

   \                                 In section .text, align 2, keep-with-next
    338          size_t mbedtls_pk_get_bitlen( const mbedtls_pk_context *ctx )
    339          {
   \                     mbedtls_pk_get_bitlen: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    340              if( ctx == NULL || ctx->pk_info == NULL )
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD002             BEQ      ??mbedtls_pk_get_bitlen_0
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD101             BNE      ??mbedtls_pk_get_bitlen_1
    341                  return( 0 );
   \                     ??mbedtls_pk_get_bitlen_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD02             POP      {R1,PC}
    342          
    343              return( ctx->pk_info->get_bitlen( ctx->pk_ctx ) );
   \                     ??mbedtls_pk_get_bitlen_1: (+1)
   \   00000010   0x6840             LDR      R0,[R0, #+4]
   \   00000012   0x6889             LDR      R1,[R1, #+8]
   \   00000014   0x4788             BLX      R1
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    344          }
    345          
    346          /*
    347           * Export debug information
    348           */

   \                                 In section .text, align 2, keep-with-next
    349          int mbedtls_pk_debug( const mbedtls_pk_context *ctx, mbedtls_pk_debug_item *items )
    350          {
   \                     mbedtls_pk_debug: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    351              if( ctx == NULL || ctx->pk_info == NULL )
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD002             BEQ      ??mbedtls_pk_debug_0
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD101             BNE      ??mbedtls_pk_debug_1
    352                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
   \                     ??mbedtls_pk_debug_0: (+1)
   \   0000000C   0x....             LDR      R0,??DataTable10_3  ;; 0xffffc180
   \   0000000E   0xBD02             POP      {R1,PC}
    353          
    354              if( ctx->pk_info->debug_func == NULL )
   \                     ??mbedtls_pk_debug_1: (+1)
   \   00000010   0x6AD2             LDR      R2,[R2, #+44]
   \   00000012   0x0013             MOVS     R3,R2
   \   00000014   0xD101             BNE      ??mbedtls_pk_debug_2
    355                  return( MBEDTLS_ERR_PK_TYPE_MISMATCH );
   \   00000016   0x....             LDR      R0,??DataTable10_2  ;; 0xffffc100
   \   00000018   0xBD02             POP      {R1,PC}
    356          
    357              ctx->pk_info->debug_func( ctx->pk_ctx, items );
   \                     ??mbedtls_pk_debug_2: (+1)
   \   0000001A   0x6840             LDR      R0,[R0, #+4]
   \   0000001C   0x4790             BLX      R2
    358              return( 0 );
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
    359          }
    360          
    361          /*
    362           * Access the PK type name
    363           */

   \                                 In section .text, align 4, keep-with-next
    364          const char *mbedtls_pk_get_name( const mbedtls_pk_context *ctx )
    365          {
    366              if( ctx == NULL || ctx->pk_info == NULL )
   \                     mbedtls_pk_get_name: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD002             BEQ      ??mbedtls_pk_get_name_0
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD102             BNE      ??mbedtls_pk_get_name_1
    367                  return( "invalid PK" );
   \                     ??mbedtls_pk_get_name_0: (+1)
   \   0000000A   0xBF00             Nop      
   \   0000000C   0x....             ADR.N    R0,?_0
   \   0000000E   0x4770             BX       LR
    368          
    369              return( ctx->pk_info->name );
   \                     ??mbedtls_pk_get_name_1: (+1)
   \   00000010   0x6840             LDR      R0,[R0, #+4]
   \   00000012   0x4770             BX       LR               ;; return
    370          }
    371          
    372          /*
    373           * Access the PK type
    374           */

   \                                 In section .text, align 2, keep-with-next
    375          mbedtls_pk_type_t mbedtls_pk_get_type( const mbedtls_pk_context *ctx )
    376          {
    377              if( ctx == NULL || ctx->pk_info == NULL )
   \                     mbedtls_pk_get_type: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD002             BEQ      ??mbedtls_pk_get_type_0
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE      ??mbedtls_pk_get_type_1
    378                  return( MBEDTLS_PK_NONE );
   \                     ??mbedtls_pk_get_type_0: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR
    379          
    380              return( ctx->pk_info->type );
   \                     ??mbedtls_pk_get_type_1: (+1)
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x4770             BX       LR               ;; return
    381          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     mbedtls_rsa_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     mbedtls_eckey_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     mbedtls_eckeydh_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     mbedtls_ecdsa_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0xFFFFC180         DC32     0xffffc180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xFFFFC080         DC32     0xffffc080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     mbedtls_rsa_alt_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0xFFFFC100         DC32     0xffffc100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0xFFFFC180         DC32     0xffffc180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0xFFFFBC80         DC32     0xffffbc80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0xFFFFC700         DC32     0xffffc700

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x69 0x6E          DC8 "invalid PK"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x50 0x4B    
   \              0x00         
   \   0000000B   0x00               DC8 0
    382          
    383          #endif /* MBEDTLS_PK_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   mbedtls_pk_can_do
         8   -- Indirect call
      16   mbedtls_pk_check_pair
        16   -- Indirect call
       8   mbedtls_pk_debug
         8   -- Indirect call
      32   mbedtls_pk_decrypt
        32   -- Indirect call
      32   mbedtls_pk_encrypt
        32   -- Indirect call
       8   mbedtls_pk_free
         8   -- Indirect call
         8   -> __aeabi_memclr
       8   mbedtls_pk_get_bitlen
         8   -- Indirect call
       0   mbedtls_pk_get_name
       0   mbedtls_pk_get_type
       0   mbedtls_pk_info_from_type
       0   mbedtls_pk_init
       0   mbedtls_pk_rsa
      16   mbedtls_pk_setup
        16   -- Indirect call
      24   mbedtls_pk_setup_rsa_alt
        24   -- Indirect call
      40   mbedtls_pk_sign
        40   -- Indirect call
        40   -> mbedtls_md_get_size
        40   -> mbedtls_md_info_from_type
      32   mbedtls_pk_verify
        32   -- Indirect call
        32   -> mbedtls_md_get_size
        32   -> mbedtls_md_info_from_type
      56   mbedtls_pk_verify_ext
        56   -- Indirect call
        56   -> mbedtls_pk_rsa
        56   -> mbedtls_pk_verify
        56   -> mbedtls_rsa_rsassa_pss_verify_ext


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable8
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
      12  ?_0
      24  mbedtls_pk_can_do
      60  mbedtls_pk_check_pair
      34  mbedtls_pk_debug
      52  mbedtls_pk_decrypt
      52  mbedtls_pk_encrypt
      28  mbedtls_pk_free
      24  mbedtls_pk_get_bitlen
      20  mbedtls_pk_get_name
      18  mbedtls_pk_get_type
      38  mbedtls_pk_info_from_type
      12  mbedtls_pk_init
       4  mbedtls_pk_rsa
      44  mbedtls_pk_setup
      56  mbedtls_pk_setup_rsa_alt
      84  mbedtls_pk_sign
      76  mbedtls_pk_verify
     182  mbedtls_pk_verify_ext

 
 864 bytes in section .text
 
 864 bytes of CODE memory

Errors: none
Warnings: none

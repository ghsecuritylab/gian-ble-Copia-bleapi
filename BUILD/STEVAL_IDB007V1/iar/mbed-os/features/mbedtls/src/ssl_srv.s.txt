###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:35
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\features\mbedtls\src\ssl_srv.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\ssl_srv.d -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\ssl_srv.s.txt
#        -o .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\ssl_srv.o
#        .\mbed-os\features\mbedtls\src\ssl_srv.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\ssl_srv.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\ssl_srv.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\features\mbedtls\src\ssl_srv.c
      1          /*
      2           *  SSLv3/TLSv1 server-side functions
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          
     22          #if !defined(MBEDTLS_CONFIG_FILE)
     23          #include "mbedtls/config.h"
     24          #else
     25          #include MBEDTLS_CONFIG_FILE
     26          #endif
     27          
     28          #if defined(MBEDTLS_SSL_SRV_C)
     29          
     30          #if defined(MBEDTLS_PLATFORM_C)
     31          #include "mbedtls/platform.h"
     32          #else
     33          #include <stdlib.h>
     34          #define mbedtls_calloc    calloc
     35          #define mbedtls_free      free
     36          #endif
     37          
     38          #include "mbedtls/debug.h"
     39          #include "mbedtls/ssl.h"
     40          #include "mbedtls/ssl_internal.h"
     41          
     42          #include <string.h>
     43          
     44          #if defined(MBEDTLS_ECP_C)
     45          #include "mbedtls/ecp.h"
     46          #endif
     47          
     48          #if defined(MBEDTLS_HAVE_TIME)
     49          #include "mbedtls/platform_time.h"
     50          #endif
     51          
     52          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
     53          /* Implementation that should never be optimized out by the compiler */
     54          static void mbedtls_zeroize( void *v, size_t n ) {
     55              volatile unsigned char *p = v; while( n-- ) *p++ = 0;
     56          }
     57          #endif
     58          
     59          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
     60          int mbedtls_ssl_set_client_transport_id( mbedtls_ssl_context *ssl,
     61                                           const unsigned char *info,
     62                                           size_t ilen )
     63          {
     64              if( ssl->conf->endpoint != MBEDTLS_SSL_IS_SERVER )
     65                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
     66          
     67              mbedtls_free( ssl->cli_id );
     68          
     69              if( ( ssl->cli_id = mbedtls_calloc( 1, ilen ) ) == NULL )
     70                  return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
     71          
     72              memcpy( ssl->cli_id, info, ilen );
     73              ssl->cli_id_len = ilen;
     74          
     75              return( 0 );
     76          }
     77          
     78          void mbedtls_ssl_conf_dtls_cookies( mbedtls_ssl_config *conf,
     79                                     mbedtls_ssl_cookie_write_t *f_cookie_write,
     80                                     mbedtls_ssl_cookie_check_t *f_cookie_check,
     81                                     void *p_cookie )
     82          {
     83              conf->f_cookie_write = f_cookie_write;
     84              conf->f_cookie_check = f_cookie_check;
     85              conf->p_cookie       = p_cookie;
     86          }
     87          #endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
     88          
     89          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
     90          static int ssl_parse_servername_ext( mbedtls_ssl_context *ssl,
     91                                               const unsigned char *buf,
     92                                               size_t len )
     93          {
     94              int ret;
     95              size_t servername_list_size, hostname_len;
     96              const unsigned char *p;
     97          
     98              MBEDTLS_SSL_DEBUG_MSG( 3, ( "parse ServerName extension" ) );
     99          
    100              servername_list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );
    101              if( servername_list_size + 2 != len )
    102              {
    103                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    104                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    105                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    106                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    107              }
    108          
    109              p = buf + 2;
    110              while( servername_list_size > 0 )
    111              {
    112                  hostname_len = ( ( p[1] << 8 ) | p[2] );
    113                  if( hostname_len + 3 > servername_list_size )
    114                  {
    115                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    116                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    117                                                      MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    118                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    119                  }
    120          
    121                  if( p[0] == MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME )
    122                  {
    123                      ret = ssl->conf->f_sni( ssl->conf->p_sni,
    124                                              ssl, p + 3, hostname_len );
    125                      if( ret != 0 )
    126                      {
    127                          MBEDTLS_SSL_DEBUG_RET( 1, "ssl_sni_wrapper", ret );
    128                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    129                                  MBEDTLS_SSL_ALERT_MSG_UNRECOGNIZED_NAME );
    130                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    131                      }
    132                      return( 0 );
    133                  }
    134          
    135                  servername_list_size -= hostname_len + 3;
    136                  p += hostname_len + 3;
    137              }
    138          
    139              if( servername_list_size != 0 )
    140              {
    141                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    142                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    143                                                  MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
    144                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    145              }
    146          
    147              return( 0 );
    148          }
    149          #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
    150          
    151          static int ssl_parse_renegotiation_info( mbedtls_ssl_context *ssl,
    152                                                   const unsigned char *buf,
    153                                                   size_t len )
    154          {
    155          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    156              if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
    157              {
    158                  /* Check verify-data in constant-time. The length OTOH is no secret */
    159                  if( len    != 1 + ssl->verify_data_len ||
    160                      buf[0] !=     ssl->verify_data_len ||
    161                      mbedtls_ssl_safer_memcmp( buf + 1, ssl->peer_verify_data,
    162                                    ssl->verify_data_len ) != 0 )
    163                  {
    164                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-matching renegotiation info" ) );
    165                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    166                                                      MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
    167                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    168                  }
    169              }
    170              else
    171          #endif /* MBEDTLS_SSL_RENEGOTIATION */
    172              {
    173                  if( len != 1 || buf[0] != 0x0 )
    174                  {
    175                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-zero length renegotiation info" ) );
    176                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    177                                                      MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
    178                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    179                  }
    180          
    181                  ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
    182              }
    183          
    184              return( 0 );
    185          }
    186          
    187          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
    188              defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
    189          
    190          /*
    191           * Status of the implementation of signature-algorithms extension:
    192           *
    193           * Currently, we are only considering the signature-algorithm extension
    194           * to pick a ciphersuite which allows us to send the ServerKeyExchange
    195           * message with a signature-hash combination that the user allows.
    196           *
    197           * We do *not* check whether all certificates in our certificate
    198           * chain are signed with an allowed signature-hash pair.
    199           * This needs to be done at a later stage.
    200           *
    201           */
    202          static int ssl_parse_signature_algorithms_ext( mbedtls_ssl_context *ssl,
    203                                                         const unsigned char *buf,
    204                                                         size_t len )
    205          {
    206              size_t sig_alg_list_size;
    207          
    208              const unsigned char *p;
    209              const unsigned char *end = buf + len;
    210          
    211              mbedtls_md_type_t md_cur;
    212              mbedtls_pk_type_t sig_cur;
    213          
    214              sig_alg_list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );
    215              if( sig_alg_list_size + 2 != len ||
    216                  sig_alg_list_size % 2 != 0 )
    217              {
    218                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    219                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    220                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    221                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    222              }
    223          
    224              /* Currently we only guarantee signing the ServerKeyExchange message according
    225               * to the constraints specified in this extension (see above), so it suffices
    226               * to remember only one suitable hash for each possible signature algorithm.
    227               *
    228               * This will change when we also consider certificate signatures,
    229               * in which case we will need to remember the whole signature-hash
    230               * pair list from the extension.
    231               */
    232          
    233              for( p = buf + 2; p < end; p += 2 )
    234              {
    235                  /* Silently ignore unknown signature or hash algorithms. */
    236          
    237                  if( ( sig_cur = mbedtls_ssl_pk_alg_from_sig( p[1] ) ) == MBEDTLS_PK_NONE )
    238                  {
    239                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, signature_algorithm ext"
    240                                                  " unknown sig alg encoding %d", p[1] ) );
    241                      continue;
    242                  }
    243          
    244                  /* Check if we support the hash the user proposes */
    245                  md_cur = mbedtls_ssl_md_alg_from_hash( p[0] );
    246                  if( md_cur == MBEDTLS_MD_NONE )
    247                  {
    248                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, signature_algorithm ext:"
    249                                                  " unknown hash alg encoding %d", p[0] ) );
    250                      continue;
    251                  }
    252          
    253                  if( mbedtls_ssl_check_sig_hash( ssl, md_cur ) == 0 )
    254                  {
    255                      mbedtls_ssl_sig_hash_set_add( &ssl->handshake->hash_algs, sig_cur, md_cur );
    256                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, signature_algorithm ext:"
    257                                                  " match sig %d and hash %d",
    258                                                  sig_cur, md_cur ) );
    259                  }
    260                  else
    261                  {
    262                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, signature_algorithm ext: "
    263                                                  "hash alg %d not supported", md_cur ) );
    264                  }
    265              }
    266          
    267              return( 0 );
    268          }
    269          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
    270                    MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
    271          
    272          #if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
    273              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    274          static int ssl_parse_supported_elliptic_curves( mbedtls_ssl_context *ssl,
    275                                                          const unsigned char *buf,
    276                                                          size_t len )
    277          {
    278              size_t list_size, our_size;
    279              const unsigned char *p;
    280              const mbedtls_ecp_curve_info *curve_info, **curves;
    281          
    282              list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );
    283              if( list_size + 2 != len ||
    284                  list_size % 2 != 0 )
    285              {
    286                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    287                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    288                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    289                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    290              }
    291          
    292              /* Should never happen unless client duplicates the extension */
    293              if( ssl->handshake->curves != NULL )
    294              {
    295                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    296                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    297                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    298                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    299              }
    300          
    301              /* Don't allow our peer to make us allocate too much memory,
    302               * and leave room for a final 0 */
    303              our_size = list_size / 2 + 1;
    304              if( our_size > MBEDTLS_ECP_DP_MAX )
    305                  our_size = MBEDTLS_ECP_DP_MAX;
    306          
    307              if( ( curves = mbedtls_calloc( our_size, sizeof( *curves ) ) ) == NULL )
    308              {
    309                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    310                                                  MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );
    311                  return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
    312              }
    313          
    314              ssl->handshake->curves = curves;
    315          
    316              p = buf + 2;
    317              while( list_size > 0 && our_size > 1 )
    318              {
    319                  curve_info = mbedtls_ecp_curve_info_from_tls_id( ( p[0] << 8 ) | p[1] );
    320          
    321                  if( curve_info != NULL )
    322                  {
    323                      *curves++ = curve_info;
    324                      our_size--;
    325                  }
    326          
    327                  list_size -= 2;
    328                  p += 2;
    329              }
    330          
    331              return( 0 );
    332          }
    333          
    334          static int ssl_parse_supported_point_formats( mbedtls_ssl_context *ssl,
    335                                                        const unsigned char *buf,
    336                                                        size_t len )
    337          {
    338              size_t list_size;
    339              const unsigned char *p;
    340          
    341              list_size = buf[0];
    342              if( list_size + 1 != len )
    343              {
    344                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    345                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    346                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    347                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    348              }
    349          
    350              p = buf + 1;
    351              while( list_size > 0 )
    352              {
    353                  if( p[0] == MBEDTLS_ECP_PF_UNCOMPRESSED ||
    354                      p[0] == MBEDTLS_ECP_PF_COMPRESSED )
    355                  {
    356          #if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C)
    357                      ssl->handshake->ecdh_ctx.point_format = p[0];
    358          #endif
    359          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    360                      ssl->handshake->ecjpake_ctx.point_format = p[0];
    361          #endif
    362                      MBEDTLS_SSL_DEBUG_MSG( 4, ( "point format selected: %d", p[0] ) );
    363                      return( 0 );
    364                  }
    365          
    366                  list_size--;
    367                  p++;
    368              }
    369          
    370              return( 0 );
    371          }
    372          #endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C ||
    373                    MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    374          
    375          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    376          static int ssl_parse_ecjpake_kkpp( mbedtls_ssl_context *ssl,
    377                                             const unsigned char *buf,
    378                                             size_t len )
    379          {
    380              int ret;
    381          
    382              if( mbedtls_ecjpake_check( &ssl->handshake->ecjpake_ctx ) != 0 )
    383              {
    384                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "skip ecjpake kkpp extension" ) );
    385                  return( 0 );
    386              }
    387          
    388              if( ( ret = mbedtls_ecjpake_read_round_one( &ssl->handshake->ecjpake_ctx,
    389                                                          buf, len ) ) != 0 )
    390              {
    391                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecjpake_read_round_one", ret );
    392                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    393                                                  MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
    394                  return( ret );
    395              }
    396          
    397              /* Only mark the extension as OK when we're sure it is */
    398              ssl->handshake->cli_exts |= MBEDTLS_TLS_EXT_ECJPAKE_KKPP_OK;
    399          
    400              return( 0 );
    401          }
    402          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    403          
    404          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
    405          static int ssl_parse_max_fragment_length_ext( mbedtls_ssl_context *ssl,
    406                                                        const unsigned char *buf,
    407                                                        size_t len )
    408          {
    409              if( len != 1 || buf[0] >= MBEDTLS_SSL_MAX_FRAG_LEN_INVALID )
    410              {
    411                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    412                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    413                                                  MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
    414                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    415              }
    416          
    417              ssl->session_negotiate->mfl_code = buf[0];
    418          
    419              return( 0 );
    420          }
    421          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
    422          
    423          #if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
    424          static int ssl_parse_truncated_hmac_ext( mbedtls_ssl_context *ssl,
    425                                                   const unsigned char *buf,
    426                                                   size_t len )
    427          {
    428              if( len != 0 )
    429              {
    430                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    431                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    432                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    433                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    434              }
    435          
    436              ((void) buf);
    437          
    438              if( ssl->conf->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_ENABLED )
    439                  ssl->session_negotiate->trunc_hmac = MBEDTLS_SSL_TRUNC_HMAC_ENABLED;
    440          
    441              return( 0 );
    442          }
    443          #endif /* MBEDTLS_SSL_TRUNCATED_HMAC */
    444          
    445          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
    446          static int ssl_parse_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,
    447                                                const unsigned char *buf,
    448                                                size_t len )
    449          {
    450              if( len != 0 )
    451              {
    452                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    453                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    454                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    455                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    456              }
    457          
    458              ((void) buf);
    459          
    460              if( ssl->conf->encrypt_then_mac == MBEDTLS_SSL_ETM_ENABLED &&
    461                  ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )
    462              {
    463                  ssl->session_negotiate->encrypt_then_mac = MBEDTLS_SSL_ETM_ENABLED;
    464              }
    465          
    466              return( 0 );
    467          }
    468          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
    469          
    470          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
    471          static int ssl_parse_extended_ms_ext( mbedtls_ssl_context *ssl,
    472                                                const unsigned char *buf,
    473                                                size_t len )
    474          {
    475              if( len != 0 )
    476              {
    477                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    478                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    479                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    480                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    481              }
    482          
    483              ((void) buf);
    484          
    485              if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_ENABLED &&
    486                  ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )
    487              {
    488                  ssl->handshake->extended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;
    489              }
    490          
    491              return( 0 );
    492          }
    493          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
    494          
    495          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
    496          static int ssl_parse_session_ticket_ext( mbedtls_ssl_context *ssl,
    497                                                   unsigned char *buf,
    498                                                   size_t len )
    499          {
    500              int ret;
    501              mbedtls_ssl_session session;
    502          
    503              mbedtls_ssl_session_init( &session );
    504          
    505              if( ssl->conf->f_ticket_parse == NULL ||
    506                  ssl->conf->f_ticket_write == NULL )
    507              {
    508                  return( 0 );
    509              }
    510          
    511              /* Remember the client asked us to send a new ticket */
    512              ssl->handshake->new_session_ticket = 1;
    513          
    514              MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket length: %d", len ) );
    515          
    516              if( len == 0 )
    517                  return( 0 );
    518          
    519          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    520              if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
    521              {
    522                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket rejected: renegotiating" ) );
    523                  return( 0 );
    524              }
    525          #endif /* MBEDTLS_SSL_RENEGOTIATION */
    526          
    527              /*
    528               * Failures are ok: just ignore the ticket and proceed.
    529               */
    530              if( ( ret = ssl->conf->f_ticket_parse( ssl->conf->p_ticket, &session,
    531                                                     buf, len ) ) != 0 )
    532              {
    533                  mbedtls_ssl_session_free( &session );
    534          
    535                  if( ret == MBEDTLS_ERR_SSL_INVALID_MAC )
    536                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket is not authentic" ) );
    537                  else if( ret == MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED )
    538                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket is expired" ) );
    539                  else
    540                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_ticket_parse", ret );
    541          
    542                  return( 0 );
    543              }
    544          
    545              /*
    546               * Keep the session ID sent by the client, since we MUST send it back to
    547               * inform them we're accepting the ticket  (RFC 5077 section 3.4)
    548               */
    549              session.id_len = ssl->session_negotiate->id_len;
    550              memcpy( &session.id, ssl->session_negotiate->id, session.id_len );
    551          
    552              mbedtls_ssl_session_free( ssl->session_negotiate );
    553              memcpy( ssl->session_negotiate, &session, sizeof( mbedtls_ssl_session ) );
    554          
    555              /* Zeroize instead of free as we copied the content */
    556              mbedtls_zeroize( &session, sizeof( mbedtls_ssl_session ) );
    557          
    558              MBEDTLS_SSL_DEBUG_MSG( 3, ( "session successfully restored from ticket" ) );
    559          
    560              ssl->handshake->resume = 1;
    561          
    562              /* Don't send a new ticket after all, this one is OK */
    563              ssl->handshake->new_session_ticket = 0;
    564          
    565              return( 0 );
    566          }
    567          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
    568          
    569          #if defined(MBEDTLS_SSL_ALPN)
    570          static int ssl_parse_alpn_ext( mbedtls_ssl_context *ssl,
    571                                         const unsigned char *buf, size_t len )
    572          {
    573              size_t list_len, cur_len, ours_len;
    574              const unsigned char *theirs, *start, *end;
    575              const char **ours;
    576          
    577              /* If ALPN not configured, just ignore the extension */
    578              if( ssl->conf->alpn_list == NULL )
    579                  return( 0 );
    580          
    581              /*
    582               * opaque ProtocolName<1..2^8-1>;
    583               *
    584               * struct {
    585               *     ProtocolName protocol_name_list<2..2^16-1>
    586               * } ProtocolNameList;
    587               */
    588          
    589              /* Min length is 2 (list_len) + 1 (name_len) + 1 (name) */
    590              if( len < 4 )
    591              {
    592                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    593                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    594                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    595              }
    596          
    597              list_len = ( buf[0] << 8 ) | buf[1];
    598              if( list_len != len - 2 )
    599              {
    600                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    601                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    602                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    603              }
    604          
    605              /*
    606               * Use our order of preference
    607               */
    608              start = buf + 2;
    609              end = buf + len;
    610              for( ours = ssl->conf->alpn_list; *ours != NULL; ours++ )
    611              {
    612                  ours_len = strlen( *ours );
    613                  for( theirs = start; theirs != end; theirs += cur_len )
    614                  {
    615                      /* If the list is well formed, we should get equality first */
    616                      if( theirs > end )
    617                      {
    618                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    619                                                          MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
    620                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    621                      }
    622          
    623                      cur_len = *theirs++;
    624          
    625                      /* Empty strings MUST NOT be included */
    626                      if( cur_len == 0 )
    627                      {
    628                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    629                                                          MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
    630                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    631                      }
    632          
    633                      if( cur_len == ours_len &&
    634                          memcmp( theirs, *ours, cur_len ) == 0 )
    635                      {
    636                          ssl->alpn_chosen = *ours;
    637                          return( 0 );
    638                      }
    639                  }
    640              }
    641          
    642              /* If we get there, no match was found */
    643              mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    644                                      MBEDTLS_SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL );
    645              return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    646          }
    647          #endif /* MBEDTLS_SSL_ALPN */
    648          
    649          /*
    650           * Auxiliary functions for ServerHello parsing and related actions
    651           */
    652          
    653          #if defined(MBEDTLS_X509_CRT_PARSE_C)
    654          /*
    655           * Return 0 if the given key uses one of the acceptable curves, -1 otherwise
    656           */
    657          #if defined(MBEDTLS_ECDSA_C)
    658          static int ssl_check_key_curve( mbedtls_pk_context *pk,
    659                                          const mbedtls_ecp_curve_info **curves )
    660          {
    661              const mbedtls_ecp_curve_info **crv = curves;
    662              mbedtls_ecp_group_id grp_id = mbedtls_pk_ec( *pk )->grp.id;
    663          
    664              while( *crv != NULL )
    665              {
    666                  if( (*crv)->grp_id == grp_id )
    667                      return( 0 );
    668                  crv++;
    669              }
    670          
    671              return( -1 );
    672          }
    673          #endif /* MBEDTLS_ECDSA_C */
    674          
    675          /*
    676           * Try picking a certificate for this ciphersuite,
    677           * return 0 on success and -1 on failure.
    678           */
    679          static int ssl_pick_cert( mbedtls_ssl_context *ssl,
    680                                    const mbedtls_ssl_ciphersuite_t * ciphersuite_info )
    681          {
    682              mbedtls_ssl_key_cert *cur, *list, *fallback = NULL;
    683              mbedtls_pk_type_t pk_alg =
    684                  mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );
    685              uint32_t flags;
    686          
    687          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
    688              if( ssl->handshake->sni_key_cert != NULL )
    689                  list = ssl->handshake->sni_key_cert;
    690              else
    691          #endif
    692                  list = ssl->conf->key_cert;
    693          
    694              if( pk_alg == MBEDTLS_PK_NONE )
    695                  return( 0 );
    696          
    697              MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite requires certificate" ) );
    698          
    699              if( list == NULL )
    700              {
    701                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "server has no certificate" ) );
    702                  return( -1 );
    703              }
    704          
    705              for( cur = list; cur != NULL; cur = cur->next )
    706              {
    707                  MBEDTLS_SSL_DEBUG_CRT( 3, "candidate certificate chain, certificate",
    708                                    cur->cert );
    709          
    710                  if( ! mbedtls_pk_can_do( cur->key, pk_alg ) )
    711                  {
    712                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate mismatch: key type" ) );
    713                      continue;
    714                  }
    715          
    716                  /*
    717                   * This avoids sending the client a cert it'll reject based on
    718                   * keyUsage or other extensions.
    719                   *
    720                   * It also allows the user to provision different certificates for
    721                   * different uses based on keyUsage, eg if they want to avoid signing
    722                   * and decrypting with the same RSA key.
    723                   */
    724                  if( mbedtls_ssl_check_cert_usage( cur->cert, ciphersuite_info,
    725                                            MBEDTLS_SSL_IS_SERVER, &flags ) != 0 )
    726                  {
    727                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate mismatch: "
    728                                          "(extended) key usage extension" ) );
    729                      continue;
    730                  }
    731          
    732          #if defined(MBEDTLS_ECDSA_C)
    733                  if( pk_alg == MBEDTLS_PK_ECDSA &&
    734                      ssl_check_key_curve( cur->key, ssl->handshake->curves ) != 0 )
    735                  {
    736                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate mismatch: elliptic curve" ) );
    737                      continue;
    738                  }
    739          #endif
    740          
    741                  /*
    742                   * Try to select a SHA-1 certificate for pre-1.2 clients, but still
    743                   * present them a SHA-higher cert rather than failing if it's the only
    744                   * one we got that satisfies the other conditions.
    745                   */
    746                  if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 &&
    747                      cur->cert->sig_md != MBEDTLS_MD_SHA1 )
    748                  {
    749                      if( fallback == NULL )
    750                          fallback = cur;
    751                      {
    752                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate not preferred: "
    753                                              "sha-2 with pre-TLS 1.2 client" ) );
    754                      continue;
    755                      }
    756                  }
    757          
    758                  /* If we get there, we got a winner */
    759                  break;
    760              }
    761          
    762              if( cur == NULL )
    763                  cur = fallback;
    764          
    765              /* Do not update ssl->handshake->key_cert unless there is a match */
    766              if( cur != NULL )
    767              {
    768                  ssl->handshake->key_cert = cur;
    769                  MBEDTLS_SSL_DEBUG_CRT( 3, "selected certificate chain, certificate",
    770                                    ssl->handshake->key_cert->cert );
    771                  return( 0 );
    772              }
    773          
    774              return( -1 );
    775          }
    776          #endif /* MBEDTLS_X509_CRT_PARSE_C */
    777          
    778          /*
    779           * Check if a given ciphersuite is suitable for use with our config/keys/etc
    780           * Sets ciphersuite_info only if the suite matches.
    781           */
    782          static int ssl_ciphersuite_match( mbedtls_ssl_context *ssl, int suite_id,
    783                                            const mbedtls_ssl_ciphersuite_t **ciphersuite_info )
    784          {
    785              const mbedtls_ssl_ciphersuite_t *suite_info;
    786          
    787          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
    788              defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)    
    789              mbedtls_pk_type_t sig_type;
    790          #endif
    791          
    792              suite_info = mbedtls_ssl_ciphersuite_from_id( suite_id );
    793              if( suite_info == NULL )
    794              {
    795                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
    796                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
    797              }
    798          
    799              MBEDTLS_SSL_DEBUG_MSG( 3, ( "trying ciphersuite: %s", suite_info->name ) );
    800          
    801              if( suite_info->min_minor_ver > ssl->minor_ver ||
    802                  suite_info->max_minor_ver < ssl->minor_ver )
    803              {
    804                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: version" ) );
    805                  return( 0 );
    806              }
    807          
    808          #if defined(MBEDTLS_SSL_PROTO_DTLS)
    809              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
    810                  ( suite_info->flags & MBEDTLS_CIPHERSUITE_NODTLS ) )
    811                  return( 0 );
    812          #endif
    813          
    814          #if defined(MBEDTLS_ARC4_C)
    815              if( ssl->conf->arc4_disabled == MBEDTLS_SSL_ARC4_DISABLED &&
    816                      suite_info->cipher == MBEDTLS_CIPHER_ARC4_128 )
    817              {
    818                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: rc4" ) );
    819                  return( 0 );
    820              }
    821          #endif
    822          
    823          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    824              if( suite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE &&
    825                  ( ssl->handshake->cli_exts & MBEDTLS_TLS_EXT_ECJPAKE_KKPP_OK ) == 0 )
    826              {
    827                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: ecjpake "
    828                                              "not configured or ext missing" ) );
    829                  return( 0 );
    830              }
    831          #endif
    832          
    833          
    834          #if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C)
    835              if( mbedtls_ssl_ciphersuite_uses_ec( suite_info ) &&
    836                  ( ssl->handshake->curves == NULL ||
    837                    ssl->handshake->curves[0] == NULL ) )
    838              {
    839                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: "
    840                                      "no common elliptic curve" ) );
    841                  return( 0 );
    842              }
    843          #endif
    844          
    845          #if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)
    846              /* If the ciphersuite requires a pre-shared key and we don't
    847               * have one, skip it now rather than failing later */
    848              if( mbedtls_ssl_ciphersuite_uses_psk( suite_info ) &&
    849                  ssl->conf->f_psk == NULL &&
    850                  ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||
    851                    ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )
    852              {
    853                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: no pre-shared key" ) );
    854                  return( 0 );
    855              }
    856          #endif
    857          
    858          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
    859              defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
    860              /* If the ciphersuite requires signing, check whether
    861               * a suitable hash algorithm is present. */
    862              if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
    863              {
    864                  sig_type = mbedtls_ssl_get_ciphersuite_sig_alg( suite_info );
    865                  if( sig_type != MBEDTLS_PK_NONE &&
    866                      mbedtls_ssl_sig_hash_set_find( &ssl->handshake->hash_algs, sig_type ) == MBEDTLS_MD_NONE )
    867                  {
    868                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: no suitable hash algorithm "
    869                                                  "for signature algorithm %d", sig_type ) );
    870                      return( 0 );
    871                  }
    872              }
    873          
    874          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
    875                    MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
    876          
    877          #if defined(MBEDTLS_X509_CRT_PARSE_C)
    878              /*
    879               * Final check: if ciphersuite requires us to have a
    880               * certificate/key of a particular type:
    881               * - select the appropriate certificate if we have one, or
    882               * - try the next ciphersuite if we don't
    883               * This must be done last since we modify the key_cert list.
    884               */
    885              if( ssl_pick_cert( ssl, suite_info ) != 0 )
    886              {
    887                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: "
    888                                      "no suitable certificate" ) );
    889                  return( 0 );
    890              }
    891          #endif
    892          
    893              *ciphersuite_info = suite_info;
    894              return( 0 );
    895          }
    896          
    897          #if defined(MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO)
    898          static int ssl_parse_client_hello_v2( mbedtls_ssl_context *ssl )
    899          {
    900              int ret, got_common_suite;
    901              unsigned int i, j;
    902              size_t n;
    903              unsigned int ciph_len, sess_len, chal_len;
    904              unsigned char *buf, *p;
    905              const int *ciphersuites;
    906              const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
    907          
    908              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse client hello v2" ) );
    909          
    910          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    911              if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
    912              {
    913                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "client hello v2 illegal for renegotiation" ) );
    914                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    915                                                  MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
    916                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    917              }
    918          #endif /* MBEDTLS_SSL_RENEGOTIATION */
    919          
    920              buf = ssl->in_hdr;
    921          
    922              MBEDTLS_SSL_DEBUG_BUF( 4, "record header", buf, 5 );
    923          
    924              MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v2, message type: %d",
    925                             buf[2] ) );
    926              MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v2, message len.: %d",
    927                             ( ( buf[0] & 0x7F ) << 8 ) | buf[1] ) );
    928              MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v2, max. version: [%d:%d]",
    929                             buf[3], buf[4] ) );
    930          
    931              /*
    932               * SSLv2 Client Hello
    933               *
    934               * Record layer:
    935               *     0  .   1   message length
    936               *
    937               * SSL layer:
    938               *     2  .   2   message type
    939               *     3  .   4   protocol version
    940               */
    941              if( buf[2] != MBEDTLS_SSL_HS_CLIENT_HELLO ||
    942                  buf[3] != MBEDTLS_SSL_MAJOR_VERSION_3 )
    943              {
    944                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    945                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    946              }
    947          
    948              n = ( ( buf[0] << 8 ) | buf[1] ) & 0x7FFF;
    949          
    950              if( n < 17 || n > 512 )
    951              {
    952                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    953                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    954              }
    955          
    956              ssl->major_ver = MBEDTLS_SSL_MAJOR_VERSION_3;
    957              ssl->minor_ver = ( buf[4] <= ssl->conf->max_minor_ver )
    958                               ? buf[4]  : ssl->conf->max_minor_ver;
    959          
    960              if( ssl->minor_ver < ssl->conf->min_minor_ver )
    961              {
    962                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "client only supports ssl smaller than minimum"
    963                                      " [%d:%d] < [%d:%d]",
    964                                      ssl->major_ver, ssl->minor_ver,
    965                                      ssl->conf->min_major_ver, ssl->conf->min_minor_ver ) );
    966          
    967                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    968                                               MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );
    969                  return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );
    970              }
    971          
    972              ssl->handshake->max_major_ver = buf[3];
    973              ssl->handshake->max_minor_ver = buf[4];
    974          
    975              if( ( ret = mbedtls_ssl_fetch_input( ssl, 2 + n ) ) != 0 )
    976              {
    977                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
    978                  return( ret );
    979              }
    980          
    981              ssl->handshake->update_checksum( ssl, buf + 2, n );
    982          
    983              buf = ssl->in_msg;
    984              n = ssl->in_left - 5;
    985          
    986              /*
    987               *    0  .   1   ciphersuitelist length
    988               *    2  .   3   session id length
    989               *    4  .   5   challenge length
    990               *    6  .  ..   ciphersuitelist
    991               *   ..  .  ..   session id
    992               *   ..  .  ..   challenge
    993               */
    994              MBEDTLS_SSL_DEBUG_BUF( 4, "record contents", buf, n );
    995          
    996              ciph_len = ( buf[0] << 8 ) | buf[1];
    997              sess_len = ( buf[2] << 8 ) | buf[3];
    998              chal_len = ( buf[4] << 8 ) | buf[5];
    999          
   1000              MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciph_len: %d, sess_len: %d, chal_len: %d",
   1001                             ciph_len, sess_len, chal_len ) );
   1002          
   1003              /*
   1004               * Make sure each parameter length is valid
   1005               */
   1006              if( ciph_len < 3 || ( ciph_len % 3 ) != 0 )
   1007              {
   1008                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1009                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1010              }
   1011          
   1012              if( sess_len > 32 )
   1013              {
   1014                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1015                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1016              }
   1017          
   1018              if( chal_len < 8 || chal_len > 32 )
   1019              {
   1020                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1021                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1022              }
   1023          
   1024              if( n != 6 + ciph_len + sess_len + chal_len )
   1025              {
   1026                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1027                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1028              }
   1029          
   1030              MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, ciphersuitelist",
   1031                             buf + 6, ciph_len );
   1032              MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, session id",
   1033                             buf + 6 + ciph_len, sess_len );
   1034              MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, challenge",
   1035                             buf + 6 + ciph_len + sess_len, chal_len );
   1036          
   1037              p = buf + 6 + ciph_len;
   1038              ssl->session_negotiate->id_len = sess_len;
   1039              memset( ssl->session_negotiate->id, 0,
   1040                      sizeof( ssl->session_negotiate->id ) );
   1041              memcpy( ssl->session_negotiate->id, p, ssl->session_negotiate->id_len );
   1042          
   1043              p += sess_len;
   1044              memset( ssl->handshake->randbytes, 0, 64 );
   1045              memcpy( ssl->handshake->randbytes + 32 - chal_len, p, chal_len );
   1046          
   1047              /*
   1048               * Check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV
   1049               */
   1050              for( i = 0, p = buf + 6; i < ciph_len; i += 3, p += 3 )
   1051              {
   1052                  if( p[0] == 0 && p[1] == 0 && p[2] == MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO )
   1053                  {
   1054                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "received TLS_EMPTY_RENEGOTIATION_INFO " ) );
   1055          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1056                      if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
   1057                      {
   1058                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "received RENEGOTIATION SCSV "
   1059                                              "during renegotiation" ) );
   1060          
   1061                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1062                                                          MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
   1063                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1064                      }
   1065          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   1066                      ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
   1067                      break;
   1068                  }
   1069              }
   1070          
   1071          #if defined(MBEDTLS_SSL_FALLBACK_SCSV)
   1072              for( i = 0, p = buf + 6; i < ciph_len; i += 3, p += 3 )
   1073              {
   1074                  if( p[0] == 0 &&
   1075                      p[1] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE >> 8 ) & 0xff ) &&
   1076                      p[2] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE      ) & 0xff ) )
   1077                  {
   1078                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "received FALLBACK_SCSV" ) );
   1079          
   1080                      if( ssl->minor_ver < ssl->conf->max_minor_ver )
   1081                      {
   1082                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "inapropriate fallback" ) );
   1083          
   1084                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1085                                                  MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK );
   1086          
   1087                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1088                      }
   1089          
   1090                      break;
   1091                  }
   1092              }
   1093          #endif /* MBEDTLS_SSL_FALLBACK_SCSV */
   1094          
   1095              got_common_suite = 0;
   1096              ciphersuites = ssl->conf->ciphersuite_list[ssl->minor_ver];
   1097              ciphersuite_info = NULL;
   1098          #if defined(MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE)
   1099              for( j = 0, p = buf + 6; j < ciph_len; j += 3, p += 3 )
   1100                  for( i = 0; ciphersuites[i] != 0; i++ )
   1101          #else
   1102              for( i = 0; ciphersuites[i] != 0; i++ )
   1103                  for( j = 0, p = buf + 6; j < ciph_len; j += 3, p += 3 )
   1104          #endif
   1105                  {
   1106                      if( p[0] != 0 ||
   1107                          p[1] != ( ( ciphersuites[i] >> 8 ) & 0xFF ) ||
   1108                          p[2] != ( ( ciphersuites[i]      ) & 0xFF ) )
   1109                          continue;
   1110          
   1111                      got_common_suite = 1;
   1112          
   1113                      if( ( ret = ssl_ciphersuite_match( ssl, ciphersuites[i],
   1114                                                         &ciphersuite_info ) ) != 0 )
   1115                          return( ret );
   1116          
   1117                      if( ciphersuite_info != NULL )
   1118                          goto have_ciphersuite_v2;
   1119                  }
   1120          
   1121              if( got_common_suite )
   1122              {
   1123                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "got ciphersuites in common, "
   1124                                      "but none of them usable" ) );
   1125                  return( MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE );
   1126              }
   1127              else
   1128              {
   1129                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no ciphersuites in common" ) );
   1130                  return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );
   1131              }
   1132          
   1133          have_ciphersuite_v2:
   1134              MBEDTLS_SSL_DEBUG_MSG( 2, ( "selected ciphersuite: %s", ciphersuite_info->name ) );
   1135          
   1136              ssl->session_negotiate->ciphersuite = ciphersuites[i];
   1137              ssl->transform_negotiate->ciphersuite_info = ciphersuite_info;
   1138          
   1139              /*
   1140               * SSLv2 Client Hello relevant renegotiation security checks
   1141               */
   1142              if( ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
   1143                  ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE )
   1144              {
   1145                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "legacy renegotiation, breaking off handshake" ) );
   1146                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1147                                                  MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
   1148                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1149              }
   1150          
   1151              ssl->in_left = 0;
   1152              ssl->state++;
   1153          
   1154              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse client hello v2" ) );
   1155          
   1156              return( 0 );
   1157          }
   1158          #endif /* MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO */
   1159          
   1160          /* This function doesn't alert on errors that happen early during
   1161             ClientHello parsing because they might indicate that the client is
   1162             not talking SSL/TLS at all and would not understand our alert. */
   1163          static int ssl_parse_client_hello( mbedtls_ssl_context *ssl )
   1164          {
   1165              int ret, got_common_suite;
   1166              size_t i, j;
   1167              size_t ciph_offset, comp_offset, ext_offset;
   1168              size_t msg_len, ciph_len, sess_len, comp_len, ext_len;
   1169          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1170              size_t cookie_offset, cookie_len;
   1171          #endif
   1172              unsigned char *buf, *p, *ext;
   1173          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1174              int renegotiation_info_seen = 0;
   1175          #endif
   1176              int handshake_failure = 0;
   1177              const int *ciphersuites;
   1178              const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
   1179              int major, minor;
   1180          
   1181              /* If there is no signature-algorithm extension present,
   1182               * we need to fall back to the default values for allowed
   1183               * signature-hash pairs. */
   1184          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
   1185              defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
   1186              int sig_hash_alg_ext_present = 0;
   1187          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
   1188                    MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
   1189          
   1190              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse client hello" ) );
   1191          
   1192          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   1193          read_record_header:
   1194          #endif
   1195              /*
   1196               * If renegotiating, then the input was read with mbedtls_ssl_read_record(),
   1197               * otherwise read it ourselves manually in order to support SSLv2
   1198               * ClientHello, which doesn't use the same record layer format.
   1199               */
   1200          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1201              if( ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE )
   1202          #endif
   1203              {
   1204                  if( ( ret = mbedtls_ssl_fetch_input( ssl, 5 ) ) != 0 )
   1205                  {
   1206                      /* No alert on a read error. */
   1207                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
   1208                      return( ret );
   1209                  }
   1210              }
   1211          
   1212              buf = ssl->in_hdr;
   1213          
   1214          #if defined(MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO)
   1215          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1216              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_STREAM )
   1217          #endif
   1218                  if( ( buf[0] & 0x80 ) != 0 )
   1219                      return( ssl_parse_client_hello_v2( ssl ) );
   1220          #endif
   1221          
   1222              MBEDTLS_SSL_DEBUG_BUF( 4, "record header", buf, mbedtls_ssl_hdr_len( ssl ) );
   1223          
   1224              /*
   1225               * SSLv3/TLS Client Hello
   1226               *
   1227               * Record layer:
   1228               *     0  .   0   message type
   1229               *     1  .   2   protocol version
   1230               *     3  .   11  DTLS: epoch + record sequence number
   1231               *     3  .   4   message length
   1232               */
   1233              MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, message type: %d",
   1234                             buf[0] ) );
   1235          
   1236              if( buf[0] != MBEDTLS_SSL_MSG_HANDSHAKE )
   1237              {
   1238                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1239                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1240              }
   1241          
   1242              MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, message len.: %d",
   1243                             ( ssl->in_len[0] << 8 ) | ssl->in_len[1] ) );
   1244          
   1245              MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, protocol version: [%d:%d]",
   1246                             buf[1], buf[2] ) );
   1247          
   1248              mbedtls_ssl_read_version( &major, &minor, ssl->conf->transport, buf + 1 );
   1249          
   1250              /* According to RFC 5246 Appendix E.1, the version here is typically
   1251               * "{03,00}, the lowest version number supported by the client, [or] the
   1252               * value of ClientHello.client_version", so the only meaningful check here
   1253               * is the major version shouldn't be less than 3 */
   1254              if( major < MBEDTLS_SSL_MAJOR_VERSION_3 )
   1255              {
   1256                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1257                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1258              }
   1259          
   1260              /* For DTLS if this is the initial handshake, remember the client sequence
   1261               * number to use it in our next message (RFC 6347 4.2.1) */
   1262          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1263              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM
   1264          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1265                  && ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE
   1266          #endif
   1267                  )
   1268              {
   1269                  /* Epoch should be 0 for initial handshakes */
   1270                  if( ssl->in_ctr[0] != 0 || ssl->in_ctr[1] != 0 )
   1271                  {
   1272                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1273                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1274                  }
   1275          
   1276                  memcpy( ssl->out_ctr + 2, ssl->in_ctr + 2, 6 );
   1277          
   1278          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   1279                  if( mbedtls_ssl_dtls_replay_check( ssl ) != 0 )
   1280                  {
   1281                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "replayed record, discarding" ) );
   1282                      ssl->next_record_offset = 0;
   1283                      ssl->in_left = 0;
   1284                      goto read_record_header;
   1285                  }
   1286          
   1287                  /* No MAC to check yet, so we can update right now */
   1288                  mbedtls_ssl_dtls_replay_update( ssl );
   1289          #endif
   1290              }
   1291          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   1292          
   1293              msg_len = ( ssl->in_len[0] << 8 ) | ssl->in_len[1];
   1294          
   1295          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1296              if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
   1297              {
   1298                  /* Set by mbedtls_ssl_read_record() */
   1299                  msg_len = ssl->in_hslen;
   1300              }
   1301              else
   1302          #endif
   1303              {
   1304                  if( msg_len > MBEDTLS_SSL_MAX_CONTENT_LEN )
   1305                  {
   1306                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1307                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1308                  }
   1309          
   1310                  if( ( ret = mbedtls_ssl_fetch_input( ssl,
   1311                                 mbedtls_ssl_hdr_len( ssl ) + msg_len ) ) != 0 )
   1312                  {
   1313                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
   1314                      return( ret );
   1315                  }
   1316          
   1317              /* Done reading this record, get ready for the next one */
   1318          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1319                  if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   1320                      ssl->next_record_offset = msg_len + mbedtls_ssl_hdr_len( ssl );
   1321                  else
   1322          #endif
   1323                      ssl->in_left = 0;
   1324              }
   1325          
   1326              buf = ssl->in_msg;
   1327          
   1328              MBEDTLS_SSL_DEBUG_BUF( 4, "record contents", buf, msg_len );
   1329          
   1330              ssl->handshake->update_checksum( ssl, buf, msg_len );
   1331          
   1332              /*
   1333               * Handshake layer:
   1334               *     0  .   0   handshake type
   1335               *     1  .   3   handshake length
   1336               *     4  .   5   DTLS only: message seqence number
   1337               *     6  .   8   DTLS only: fragment offset
   1338               *     9  .  11   DTLS only: fragment length
   1339               */
   1340              if( msg_len < mbedtls_ssl_hs_hdr_len( ssl ) )
   1341              {
   1342                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1343                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1344              }
   1345          
   1346              MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, handshake type: %d", buf[0] ) );
   1347          
   1348              if( buf[0] != MBEDTLS_SSL_HS_CLIENT_HELLO )
   1349              {
   1350                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1351                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1352              }
   1353          
   1354              MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, handshake len.: %d",
   1355                             ( buf[1] << 16 ) | ( buf[2] << 8 ) | buf[3] ) );
   1356          
   1357              /* We don't support fragmentation of ClientHello (yet?) */
   1358              if( buf[1] != 0 ||
   1359                  msg_len != mbedtls_ssl_hs_hdr_len( ssl ) + ( ( buf[2] << 8 ) | buf[3] ) )
   1360              {
   1361                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1362                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1363              }
   1364          
   1365          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1366              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   1367              {
   1368                  /*
   1369                   * Copy the client's handshake message_seq on initial handshakes,
   1370                   * check sequence number on renego.
   1371                   */
   1372          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1373                  if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
   1374                  {
   1375                      /* This couldn't be done in ssl_prepare_handshake_record() */
   1376                      unsigned int cli_msg_seq = ( ssl->in_msg[4] << 8 ) |
   1377                                                   ssl->in_msg[5];
   1378          
   1379                      if( cli_msg_seq != ssl->handshake->in_msg_seq )
   1380                      {
   1381                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message_seq: "
   1382                                              "%d (expected %d)", cli_msg_seq,
   1383                                              ssl->handshake->in_msg_seq ) );
   1384                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1385                      }
   1386          
   1387                      ssl->handshake->in_msg_seq++;
   1388                  }
   1389                  else
   1390          #endif
   1391                  {
   1392                      unsigned int cli_msg_seq = ( ssl->in_msg[4] << 8 ) |
   1393                                                   ssl->in_msg[5];
   1394                      ssl->handshake->out_msg_seq = cli_msg_seq;
   1395                      ssl->handshake->in_msg_seq  = cli_msg_seq + 1;
   1396                  }
   1397          
   1398                  /*
   1399                   * For now we don't support fragmentation, so make sure
   1400                   * fragment_offset == 0 and fragment_length == length
   1401                   */
   1402                  if( ssl->in_msg[6] != 0 || ssl->in_msg[7] != 0 || ssl->in_msg[8] != 0 ||
   1403                      memcmp( ssl->in_msg + 1, ssl->in_msg + 9, 3 ) != 0 )
   1404                  {
   1405                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "ClientHello fragmentation not supported" ) );
   1406                      return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
   1407                  }
   1408              }
   1409          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   1410          
   1411              buf += mbedtls_ssl_hs_hdr_len( ssl );
   1412              msg_len -= mbedtls_ssl_hs_hdr_len( ssl );
   1413          
   1414              /*
   1415               * ClientHello layer:
   1416               *     0  .   1   protocol version
   1417               *     2  .  33   random bytes (starting with 4 bytes of Unix time)
   1418               *    34  .  35   session id length (1 byte)
   1419               *    35  . 34+x  session id
   1420               *   35+x . 35+x  DTLS only: cookie length (1 byte)
   1421               *   36+x .  ..   DTLS only: cookie
   1422               *    ..  .  ..   ciphersuite list length (2 bytes)
   1423               *    ..  .  ..   ciphersuite list
   1424               *    ..  .  ..   compression alg. list length (1 byte)
   1425               *    ..  .  ..   compression alg. list
   1426               *    ..  .  ..   extensions length (2 bytes, optional)
   1427               *    ..  .  ..   extensions (optional)
   1428               */
   1429          
   1430              /*
   1431               * Minimal length (with everything empty and extensions ommitted) is
   1432               * 2 + 32 + 1 + 2 + 1 = 38 bytes. Check that first, so that we can
   1433               * read at least up to session id length without worrying.
   1434               */
   1435              if( msg_len < 38 )
   1436              {
   1437                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1438                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1439              }
   1440          
   1441              /*
   1442               * Check and save the protocol version
   1443               */
   1444              MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, version", buf, 2 );
   1445          
   1446              mbedtls_ssl_read_version( &ssl->major_ver, &ssl->minor_ver,
   1447                                ssl->conf->transport, buf );
   1448          
   1449              ssl->handshake->max_major_ver = ssl->major_ver;
   1450              ssl->handshake->max_minor_ver = ssl->minor_ver;
   1451          
   1452              if( ssl->major_ver < ssl->conf->min_major_ver ||
   1453                  ssl->minor_ver < ssl->conf->min_minor_ver )
   1454              {
   1455                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "client only supports ssl smaller than minimum"
   1456                                      " [%d:%d] < [%d:%d]",
   1457                                      ssl->major_ver, ssl->minor_ver,
   1458                                      ssl->conf->min_major_ver, ssl->conf->min_minor_ver ) );
   1459                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1460                                               MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );
   1461                  return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );
   1462              }
   1463          
   1464              if( ssl->major_ver > ssl->conf->max_major_ver )
   1465              {
   1466                  ssl->major_ver = ssl->conf->max_major_ver;
   1467                  ssl->minor_ver = ssl->conf->max_minor_ver;
   1468              }
   1469              else if( ssl->minor_ver > ssl->conf->max_minor_ver )
   1470                  ssl->minor_ver = ssl->conf->max_minor_ver;
   1471          
   1472              /*
   1473               * Save client random (inc. Unix time)
   1474               */
   1475              MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, random bytes", buf + 2, 32 );
   1476          
   1477              memcpy( ssl->handshake->randbytes, buf + 2, 32 );
   1478          
   1479              /*
   1480               * Check the session ID length and save session ID
   1481               */
   1482              sess_len = buf[34];
   1483          
   1484              if( sess_len > sizeof( ssl->session_negotiate->id ) ||
   1485                  sess_len + 34 + 2 > msg_len ) /* 2 for cipherlist length field */
   1486              {
   1487                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1488                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1489                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   1490                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1491              }
   1492          
   1493              MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, session id", buf + 35, sess_len );
   1494          
   1495              ssl->session_negotiate->id_len = sess_len;
   1496              memset( ssl->session_negotiate->id, 0,
   1497                      sizeof( ssl->session_negotiate->id ) );
   1498              memcpy( ssl->session_negotiate->id, buf + 35,
   1499                      ssl->session_negotiate->id_len );
   1500          
   1501              /*
   1502               * Check the cookie length and content
   1503               */
   1504          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1505              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   1506              {
   1507                  cookie_offset = 35 + sess_len;
   1508                  cookie_len = buf[cookie_offset];
   1509          
   1510                  if( cookie_offset + 1 + cookie_len + 2 > msg_len )
   1511                  {
   1512                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1513                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1514                                                      MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );
   1515                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1516                  }
   1517          
   1518                  MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, cookie",
   1519                                 buf + cookie_offset + 1, cookie_len );
   1520          
   1521          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
   1522                  if( ssl->conf->f_cookie_check != NULL
   1523          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1524                      && ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE
   1525          #endif
   1526                      )
   1527                  {
   1528                      if( ssl->conf->f_cookie_check( ssl->conf->p_cookie,
   1529                                               buf + cookie_offset + 1, cookie_len,
   1530                                               ssl->cli_id, ssl->cli_id_len ) != 0 )
   1531                      {
   1532                          MBEDTLS_SSL_DEBUG_MSG( 2, ( "cookie verification failed" ) );
   1533                          ssl->handshake->verify_cookie_len = 1;
   1534                      }
   1535                      else
   1536                      {
   1537                          MBEDTLS_SSL_DEBUG_MSG( 2, ( "cookie verification passed" ) );
   1538                          ssl->handshake->verify_cookie_len = 0;
   1539                      }
   1540                  }
   1541                  else
   1542          #endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
   1543                  {
   1544                      /* We know we didn't send a cookie, so it should be empty */
   1545                      if( cookie_len != 0 )
   1546                      {
   1547                          /* This may be an attacker's probe, so don't send an alert */
   1548                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1549                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1550                      }
   1551          
   1552                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "cookie verification skipped" ) );
   1553                  }
   1554          
   1555              /*
   1556               * Check the ciphersuitelist length (will be parsed later)
   1557               */
   1558                  ciph_offset = cookie_offset + 1 + cookie_len;
   1559              }
   1560              else
   1561          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   1562                  ciph_offset = 35 + sess_len;
   1563          
   1564              ciph_len = ( buf[ciph_offset + 0] << 8 )
   1565                       | ( buf[ciph_offset + 1]      );
   1566          
   1567              if( ciph_len < 2 ||
   1568                  ciph_len + 2 + ciph_offset + 1 > msg_len || /* 1 for comp. alg. len */
   1569                  ( ciph_len % 2 ) != 0 )
   1570              {
   1571                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1572                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1573                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   1574                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1575              }
   1576          
   1577              MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, ciphersuitelist",
   1578                             buf + ciph_offset + 2,  ciph_len );
   1579          
   1580              /*
   1581               * Check the compression algorithms length and pick one
   1582               */
   1583              comp_offset = ciph_offset + 2 + ciph_len;
   1584          
   1585              comp_len = buf[comp_offset];
   1586          
   1587              if( comp_len < 1 ||
   1588                  comp_len > 16 ||
   1589                  comp_len + comp_offset + 1 > msg_len )
   1590              {
   1591                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1592                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1593                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   1594                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1595              }
   1596          
   1597              MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, compression",
   1598                                buf + comp_offset + 1, comp_len );
   1599          
   1600              ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_NULL;
   1601          #if defined(MBEDTLS_ZLIB_SUPPORT)
   1602              for( i = 0; i < comp_len; ++i )
   1603              {
   1604                  if( buf[comp_offset + 1 + i] == MBEDTLS_SSL_COMPRESS_DEFLATE )
   1605                  {
   1606                      ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_DEFLATE;
   1607                      break;
   1608                  }
   1609              }
   1610          #endif
   1611          
   1612              /* See comments in ssl_write_client_hello() */
   1613          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1614              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   1615                  ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_NULL;
   1616          #endif
   1617          
   1618              /* Do not parse the extensions if the protocol is SSLv3 */
   1619          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   1620              if( ( ssl->major_ver != 3 ) || ( ssl->minor_ver != 0 ) )
   1621              {
   1622          #endif
   1623                  /*
   1624                   * Check the extension length
   1625                   */
   1626                  ext_offset = comp_offset + 1 + comp_len;
   1627                  if( msg_len > ext_offset )
   1628                  {
   1629                      if( msg_len < ext_offset + 2 )
   1630                      {
   1631                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1632                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1633                                                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   1634                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1635                      }
   1636          
   1637                      ext_len = ( buf[ext_offset + 0] << 8 )
   1638                              | ( buf[ext_offset + 1]      );
   1639          
   1640                      if( ( ext_len > 0 && ext_len < 4 ) ||
   1641                          msg_len != ext_offset + 2 + ext_len )
   1642                      {
   1643                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1644                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1645                                                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   1646                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1647                      }
   1648                  }
   1649                  else
   1650                      ext_len = 0;
   1651          
   1652                  ext = buf + ext_offset + 2;
   1653                  MBEDTLS_SSL_DEBUG_BUF( 3, "client hello extensions", ext, ext_len );
   1654          
   1655                  while( ext_len != 0 )
   1656                  {
   1657                      unsigned int ext_id   = ( ( ext[0] <<  8 )
   1658                                              | ( ext[1]       ) );
   1659                      unsigned int ext_size = ( ( ext[2] <<  8 )
   1660                                              | ( ext[3]       ) );
   1661          
   1662                      if( ext_size + 4 > ext_len )
   1663                      {
   1664                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1665                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1666                                                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   1667                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1668                      }
   1669                      switch( ext_id )
   1670                      {
   1671          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   1672                      case MBEDTLS_TLS_EXT_SERVERNAME:
   1673                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found ServerName extension" ) );
   1674                          if( ssl->conf->f_sni == NULL )
   1675                              break;
   1676          
   1677                          ret = ssl_parse_servername_ext( ssl, ext + 4, ext_size );
   1678                          if( ret != 0 )
   1679                              return( ret );
   1680                          break;
   1681          #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
   1682          
   1683                      case MBEDTLS_TLS_EXT_RENEGOTIATION_INFO:
   1684                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found renegotiation extension" ) );
   1685          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1686                          renegotiation_info_seen = 1;
   1687          #endif
   1688          
   1689                          ret = ssl_parse_renegotiation_info( ssl, ext + 4, ext_size );
   1690                          if( ret != 0 )
   1691                              return( ret );
   1692                          break;
   1693          
   1694          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
   1695              defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
   1696                      case MBEDTLS_TLS_EXT_SIG_ALG:
   1697                              MBEDTLS_SSL_DEBUG_MSG( 3, ( "found signature_algorithms extension" ) );
   1698          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1699                          if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
   1700                              break;
   1701          #endif
   1702                          ret = ssl_parse_signature_algorithms_ext( ssl, ext + 4, ext_size );
   1703                          if( ret != 0 )
   1704                              return( ret );
   1705          
   1706                          sig_hash_alg_ext_present = 1;
   1707                          break;
   1708          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
   1709                    MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
   1710          
   1711          #if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
   1712              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   1713                      case MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES:
   1714                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found supported elliptic curves extension" ) );
   1715          
   1716                          ret = ssl_parse_supported_elliptic_curves( ssl, ext + 4, ext_size );
   1717                          if( ret != 0 )
   1718                              return( ret );
   1719                          break;
   1720          
   1721                      case MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS:
   1722                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found supported point formats extension" ) );
   1723                          ssl->handshake->cli_exts |= MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT;
   1724          
   1725                          ret = ssl_parse_supported_point_formats( ssl, ext + 4, ext_size );
   1726                          if( ret != 0 )
   1727                              return( ret );
   1728                          break;
   1729          #endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C ||
   1730                    MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   1731          
   1732          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   1733                      case MBEDTLS_TLS_EXT_ECJPAKE_KKPP:
   1734                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found ecjpake kkpp extension" ) );
   1735          
   1736                          ret = ssl_parse_ecjpake_kkpp( ssl, ext + 4, ext_size );
   1737                          if( ret != 0 )
   1738                              return( ret );
   1739                          break;
   1740          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   1741          
   1742          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   1743                      case MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH:
   1744                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found max fragment length extension" ) );
   1745          
   1746                          ret = ssl_parse_max_fragment_length_ext( ssl, ext + 4, ext_size );
   1747                          if( ret != 0 )
   1748                              return( ret );
   1749                          break;
   1750          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
   1751          
   1752          #if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
   1753                      case MBEDTLS_TLS_EXT_TRUNCATED_HMAC:
   1754                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found truncated hmac extension" ) );
   1755          
   1756                          ret = ssl_parse_truncated_hmac_ext( ssl, ext + 4, ext_size );
   1757                          if( ret != 0 )
   1758                              return( ret );
   1759                          break;
   1760          #endif /* MBEDTLS_SSL_TRUNCATED_HMAC */
   1761          
   1762          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   1763                      case MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC:
   1764                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found encrypt then mac extension" ) );
   1765          
   1766                          ret = ssl_parse_encrypt_then_mac_ext( ssl, ext + 4, ext_size );
   1767                          if( ret != 0 )
   1768                              return( ret );
   1769                          break;
   1770          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
   1771          
   1772          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   1773                      case MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET:
   1774                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found extended master secret extension" ) );
   1775          
   1776                          ret = ssl_parse_extended_ms_ext( ssl, ext + 4, ext_size );
   1777                          if( ret != 0 )
   1778                              return( ret );
   1779                          break;
   1780          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
   1781          
   1782          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   1783                      case MBEDTLS_TLS_EXT_SESSION_TICKET:
   1784                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found session ticket extension" ) );
   1785          
   1786                          ret = ssl_parse_session_ticket_ext( ssl, ext + 4, ext_size );
   1787                          if( ret != 0 )
   1788                              return( ret );
   1789                          break;
   1790          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   1791          
   1792          #if defined(MBEDTLS_SSL_ALPN)
   1793                      case MBEDTLS_TLS_EXT_ALPN:
   1794                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found alpn extension" ) );
   1795          
   1796                          ret = ssl_parse_alpn_ext( ssl, ext + 4, ext_size );
   1797                          if( ret != 0 )
   1798                              return( ret );
   1799                          break;
   1800          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   1801          
   1802                      default:
   1803                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "unknown extension found: %d (ignoring)",
   1804                                         ext_id ) );
   1805                      }
   1806          
   1807                      ext_len -= 4 + ext_size;
   1808                      ext += 4 + ext_size;
   1809          
   1810                      if( ext_len > 0 && ext_len < 4 )
   1811                      {
   1812                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1813                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1814                                                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   1815                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1816                      }
   1817                  }
   1818          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   1819              }
   1820          #endif
   1821          
   1822          #if defined(MBEDTLS_SSL_FALLBACK_SCSV)
   1823              for( i = 0, p = buf + ciph_offset + 2; i < ciph_len; i += 2, p += 2 )
   1824              {
   1825                  if( p[0] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE >> 8 ) & 0xff ) &&
   1826                      p[1] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE      ) & 0xff ) )
   1827                  {
   1828                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "received FALLBACK_SCSV" ) );
   1829          
   1830                      if( ssl->minor_ver < ssl->conf->max_minor_ver )
   1831                      {
   1832                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "inapropriate fallback" ) );
   1833          
   1834                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1835                                                  MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK );
   1836          
   1837                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1838                      }
   1839          
   1840                      break;
   1841                  }
   1842              }
   1843          #endif /* MBEDTLS_SSL_FALLBACK_SCSV */
   1844          
   1845          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
   1846              defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
   1847          
   1848              /*
   1849               * Try to fall back to default hash SHA1 if the client
   1850               * hasn't provided any preferred signature-hash combinations.
   1851               */
   1852              if( sig_hash_alg_ext_present == 0 )
   1853              {
   1854                  mbedtls_md_type_t md_default = MBEDTLS_MD_SHA1;
   1855          
   1856                  if( mbedtls_ssl_check_sig_hash( ssl, md_default ) != 0 )
   1857                      md_default = MBEDTLS_MD_NONE;
   1858          
   1859                  mbedtls_ssl_sig_hash_set_const_hash( &ssl->handshake->hash_algs, md_default );
   1860              }
   1861          
   1862          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
   1863                    MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
   1864          
   1865              /*
   1866               * Check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV
   1867               */
   1868              for( i = 0, p = buf + ciph_offset + 2; i < ciph_len; i += 2, p += 2 )
   1869              {
   1870                  if( p[0] == 0 && p[1] == MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO )
   1871                  {
   1872                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "received TLS_EMPTY_RENEGOTIATION_INFO " ) );
   1873          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1874                      if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
   1875                      {
   1876                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "received RENEGOTIATION SCSV "
   1877                                                      "during renegotiation" ) );
   1878                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1879                                                          MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
   1880                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1881                      }
   1882          #endif
   1883                      ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
   1884                      break;
   1885                  }
   1886              }
   1887          
   1888              /*
   1889               * Renegotiation security checks
   1890               */
   1891              if( ssl->secure_renegotiation != MBEDTLS_SSL_SECURE_RENEGOTIATION &&
   1892                  ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE )
   1893              {
   1894                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "legacy renegotiation, breaking off handshake" ) );
   1895                  handshake_failure = 1;
   1896              }
   1897          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1898              else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   1899                       ssl->secure_renegotiation == MBEDTLS_SSL_SECURE_RENEGOTIATION &&
   1900                       renegotiation_info_seen == 0 )
   1901              {
   1902                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "renegotiation_info extension missing (secure)" ) );
   1903                  handshake_failure = 1;
   1904              }
   1905              else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   1906                       ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
   1907                       ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION )
   1908              {
   1909                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "legacy renegotiation not allowed" ) );
   1910                  handshake_failure = 1;
   1911              }
   1912              else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   1913                       ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
   1914                       renegotiation_info_seen == 1 )
   1915              {
   1916                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "renegotiation_info extension present (legacy)" ) );
   1917                  handshake_failure = 1;
   1918              }
   1919          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   1920          
   1921              if( handshake_failure == 1 )
   1922              {
   1923                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1924                                                  MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
   1925                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1926              }
   1927          
   1928              /*
   1929               * Search for a matching ciphersuite
   1930               * (At the end because we need information from the EC-based extensions
   1931               * and certificate from the SNI callback triggered by the SNI extension.)
   1932               */
   1933              got_common_suite = 0;
   1934              ciphersuites = ssl->conf->ciphersuite_list[ssl->minor_ver];
   1935              ciphersuite_info = NULL;
   1936          #if defined(MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE)
   1937              for( j = 0, p = buf + ciph_offset + 2; j < ciph_len; j += 2, p += 2 )
   1938                  for( i = 0; ciphersuites[i] != 0; i++ )
   1939          #else
   1940              for( i = 0; ciphersuites[i] != 0; i++ )
   1941                  for( j = 0, p = buf + ciph_offset + 2; j < ciph_len; j += 2, p += 2 )
   1942          #endif
   1943                  {
   1944                      if( p[0] != ( ( ciphersuites[i] >> 8 ) & 0xFF ) ||
   1945                          p[1] != ( ( ciphersuites[i]      ) & 0xFF ) )
   1946                          continue;
   1947          
   1948                      got_common_suite = 1;
   1949          
   1950                      if( ( ret = ssl_ciphersuite_match( ssl, ciphersuites[i],
   1951                                                         &ciphersuite_info ) ) != 0 )
   1952                          return( ret );
   1953          
   1954                      if( ciphersuite_info != NULL )
   1955                          goto have_ciphersuite;
   1956                  }
   1957          
   1958              if( got_common_suite )
   1959              {
   1960                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "got ciphersuites in common, "
   1961                                      "but none of them usable" ) );
   1962                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1963                                                  MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
   1964                  return( MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE );
   1965              }
   1966              else
   1967              {
   1968                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no ciphersuites in common" ) );
   1969                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1970                                                  MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
   1971                  return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );
   1972              }
   1973          
   1974          have_ciphersuite:
   1975              MBEDTLS_SSL_DEBUG_MSG( 2, ( "selected ciphersuite: %s", ciphersuite_info->name ) );
   1976          
   1977              ssl->session_negotiate->ciphersuite = ciphersuites[i];
   1978              ssl->transform_negotiate->ciphersuite_info = ciphersuite_info;
   1979          
   1980              ssl->state++;
   1981          
   1982          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1983              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   1984                  mbedtls_ssl_recv_flight_completed( ssl );
   1985          #endif
   1986          
   1987              /* Debugging-only output for testsuite */
   1988          #if defined(MBEDTLS_DEBUG_C)                         && \
   1989              defined(MBEDTLS_SSL_PROTO_TLS1_2)                && \
   1990              defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
   1991              if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
   1992              {
   1993                  mbedtls_pk_type_t sig_alg = mbedtls_ssl_get_ciphersuite_sig_alg( ciphersuite_info );
   1994                  if( sig_alg != MBEDTLS_PK_NONE )
   1995                  {
   1996                      mbedtls_md_type_t md_alg = mbedtls_ssl_sig_hash_set_find( &ssl->handshake->hash_algs,
   1997                                                                            sig_alg );
   1998                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, signature_algorithm ext: %d",
   1999                                                  mbedtls_ssl_hash_from_md_alg( md_alg ) ) );
   2000                  }
   2001                  else
   2002                  {
   2003                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "no hash algorithm for signature algorithm "
   2004                                                  "%d - should not happen", sig_alg ) );
   2005                  }
   2006              }
   2007          #endif
   2008          
   2009              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse client hello" ) );
   2010          
   2011              return( 0 );
   2012          }
   2013          
   2014          #if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
   2015          static void ssl_write_truncated_hmac_ext( mbedtls_ssl_context *ssl,
   2016                                                    unsigned char *buf,
   2017                                                    size_t *olen )
   2018          {
   2019              unsigned char *p = buf;
   2020          
   2021              if( ssl->session_negotiate->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_DISABLED )
   2022              {
   2023                  *olen = 0;
   2024                  return;
   2025              }
   2026          
   2027              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding truncated hmac extension" ) );
   2028          
   2029              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC >> 8 ) & 0xFF );
   2030              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC      ) & 0xFF );
   2031          
   2032              *p++ = 0x00;
   2033              *p++ = 0x00;
   2034          
   2035              *olen = 4;
   2036          }
   2037          #endif /* MBEDTLS_SSL_TRUNCATED_HMAC */
   2038          
   2039          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   2040          static void ssl_write_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,
   2041                                                      unsigned char *buf,
   2042                                                      size_t *olen )
   2043          {
   2044              unsigned char *p = buf;
   2045              const mbedtls_ssl_ciphersuite_t *suite = NULL;
   2046              const mbedtls_cipher_info_t *cipher = NULL;
   2047          
   2048              if( ssl->session_negotiate->encrypt_then_mac == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
   2049                  ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
   2050              {
   2051                  *olen = 0;
   2052                  return;
   2053              }
   2054          
   2055              /*
   2056               * RFC 7366: "If a server receives an encrypt-then-MAC request extension
   2057               * from a client and then selects a stream or Authenticated Encryption
   2058               * with Associated Data (AEAD) ciphersuite, it MUST NOT send an
   2059               * encrypt-then-MAC response extension back to the client."
   2060               */
   2061              if( ( suite = mbedtls_ssl_ciphersuite_from_id(
   2062                              ssl->session_negotiate->ciphersuite ) ) == NULL ||
   2063                  ( cipher = mbedtls_cipher_info_from_type( suite->cipher ) ) == NULL ||
   2064                  cipher->mode != MBEDTLS_MODE_CBC )
   2065              {
   2066                  *olen = 0;
   2067                  return;
   2068              }
   2069          
   2070              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding encrypt then mac extension" ) );
   2071          
   2072              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC >> 8 ) & 0xFF );
   2073              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC      ) & 0xFF );
   2074          
   2075              *p++ = 0x00;
   2076              *p++ = 0x00;
   2077          
   2078              *olen = 4;
   2079          }
   2080          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
   2081          
   2082          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   2083          static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
   2084                                                 unsigned char *buf,
   2085                                                 size_t *olen )
   2086          {
   2087              unsigned char *p = buf;
   2088          
   2089              if( ssl->handshake->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
   2090                  ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
   2091              {
   2092                  *olen = 0;
   2093                  return;
   2094              }
   2095          
   2096              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding extended master secret "
   2097                                  "extension" ) );
   2098          
   2099              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
   2100              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );
   2101          
   2102              *p++ = 0x00;
   2103              *p++ = 0x00;
   2104          
   2105              *olen = 4;
   2106          }
   2107          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
   2108          
   2109          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   2110          static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
   2111                                                    unsigned char *buf,
   2112                                                    size_t *olen )
   2113          {
   2114              unsigned char *p = buf;
   2115          
   2116              if( ssl->handshake->new_session_ticket == 0 )
   2117              {
   2118                  *olen = 0;
   2119                  return;
   2120              }
   2121          
   2122              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding session ticket extension" ) );
   2123          
   2124              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET >> 8 ) & 0xFF );
   2125              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET      ) & 0xFF );
   2126          
   2127              *p++ = 0x00;
   2128              *p++ = 0x00;
   2129          
   2130              *olen = 4;
   2131          }
   2132          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   2133          
   2134          static void ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl,
   2135                                                   unsigned char *buf,
   2136                                                   size_t *olen )
   2137          {
   2138              unsigned char *p = buf;
   2139          
   2140              if( ssl->secure_renegotiation != MBEDTLS_SSL_SECURE_RENEGOTIATION )
   2141              {
   2142                  *olen = 0;
   2143                  return;
   2144              }
   2145          
   2146              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, secure renegotiation extension" ) );
   2147          
   2148              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );
   2149              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );
   2150          
   2151          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   2152              if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
   2153              {
   2154                  *p++ = 0x00;
   2155                  *p++ = ( ssl->verify_data_len * 2 + 1 ) & 0xFF;
   2156                  *p++ = ssl->verify_data_len * 2 & 0xFF;
   2157          
   2158                  memcpy( p, ssl->peer_verify_data, ssl->verify_data_len );
   2159                  p += ssl->verify_data_len;
   2160                  memcpy( p, ssl->own_verify_data, ssl->verify_data_len );
   2161                  p += ssl->verify_data_len;
   2162              }
   2163              else
   2164          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   2165              {
   2166                  *p++ = 0x00;
   2167                  *p++ = 0x01;
   2168                  *p++ = 0x00;
   2169              }
   2170          
   2171              *olen = p - buf;
   2172          }
   2173          
   2174          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   2175          static void ssl_write_max_fragment_length_ext( mbedtls_ssl_context *ssl,
   2176                                                         unsigned char *buf,
   2177                                                         size_t *olen )
   2178          {
   2179              unsigned char *p = buf;
   2180          
   2181              if( ssl->session_negotiate->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE )
   2182              {
   2183                  *olen = 0;
   2184                  return;
   2185              }
   2186          
   2187              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, max_fragment_length extension" ) );
   2188          
   2189              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH >> 8 ) & 0xFF );
   2190              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH      ) & 0xFF );
   2191          
   2192              *p++ = 0x00;
   2193              *p++ = 1;
   2194          
   2195              *p++ = ssl->session_negotiate->mfl_code;
   2196          
   2197              *olen = 5;
   2198          }
   2199          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
   2200          
   2201          #if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
   2202              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   2203          static void ssl_write_supported_point_formats_ext( mbedtls_ssl_context *ssl,
   2204                                                             unsigned char *buf,
   2205                                                             size_t *olen )
   2206          {
   2207              unsigned char *p = buf;
   2208              ((void) ssl);
   2209          
   2210              if( ( ssl->handshake->cli_exts &
   2211                    MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT ) == 0 )
   2212              {
   2213                  *olen = 0;
   2214                  return;
   2215              }
   2216          
   2217              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, supported_point_formats extension" ) );
   2218          
   2219              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS >> 8 ) & 0xFF );
   2220              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS      ) & 0xFF );
   2221          
   2222              *p++ = 0x00;
   2223              *p++ = 2;
   2224          
   2225              *p++ = 1;
   2226              *p++ = MBEDTLS_ECP_PF_UNCOMPRESSED;
   2227          
   2228              *olen = 6;
   2229          }
   2230          #endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C || MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   2231          
   2232          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   2233          static void ssl_write_ecjpake_kkpp_ext( mbedtls_ssl_context *ssl,
   2234                                                  unsigned char *buf,
   2235                                                  size_t *olen )
   2236          {
   2237              int ret;
   2238              unsigned char *p = buf;
   2239              const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
   2240              size_t kkpp_len;
   2241          
   2242              *olen = 0;
   2243          
   2244              /* Skip costly computation if not needed */
   2245              if( ssl->transform_negotiate->ciphersuite_info->key_exchange !=
   2246                  MBEDTLS_KEY_EXCHANGE_ECJPAKE )
   2247                  return;
   2248          
   2249              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, ecjpake kkpp extension" ) );
   2250          
   2251              if( end - p < 4 )
   2252              {
   2253                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "buffer too small" ) );
   2254                  return;
   2255              }
   2256          
   2257              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ECJPAKE_KKPP >> 8 ) & 0xFF );
   2258              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ECJPAKE_KKPP      ) & 0xFF );
   2259          
   2260              ret = mbedtls_ecjpake_write_round_one( &ssl->handshake->ecjpake_ctx,
   2261                                                  p + 2, end - p - 2, &kkpp_len,
   2262                                                  ssl->conf->f_rng, ssl->conf->p_rng );
   2263              if( ret != 0 )
   2264              {
   2265                  MBEDTLS_SSL_DEBUG_RET( 1 , "mbedtls_ecjpake_write_round_one", ret );
   2266                  return;
   2267              }
   2268          
   2269              *p++ = (unsigned char)( ( kkpp_len >> 8 ) & 0xFF );
   2270              *p++ = (unsigned char)( ( kkpp_len      ) & 0xFF );
   2271          
   2272              *olen = kkpp_len + 4;
   2273          }
   2274          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   2275          
   2276          #if defined(MBEDTLS_SSL_ALPN )
   2277          static void ssl_write_alpn_ext( mbedtls_ssl_context *ssl,
   2278                                          unsigned char *buf, size_t *olen )
   2279          {
   2280              if( ssl->alpn_chosen == NULL )
   2281              {
   2282                  *olen = 0;
   2283                  return;
   2284              }
   2285          
   2286              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding alpn extension" ) );
   2287          
   2288              /*
   2289               * 0 . 1    ext identifier
   2290               * 2 . 3    ext length
   2291               * 4 . 5    protocol list length
   2292               * 6 . 6    protocol name length
   2293               * 7 . 7+n  protocol name
   2294               */
   2295              buf[0] = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN >> 8 ) & 0xFF );
   2296              buf[1] = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN      ) & 0xFF );
   2297          
   2298              *olen = 7 + strlen( ssl->alpn_chosen );
   2299          
   2300              buf[2] = (unsigned char)( ( ( *olen - 4 ) >> 8 ) & 0xFF );
   2301              buf[3] = (unsigned char)( ( ( *olen - 4 )      ) & 0xFF );
   2302          
   2303              buf[4] = (unsigned char)( ( ( *olen - 6 ) >> 8 ) & 0xFF );
   2304              buf[5] = (unsigned char)( ( ( *olen - 6 )      ) & 0xFF );
   2305          
   2306              buf[6] = (unsigned char)( ( ( *olen - 7 )      ) & 0xFF );
   2307          
   2308              memcpy( buf + 7, ssl->alpn_chosen, *olen - 7 );
   2309          }
   2310          #endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C */
   2311          
   2312          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
   2313          static int ssl_write_hello_verify_request( mbedtls_ssl_context *ssl )
   2314          {
   2315              int ret;
   2316              unsigned char *p = ssl->out_msg + 4;
   2317              unsigned char *cookie_len_byte;
   2318          
   2319              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write hello verify request" ) );
   2320          
   2321              /*
   2322               * struct {
   2323               *   ProtocolVersion server_version;
   2324               *   opaque cookie<0..2^8-1>;
   2325               * } HelloVerifyRequest;
   2326               */
   2327          
   2328              /* The RFC is not clear on this point, but sending the actual negotiated
   2329               * version looks like the most interoperable thing to do. */
   2330              mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
   2331                                 ssl->conf->transport, p );
   2332              MBEDTLS_SSL_DEBUG_BUF( 3, "server version", p, 2 );
   2333              p += 2;
   2334          
   2335              /* If we get here, f_cookie_check is not null */
   2336              if( ssl->conf->f_cookie_write == NULL )
   2337              {
   2338                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "inconsistent cookie callbacks" ) );
   2339                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   2340              }
   2341          
   2342              /* Skip length byte until we know the length */
   2343              cookie_len_byte = p++;
   2344          
   2345              if( ( ret = ssl->conf->f_cookie_write( ssl->conf->p_cookie,
   2346                                               &p, ssl->out_buf + MBEDTLS_SSL_BUFFER_LEN,
   2347                                               ssl->cli_id, ssl->cli_id_len ) ) != 0 )
   2348              {
   2349                  MBEDTLS_SSL_DEBUG_RET( 1, "f_cookie_write", ret );
   2350                  return( ret );
   2351              }
   2352          
   2353              *cookie_len_byte = (unsigned char)( p - ( cookie_len_byte + 1 ) );
   2354          
   2355              MBEDTLS_SSL_DEBUG_BUF( 3, "cookie sent", cookie_len_byte + 1, *cookie_len_byte );
   2356          
   2357              ssl->out_msglen  = p - ssl->out_msg;
   2358              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   2359              ssl->out_msg[0]  = MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST;
   2360          
   2361              ssl->state = MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT;
   2362          
   2363              if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
   2364              {
   2365                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
   2366                  return( ret );
   2367              }
   2368          
   2369              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write hello verify request" ) );
   2370          
   2371              return( 0 );
   2372          }
   2373          #endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
   2374          
   2375          static int ssl_write_server_hello( mbedtls_ssl_context *ssl )
   2376          {
   2377          #if defined(MBEDTLS_HAVE_TIME)
   2378              mbedtls_time_t t;
   2379          #endif
   2380              int ret;
   2381              size_t olen, ext_len = 0, n;
   2382              unsigned char *buf, *p;
   2383          
   2384              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write server hello" ) );
   2385          
   2386          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
   2387              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   2388                  ssl->handshake->verify_cookie_len != 0 )
   2389              {
   2390                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "client hello was not authenticated" ) );
   2391                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write server hello" ) );
   2392          
   2393                  return( ssl_write_hello_verify_request( ssl ) );
   2394              }
   2395          #endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
   2396          
   2397              if( ssl->conf->f_rng == NULL )
   2398              {
   2399                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "no RNG provided") );
   2400                  return( MBEDTLS_ERR_SSL_NO_RNG );
   2401              }
   2402          
   2403              /*
   2404               *     0  .   0   handshake type
   2405               *     1  .   3   handshake length
   2406               *     4  .   5   protocol version
   2407               *     6  .   9   UNIX time()
   2408               *    10  .  37   random bytes
   2409               */
   2410              buf = ssl->out_msg;
   2411              p = buf + 4;
   2412          
   2413              mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
   2414                                 ssl->conf->transport, p );
   2415              p += 2;
   2416          
   2417              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, chosen version: [%d:%d]",
   2418                                  buf[4], buf[5] ) );
   2419          
   2420          #if defined(MBEDTLS_HAVE_TIME)
   2421              t = mbedtls_time( NULL );
   2422              *p++ = (unsigned char)( t >> 24 );
   2423              *p++ = (unsigned char)( t >> 16 );
   2424              *p++ = (unsigned char)( t >>  8 );
   2425              *p++ = (unsigned char)( t       );
   2426          
   2427              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, current time: %lu", t ) );
   2428          #else
   2429              if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 4 ) ) != 0 )
   2430                  return( ret );
   2431          
   2432              p += 4;
   2433          #endif /* MBEDTLS_HAVE_TIME */
   2434          
   2435              if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 28 ) ) != 0 )
   2436                  return( ret );
   2437          
   2438              p += 28;
   2439          
   2440              memcpy( ssl->handshake->randbytes + 32, buf + 6, 32 );
   2441          
   2442              MBEDTLS_SSL_DEBUG_BUF( 3, "server hello, random bytes", buf + 6, 32 );
   2443          
   2444              /*
   2445               * Resume is 0  by default, see ssl_handshake_init().
   2446               * It may be already set to 1 by ssl_parse_session_ticket_ext().
   2447               * If not, try looking up session ID in our cache.
   2448               */
   2449              if( ssl->handshake->resume == 0 &&
   2450          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   2451                  ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE &&
   2452          #endif
   2453                  ssl->session_negotiate->id_len != 0 &&
   2454                  ssl->conf->f_get_cache != NULL &&
   2455                  ssl->conf->f_get_cache( ssl->conf->p_cache, ssl->session_negotiate ) == 0 )
   2456              {
   2457                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "session successfully restored from cache" ) );
   2458                  ssl->handshake->resume = 1;
   2459              }
   2460          
   2461              if( ssl->handshake->resume == 0 )
   2462              {
   2463                  /*
   2464                   * New session, create a new session id,
   2465                   * unless we're about to issue a session ticket
   2466                   */
   2467                  ssl->state++;
   2468          
   2469          #if defined(MBEDTLS_HAVE_TIME)
   2470                  ssl->session_negotiate->start = mbedtls_time( NULL );
   2471          #endif
   2472          
   2473          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   2474                  if( ssl->handshake->new_session_ticket != 0 )
   2475                  {
   2476                      ssl->session_negotiate->id_len = n = 0;
   2477                      memset( ssl->session_negotiate->id, 0, 32 );
   2478                  }
   2479                  else
   2480          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   2481                  {
   2482                      ssl->session_negotiate->id_len = n = 32;
   2483                      if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, ssl->session_negotiate->id,
   2484                                              n ) ) != 0 )
   2485                          return( ret );
   2486                  }
   2487              }
   2488              else
   2489              {
   2490                  /*
   2491                   * Resuming a session
   2492                   */
   2493                  n = ssl->session_negotiate->id_len;
   2494                  ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;
   2495          
   2496                  if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )
   2497                  {
   2498                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_derive_keys", ret );
   2499                      return( ret );
   2500                  }
   2501              }
   2502          
   2503              /*
   2504               *    38  .  38     session id length
   2505               *    39  . 38+n    session id
   2506               *   39+n . 40+n    chosen ciphersuite
   2507               *   41+n . 41+n    chosen compression alg.
   2508               *   42+n . 43+n    extensions length
   2509               *   44+n . 43+n+m  extensions
   2510               */
   2511              *p++ = (unsigned char) ssl->session_negotiate->id_len;
   2512              memcpy( p, ssl->session_negotiate->id, ssl->session_negotiate->id_len );
   2513              p += ssl->session_negotiate->id_len;
   2514          
   2515              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, session id len.: %d", n ) );
   2516              MBEDTLS_SSL_DEBUG_BUF( 3,   "server hello, session id", buf + 39, n );
   2517              MBEDTLS_SSL_DEBUG_MSG( 3, ( "%s session has been resumed",
   2518                             ssl->handshake->resume ? "a" : "no" ) );
   2519          
   2520              *p++ = (unsigned char)( ssl->session_negotiate->ciphersuite >> 8 );
   2521              *p++ = (unsigned char)( ssl->session_negotiate->ciphersuite      );
   2522              *p++ = (unsigned char)( ssl->session_negotiate->compression      );
   2523          
   2524              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, chosen ciphersuite: %s",
   2525                     mbedtls_ssl_get_ciphersuite_name( ssl->session_negotiate->ciphersuite ) ) );
   2526              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, compress alg.: 0x%02X",
   2527                             ssl->session_negotiate->compression ) );
   2528          
   2529              /* Do not write the extensions if the protocol is SSLv3 */
   2530          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   2531              if( ( ssl->major_ver != 3 ) || ( ssl->minor_ver != 0 ) )
   2532              {
   2533          #endif
   2534          
   2535              /*
   2536               *  First write extensions, then the total length
   2537               */
   2538              ssl_write_renegotiation_ext( ssl, p + 2 + ext_len, &olen );
   2539              ext_len += olen;
   2540          
   2541          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   2542              ssl_write_max_fragment_length_ext( ssl, p + 2 + ext_len, &olen );
   2543              ext_len += olen;
   2544          #endif
   2545          
   2546          #if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
   2547              ssl_write_truncated_hmac_ext( ssl, p + 2 + ext_len, &olen );
   2548              ext_len += olen;
   2549          #endif
   2550          
   2551          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   2552              ssl_write_encrypt_then_mac_ext( ssl, p + 2 + ext_len, &olen );
   2553              ext_len += olen;
   2554          #endif
   2555          
   2556          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   2557              ssl_write_extended_ms_ext( ssl, p + 2 + ext_len, &olen );
   2558              ext_len += olen;
   2559          #endif
   2560          
   2561          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   2562              ssl_write_session_ticket_ext( ssl, p + 2 + ext_len, &olen );
   2563              ext_len += olen;
   2564          #endif
   2565          
   2566          #if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
   2567              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   2568              ssl_write_supported_point_formats_ext( ssl, p + 2 + ext_len, &olen );
   2569              ext_len += olen;
   2570          #endif
   2571          
   2572          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   2573              ssl_write_ecjpake_kkpp_ext( ssl, p + 2 + ext_len, &olen );
   2574              ext_len += olen;
   2575          #endif
   2576          
   2577          #if defined(MBEDTLS_SSL_ALPN)
   2578              ssl_write_alpn_ext( ssl, p + 2 + ext_len, &olen );
   2579              ext_len += olen;
   2580          #endif
   2581          
   2582              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, total extension length: %d", ext_len ) );
   2583          
   2584              if( ext_len > 0 )
   2585              {
   2586                  *p++ = (unsigned char)( ( ext_len >> 8 ) & 0xFF );
   2587                  *p++ = (unsigned char)( ( ext_len      ) & 0xFF );
   2588                  p += ext_len;
   2589              }
   2590          
   2591          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   2592              }
   2593          #endif
   2594          
   2595              ssl->out_msglen  = p - buf;
   2596              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   2597              ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO;
   2598          
   2599              ret = mbedtls_ssl_write_record( ssl );
   2600          
   2601              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write server hello" ) );
   2602          
   2603              return( ret );
   2604          }
   2605          
   2606          #if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)       && \
   2607              !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)   && \
   2608              !defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)  && \
   2609              !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) && \
   2610              !defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)&& \
   2611              !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
   2612          static int ssl_write_certificate_request( mbedtls_ssl_context *ssl )
   2613          {
   2614              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2615                  ssl->transform_negotiate->ciphersuite_info;
   2616          
   2617              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate request" ) );
   2618          
   2619              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   2620                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
   2621                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   2622                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
   2623                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
   2624              {
   2625                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate request" ) );
   2626                  ssl->state++;
   2627                  return( 0 );
   2628              }
   2629          
   2630              MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   2631              return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   2632          }
   2633          #else
   2634          static int ssl_write_certificate_request( mbedtls_ssl_context *ssl )
   2635          {
   2636              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   2637              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2638                  ssl->transform_negotiate->ciphersuite_info;
   2639              size_t dn_size, total_dn_size; /* excluding length bytes */
   2640              size_t ct_len, sa_len; /* including length bytes */
   2641              unsigned char *buf, *p;
   2642              const unsigned char * const end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
   2643              const mbedtls_x509_crt *crt;
   2644              int authmode;
   2645          
   2646              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate request" ) );
   2647          
   2648              ssl->state++;
   2649          
   2650          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   2651              if( ssl->handshake->sni_authmode != MBEDTLS_SSL_VERIFY_UNSET )
   2652                  authmode = ssl->handshake->sni_authmode;
   2653              else
   2654          #endif
   2655                  authmode = ssl->conf->authmode;
   2656          
   2657              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   2658                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
   2659                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   2660                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
   2661                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE ||
   2662                  authmode == MBEDTLS_SSL_VERIFY_NONE )
   2663              {
   2664                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate request" ) );
   2665                  return( 0 );
   2666              }
   2667          
   2668              /*
   2669               *     0  .   0   handshake type
   2670               *     1  .   3   handshake length
   2671               *     4  .   4   cert type count
   2672               *     5  .. m-1  cert types
   2673               *     m  .. m+1  sig alg length (TLS 1.2 only)
   2674               *    m+1 .. n-1  SignatureAndHashAlgorithms (TLS 1.2 only)
   2675               *     n  .. n+1  length of all DNs
   2676               *    n+2 .. n+3  length of DN 1
   2677               *    n+4 .. ...  Distinguished Name #1
   2678               *    ... .. ...  length of DN 2, etc.
   2679               */
   2680              buf = ssl->out_msg;
   2681              p = buf + 4;
   2682          
   2683              /*
   2684               * Supported certificate types
   2685               *
   2686               *     ClientCertificateType certificate_types<1..2^8-1>;
   2687               *     enum { (255) } ClientCertificateType;
   2688               */
   2689              ct_len = 0;
   2690          
   2691          #if defined(MBEDTLS_RSA_C)
   2692              p[1 + ct_len++] = MBEDTLS_SSL_CERT_TYPE_RSA_SIGN;
   2693          #endif
   2694          #if defined(MBEDTLS_ECDSA_C)
   2695              p[1 + ct_len++] = MBEDTLS_SSL_CERT_TYPE_ECDSA_SIGN;
   2696          #endif
   2697          
   2698              p[0] = (unsigned char) ct_len++;
   2699              p += ct_len;
   2700          
   2701              sa_len = 0;
   2702          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   2703              /*
   2704               * Add signature_algorithms for verify (TLS 1.2)
   2705               *
   2706               *     SignatureAndHashAlgorithm supported_signature_algorithms<2..2^16-2>;
   2707               *
   2708               *     struct {
   2709               *           HashAlgorithm hash;
   2710               *           SignatureAlgorithm signature;
   2711               *     } SignatureAndHashAlgorithm;
   2712               *
   2713               *     enum { (255) } HashAlgorithm;
   2714               *     enum { (255) } SignatureAlgorithm;
   2715               */
   2716              if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
   2717              {
   2718                  const int *cur;
   2719          
   2720                  /*
   2721                   * Supported signature algorithms
   2722                   */
   2723                  for( cur = ssl->conf->sig_hashes; *cur != MBEDTLS_MD_NONE; cur++ )
   2724                  {
   2725                      unsigned char hash = mbedtls_ssl_hash_from_md_alg( *cur );
   2726          
   2727                      if( MBEDTLS_SSL_HASH_NONE == hash || mbedtls_ssl_set_calc_verify_md( ssl, hash ) )
   2728                          continue;
   2729          
   2730          #if defined(MBEDTLS_RSA_C)
   2731                      p[2 + sa_len++] = hash;
   2732                      p[2 + sa_len++] = MBEDTLS_SSL_SIG_RSA;
   2733          #endif
   2734          #if defined(MBEDTLS_ECDSA_C)
   2735                      p[2 + sa_len++] = hash;
   2736                      p[2 + sa_len++] = MBEDTLS_SSL_SIG_ECDSA;
   2737          #endif
   2738                  }
   2739          
   2740                  p[0] = (unsigned char)( sa_len >> 8 );
   2741                  p[1] = (unsigned char)( sa_len      );
   2742                  sa_len += 2;
   2743                  p += sa_len;
   2744              }
   2745          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   2746          
   2747              /*
   2748               * DistinguishedName certificate_authorities<0..2^16-1>;
   2749               * opaque DistinguishedName<1..2^16-1>;
   2750               */
   2751              p += 2;
   2752          
   2753              total_dn_size = 0;
   2754          
   2755              if( ssl->conf->cert_req_ca_list ==  MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED )
   2756              {
   2757          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   2758                  if( ssl->handshake->sni_ca_chain != NULL )
   2759                      crt = ssl->handshake->sni_ca_chain;
   2760                  else
   2761          #endif
   2762                      crt = ssl->conf->ca_chain;
   2763          
   2764                  while( crt != NULL && crt->version != 0 )
   2765                  {
   2766                      dn_size = crt->subject_raw.len;
   2767          
   2768                      if( end < p ||
   2769                          (size_t)( end - p ) < dn_size ||
   2770                          (size_t)( end - p ) < 2 + dn_size )
   2771                      {
   2772                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "skipping CAs: buffer too short" ) );
   2773                          break;
   2774                      }
   2775          
   2776                      *p++ = (unsigned char)( dn_size >> 8 );
   2777                      *p++ = (unsigned char)( dn_size      );
   2778                      memcpy( p, crt->subject_raw.p, dn_size );
   2779                      p += dn_size;
   2780          
   2781                      MBEDTLS_SSL_DEBUG_BUF( 3, "requested DN", p - dn_size, dn_size );
   2782          
   2783                      total_dn_size += 2 + dn_size;
   2784                      crt = crt->next;
   2785                  }
   2786              }
   2787          
   2788              ssl->out_msglen  = p - buf;
   2789              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   2790              ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_REQUEST;
   2791              ssl->out_msg[4 + ct_len + sa_len] = (unsigned char)( total_dn_size  >> 8 );
   2792              ssl->out_msg[5 + ct_len + sa_len] = (unsigned char)( total_dn_size       );
   2793          
   2794              ret = mbedtls_ssl_write_record( ssl );
   2795          
   2796              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write certificate request" ) );
   2797          
   2798              return( ret );
   2799          }
   2800          #endif /* !MBEDTLS_KEY_EXCHANGE_RSA_ENABLED &&
   2801                    !MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED &&
   2802                    !MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED &&
   2803                    !MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED &&
   2804                    !MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED &&
   2805                    !MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
   2806          
   2807          #if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \
   2808              defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
   2809          static int ssl_get_ecdh_params_from_cert( mbedtls_ssl_context *ssl )
   2810          {
   2811              int ret;
   2812          
   2813              if( ! mbedtls_pk_can_do( mbedtls_ssl_own_key( ssl ), MBEDTLS_PK_ECKEY ) )
   2814              {
   2815                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "server key not ECDH capable" ) );
   2816                  return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );
   2817              }
   2818          
   2819              if( ( ret = mbedtls_ecdh_get_params( &ssl->handshake->ecdh_ctx,
   2820                                           mbedtls_pk_ec( *mbedtls_ssl_own_key( ssl ) ),
   2821                                           MBEDTLS_ECDH_OURS ) ) != 0 )
   2822              {
   2823                  MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ecdh_get_params" ), ret );
   2824                  return( ret );
   2825              }
   2826          
   2827              return( 0 );
   2828          }
   2829          #endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||
   2830                    MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
   2831          
   2832          static int ssl_write_server_key_exchange( mbedtls_ssl_context *ssl )
   2833          {
   2834              int ret;
   2835              size_t n = 0;
   2836              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2837                                      ssl->transform_negotiate->ciphersuite_info;
   2838          
   2839          #if defined(MBEDTLS_KEY_EXCHANGE__SOME_PFS__ENABLED)
   2840              unsigned char *p = ssl->out_msg + 4;
   2841              size_t len;
   2842          #if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)
   2843              unsigned char *dig_signed = p;
   2844              size_t dig_signed_len = 0;
   2845          #endif /* MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED */
   2846          #endif /* MBEDTLS_KEY_EXCHANGE__SOME_PFS__ENABLED */
   2847          
   2848              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write server key exchange" ) );
   2849          
   2850              /*
   2851               *
   2852               * Part 1: Extract static ECDH parameters and abort
   2853               *         if ServerKeyExchange not needed.
   2854               *
   2855               */
   2856          
   2857              /* For suites involving ECDH, extract DH parameters
   2858               * from certificate at this point. */
   2859          #if defined(MBEDTLS_KEY_EXCHANGE__SOME__ECDH_ENABLED)
   2860              if( mbedtls_ssl_ciphersuite_uses_ecdh( ciphersuite_info ) )
   2861              {
   2862                  ssl_get_ecdh_params_from_cert( ssl );
   2863              }
   2864          #endif /* MBEDTLS_KEY_EXCHANGE__SOME__ECDH_ENABLED */
   2865          
   2866              /* Key exchanges not involving ephemeral keys don't use
   2867               * ServerKeyExchange, so end here. */
   2868          #if defined(MBEDTLS_KEY_EXCHANGE__SOME_NON_PFS__ENABLED)
   2869              if( mbedtls_ssl_ciphersuite_no_pfs( ciphersuite_info ) )
   2870              {
   2871                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write server key exchange" ) );
   2872                  ssl->state++;
   2873                  return( 0 );
   2874              }
   2875          #endif /* MBEDTLS_KEY_EXCHANGE__NON_PFS__ENABLED */
   2876          
   2877              /*
   2878               *
   2879               * Part 2: Provide key exchange parameters for chosen ciphersuite.
   2880               *
   2881               */
   2882          
   2883              /*
   2884               * - ECJPAKE key exchanges
   2885               */
   2886          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   2887              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
   2888              {
   2889                  const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
   2890          
   2891                  ret = mbedtls_ecjpake_write_round_two( &ssl->handshake->ecjpake_ctx,
   2892                          p, end - p, &len, ssl->conf->f_rng, ssl->conf->p_rng );
   2893                  if( ret != 0 )
   2894                  {
   2895                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecjpake_write_round_two", ret );
   2896                      return( ret );
   2897                  }
   2898          
   2899                  p += len;
   2900                  n += len;
   2901              }
   2902          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   2903          
   2904              /*
   2905               * For (EC)DHE key exchanges with PSK, parameters are prefixed by support
   2906               * identity hint (RFC 4279, Sec. 3). Until someone needs this feature,
   2907               * we use empty support identity hints here.
   2908               **/
   2909          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)   || \
   2910              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
   2911              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   2912                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )
   2913              {
   2914                  *(p++) = 0x00;
   2915                  *(p++) = 0x00;
   2916          
   2917                  n += 2;
   2918              }
   2919          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED ||
   2920                    MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
   2921          
   2922              /*
   2923               * - DHE key exchanges
   2924               */
   2925          #if defined(MBEDTLS_KEY_EXCHANGE__SOME__DHE_ENABLED)
   2926              if( mbedtls_ssl_ciphersuite_uses_dhe( ciphersuite_info ) )
   2927              {
   2928                  if( ssl->conf->dhm_P.p == NULL || ssl->conf->dhm_G.p == NULL )
   2929                  {
   2930                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "no DH parameters set" ) );
   2931                      return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   2932                  }
   2933          
   2934                  /*
   2935                   * Ephemeral DH parameters:
   2936                   *
   2937                   * struct {
   2938                   *     opaque dh_p<1..2^16-1>;
   2939                   *     opaque dh_g<1..2^16-1>;
   2940                   *     opaque dh_Ys<1..2^16-1>;
   2941                   * } ServerDHParams;
   2942                   */
   2943                  if( ( ret = mbedtls_mpi_copy( &ssl->handshake->dhm_ctx.P, &ssl->conf->dhm_P ) ) != 0 ||
   2944                      ( ret = mbedtls_mpi_copy( &ssl->handshake->dhm_ctx.G, &ssl->conf->dhm_G ) ) != 0 )
   2945                  {
   2946                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_mpi_copy", ret );
   2947                      return( ret );
   2948                  }
   2949          
   2950                  if( ( ret = mbedtls_dhm_make_params( &ssl->handshake->dhm_ctx,
   2951                                  (int) mbedtls_mpi_size( &ssl->handshake->dhm_ctx.P ),
   2952                                  p, &len, ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
   2953                  {
   2954                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_dhm_make_params", ret );
   2955                      return( ret );
   2956                  }
   2957          
   2958          #if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)        
   2959                  dig_signed = p;
   2960                  dig_signed_len = len;
   2961          #endif
   2962          
   2963                  p += len;
   2964                  n += len;
   2965          
   2966                  MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: X ", &ssl->handshake->dhm_ctx.X  );
   2967                  MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: P ", &ssl->handshake->dhm_ctx.P  );
   2968                  MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: G ", &ssl->handshake->dhm_ctx.G  );
   2969                  MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: GX", &ssl->handshake->dhm_ctx.GX );
   2970              }
   2971          #endif /* MBEDTLS_KEY_EXCHANGE__SOME__DHE_ENABLED */
   2972          
   2973              /*
   2974               * - ECDHE key exchanges
   2975               */
   2976          #if defined(MBEDTLS_KEY_EXCHANGE__SOME__ECDHE_ENABLED)
   2977              if( mbedtls_ssl_ciphersuite_uses_ecdhe( ciphersuite_info ) )
   2978              {
   2979                  /*
   2980                   * Ephemeral ECDH parameters:
   2981                   *
   2982                   * struct {
   2983                   *     ECParameters curve_params;
   2984                   *     ECPoint      public;
   2985                   * } ServerECDHParams;
   2986                   */
   2987                  const mbedtls_ecp_curve_info **curve = NULL;
   2988                  const mbedtls_ecp_group_id *gid;
   2989          
   2990                  /* Match our preference list against the offered curves */
   2991                  for( gid = ssl->conf->curve_list; *gid != MBEDTLS_ECP_DP_NONE; gid++ )
   2992                      for( curve = ssl->handshake->curves; *curve != NULL; curve++ )
   2993                          if( (*curve)->grp_id == *gid )
   2994                              goto curve_matching_done;
   2995          
   2996          curve_matching_done:
   2997                  if( curve == NULL || *curve == NULL )
   2998                  {
   2999                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "no matching curve for ECDHE" ) );
   3000                      return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );
   3001                  }
   3002          
   3003                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "ECDHE curve: %s", (*curve)->name ) );
   3004          
   3005                  if( ( ret = mbedtls_ecp_group_load( &ssl->handshake->ecdh_ctx.grp,
   3006                                                 (*curve)->grp_id ) ) != 0 )
   3007                  {
   3008                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecp_group_load", ret );
   3009                      return( ret );
   3010                  }
   3011          
   3012                  if( ( ret = mbedtls_ecdh_make_params( &ssl->handshake->ecdh_ctx, &len,
   3013                                                p, MBEDTLS_SSL_MAX_CONTENT_LEN - n,
   3014                                                ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
   3015                  {
   3016                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_make_params", ret );
   3017                      return( ret );
   3018                  }
   3019          
   3020          #if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)
   3021                  dig_signed     = p;
   3022                  dig_signed_len = len;
   3023          #endif
   3024          
   3025                  p += len;
   3026                  n += len;
   3027          
   3028                  MBEDTLS_SSL_DEBUG_ECP( 3, "ECDH: Q ", &ssl->handshake->ecdh_ctx.Q );
   3029              }
   3030          #endif /* MBEDTLS_KEY_EXCHANGE__SOME__ECDHE_ENABLED */
   3031          
   3032              /*
   3033               *
   3034               * Part 3: For key exchanges involving the server signing the
   3035               *         exchange parameters, compute and add the signature here.
   3036               *
   3037               */
   3038          #if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)
   3039              if( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) )
   3040              {
   3041                  size_t signature_len = 0;
   3042                  unsigned int hashlen = 0;
   3043                  unsigned char hash[64];
   3044          
   3045                  /*
   3046                   * 3.1: Choose hash algorithm:
   3047                   * A: For TLS 1.2, obey signature-hash-algorithm extension 
   3048                   *    to choose appropriate hash.
   3049                   * B: For SSL3, TLS1.0, TLS1.1 and ECDHE_ECDSA, use SHA1
   3050                   *    (RFC 4492, Sec. 5.4)
   3051                   * C: Otherwise, use MD5 + SHA1 (RFC 4346, Sec. 7.4.3)
   3052                   */
   3053          
   3054                  mbedtls_md_type_t md_alg;
   3055          
   3056          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3057                  mbedtls_pk_type_t sig_alg =
   3058                      mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );
   3059                  if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
   3060                  {
   3061                      /* A: For TLS 1.2, obey signature-hash-algorithm extension
   3062                       *    (RFC 5246, Sec. 7.4.1.4.1). */
   3063                      if( sig_alg == MBEDTLS_PK_NONE ||
   3064                          ( md_alg = mbedtls_ssl_sig_hash_set_find( &ssl->handshake->hash_algs,
   3065                                                                    sig_alg ) ) == MBEDTLS_MD_NONE )
   3066                      {
   3067                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   3068                          /* (... because we choose a cipher suite 
   3069                           *      only if there is a matching hash.) */
   3070                          return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   3071                      }
   3072                  }
   3073                  else
   3074          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   3075          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
   3076              defined(MBEDTLS_SSL_PROTO_TLS1_1)
   3077                  if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )
   3078                  {
   3079                      /* B: Default hash SHA1 */
   3080                      md_alg = MBEDTLS_MD_SHA1;
   3081                  }
   3082                  else
   3083          #endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \
   3084                    MBEDTLS_SSL_PROTO_TLS1_1 */
   3085                  {
   3086                      /* C: MD5 + SHA1 */
   3087                      md_alg = MBEDTLS_MD_NONE;
   3088                  }
   3089          
   3090                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "pick hash algorithm %d for signing", md_alg ) );
   3091          
   3092                  /*
   3093                   * 3.2: Compute the hash to be signed
   3094                   */
   3095          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
   3096              defined(MBEDTLS_SSL_PROTO_TLS1_1)
   3097                  if( md_alg == MBEDTLS_MD_NONE )
   3098                  {
   3099                      mbedtls_md5_context mbedtls_md5;
   3100                      mbedtls_sha1_context mbedtls_sha1;
   3101          
   3102                      mbedtls_md5_init(  &mbedtls_md5  );
   3103                      mbedtls_sha1_init( &mbedtls_sha1 );
   3104          
   3105                      /*
   3106                       * digitally-signed struct {
   3107                       *     opaque md5_hash[16];
   3108                       *     opaque sha_hash[20];
   3109                       * };
   3110                       *
   3111                       * md5_hash
   3112                       *     MD5(ClientHello.random + ServerHello.random
   3113                       *                            + ServerParams);
   3114                       * sha_hash
   3115                       *     SHA(ClientHello.random + ServerHello.random
   3116                       *                            + ServerParams);
   3117                       */
   3118          
   3119                      mbedtls_md5_starts( &mbedtls_md5 );
   3120                      mbedtls_md5_update( &mbedtls_md5, ssl->handshake->randbytes,  64 );
   3121                      mbedtls_md5_update( &mbedtls_md5, dig_signed, dig_signed_len );
   3122                      mbedtls_md5_finish( &mbedtls_md5, hash );
   3123          
   3124                      mbedtls_sha1_starts( &mbedtls_sha1 );
   3125                      mbedtls_sha1_update( &mbedtls_sha1, ssl->handshake->randbytes,  64 );
   3126                      mbedtls_sha1_update( &mbedtls_sha1, dig_signed, dig_signed_len );
   3127                      mbedtls_sha1_finish( &mbedtls_sha1, hash + 16 );
   3128          
   3129                      hashlen = 36;
   3130          
   3131                      mbedtls_md5_free(  &mbedtls_md5  );
   3132                      mbedtls_sha1_free( &mbedtls_sha1 );
   3133                  }
   3134                  else
   3135          #endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \
   3136                    MBEDTLS_SSL_PROTO_TLS1_1 */
   3137          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
   3138              defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3139                  if( md_alg != MBEDTLS_MD_NONE )
   3140                  {
   3141                      mbedtls_md_context_t ctx;
   3142                      const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type( md_alg );
   3143          
   3144                      mbedtls_md_init( &ctx );
   3145          
   3146                      /* Info from md_alg will be used instead */
   3147                      hashlen = 0;
   3148          
   3149                      /*
   3150                       * digitally-signed struct {
   3151                       *     opaque client_random[32];
   3152                       *     opaque server_random[32];
   3153                       *     ServerDHParams params;
   3154                       * };
   3155                       */
   3156                      if( ( ret = mbedtls_md_setup( &ctx, md_info, 0 ) ) != 0 )
   3157                      {
   3158                          MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_setup", ret );
   3159                          return( ret );
   3160                      }
   3161          
   3162                      mbedtls_md_starts( &ctx );
   3163                      mbedtls_md_update( &ctx, ssl->handshake->randbytes, 64 );
   3164                      mbedtls_md_update( &ctx, dig_signed, dig_signed_len );
   3165                      mbedtls_md_finish( &ctx, hash );
   3166                      mbedtls_md_free( &ctx );
   3167                  }
   3168                  else
   3169          #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \
   3170                    MBEDTLS_SSL_PROTO_TLS1_2 */
   3171                  {
   3172                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   3173                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   3174                  }
   3175          
   3176                  MBEDTLS_SSL_DEBUG_BUF( 3, "parameters hash", hash, hashlen != 0 ? hashlen :
   3177                      (unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) );
   3178          
   3179                  /*
   3180                   * 3.3: Compute and add the signature
   3181                   */
   3182                  if( mbedtls_ssl_own_key( ssl ) == NULL )
   3183                  {
   3184                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no private key" ) );
   3185                      return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );
   3186                  }
   3187          
   3188          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3189                  if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
   3190                  {
   3191                      /*
   3192                       * For TLS 1.2, we need to specify signature and hash algorithm
   3193                       * explicitly through a prefix to the signature.
   3194                       *
   3195                       * struct {
   3196                       *    HashAlgorithm hash;
   3197                       *    SignatureAlgorithm signature;
   3198                       * } SignatureAndHashAlgorithm;
   3199                       *
   3200                       * struct {
   3201                       *    SignatureAndHashAlgorithm algorithm;
   3202                       *    opaque signature<0..2^16-1>;
   3203                       * } DigitallySigned;
   3204                       *
   3205                       */
   3206          
   3207                      *(p++) = mbedtls_ssl_hash_from_md_alg( md_alg );
   3208                      *(p++) = mbedtls_ssl_sig_from_pk_alg( sig_alg );
   3209          
   3210                      n += 2;
   3211                  }
   3212          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   3213          
   3214                  if( ( ret = mbedtls_pk_sign( mbedtls_ssl_own_key( ssl ), md_alg, hash, hashlen,
   3215                                  p + 2 , &signature_len, ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
   3216                  {
   3217                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_pk_sign", ret );
   3218                      return( ret );
   3219                  }
   3220          
   3221                  *(p++) = (unsigned char)( signature_len >> 8 );
   3222                  *(p++) = (unsigned char)( signature_len      );
   3223                  n += 2;
   3224          
   3225                  MBEDTLS_SSL_DEBUG_BUF( 3, "my signature", p, signature_len );
   3226          
   3227                  n += signature_len;
   3228              }
   3229          #endif /* MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED */
   3230          
   3231              /* Done with actual work; add header and send. */
   3232          
   3233              ssl->out_msglen  = 4 + n;
   3234              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   3235              ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE;
   3236          
   3237              ssl->state++;
   3238          
   3239              if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
   3240              {
   3241                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
   3242                  return( ret );
   3243              }
   3244          
   3245              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write server key exchange" ) );
   3246          
   3247              return( 0 );
   3248          }
   3249          
   3250          static int ssl_write_server_hello_done( mbedtls_ssl_context *ssl )
   3251          {
   3252              int ret;
   3253          
   3254              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write server hello done" ) );
   3255          
   3256              ssl->out_msglen  = 4;
   3257              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   3258              ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO_DONE;
   3259          
   3260              ssl->state++;
   3261          
   3262          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3263              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   3264                  mbedtls_ssl_send_flight_completed( ssl );
   3265          #endif
   3266          
   3267              if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
   3268              {
   3269                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
   3270                  return( ret );
   3271              }
   3272          
   3273              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write server hello done" ) );
   3274          
   3275              return( 0 );
   3276          }
   3277          
   3278          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \
   3279              defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
   3280          static int ssl_parse_client_dh_public( mbedtls_ssl_context *ssl, unsigned char **p,
   3281                                                 const unsigned char *end )
   3282          {
   3283              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   3284              size_t n;
   3285          
   3286              /*
   3287               * Receive G^Y mod P, premaster = (G^Y)^X mod P
   3288               */
   3289              if( *p + 2 > end )
   3290              {
   3291                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3292                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3293              }
   3294          
   3295              n = ( (*p)[0] << 8 ) | (*p)[1];
   3296              *p += 2;
   3297          
   3298              if( *p + n > end )
   3299              {
   3300                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3301                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3302              }
   3303          
   3304              if( ( ret = mbedtls_dhm_read_public( &ssl->handshake->dhm_ctx, *p, n ) ) != 0 )
   3305              {
   3306                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_dhm_read_public", ret );
   3307                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );
   3308              }
   3309          
   3310              *p += n;
   3311          
   3312              MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: GY", &ssl->handshake->dhm_ctx.GY );
   3313          
   3314              return( ret );
   3315          }
   3316          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||
   3317                    MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
   3318          
   3319          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) ||                           \
   3320              defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
   3321          static int ssl_parse_encrypted_pms( mbedtls_ssl_context *ssl,
   3322                                              const unsigned char *p,
   3323                                              const unsigned char *end,
   3324                                              size_t pms_offset )
   3325          {
   3326              int ret;
   3327              size_t len = mbedtls_pk_get_len( mbedtls_ssl_own_key( ssl ) );
   3328              unsigned char *pms = ssl->handshake->premaster + pms_offset;
   3329              unsigned char ver[2];
   3330              unsigned char fake_pms[48], peer_pms[48];
   3331              unsigned char mask;
   3332              size_t i, peer_pmslen;
   3333              unsigned int diff;
   3334          
   3335              if( ! mbedtls_pk_can_do( mbedtls_ssl_own_key( ssl ), MBEDTLS_PK_RSA ) )
   3336              {
   3337                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no RSA private key" ) );
   3338                  return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );
   3339              }
   3340          
   3341              /*
   3342               * Decrypt the premaster using own private RSA key
   3343               */
   3344          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
   3345              defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3346              if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )
   3347              {
   3348                  if( *p++ != ( ( len >> 8 ) & 0xFF ) ||
   3349                      *p++ != ( ( len      ) & 0xFF ) )
   3350                  {
   3351                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3352                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3353                  }
   3354              }
   3355          #endif
   3356          
   3357              if( p + len != end )
   3358              {
   3359                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3360                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3361              }
   3362          
   3363              mbedtls_ssl_write_version( ssl->handshake->max_major_ver,
   3364                                 ssl->handshake->max_minor_ver,
   3365                                 ssl->conf->transport, ver );
   3366          
   3367              /*
   3368               * Protection against Bleichenbacher's attack: invalid PKCS#1 v1.5 padding
   3369               * must not cause the connection to end immediately; instead, send a
   3370               * bad_record_mac later in the handshake.
   3371               * Also, avoid data-dependant branches here to protect against
   3372               * timing-based variants.
   3373               */
   3374              ret = ssl->conf->f_rng( ssl->conf->p_rng, fake_pms, sizeof( fake_pms ) );
   3375              if( ret != 0 )
   3376                  return( ret );
   3377          
   3378              ret = mbedtls_pk_decrypt( mbedtls_ssl_own_key( ssl ), p, len,
   3379                                peer_pms, &peer_pmslen,
   3380                                sizeof( peer_pms ),
   3381                                ssl->conf->f_rng, ssl->conf->p_rng );
   3382          
   3383              diff  = (unsigned int) ret;
   3384              diff |= peer_pmslen ^ 48;
   3385              diff |= peer_pms[0] ^ ver[0];
   3386              diff |= peer_pms[1] ^ ver[1];
   3387          
   3388          #if defined(MBEDTLS_SSL_DEBUG_ALL)
   3389              if( diff != 0 )
   3390                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3391          #endif
   3392          
   3393              if( sizeof( ssl->handshake->premaster ) < pms_offset ||
   3394                  sizeof( ssl->handshake->premaster ) - pms_offset < 48 )
   3395              {
   3396                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   3397                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   3398              }
   3399              ssl->handshake->pmslen = 48;
   3400          
   3401              /* mask = diff ? 0xff : 0x00 using bit operations to avoid branches */
   3402              /* MSVC has a warning about unary minus on unsigned, but this is
   3403               * well-defined and precisely what we want to do here */
   3404          #if defined(_MSC_VER)
   3405          #pragma warning( push )
   3406          #pragma warning( disable : 4146 )
   3407          #endif
   3408              mask = - ( ( diff | - diff ) >> ( sizeof( unsigned int ) * 8 - 1 ) );
   3409          #if defined(_MSC_VER)
   3410          #pragma warning( pop )
   3411          #endif
   3412          
   3413              for( i = 0; i < ssl->handshake->pmslen; i++ )
   3414                  pms[i] = ( mask & fake_pms[i] ) | ( (~mask) & peer_pms[i] );
   3415          
   3416              return( 0 );
   3417          }
   3418          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED ||
   3419                    MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
   3420          
   3421          #if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)
   3422          static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,
   3423                                                    const unsigned char *end )
   3424          {
   3425              int ret = 0;
   3426              size_t n;
   3427          
   3428              if( ssl->conf->f_psk == NULL &&
   3429                  ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||
   3430                    ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )
   3431              {
   3432                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no pre-shared key" ) );
   3433                  return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );
   3434              }
   3435          
   3436              /*
   3437               * Receive client pre-shared key identity name
   3438               */
   3439              if( *p + 2 > end )
   3440              {
   3441                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3442                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3443              }
   3444          
   3445              n = ( (*p)[0] << 8 ) | (*p)[1];
   3446              *p += 2;
   3447          
   3448              if( n < 1 || n > 65535 || *p + n > end )
   3449              {
   3450                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3451                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3452              }
   3453          
   3454              if( ssl->conf->f_psk != NULL )
   3455              {
   3456                  if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )
   3457                      ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;
   3458              }
   3459              else
   3460              {
   3461                  /* Identity is not a big secret since clients send it in the clear,
   3462                   * but treat it carefully anyway, just in case */
   3463                  if( n != ssl->conf->psk_identity_len ||
   3464                      mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )
   3465                  {
   3466                      ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;
   3467                  }
   3468              }
   3469          
   3470              if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )
   3471              {
   3472                  MBEDTLS_SSL_DEBUG_BUF( 3, "Unknown PSK identity", *p, n );
   3473                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   3474                                                  MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );
   3475                  return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );
   3476              }
   3477          
   3478              *p += n;
   3479          
   3480              return( 0 );
   3481          }
   3482          #endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */
   3483          
   3484          static int ssl_parse_client_key_exchange( mbedtls_ssl_context *ssl )
   3485          {
   3486              int ret;
   3487              const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
   3488              unsigned char *p, *end;
   3489          
   3490              ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
   3491          
   3492              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse client key exchange" ) );
   3493          
   3494              if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
   3495              {
   3496                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
   3497                  return( ret );
   3498              }
   3499          
   3500              p = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );
   3501              end = ssl->in_msg + ssl->in_hslen;
   3502          
   3503              if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
   3504              {
   3505                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3506                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3507              }
   3508          
   3509              if( ssl->in_msg[0] != MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE )
   3510              {
   3511                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3512                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3513              }
   3514          
   3515          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)
   3516              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA )
   3517              {
   3518                  if( ( ret = ssl_parse_client_dh_public( ssl, &p, end ) ) != 0 )
   3519                  {
   3520                      MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_dh_public" ), ret );
   3521                      return( ret );
   3522                  }
   3523          
   3524                  if( p != end )
   3525                  {
   3526                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange" ) );
   3527                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3528                  }
   3529          
   3530                  if( ( ret = mbedtls_dhm_calc_secret( &ssl->handshake->dhm_ctx,
   3531                                                ssl->handshake->premaster,
   3532                                                MBEDTLS_PREMASTER_SIZE,
   3533                                               &ssl->handshake->pmslen,
   3534                                                ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
   3535                  {
   3536                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_dhm_calc_secret", ret );
   3537                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS );
   3538                  }
   3539          
   3540                  MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: K ", &ssl->handshake->dhm_ctx.K  );
   3541              }
   3542              else
   3543          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED */
   3544          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \
   3545              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \
   3546              defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                      \
   3547              defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
   3548              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
   3549                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ||
   3550                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||
   3551                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )
   3552              {
   3553                  if( ( ret = mbedtls_ecdh_read_public( &ssl->handshake->ecdh_ctx,
   3554                                                p, end - p) ) != 0 )
   3555                  {
   3556                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_read_public", ret );
   3557                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );
   3558                  }
   3559          
   3560                  MBEDTLS_SSL_DEBUG_ECP( 3, "ECDH: Qp ", &ssl->handshake->ecdh_ctx.Qp );
   3561          
   3562                  if( ( ret = mbedtls_ecdh_calc_secret( &ssl->handshake->ecdh_ctx,
   3563                                                &ssl->handshake->pmslen,
   3564                                                 ssl->handshake->premaster,
   3565                                                 MBEDTLS_MPI_MAX_SIZE,
   3566                                                 ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
   3567                  {
   3568                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_calc_secret", ret );
   3569                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS );
   3570                  }
   3571          
   3572                  MBEDTLS_SSL_DEBUG_MPI( 3, "ECDH: z  ", &ssl->handshake->ecdh_ctx.z );
   3573              }
   3574              else
   3575          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||
   3576                    MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||
   3577                    MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||
   3578                    MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
   3579          #if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)
   3580              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK )
   3581              {
   3582                  if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )
   3583                  {
   3584                      MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_psk_identity" ), ret );
   3585                      return( ret );
   3586                  }
   3587          
   3588                  if( p != end )
   3589                  {
   3590                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange" ) );
   3591                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3592                  }
   3593          
   3594                  if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,
   3595                                  ciphersuite_info->key_exchange ) ) != 0 )
   3596                  {
   3597                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_psk_derive_premaster", ret );
   3598                      return( ret );
   3599                  }
   3600              }
   3601              else
   3602          #endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED */
   3603          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
   3604              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )
   3605              {
   3606                  if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )
   3607                  {
   3608                      MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_psk_identity" ), ret );
   3609                      return( ret );
   3610                  }
   3611          
   3612                  if( ( ret = ssl_parse_encrypted_pms( ssl, p, end, 2 ) ) != 0 )
   3613                  {
   3614                      MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_encrypted_pms" ), ret );
   3615                      return( ret );
   3616                  }
   3617          
   3618                  if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,
   3619                                  ciphersuite_info->key_exchange ) ) != 0 )
   3620                  {
   3621                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_psk_derive_premaster", ret );
   3622                      return( ret );
   3623                  }
   3624              }
   3625              else
   3626          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
   3627          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
   3628              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )
   3629              {
   3630                  if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )
   3631                  {
   3632                      MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_psk_identity" ), ret );
   3633                      return( ret );
   3634                  }
   3635                  if( ( ret = ssl_parse_client_dh_public( ssl, &p, end ) ) != 0 )
   3636                  {
   3637                      MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_dh_public" ), ret );
   3638                      return( ret );
   3639                  }
   3640          
   3641                  if( p != end )
   3642                  {
   3643                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange" ) );
   3644                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3645                  }
   3646          
   3647                  if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,
   3648                                  ciphersuite_info->key_exchange ) ) != 0 )
   3649                  {
   3650                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_psk_derive_premaster", ret );
   3651                      return( ret );
   3652                  }
   3653              }
   3654              else
   3655          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
   3656          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
   3657              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )
   3658              {
   3659                  if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )
   3660                  {
   3661                      MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_psk_identity" ), ret );
   3662                      return( ret );
   3663                  }
   3664          
   3665                  if( ( ret = mbedtls_ecdh_read_public( &ssl->handshake->ecdh_ctx,
   3666                                                 p, end - p ) ) != 0 )
   3667                  {
   3668                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_read_public", ret );
   3669                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );
   3670                  }
   3671          
   3672                  MBEDTLS_SSL_DEBUG_ECP( 3, "ECDH: Qp ", &ssl->handshake->ecdh_ctx.Qp );
   3673          
   3674                  if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,
   3675                                  ciphersuite_info->key_exchange ) ) != 0 )
   3676                  {
   3677                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_psk_derive_premaster", ret );
   3678                      return( ret );
   3679                  }
   3680              }
   3681              else
   3682          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
   3683          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)
   3684              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )
   3685              {
   3686                  if( ( ret = ssl_parse_encrypted_pms( ssl, p, end, 0 ) ) != 0 )
   3687                  {
   3688                      MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_parse_encrypted_pms_secret" ), ret );
   3689                      return( ret );
   3690                  }
   3691              }
   3692              else
   3693          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED */
   3694          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   3695              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
   3696              {
   3697                  ret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx,
   3698                                                        p, end - p );
   3699                  if( ret != 0 )
   3700                  {
   3701                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecjpake_read_round_two", ret );
   3702                      return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
   3703                  }
   3704          
   3705                  ret = mbedtls_ecjpake_derive_secret( &ssl->handshake->ecjpake_ctx,
   3706                          ssl->handshake->premaster, 32, &ssl->handshake->pmslen,
   3707                          ssl->conf->f_rng, ssl->conf->p_rng );
   3708                  if( ret != 0 )
   3709                  {
   3710                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecjpake_derive_secret", ret );
   3711                      return( ret );
   3712                  }
   3713              }
   3714              else
   3715          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   3716              {
   3717                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   3718                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   3719              }
   3720          
   3721              if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )
   3722              {
   3723                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_derive_keys", ret );
   3724                  return( ret );
   3725              }
   3726          
   3727              ssl->state++;
   3728          
   3729              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse client key exchange" ) );
   3730          
   3731              return( 0 );
   3732          }
   3733          
   3734          #if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)       && \
   3735              !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)   && \
   3736              !defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)  && \
   3737              !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) && \
   3738              !defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)&& \
   3739              !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
   3740          static int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )
   3741          {
   3742              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   3743                  ssl->transform_negotiate->ciphersuite_info;
   3744          
   3745              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate verify" ) );
   3746          
   3747              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   3748                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
   3749                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
   3750                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   3751                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
   3752              {
   3753                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate verify" ) );
   3754                  ssl->state++;
   3755                  return( 0 );
   3756              }
   3757          
   3758              MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   3759              return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   3760          }
   3761          #else
   3762          static int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )
   3763          {
   3764              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   3765              size_t i, sig_len;
   3766              unsigned char hash[48];
   3767              unsigned char *hash_start = hash;
   3768              size_t hashlen;
   3769          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3770              mbedtls_pk_type_t pk_alg;
   3771          #endif
   3772              mbedtls_md_type_t md_alg;
   3773              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   3774                  ssl->transform_negotiate->ciphersuite_info;
   3775          
   3776              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate verify" ) );
   3777          
   3778              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   3779                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
   3780                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
   3781                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   3782                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE ||
   3783                  ssl->session_negotiate->peer_cert == NULL )
   3784              {
   3785                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate verify" ) );
   3786                  ssl->state++;
   3787                  return( 0 );
   3788              }
   3789          
   3790              /* Read the message without adding it to the checksum */
   3791              do {
   3792          
   3793                  if( ( ret = mbedtls_ssl_read_record_layer( ssl ) ) != 0 )
   3794                  {
   3795                      MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ssl_read_record_layer" ), ret );
   3796                      return( ret );
   3797                  }
   3798          
   3799                  ret = mbedtls_ssl_handle_message_type( ssl );
   3800          
   3801              } while( MBEDTLS_ERR_SSL_NON_FATAL == ret );
   3802          
   3803              if( 0 != ret )
   3804              {
   3805                  MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ssl_handle_message_type" ), ret );
   3806                  return( ret );
   3807              }
   3808          
   3809              ssl->state++;
   3810          
   3811              /* Process the message contents */
   3812              if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE ||
   3813                  ssl->in_msg[0] != MBEDTLS_SSL_HS_CERTIFICATE_VERIFY )
   3814              {
   3815                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
   3816                  return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
   3817              }
   3818          
   3819              i = mbedtls_ssl_hs_hdr_len( ssl );
   3820          
   3821              /*
   3822               *  struct {
   3823               *     SignatureAndHashAlgorithm algorithm; -- TLS 1.2 only
   3824               *     opaque signature<0..2^16-1>;
   3825               *  } DigitallySigned;
   3826               */
   3827          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
   3828              defined(MBEDTLS_SSL_PROTO_TLS1_1)
   3829              if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )
   3830              {
   3831                  md_alg = MBEDTLS_MD_NONE;
   3832                  hashlen = 36;
   3833          
   3834                  /* For ECDSA, use SHA-1, not MD-5 + SHA-1 */
   3835                  if( mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk,
   3836                                  MBEDTLS_PK_ECDSA ) )
   3837                  {
   3838                      hash_start += 16;
   3839                      hashlen -= 16;
   3840                      md_alg = MBEDTLS_MD_SHA1;
   3841                  }
   3842              }
   3843              else
   3844          #endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 ||
   3845                    MBEDTLS_SSL_PROTO_TLS1_1 */
   3846          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3847              if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
   3848              {
   3849                  if( i + 2 > ssl->in_hslen )
   3850                  {
   3851                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
   3852                      return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
   3853                  }
   3854          
   3855                  /*
   3856                   * Hash
   3857                   */
   3858                  md_alg = mbedtls_ssl_md_alg_from_hash( ssl->in_msg[i] );
   3859          
   3860                  if( md_alg == MBEDTLS_MD_NONE || mbedtls_ssl_set_calc_verify_md( ssl, ssl->in_msg[i] ) )
   3861                  {
   3862                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "peer not adhering to requested sig_alg"
   3863                                          " for verify message" ) );
   3864                      return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
   3865                  }
   3866          
   3867          #if !defined(MBEDTLS_MD_SHA1)
   3868                  if( MBEDTLS_MD_SHA1 == md_alg )
   3869                      hash_start += 16;
   3870          #endif
   3871          
   3872                  /* Info from md_alg will be used instead */
   3873                  hashlen = 0;
   3874          
   3875                  i++;
   3876          
   3877                  /*
   3878                   * Signature
   3879                   */
   3880                  if( ( pk_alg = mbedtls_ssl_pk_alg_from_sig( ssl->in_msg[i] ) )
   3881                                  == MBEDTLS_PK_NONE )
   3882                  {
   3883                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "peer not adhering to requested sig_alg"
   3884                                          " for verify message" ) );
   3885                      return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
   3886                  }
   3887          
   3888                  /*
   3889                   * Check the certificate's key type matches the signature alg
   3890                   */
   3891                  if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )
   3892                  {
   3893                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "sig_alg doesn't match cert key" ) );
   3894                      return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
   3895                  }
   3896          
   3897                  i++;
   3898              }
   3899              else
   3900          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   3901              {
   3902                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   3903                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   3904              }
   3905          
   3906              if( i + 2 > ssl->in_hslen )
   3907              {
   3908                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
   3909                  return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
   3910              }
   3911          
   3912              sig_len = ( ssl->in_msg[i] << 8 ) | ssl->in_msg[i+1];
   3913              i += 2;
   3914          
   3915              if( i + sig_len != ssl->in_hslen )
   3916              {
   3917                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
   3918                  return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
   3919              }
   3920          
   3921              /* Calculate hash and verify signature */
   3922              ssl->handshake->calc_verify( ssl, hash );
   3923          
   3924              if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,
   3925                                     md_alg, hash_start, hashlen,
   3926                                     ssl->in_msg + i, sig_len ) ) != 0 )
   3927              {
   3928                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_pk_verify", ret );
   3929                  return( ret );
   3930              }
   3931          
   3932              mbedtls_ssl_update_handshake_status( ssl );
   3933          
   3934              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse certificate verify" ) );
   3935          
   3936              return( ret );
   3937          }
   3938          #endif /* !MBEDTLS_KEY_EXCHANGE_RSA_ENABLED &&
   3939                    !MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED &&
   3940                    !MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED &&
   3941                    !MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED &&
   3942                    !MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED &&
   3943                    !MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
   3944          
   3945          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   3946          static int ssl_write_new_session_ticket( mbedtls_ssl_context *ssl )
   3947          {
   3948              int ret;
   3949              size_t tlen;
   3950              uint32_t lifetime;
   3951          
   3952              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write new session ticket" ) );
   3953          
   3954              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   3955              ssl->out_msg[0]  = MBEDTLS_SSL_HS_NEW_SESSION_TICKET;
   3956          
   3957              /*
   3958               * struct {
   3959               *     uint32 ticket_lifetime_hint;
   3960               *     opaque ticket<0..2^16-1>;
   3961               * } NewSessionTicket;
   3962               *
   3963               * 4  .  7   ticket_lifetime_hint (0 = unspecified)
   3964               * 8  .  9   ticket_len (n)
   3965               * 10 .  9+n ticket content
   3966               */
   3967          
   3968              if( ( ret = ssl->conf->f_ticket_write( ssl->conf->p_ticket,
   3969                                          ssl->session_negotiate,
   3970                                          ssl->out_msg + 10,
   3971                                          ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN,
   3972                                          &tlen, &lifetime ) ) != 0 )
   3973              {
   3974                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_ticket_write", ret );
   3975                  tlen = 0;
   3976              }
   3977          
   3978              ssl->out_msg[4] = ( lifetime >> 24 ) & 0xFF;
   3979              ssl->out_msg[5] = ( lifetime >> 16 ) & 0xFF;
   3980              ssl->out_msg[6] = ( lifetime >>  8 ) & 0xFF;
   3981              ssl->out_msg[7] = ( lifetime       ) & 0xFF;
   3982          
   3983              ssl->out_msg[8] = (unsigned char)( ( tlen >> 8 ) & 0xFF );
   3984              ssl->out_msg[9] = (unsigned char)( ( tlen      ) & 0xFF );
   3985          
   3986              ssl->out_msglen = 10 + tlen;
   3987          
   3988              /*
   3989               * Morally equivalent to updating ssl->state, but NewSessionTicket and
   3990               * ChangeCipherSpec share the same state.
   3991               */
   3992              ssl->handshake->new_session_ticket = 0;
   3993          
   3994              if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
   3995              {
   3996                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
   3997                  return( ret );
   3998              }
   3999          
   4000              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write new session ticket" ) );
   4001          
   4002              return( 0 );
   4003          }
   4004          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   4005          
   4006          /*
   4007           * SSL handshake -- server side -- single step
   4008           */
   4009          int mbedtls_ssl_handshake_server_step( mbedtls_ssl_context *ssl )
   4010          {
   4011              int ret = 0;
   4012          
   4013              if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER || ssl->handshake == NULL )
   4014                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   4015          
   4016              MBEDTLS_SSL_DEBUG_MSG( 2, ( "server state: %d", ssl->state ) );
   4017          
   4018              if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
   4019                  return( ret );
   4020          
   4021          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4022              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   4023                  ssl->handshake->retransmit_state == MBEDTLS_SSL_RETRANS_SENDING )
   4024              {
   4025                  if( ( ret = mbedtls_ssl_resend( ssl ) ) != 0 )
   4026                      return( ret );
   4027              }
   4028          #endif
   4029          
   4030              switch( ssl->state )
   4031              {
   4032                  case MBEDTLS_SSL_HELLO_REQUEST:
   4033                      ssl->state = MBEDTLS_SSL_CLIENT_HELLO;
   4034                      break;
   4035          
   4036                  /*
   4037                   *  <==   ClientHello
   4038                   */
   4039                  case MBEDTLS_SSL_CLIENT_HELLO:
   4040                      ret = ssl_parse_client_hello( ssl );
   4041                      break;
   4042          
   4043          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4044                  case MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT:
   4045                      return( MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED );
   4046          #endif
   4047          
   4048                  /*
   4049                   *  ==>   ServerHello
   4050                   *        Certificate
   4051                   *      ( ServerKeyExchange  )
   4052                   *      ( CertificateRequest )
   4053                   *        ServerHelloDone
   4054                   */
   4055                  case MBEDTLS_SSL_SERVER_HELLO:
   4056                      ret = ssl_write_server_hello( ssl );
   4057                      break;
   4058          
   4059                  case MBEDTLS_SSL_SERVER_CERTIFICATE:
   4060                      ret = mbedtls_ssl_write_certificate( ssl );
   4061                      break;
   4062          
   4063                  case MBEDTLS_SSL_SERVER_KEY_EXCHANGE:
   4064                      ret = ssl_write_server_key_exchange( ssl );
   4065                      break;
   4066          
   4067                  case MBEDTLS_SSL_CERTIFICATE_REQUEST:
   4068                      ret = ssl_write_certificate_request( ssl );
   4069                      break;
   4070          
   4071                  case MBEDTLS_SSL_SERVER_HELLO_DONE:
   4072                      ret = ssl_write_server_hello_done( ssl );
   4073                      break;
   4074          
   4075                  /*
   4076                   *  <== ( Certificate/Alert  )
   4077                   *        ClientKeyExchange
   4078                   *      ( CertificateVerify  )
   4079                   *        ChangeCipherSpec
   4080                   *        Finished
   4081                   */
   4082                  case MBEDTLS_SSL_CLIENT_CERTIFICATE:
   4083                      ret = mbedtls_ssl_parse_certificate( ssl );
   4084                      break;
   4085          
   4086                  case MBEDTLS_SSL_CLIENT_KEY_EXCHANGE:
   4087                      ret = ssl_parse_client_key_exchange( ssl );
   4088                      break;
   4089          
   4090                  case MBEDTLS_SSL_CERTIFICATE_VERIFY:
   4091                      ret = ssl_parse_certificate_verify( ssl );
   4092                      break;
   4093          
   4094                  case MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC:
   4095                      ret = mbedtls_ssl_parse_change_cipher_spec( ssl );
   4096                      break;
   4097          
   4098                  case MBEDTLS_SSL_CLIENT_FINISHED:
   4099                      ret = mbedtls_ssl_parse_finished( ssl );
   4100                      break;
   4101          
   4102                  /*
   4103                   *  ==> ( NewSessionTicket )
   4104                   *        ChangeCipherSpec
   4105                   *        Finished
   4106                   */
   4107                  case MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC:
   4108          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   4109                      if( ssl->handshake->new_session_ticket != 0 )
   4110                          ret = ssl_write_new_session_ticket( ssl );
   4111                      else
   4112          #endif
   4113                          ret = mbedtls_ssl_write_change_cipher_spec( ssl );
   4114                      break;
   4115          
   4116                  case MBEDTLS_SSL_SERVER_FINISHED:
   4117                      ret = mbedtls_ssl_write_finished( ssl );
   4118                      break;
   4119          
   4120                  case MBEDTLS_SSL_FLUSH_BUFFERS:
   4121                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "handshake: done" ) );
   4122                      ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
   4123                      break;
   4124          
   4125                  case MBEDTLS_SSL_HANDSHAKE_WRAPUP:
   4126                      mbedtls_ssl_handshake_wrapup( ssl );
   4127                      break;
   4128          
   4129                  default:
   4130                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid state %d", ssl->state ) );
   4131                      return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   4132              }
   4133          
   4134              return( ret );
   4135          }
   4136          #endif /* MBEDTLS_SSL_SRV_C */


 

 


Errors: none
Warnings: none

###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:29
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\features\mbedtls\src\hmac_drbg.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\hmac_drbg.d
#        -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\hmac_drbg.s.txt
#        -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\hmac_drbg.o
#        .\mbed-os\features\mbedtls\src\hmac_drbg.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\hmac_drbg.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\hmac_drbg.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\features\mbedtls\src\hmac_drbg.c
      1          /*
      2           *  HMAC_DRBG implementation (NIST SP 800-90)
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          
     22          /*
     23           *  The NIST SP 800-90A DRBGs are described in the following publication.
     24           *  http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf
     25           *  References below are based on rev. 1 (January 2012).
     26           */
     27          
     28          #if !defined(MBEDTLS_CONFIG_FILE)
     29          #include "mbedtls/config.h"
     30          #else
     31          #include MBEDTLS_CONFIG_FILE
     32          #endif
     33          
     34          #if defined(MBEDTLS_HMAC_DRBG_C)
     35          
     36          #include "mbedtls/hmac_drbg.h"
     37          
     38          #include <string.h>
     39          
     40          #if defined(MBEDTLS_FS_IO)
     41          #include <stdio.h>
     42          #endif
     43          
     44          #if defined(MBEDTLS_SELF_TEST)
     45          #if defined(MBEDTLS_PLATFORM_C)
     46          #include "mbedtls/platform.h"
     47          #else
     48          #include <stdio.h>
     49          #define mbedtls_printf printf
     50          #endif /* MBEDTLS_SELF_TEST */
     51          #endif /* MBEDTLS_PLATFORM_C */
     52          
     53          /* Implementation that should never be optimized out by the compiler */
     54          static void mbedtls_zeroize( void *v, size_t n ) {
     55              volatile unsigned char *p = v; while( n-- ) *p++ = 0;
     56          }
     57          
     58          /*
     59           * HMAC_DRBG context initialization
     60           */

   \                                 In section .text, align 2, keep-with-next
     61          void mbedtls_hmac_drbg_init( mbedtls_hmac_drbg_context *ctx )
     62          {
   \                     mbedtls_hmac_drbg_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     63              memset( ctx, 0, sizeof( mbedtls_hmac_drbg_context ) );
   \   00000002   0x2164             MOVS     R1,#+100
   \   00000004   0x.... 0x....      BL       __aeabi_memclr4
     64          
     65          #if defined(MBEDTLS_THREADING_C)
     66              mbedtls_mutex_init( &ctx->mutex );
     67          #endif
     68          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
     69          
     70          /*
     71           * HMAC_DRBG update, using optional additional data (10.1.2.2)
     72           */

   \                                 In section .text, align 2, keep-with-next
     73          void mbedtls_hmac_drbg_update( mbedtls_hmac_drbg_context *ctx,
     74                                 const unsigned char *additional, size_t add_len )
     75          {
   \                     mbedtls_hmac_drbg_update: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0017             MOVS     R7,R2
     76              size_t md_len = mbedtls_md_get_size( ctx->md_ctx.md_info );
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       mbedtls_md_get_size
   \   0000000E   0x0006             MOVS     R6,R0
     77              unsigned char rounds = ( additional != NULL && add_len != 0 ) ? 2 : 1;
   \   00000010   0x9812             LDR      R0,[SP, #+72]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD003             BEQ      ??mbedtls_hmac_drbg_update_0
   \   00000016   0x2F00             CMP      R7,#+0
   \   00000018   0xD001             BEQ      ??mbedtls_hmac_drbg_update_0
   \   0000001A   0x2502             MOVS     R5,#+2
   \   0000001C   0xE000             B        ??mbedtls_hmac_drbg_update_1
   \                     ??mbedtls_hmac_drbg_update_0: (+1)
   \   0000001E   0x2501             MOVS     R5,#+1
     78              unsigned char sep[1];
     79              unsigned char K[MBEDTLS_MD_MAX_SIZE];
     80          
     81              for( sep[0] = 0; sep[0] < rounds; sep[0]++ )
   \                     ??mbedtls_hmac_drbg_update_1: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE02B             B        ??mbedtls_hmac_drbg_update_2
     82              {
     83                  /* Step 1 or 4 */
     84                  mbedtls_md_hmac_reset( &ctx->md_ctx );
   \                     ??mbedtls_hmac_drbg_update_3: (+1)
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       mbedtls_md_hmac_reset
     85                  mbedtls_md_hmac_update( &ctx->md_ctx, ctx->V, md_len );
   \   0000002A   0x0032             MOVS     R2,R6
   \   0000002C   0x0021             MOVS     R1,R4
   \   0000002E   0x310C             ADDS     R1,R1,#+12
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       mbedtls_md_hmac_update
     86                  mbedtls_md_hmac_update( &ctx->md_ctx, sep, 1 );
   \   00000036   0x2201             MOVS     R2,#+1
   \   00000038   0x4669             MOV      R1,SP
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       mbedtls_md_hmac_update
     87                  if( rounds == 2 )
   \   00000040   0x2D02             CMP      R5,#+2
   \   00000042   0xD104             BNE      ??mbedtls_hmac_drbg_update_4
     88                      mbedtls_md_hmac_update( &ctx->md_ctx, additional, add_len );
   \   00000044   0x003A             MOVS     R2,R7
   \   00000046   0x9912             LDR      R1,[SP, #+72]
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       mbedtls_md_hmac_update
     89                  mbedtls_md_hmac_finish( &ctx->md_ctx, K );
   \                     ??mbedtls_hmac_drbg_update_4: (+1)
   \   0000004E   0xA901             ADD      R1,SP,#+4
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       mbedtls_md_hmac_finish
     90          
     91                  /* Step 2 or 5 */
     92                  mbedtls_md_hmac_starts( &ctx->md_ctx, K, md_len );
   \   00000056   0x0032             MOVS     R2,R6
   \   00000058   0xA901             ADD      R1,SP,#+4
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       mbedtls_md_hmac_starts
     93                  mbedtls_md_hmac_update( &ctx->md_ctx, ctx->V, md_len );
   \   00000060   0x0032             MOVS     R2,R6
   \   00000062   0x0021             MOVS     R1,R4
   \   00000064   0x310C             ADDS     R1,R1,#+12
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       mbedtls_md_hmac_update
     94                  mbedtls_md_hmac_finish( &ctx->md_ctx, ctx->V );
   \   0000006C   0x0021             MOVS     R1,R4
   \   0000006E   0x310C             ADDS     R1,R1,#+12
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       mbedtls_md_hmac_finish
     95              }
   \   00000076   0x4668             MOV      R0,SP
   \   00000078   0x7800             LDRB     R0,[R0, #+0]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \                     ??mbedtls_hmac_drbg_update_2: (+1)
   \   0000007C   0x4669             MOV      R1,SP
   \   0000007E   0x7008             STRB     R0,[R1, #+0]
   \   00000080   0x4668             MOV      R0,SP
   \   00000082   0x7800             LDRB     R0,[R0, #+0]
   \   00000084   0x42A8             CMP      R0,R5
   \   00000086   0xDBCD             BLT      ??mbedtls_hmac_drbg_update_3
     96          }
   \   00000088   0xB013             ADD      SP,SP,#+76
   \   0000008A   0xBDF0             POP      {R4-R7,PC}       ;; return
     97          
     98          /*
     99           * Simplified HMAC_DRBG initialisation (for use with deterministic ECDSA)
    100           */

   \                                 In section .text, align 2, keep-with-next
    101          int mbedtls_hmac_drbg_seed_buf( mbedtls_hmac_drbg_context *ctx,
    102                                  const mbedtls_md_info_t * md_info,
    103                                  const unsigned char *data, size_t data_len )
    104          {
   \                     mbedtls_hmac_drbg_seed_buf: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0017             MOVS     R7,R2
   \   00000008   0x001E             MOVS     R6,R3
    105              int ret;
    106          
    107              if( ( ret = mbedtls_md_setup( &ctx->md_ctx, md_info, 1 ) ) != 0 )
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x.... 0x....      BL       mbedtls_md_setup
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD117             BNE      ??mbedtls_hmac_drbg_seed_buf_0
    108                  return( ret );
    109          
    110              /*
    111               * Set initial working state.
    112               * Use the V memory location, which is currently all 0, to initialize the
    113               * MD context with an all-zero key. Then set V to its initial value.
    114               */
    115              mbedtls_md_hmac_starts( &ctx->md_ctx, ctx->V, mbedtls_md_get_size( md_info ) );
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x.... 0x....      BL       mbedtls_md_get_size
   \   0000001A   0x0002             MOVS     R2,R0
   \   0000001C   0x0021             MOVS     R1,R4
   \   0000001E   0x310C             ADDS     R1,R1,#+12
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       mbedtls_md_hmac_starts
    116              memset( ctx->V, 0x01, mbedtls_md_get_size( md_info ) );
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0x.... 0x....      BL       mbedtls_md_get_size
   \   0000002C   0x0001             MOVS     R1,R0
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x300C             ADDS     R0,R0,#+12
   \   00000034   0x.... 0x....      BL       __aeabi_memset4
    117          
    118              mbedtls_hmac_drbg_update( ctx, data, data_len );
   \   00000038   0x0032             MOVS     R2,R6
   \   0000003A   0x0039             MOVS     R1,R7
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       mbedtls_hmac_drbg_update
    119          
    120              return( 0 );
   \   00000042   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_hmac_drbg_seed_buf_0: (+1)
   \   00000044   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    121          }
    122          
    123          /*
    124           * HMAC_DRBG reseeding: 10.1.2.4 (arabic) + 9.2 (Roman)
    125           */

   \                                 In section .text, align 2, keep-with-next
    126          int mbedtls_hmac_drbg_reseed( mbedtls_hmac_drbg_context *ctx,
    127                                const unsigned char *additional, size_t len )
    128          {
   \                     mbedtls_hmac_drbg_reseed: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0E1             SUB      SP,SP,#+388
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0015             MOVS     R5,R2
    129              unsigned char seed[MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT];
    130              size_t seedlen;
    131          
    132              /* III. Check input length */
    133              if( len > MBEDTLS_HMAC_DRBG_MAX_INPUT ||
    134                  ctx->entropy_len + len > MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT )
   \   0000000A   0x20FF             MOVS     R0,#+255
   \   0000000C   0x1C80             ADDS     R0,R0,#+2        ;; #+257
   \   0000000E   0x4285             CMP      R5,R0
   \   00000010   0xD205             BCS      ??mbedtls_hmac_drbg_reseed_0
   \   00000012   0x6D27             LDR      R7,[R4, #+80]
   \   00000014   0x1978             ADDS     R0,R7,R5
   \   00000016   0x21FF             MOVS     R1,#+255
   \   00000018   0x3182             ADDS     R1,R1,#+130      ;; #+385
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD301             BCC      ??mbedtls_hmac_drbg_reseed_1
    135              {
    136                  return( MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG );
   \                     ??mbedtls_hmac_drbg_reseed_0: (+1)
   \   0000001E   0x2004             MOVS     R0,#+4
   \   00000020   0xE00B             B.N      ??mbedtls_hmac_drbg_reseed_2
    137              }
    138          
    139              memset( seed, 0, MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT );
   \                     ??mbedtls_hmac_drbg_reseed_1: (+1)
   \   00000022   0x1E49             SUBS     R1,R1,#+1
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x.... 0x....      BL       __aeabi_memclr4
    140          
    141              /* IV. Gather entropy_len bytes of entropy for the seed */
    142              if( ctx->f_entropy( ctx->p_entropy, seed, ctx->entropy_len ) != 0 )
   \   0000002A   0x003A             MOVS     R2,R7
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x6E20             LDR      R0,[R4, #+96]
   \   00000030   0x6DE3             LDR      R3,[R4, #+92]
   \   00000032   0x4798             BLX      R3
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD002             BEQ      ??mbedtls_hmac_drbg_reseed_3
    143                  return( MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED );
   \   00000038   0x2008             MOVS     R0,#+8
   \                     ??mbedtls_hmac_drbg_reseed_2: (+1)
   \   0000003A   0x43C0             MVNS     R0,R0            ;; #-9
   \   0000003C   0xE013             B        ??mbedtls_hmac_drbg_reseed_4
    144          
    145              seedlen = ctx->entropy_len;
   \                     ??mbedtls_hmac_drbg_reseed_3: (+1)
   \   0000003E   0x6D27             LDR      R7,[R4, #+80]
    146          
    147              /* 1. Concatenate entropy and additional data if any */
    148              if( additional != NULL && len != 0 )
   \   00000040   0x2E00             CMP      R6,#+0
   \   00000042   0xD008             BEQ      ??mbedtls_hmac_drbg_reseed_5
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD006             BEQ      ??mbedtls_hmac_drbg_reseed_5
    149              {
    150                  memcpy( seed + seedlen, additional, len );
   \   00000048   0x002A             MOVS     R2,R5
   \   0000004A   0x0031             MOVS     R1,R6
   \   0000004C   0x4668             MOV      R0,SP
   \   0000004E   0x19C0             ADDS     R0,R0,R7
   \   00000050   0x.... 0x....      BL       __aeabi_memcpy
    151                  seedlen += len;
   \   00000054   0x197F             ADDS     R7,R7,R5
    152              }
    153          
    154              /* 2. Update state */
    155              mbedtls_hmac_drbg_update( ctx, seed, seedlen );
   \                     ??mbedtls_hmac_drbg_reseed_5: (+1)
   \   00000056   0x003A             MOVS     R2,R7
   \   00000058   0x4669             MOV      R1,SP
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       mbedtls_hmac_drbg_update
    156          
    157              /* 3. Reset reseed_counter */
    158              ctx->reseed_counter = 1;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x64E0             STR      R0,[R4, #+76]
    159          
    160              /* 4. Done */
    161              return( 0 );
   \   00000064   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_hmac_drbg_reseed_4: (+1)
   \   00000066   0xB061             ADD      SP,SP,#+388
   \   00000068   0xBDF0             POP      {R4-R7,PC}       ;; return
    162          }
    163          
    164          /*
    165           * HMAC_DRBG initialisation (10.1.2.3 + 9.1)
    166           */

   \                                 In section .text, align 2, keep-with-next
    167          int mbedtls_hmac_drbg_seed( mbedtls_hmac_drbg_context *ctx,
    168                              const mbedtls_md_info_t * md_info,
    169                              int (*f_entropy)(void *, unsigned char *, size_t),
    170                              void *p_entropy,
    171                              const unsigned char *custom,
    172                              size_t len )
    173          {
   \                     mbedtls_hmac_drbg_seed: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0017             MOVS     R7,R2
   \   00000008   0x001E             MOVS     R6,R3
    174              int ret;
    175              size_t entropy_len, md_size;
    176          
    177              if( ( ret = mbedtls_md_setup( &ctx->md_ctx, md_info, 1 ) ) != 0 )
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x.... 0x....      BL       mbedtls_md_setup
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD128             BNE      ??mbedtls_hmac_drbg_seed_0
    178                  return( ret );
    179          
    180              md_size = mbedtls_md_get_size( md_info );
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       mbedtls_md_get_size
   \   0000001A   0x0004             MOVS     R4,R0
    181          
    182              /*
    183               * Set initial working state.
    184               * Use the V memory location, which is currently all 0, to initialize the
    185               * MD context with an all-zero key. Then set V to its initial value.
    186               */
    187              mbedtls_md_hmac_starts( &ctx->md_ctx, ctx->V, md_size );
   \   0000001C   0x0022             MOVS     R2,R4
   \   0000001E   0x0029             MOVS     R1,R5
   \   00000020   0x310C             ADDS     R1,R1,#+12
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0x.... 0x....      BL       mbedtls_md_hmac_starts
    188              memset( ctx->V, 0x01, md_size );
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x0021             MOVS     R1,R4
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x300C             ADDS     R0,R0,#+12
   \   00000030   0x.... 0x....      BL       __aeabi_memset4
    189          
    190              ctx->f_entropy = f_entropy;
   \   00000034   0x65EF             STR      R7,[R5, #+92]
    191              ctx->p_entropy = p_entropy;
   \   00000036   0x662E             STR      R6,[R5, #+96]
    192          
    193              ctx->reseed_interval = MBEDTLS_HMAC_DRBG_RESEED_INTERVAL;
   \   00000038   0x....             LDR      R0,??DataTable2  ;; 0x2710
   \   0000003A   0x65A8             STR      R0,[R5, #+88]
    194          
    195              /*
    196               * See SP800-57 5.6.1 (p. 65-66) for the security strength provided by
    197               * each hash function, then according to SP800-90A rev1 10.1 table 2,
    198               * min_entropy_len (in bits) is security_strength.
    199               *
    200               * (This also matches the sizes used in the NIST test vectors.)
    201               */
    202              entropy_len = md_size <= 20 ? 16 : /* 160-bits hash -> 128 bits */
    203                            md_size <= 28 ? 24 : /* 224-bits hash -> 192 bits */
    204                                            32;  /* better (256+) -> 256 bits */
   \   0000003C   0x2C15             CMP      R4,#+21
   \   0000003E   0xD201             BCS      ??mbedtls_hmac_drbg_seed_1
   \   00000040   0x2410             MOVS     R4,#+16
   \   00000042   0xE004             B        ??mbedtls_hmac_drbg_seed_2
   \                     ??mbedtls_hmac_drbg_seed_1: (+1)
   \   00000044   0x2C1D             CMP      R4,#+29
   \   00000046   0xD201             BCS      ??mbedtls_hmac_drbg_seed_3
   \   00000048   0x2418             MOVS     R4,#+24
   \   0000004A   0xE000             B        ??mbedtls_hmac_drbg_seed_2
   \                     ??mbedtls_hmac_drbg_seed_3: (+1)
   \   0000004C   0x2420             MOVS     R4,#+32
    205          
    206              /*
    207               * For initialisation, use more entropy to emulate a nonce
    208               * (Again, matches test vectors.)
    209               */
    210              ctx->entropy_len = entropy_len * 3 / 2;
   \                     ??mbedtls_hmac_drbg_seed_2: (+1)
   \   0000004E   0x0060             LSLS     R0,R4,#+1
   \   00000050   0x1900             ADDS     R0,R0,R4
   \   00000052   0x0840             LSRS     R0,R0,#+1
   \   00000054   0x6528             STR      R0,[R5, #+80]
    211          
    212              if( ( ret = mbedtls_hmac_drbg_reseed( ctx, custom, len ) ) != 0 )
   \   00000056   0x9A07             LDR      R2,[SP, #+28]
   \   00000058   0x9906             LDR      R1,[SP, #+24]
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0x.... 0x....      BL       mbedtls_hmac_drbg_reseed
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD100             BNE      ??mbedtls_hmac_drbg_seed_0
    213                  return( ret );
    214          
    215              ctx->entropy_len = entropy_len;
   \   00000064   0x652C             STR      R4,[R5, #+80]
    216          
    217              return( 0 );
   \                     ??mbedtls_hmac_drbg_seed_0: (+1)
   \   00000066   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    218          }
    219          
    220          /*
    221           * Set prediction resistance
    222           */

   \                                 In section .text, align 2, keep-with-next
    223          void mbedtls_hmac_drbg_set_prediction_resistance( mbedtls_hmac_drbg_context *ctx,
    224                                                    int resistance )
    225          {
    226              ctx->prediction_resistance = resistance;
   \                     mbedtls_hmac_drbg_set_prediction_resistance: (+1)
   \   00000000   0x6541             STR      R1,[R0, #+84]
    227          }
   \   00000002   0x4770             BX       LR               ;; return
    228          
    229          /*
    230           * Set entropy length grabbed for reseeds
    231           */

   \                                 In section .text, align 2, keep-with-next
    232          void mbedtls_hmac_drbg_set_entropy_len( mbedtls_hmac_drbg_context *ctx, size_t len )
    233          {
    234              ctx->entropy_len = len;
   \                     mbedtls_hmac_drbg_set_entropy_len: (+1)
   \   00000000   0x6501             STR      R1,[R0, #+80]
    235          }
   \   00000002   0x4770             BX       LR               ;; return
    236          
    237          /*
    238           * Set reseed interval
    239           */

   \                                 In section .text, align 2, keep-with-next
    240          void mbedtls_hmac_drbg_set_reseed_interval( mbedtls_hmac_drbg_context *ctx, int interval )
    241          {
    242              ctx->reseed_interval = interval;
   \                     mbedtls_hmac_drbg_set_reseed_interval: (+1)
   \   00000000   0x6581             STR      R1,[R0, #+88]
    243          }
   \   00000002   0x4770             BX       LR               ;; return
    244          
    245          /*
    246           * HMAC_DRBG random function with optional additional data:
    247           * 10.1.2.5 (arabic) + 9.3 (Roman)
    248           */

   \                                 In section .text, align 2, keep-with-next
    249          int mbedtls_hmac_drbg_random_with_add( void *p_rng,
    250                                         unsigned char *output, size_t out_len,
    251                                         const unsigned char *additional, size_t add_len )
    252          {
   \                     mbedtls_hmac_drbg_random_with_add: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x0016             MOVS     R6,R2
    253              int ret;
    254              mbedtls_hmac_drbg_context *ctx = (mbedtls_hmac_drbg_context *) p_rng;
    255              size_t md_len = mbedtls_md_get_size( ctx->md_ctx.md_info );
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0x.... 0x....      BL       mbedtls_md_get_size
   \   00000010   0x9000             STR      R0,[SP, #+0]
    256              size_t left = out_len;
    257              unsigned char *out = output;
    258          
    259              /* II. Check request length */
    260              if( out_len > MBEDTLS_HMAC_DRBG_MAX_REQUEST )
   \   00000012   0x....             LDR      R0,??DataTable2_1  ;; 0x401
   \   00000014   0x4286             CMP      R6,R0
   \   00000016   0xD301             BCC      ??mbedtls_hmac_drbg_random_with_add_0
    261                  return( MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG );
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xE005             B.N      ??mbedtls_hmac_drbg_random_with_add_1
    262          
    263              /* III. Check input length */
    264              if( add_len > MBEDTLS_HMAC_DRBG_MAX_INPUT )
   \                     ??mbedtls_hmac_drbg_random_with_add_0: (+1)
   \   0000001C   0x9808             LDR      R0,[SP, #+32]
   \   0000001E   0x21FF             MOVS     R1,#+255
   \   00000020   0x1C89             ADDS     R1,R1,#+2        ;; #+257
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD302             BCC      ??mbedtls_hmac_drbg_random_with_add_2
    265                  return( MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG );
   \   00000026   0x2004             MOVS     R0,#+4
   \                     ??mbedtls_hmac_drbg_random_with_add_1: (+1)
   \   00000028   0x43C0             MVNS     R0,R0            ;; #-5
   \   0000002A   0xE043             B        ??mbedtls_hmac_drbg_random_with_add_3
    266          
    267              /* 1. (aka VII and IX) Check reseed counter and PR */
    268              if( ctx->f_entropy != NULL && /* For no-reseeding instances */
    269                  ( ctx->prediction_resistance == MBEDTLS_HMAC_DRBG_PR_ON ||
    270                    ctx->reseed_counter > ctx->reseed_interval ) )
   \                     ??mbedtls_hmac_drbg_random_with_add_2: (+1)
   \   0000002C   0x6DE8             LDR      R0,[R5, #+92]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD00F             BEQ      ??mbedtls_hmac_drbg_random_with_add_4
   \   00000032   0x6D68             LDR      R0,[R5, #+84]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD003             BEQ      ??mbedtls_hmac_drbg_random_with_add_5
   \   00000038   0x6DA8             LDR      R0,[R5, #+88]
   \   0000003A   0x6CE9             LDR      R1,[R5, #+76]
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xDA08             BGE      ??mbedtls_hmac_drbg_random_with_add_4
    271              {
    272                  if( ( ret = mbedtls_hmac_drbg_reseed( ctx, additional, add_len ) ) != 0 )
   \                     ??mbedtls_hmac_drbg_random_with_add_5: (+1)
   \   00000040   0x9A08             LDR      R2,[SP, #+32]
   \   00000042   0x9902             LDR      R1,[SP, #+8]
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0x.... 0x....      BL       mbedtls_hmac_drbg_reseed
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD132             BNE      ??mbedtls_hmac_drbg_random_with_add_3
    273                      return( ret );
    274          
    275                  add_len = 0; /* VII.4 */
   \   0000004E   0x9008             STR      R0,[SP, #+32]
   \   00000050   0xE025             B        ??mbedtls_hmac_drbg_random_with_add_6
    276              }
    277          
    278              /* 2. Use additional data if any */
    279              if( additional != NULL && add_len != 0 )
   \                     ??mbedtls_hmac_drbg_random_with_add_4: (+1)
   \   00000052   0x9802             LDR      R0,[SP, #+8]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD022             BEQ      ??mbedtls_hmac_drbg_random_with_add_6
   \   00000058   0x9808             LDR      R0,[SP, #+32]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD01F             BEQ      ??mbedtls_hmac_drbg_random_with_add_6
    280                  mbedtls_hmac_drbg_update( ctx, additional, add_len );
   \   0000005E   0x4602             MOV      R2,R0
   \   00000060   0x9902             LDR      R1,[SP, #+8]
   \   00000062   0x0028             MOVS     R0,R5
   \   00000064   0x.... 0x....      BL       mbedtls_hmac_drbg_update
   \   00000068   0xE019             B        ??mbedtls_hmac_drbg_random_with_add_6
    281          
    282              /* 3, 4, 5. Generate bytes */
    283              while( left != 0 )
    284              {
    285                  size_t use_len = left > md_len ? md_len : left;
   \                     ??mbedtls_hmac_drbg_random_with_add_7: (+1)
   \   0000006A   0x9C00             LDR      R4,[SP, #+0]
   \   0000006C   0x42B4             CMP      R4,R6
   \   0000006E   0xD900             BLS      ??mbedtls_hmac_drbg_random_with_add_8
   \   00000070   0x0034             MOVS     R4,R6
    286          
    287                  mbedtls_md_hmac_reset( &ctx->md_ctx );
   \                     ??mbedtls_hmac_drbg_random_with_add_8: (+1)
   \   00000072   0x0028             MOVS     R0,R5
   \   00000074   0x.... 0x....      BL       mbedtls_md_hmac_reset
    288                  mbedtls_md_hmac_update( &ctx->md_ctx, ctx->V, md_len );
   \   00000078   0x9A00             LDR      R2,[SP, #+0]
   \   0000007A   0x0029             MOVS     R1,R5
   \   0000007C   0x310C             ADDS     R1,R1,#+12
   \   0000007E   0x0028             MOVS     R0,R5
   \   00000080   0x.... 0x....      BL       mbedtls_md_hmac_update
    289                  mbedtls_md_hmac_finish( &ctx->md_ctx, ctx->V );
   \   00000084   0x0029             MOVS     R1,R5
   \   00000086   0x310C             ADDS     R1,R1,#+12
   \   00000088   0x0028             MOVS     R0,R5
   \   0000008A   0x.... 0x....      BL       mbedtls_md_hmac_finish
    290          
    291                  memcpy( out, ctx->V, use_len );
   \   0000008E   0x0022             MOVS     R2,R4
   \   00000090   0x0029             MOVS     R1,R5
   \   00000092   0x310C             ADDS     R1,R1,#+12
   \   00000094   0x0038             MOVS     R0,R7
   \   00000096   0x.... 0x....      BL       __aeabi_memcpy
    292                  out += use_len;
   \   0000009A   0x193F             ADDS     R7,R7,R4
    293                  left -= use_len;
   \   0000009C   0x1B36             SUBS     R6,R6,R4
    294              }
   \                     ??mbedtls_hmac_drbg_random_with_add_6: (+1)
   \   0000009E   0x2E00             CMP      R6,#+0
   \   000000A0   0xD1E3             BNE      ??mbedtls_hmac_drbg_random_with_add_7
    295          
    296              /* 6. Update */
    297              mbedtls_hmac_drbg_update( ctx, additional, add_len );
   \   000000A2   0x9A08             LDR      R2,[SP, #+32]
   \   000000A4   0x9902             LDR      R1,[SP, #+8]
   \   000000A6   0x0028             MOVS     R0,R5
   \   000000A8   0x.... 0x....      BL       mbedtls_hmac_drbg_update
    298          
    299              /* 7. Update reseed counter */
    300              ctx->reseed_counter++;
   \   000000AC   0x6CE8             LDR      R0,[R5, #+76]
   \   000000AE   0x1C40             ADDS     R0,R0,#+1
   \   000000B0   0x64E8             STR      R0,[R5, #+76]
    301          
    302              /* 8. Done */
    303              return( 0 );
   \   000000B2   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_hmac_drbg_random_with_add_3: (+1)
   \   000000B4   0xB003             ADD      SP,SP,#+12
   \   000000B6   0xBDF0             POP      {R4-R7,PC}       ;; return
    304          }
    305          
    306          /*
    307           * HMAC_DRBG random function
    308           */

   \                                 In section .text, align 2, keep-with-next
    309          int mbedtls_hmac_drbg_random( void *p_rng, unsigned char *output, size_t out_len )
    310          {
   \                     mbedtls_hmac_drbg_random: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0016             MOVS     R6,R2
    311              int ret;
    312              mbedtls_hmac_drbg_context *ctx = (mbedtls_hmac_drbg_context *) p_rng;
    313          
    314          #if defined(MBEDTLS_THREADING_C)
    315              if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
    316                  return( ret );
    317          #endif
    318          
    319              ret = mbedtls_hmac_drbg_random_with_add( ctx, output, out_len, NULL, 0 );
   \   00000008   0x6828             LDR      R0,[R5, #+0]
   \   0000000A   0x.... 0x....      BL       mbedtls_md_get_size
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x....             LDR      R0,??DataTable2_1  ;; 0x401
   \   00000012   0x4286             CMP      R6,R0
   \   00000014   0xD302             BCC      ??mbedtls_hmac_drbg_random_0
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x43C0             MVNS     R0,R0            ;; #-3
   \   0000001A   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??mbedtls_hmac_drbg_random_0: (+1)
   \   0000001C   0x6DE8             LDR      R0,[R5, #+92]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD028             BEQ      ??mbedtls_hmac_drbg_random_1
   \   00000022   0x6D68             LDR      R0,[R5, #+84]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD003             BEQ      ??mbedtls_hmac_drbg_random_2
   \   00000028   0x6DA8             LDR      R0,[R5, #+88]
   \   0000002A   0x6CE9             LDR      R1,[R5, #+76]
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xDA21             BGE      ??mbedtls_hmac_drbg_random_1
   \                     ??mbedtls_hmac_drbg_random_2: (+1)
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x.... 0x....      BL       mbedtls_hmac_drbg_reseed
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD01A             BEQ      ??mbedtls_hmac_drbg_random_1
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??mbedtls_hmac_drbg_random_3: (+1)
   \   00000040   0x9C00             LDR      R4,[SP, #+0]
   \   00000042   0x42B4             CMP      R4,R6
   \   00000044   0xD900             BLS      ??mbedtls_hmac_drbg_random_4
   \   00000046   0x0034             MOVS     R4,R6
   \                     ??mbedtls_hmac_drbg_random_4: (+1)
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       mbedtls_md_hmac_reset
   \   0000004E   0x9A00             LDR      R2,[SP, #+0]
   \   00000050   0x0029             MOVS     R1,R5
   \   00000052   0x310C             ADDS     R1,R1,#+12
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       mbedtls_md_hmac_update
   \   0000005A   0x0029             MOVS     R1,R5
   \   0000005C   0x310C             ADDS     R1,R1,#+12
   \   0000005E   0x0028             MOVS     R0,R5
   \   00000060   0x.... 0x....      BL       mbedtls_md_hmac_finish
   \   00000064   0x0022             MOVS     R2,R4
   \   00000066   0x0029             MOVS     R1,R5
   \   00000068   0x310C             ADDS     R1,R1,#+12
   \   0000006A   0x0038             MOVS     R0,R7
   \   0000006C   0x.... 0x....      BL       __aeabi_memcpy
   \   00000070   0x193F             ADDS     R7,R7,R4
   \   00000072   0x1B36             SUBS     R6,R6,R4
   \                     ??mbedtls_hmac_drbg_random_1: (+1)
   \   00000074   0x2E00             CMP      R6,#+0
   \   00000076   0xD1E3             BNE      ??mbedtls_hmac_drbg_random_3
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x0028             MOVS     R0,R5
   \   0000007E   0x.... 0x....      BL       mbedtls_hmac_drbg_update
   \   00000082   0x6CE8             LDR      R0,[R5, #+76]
   \   00000084   0x1C40             ADDS     R0,R0,#+1
   \   00000086   0x64E8             STR      R0,[R5, #+76]
   \   00000088   0x2000             MOVS     R0,#+0
    320          
    321          #if defined(MBEDTLS_THREADING_C)
    322              if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
    323                  return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
    324          #endif
    325          
    326              return( ret );
   \   0000008A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    327          }
    328          
    329          /*
    330           * Free an HMAC_DRBG context
    331           */

   \                                 In section .text, align 2, keep-with-next
    332          void mbedtls_hmac_drbg_free( mbedtls_hmac_drbg_context *ctx )
    333          {
   \                     mbedtls_hmac_drbg_free: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    334              if( ctx == NULL )
   \   00000004   0xD005             BEQ      ??mbedtls_hmac_drbg_free_0
    335                  return;
    336          
    337          #if defined(MBEDTLS_THREADING_C)
    338              mbedtls_mutex_free( &ctx->mutex );
    339          #endif
    340              mbedtls_md_free( &ctx->md_ctx );
   \   00000006   0x.... 0x....      BL       mbedtls_md_free
    341              mbedtls_zeroize( ctx, sizeof( mbedtls_hmac_drbg_context ) );
   \   0000000A   0x2164             MOVS     R1,#+100
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memclr
    342          }
   \                     ??mbedtls_hmac_drbg_free_0: (+1)
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    343          
    344          #if defined(MBEDTLS_FS_IO)
    345          int mbedtls_hmac_drbg_write_seed_file( mbedtls_hmac_drbg_context *ctx, const char *path )
    346          {
    347              int ret;
    348              FILE *f;
    349              unsigned char buf[ MBEDTLS_HMAC_DRBG_MAX_INPUT ];
    350          
    351              if( ( f = fopen( path, "wb" ) ) == NULL )
    352                  return( MBEDTLS_ERR_HMAC_DRBG_FILE_IO_ERROR );
    353          
    354              if( ( ret = mbedtls_hmac_drbg_random( ctx, buf, sizeof( buf ) ) ) != 0 )
    355                  goto exit;
    356          
    357              if( fwrite( buf, 1, sizeof( buf ), f ) != sizeof( buf ) )
    358              {
    359                  ret = MBEDTLS_ERR_HMAC_DRBG_FILE_IO_ERROR;
    360                  goto exit;
    361              }
    362          
    363              ret = 0;
    364          
    365          exit:
    366              fclose( f );
    367              return( ret );
    368          }
    369          
    370          int mbedtls_hmac_drbg_update_seed_file( mbedtls_hmac_drbg_context *ctx, const char *path )
    371          {
    372              FILE *f;
    373              size_t n;
    374              unsigned char buf[ MBEDTLS_HMAC_DRBG_MAX_INPUT ];
    375          
    376              if( ( f = fopen( path, "rb" ) ) == NULL )
    377                  return( MBEDTLS_ERR_HMAC_DRBG_FILE_IO_ERROR );
    378          
    379              fseek( f, 0, SEEK_END );
    380              n = (size_t) ftell( f );
    381              fseek( f, 0, SEEK_SET );
    382          
    383              if( n > MBEDTLS_HMAC_DRBG_MAX_INPUT )
    384              {
    385                  fclose( f );
    386                  return( MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG );
    387              }
    388          
    389              if( fread( buf, 1, n, f ) != n )
    390              {
    391                  fclose( f );
    392                  return( MBEDTLS_ERR_HMAC_DRBG_FILE_IO_ERROR );
    393              }
    394          
    395              fclose( f );
    396          
    397              mbedtls_hmac_drbg_update( ctx, buf, n );
    398          
    399              return( mbedtls_hmac_drbg_write_seed_file( ctx, path ) );
    400          }
    401          #endif /* MBEDTLS_FS_IO */
    402          
    403          
    404          #if defined(MBEDTLS_SELF_TEST)
    405          
    406          #if !defined(MBEDTLS_SHA1_C)
    407          /* Dummy checkup routine */

   \                                 In section .text, align 2, keep-with-next
    408          int mbedtls_hmac_drbg_self_test( int verbose )
    409          {
    410              (void) verbose;
    411              return( 0 );
   \                     mbedtls_hmac_drbg_self_test: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    412          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x00000401         DC32     0x401
    413          #else
    414          
    415          #define OUTPUT_LEN  80
    416          
    417          /* From a NIST PR=true test vector */
    418          static const unsigned char entropy_pr[] = {
    419              0xa0, 0xc9, 0xab, 0x58, 0xf1, 0xe2, 0xe5, 0xa4, 0xde, 0x3e, 0xbd, 0x4f,
    420              0xf7, 0x3e, 0x9c, 0x5b, 0x64, 0xef, 0xd8, 0xca, 0x02, 0x8c, 0xf8, 0x11,
    421              0x48, 0xa5, 0x84, 0xfe, 0x69, 0xab, 0x5a, 0xee, 0x42, 0xaa, 0x4d, 0x42,
    422              0x17, 0x60, 0x99, 0xd4, 0x5e, 0x13, 0x97, 0xdc, 0x40, 0x4d, 0x86, 0xa3,
    423              0x7b, 0xf5, 0x59, 0x54, 0x75, 0x69, 0x51, 0xe4 };
    424          static const unsigned char result_pr[OUTPUT_LEN] = {
    425              0x9a, 0x00, 0xa2, 0xd0, 0x0e, 0xd5, 0x9b, 0xfe, 0x31, 0xec, 0xb1, 0x39,
    426              0x9b, 0x60, 0x81, 0x48, 0xd1, 0x96, 0x9d, 0x25, 0x0d, 0x3c, 0x1e, 0x94,
    427              0x10, 0x10, 0x98, 0x12, 0x93, 0x25, 0xca, 0xb8, 0xfc, 0xcc, 0x2d, 0x54,
    428              0x73, 0x19, 0x70, 0xc0, 0x10, 0x7a, 0xa4, 0x89, 0x25, 0x19, 0x95, 0x5e,
    429              0x4b, 0xc6, 0x00, 0x1d, 0x7f, 0x4e, 0x6a, 0x2b, 0xf8, 0xa3, 0x01, 0xab,
    430              0x46, 0x05, 0x5c, 0x09, 0xa6, 0x71, 0x88, 0xf1, 0xa7, 0x40, 0xee, 0xf3,
    431              0xe1, 0x5c, 0x02, 0x9b, 0x44, 0xaf, 0x03, 0x44 };
    432          
    433          /* From a NIST PR=false test vector */
    434          static const unsigned char entropy_nopr[] = {
    435              0x79, 0x34, 0x9b, 0xbf, 0x7c, 0xdd, 0xa5, 0x79, 0x95, 0x57, 0x86, 0x66,
    436              0x21, 0xc9, 0x13, 0x83, 0x11, 0x46, 0x73, 0x3a, 0xbf, 0x8c, 0x35, 0xc8,
    437              0xc7, 0x21, 0x5b, 0x5b, 0x96, 0xc4, 0x8e, 0x9b, 0x33, 0x8c, 0x74, 0xe3,
    438              0xe9, 0x9d, 0xfe, 0xdf };
    439          static const unsigned char result_nopr[OUTPUT_LEN] = {
    440              0xc6, 0xa1, 0x6a, 0xb8, 0xd4, 0x20, 0x70, 0x6f, 0x0f, 0x34, 0xab, 0x7f,
    441              0xec, 0x5a, 0xdc, 0xa9, 0xd8, 0xca, 0x3a, 0x13, 0x3e, 0x15, 0x9c, 0xa6,
    442              0xac, 0x43, 0xc6, 0xf8, 0xa2, 0xbe, 0x22, 0x83, 0x4a, 0x4c, 0x0a, 0x0a,
    443              0xff, 0xb1, 0x0d, 0x71, 0x94, 0xf1, 0xc1, 0xa5, 0xcf, 0x73, 0x22, 0xec,
    444              0x1a, 0xe0, 0x96, 0x4e, 0xd4, 0xbf, 0x12, 0x27, 0x46, 0xe0, 0x87, 0xfd,
    445              0xb5, 0xb3, 0xe9, 0x1b, 0x34, 0x93, 0xd5, 0xbb, 0x98, 0xfa, 0xed, 0x49,
    446              0xe8, 0x5f, 0x13, 0x0f, 0xc8, 0xa4, 0x59, 0xb7 };
    447          
    448          /* "Entropy" from buffer */
    449          static size_t test_offset;
    450          static int hmac_drbg_self_test_entropy( void *data,
    451                                                  unsigned char *buf, size_t len )
    452          {
    453              const unsigned char *p = data;
    454              memcpy( buf, p + test_offset, len );
    455              test_offset += len;
    456              return( 0 );
    457          }
    458          
    459          #define CHK( c )    if( (c) != 0 )                          \
    460                              {                                       \
    461                                  if( verbose != 0 )                  \
    462                                      mbedtls_printf( "failed\n" );  \
    463                                  return( 1 );                        \
    464                              }
    465          
    466          /*
    467           * Checkup routine for HMAC_DRBG with SHA-1
    468           */
    469          int mbedtls_hmac_drbg_self_test( int verbose )
    470          {
    471              mbedtls_hmac_drbg_context ctx;
    472              unsigned char buf[OUTPUT_LEN];
    473              const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type( MBEDTLS_MD_SHA1 );
    474          
    475              mbedtls_hmac_drbg_init( &ctx );
    476          
    477              /*
    478               * PR = True
    479               */
    480              if( verbose != 0 )
    481                  mbedtls_printf( "  HMAC_DRBG (PR = True) : " );
    482          
    483              test_offset = 0;
    484              CHK( mbedtls_hmac_drbg_seed( &ctx, md_info,
    485                                   hmac_drbg_self_test_entropy, (void *) entropy_pr,
    486                                   NULL, 0 ) );
    487              mbedtls_hmac_drbg_set_prediction_resistance( &ctx, MBEDTLS_HMAC_DRBG_PR_ON );
    488              CHK( mbedtls_hmac_drbg_random( &ctx, buf, OUTPUT_LEN ) );
    489              CHK( mbedtls_hmac_drbg_random( &ctx, buf, OUTPUT_LEN ) );
    490              CHK( memcmp( buf, result_pr, OUTPUT_LEN ) );
    491              mbedtls_hmac_drbg_free( &ctx );
    492          
    493              mbedtls_hmac_drbg_free( &ctx );
    494          
    495              if( verbose != 0 )
    496                  mbedtls_printf( "passed\n" );
    497          
    498              /*
    499               * PR = False
    500               */
    501              if( verbose != 0 )
    502                  mbedtls_printf( "  HMAC_DRBG (PR = False) : " );
    503          
    504              mbedtls_hmac_drbg_init( &ctx );
    505          
    506              test_offset = 0;
    507              CHK( mbedtls_hmac_drbg_seed( &ctx, md_info,
    508                                   hmac_drbg_self_test_entropy, (void *) entropy_nopr,
    509                                   NULL, 0 ) );
    510              CHK( mbedtls_hmac_drbg_reseed( &ctx, NULL, 0 ) );
    511              CHK( mbedtls_hmac_drbg_random( &ctx, buf, OUTPUT_LEN ) );
    512              CHK( mbedtls_hmac_drbg_random( &ctx, buf, OUTPUT_LEN ) );
    513              CHK( memcmp( buf, result_nopr, OUTPUT_LEN ) );
    514              mbedtls_hmac_drbg_free( &ctx );
    515          
    516              mbedtls_hmac_drbg_free( &ctx );
    517          
    518              if( verbose != 0 )
    519                  mbedtls_printf( "passed\n" );
    520          
    521              if( verbose != 0 )
    522                  mbedtls_printf( "\n" );
    523          
    524              return( 0 );
    525          }
    526          #endif /* MBEDTLS_SHA1_C */
    527          #endif /* MBEDTLS_SELF_TEST */
    528          
    529          #endif /* MBEDTLS_HMAC_DRBG_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   mbedtls_hmac_drbg_free
         8   -> __aeabi_memclr
         8   -> mbedtls_md_free
       8   mbedtls_hmac_drbg_init
         8   -> __aeabi_memclr4
      24   mbedtls_hmac_drbg_random
        24   -> __aeabi_memcpy
        24   -> mbedtls_hmac_drbg_reseed
        24   -> mbedtls_hmac_drbg_update
        24   -> mbedtls_md_get_size
        24   -> mbedtls_md_hmac_finish
        24   -> mbedtls_md_hmac_reset
        24   -> mbedtls_md_hmac_update
      32   mbedtls_hmac_drbg_random_with_add
        32   -> __aeabi_memcpy
        32   -> mbedtls_hmac_drbg_reseed
        32   -> mbedtls_hmac_drbg_update
        32   -> mbedtls_md_get_size
        32   -> mbedtls_md_hmac_finish
        32   -> mbedtls_md_hmac_reset
        32   -> mbedtls_md_hmac_update
     408   mbedtls_hmac_drbg_reseed
       408   -- Indirect call
       408   -> __aeabi_memclr4
       408   -> __aeabi_memcpy
       408   -> mbedtls_hmac_drbg_update
      24   mbedtls_hmac_drbg_seed
        24   -> __aeabi_memset4
        24   -> mbedtls_hmac_drbg_reseed
        24   -> mbedtls_md_get_size
        24   -> mbedtls_md_hmac_starts
        24   -> mbedtls_md_setup
      24   mbedtls_hmac_drbg_seed_buf
        24   -> __aeabi_memset4
        24   -> mbedtls_hmac_drbg_update
        24   -> mbedtls_md_get_size
        24   -> mbedtls_md_hmac_starts
        24   -> mbedtls_md_setup
       0   mbedtls_hmac_drbg_self_test
       0   mbedtls_hmac_drbg_set_entropy_len
       0   mbedtls_hmac_drbg_set_prediction_resistance
       0   mbedtls_hmac_drbg_set_reseed_interval
      96   mbedtls_hmac_drbg_update
        96   -> mbedtls_md_get_size
        96   -> mbedtls_md_hmac_finish
        96   -> mbedtls_md_hmac_reset
        96   -> mbedtls_md_hmac_starts
        96   -> mbedtls_md_hmac_update


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
      20  mbedtls_hmac_drbg_free
      10  mbedtls_hmac_drbg_init
     140  mbedtls_hmac_drbg_random
     184  mbedtls_hmac_drbg_random_with_add
     106  mbedtls_hmac_drbg_reseed
     104  mbedtls_hmac_drbg_seed
      70  mbedtls_hmac_drbg_seed_buf
       4  mbedtls_hmac_drbg_self_test
       4  mbedtls_hmac_drbg_set_entropy_len
       4  mbedtls_hmac_drbg_set_prediction_resistance
       4  mbedtls_hmac_drbg_set_reseed_interval
     140  mbedtls_hmac_drbg_update

 
 798 bytes in section .text
 
 798 bytes of CODE memory

Errors: none
Warnings: none

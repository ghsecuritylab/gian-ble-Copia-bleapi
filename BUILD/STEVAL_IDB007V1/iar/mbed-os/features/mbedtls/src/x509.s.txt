###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:37
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\features\mbedtls\src\x509.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\x509.d -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\x509.s.txt -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\x509.o
#        .\mbed-os\features\mbedtls\src\x509.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\x509.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\x509.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\features\mbedtls\src\x509.c
      1          /*
      2           *  X.509 common functions for parsing and verification
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          /*
     22           *  The ITU-T X.509 standard defines a certificate format for PKI.
     23           *
     24           *  http://www.ietf.org/rfc/rfc5280.txt (Certificates and CRLs)
     25           *  http://www.ietf.org/rfc/rfc3279.txt (Alg IDs for CRLs)
     26           *  http://www.ietf.org/rfc/rfc2986.txt (CSRs, aka PKCS#10)
     27           *
     28           *  http://www.itu.int/ITU-T/studygroups/com17/languages/X.680-0207.pdf
     29           *  http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf
     30           */
     31          
     32          #if !defined(MBEDTLS_CONFIG_FILE)
     33          #include "mbedtls/config.h"
     34          #else
     35          #include MBEDTLS_CONFIG_FILE
     36          #endif
     37          
     38          #if defined(MBEDTLS_X509_USE_C)
     39          
     40          #include "mbedtls/x509.h"
     41          #include "mbedtls/asn1.h"
     42          #include "mbedtls/oid.h"
     43          
     44          #include <stdio.h>
     45          #include <string.h>
     46          
     47          #if defined(MBEDTLS_PEM_PARSE_C)
     48          #include "mbedtls/pem.h"
     49          #endif
     50          
     51          #if defined(MBEDTLS_PLATFORM_C)
     52          #include "mbedtls/platform.h"
     53          #else
     54          #include <stdio.h>
     55          #include <stdlib.h>
     56          #define mbedtls_free      free
     57          #define mbedtls_calloc    calloc
     58          #define mbedtls_printf    printf
     59          #define mbedtls_snprintf  snprintf
     60          #endif
     61          
     62          
     63          #if defined(MBEDTLS_HAVE_TIME)
     64          #include "mbedtls/platform_time.h"
     65          #endif
     66          
     67          #if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)
     68          #include <windows.h>
     69          #else
     70          #include <time.h>
     71          #endif
     72          
     73          #if defined(MBEDTLS_FS_IO)
     74          #include <stdio.h>
     75          #if !defined(_WIN32)
     76          #include <sys/types.h>
     77          #include <sys/stat.h>
     78          #include <dirent.h>
     79          #endif
     80          #endif
     81          
     82          #define CHECK(code) if( ( ret = code ) != 0 ){ return( ret ); }
     83          #define CHECK_RANGE(min, max, val) if( val < min || val > max ){ return( ret ); }
     84          
     85          /*
     86           *  CertificateSerialNumber  ::=  INTEGER
     87           */

   \                                 In section .text, align 2, keep-with-next
     88          int mbedtls_x509_get_serial( unsigned char **p, const unsigned char *end,
     89                               mbedtls_x509_buf *serial )
     90          {
   \                     mbedtls_x509_get_serial: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x0014             MOVS     R4,R2
     91              int ret;
     92          
     93              if( ( end - *p ) < 1 )
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x1A0A             SUBS     R2,R1,R0
   \   0000000A   0x2A01             CMP      R2,#+1
   \   0000000C   0xDA01             BGE      ??mbedtls_x509_get_serial_0
     94                  return( MBEDTLS_ERR_X509_INVALID_SERIAL +
     95                          MBEDTLS_ERR_ASN1_OUT_OF_DATA );
   \   0000000E   0x....             LDR      R0,??DataTable14  ;; 0xffffdd20
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??mbedtls_x509_get_serial_0: (+1)
   \   00000012   0x7802             LDRB     R2,[R0, #+0]
   \   00000014   0x2A82             CMP      R2,#+130
   \   00000016   0xD003             BEQ      ??mbedtls_x509_get_serial_1
   \   00000018   0x2A02             CMP      R2,#+2
   \   0000001A   0xD001             BEQ      ??mbedtls_x509_get_serial_1
     96          
     97              if( **p != ( MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_PRIMITIVE | 2 ) &&
     98                  **p !=   MBEDTLS_ASN1_INTEGER )
     99                  return( MBEDTLS_ERR_X509_INVALID_SERIAL +
    100                          MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );
   \   0000001C   0x....             LDR      R0,??DataTable14_1  ;; 0xffffdd1e
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}
    101          
    102              serial->tag = *(*p)++;
   \                     ??mbedtls_x509_get_serial_1: (+1)
   \   00000020   0x1C42             ADDS     R2,R0,#+1
   \   00000022   0x602A             STR      R2,[R5, #+0]
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x6020             STR      R0,[R4, #+0]
    103          
    104              if( ( ret = mbedtls_asn1_get_len( p, end, &serial->len ) ) != 0 )
   \   00000028   0x1D22             ADDS     R2,R4,#+4
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x.... 0x....      BL       mbedtls_asn1_get_len
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD002             BEQ      ??mbedtls_x509_get_serial_2
    105                  return( MBEDTLS_ERR_X509_INVALID_SERIAL + ret );
   \   00000034   0x....             LDR      R1,??DataTable14_2  ;; 0xffffdd80
   \   00000036   0x1840             ADDS     R0,R0,R1
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}
    106          
    107              serial->p = *p;
   \                     ??mbedtls_x509_get_serial_2: (+1)
   \   0000003A   0x6828             LDR      R0,[R5, #+0]
   \   0000003C   0x60A0             STR      R0,[R4, #+8]
    108              *p += serial->len;
   \   0000003E   0x6828             LDR      R0,[R5, #+0]
   \   00000040   0x6861             LDR      R1,[R4, #+4]
   \   00000042   0x1840             ADDS     R0,R0,R1
   \   00000044   0x6028             STR      R0,[R5, #+0]
    109          
    110              return( 0 );
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    111          }
    112          
    113          /* Get an algorithm identifier without parameters (eg for signatures)
    114           *
    115           *  AlgorithmIdentifier  ::=  SEQUENCE  {
    116           *       algorithm               OBJECT IDENTIFIER,
    117           *       parameters              ANY DEFINED BY algorithm OPTIONAL  }
    118           */

   \                                 In section .text, align 2, keep-with-next
    119          int mbedtls_x509_get_alg_null( unsigned char **p, const unsigned char *end,
    120                                 mbedtls_x509_buf *alg )
    121          {
   \                     mbedtls_x509_get_alg_null: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    122              int ret;
    123          
    124              if( ( ret = mbedtls_asn1_get_alg_null( p, end, alg ) ) != 0 )
   \   00000002   0x.... 0x....      BL       mbedtls_asn1_get_alg_null
   \   00000006   0x....             B.N      ?Subroutine0
    125                  return( MBEDTLS_ERR_X509_INVALID_ALG + ret );
    126          
    127              return( 0 );
    128          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD001             BEQ      ??Subroutine0_0
   \   00000004   0x....             LDR      R1,??DataTable15  ;; 0xffffdd00
   \   00000006   0x1840             ADDS     R0,R0,R1
   \                     ??Subroutine0_0: (+1)
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    129          
    130          /*
    131           * Parse an algorithm identifier with (optional) paramaters
    132           */

   \                                 In section .text, align 2, keep-with-next
    133          int mbedtls_x509_get_alg( unsigned char **p, const unsigned char *end,
    134                            mbedtls_x509_buf *alg, mbedtls_x509_buf *params )
    135          {
   \                     mbedtls_x509_get_alg: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    136              int ret;
    137          
    138              if( ( ret = mbedtls_asn1_get_alg( p, end, alg, params ) ) != 0 )
   \   00000002   0x.... 0x....      BL       mbedtls_asn1_get_alg
   \   00000006                      REQUIRE ?Subroutine0
   \   00000006                      ;; // Fall through to label ?Subroutine0
    139                  return( MBEDTLS_ERR_X509_INVALID_ALG + ret );
    140          
    141              return( 0 );
    142          }
    143          
    144          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
    145          /*
    146           * HashAlgorithm ::= AlgorithmIdentifier
    147           *
    148           * AlgorithmIdentifier  ::=  SEQUENCE  {
    149           *      algorithm               OBJECT IDENTIFIER,
    150           *      parameters              ANY DEFINED BY algorithm OPTIONAL  }
    151           *
    152           * For HashAlgorithm, parameters MUST be NULL or absent.
    153           */
    154          static int x509_get_hash_alg( const mbedtls_x509_buf *alg, mbedtls_md_type_t *md_alg )
    155          {
    156              int ret;
    157              unsigned char *p;
    158              const unsigned char *end;
    159              mbedtls_x509_buf md_oid;
    160              size_t len;
    161          
    162              /* Make sure we got a SEQUENCE and setup bounds */
    163              if( alg->tag != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) )
    164                  return( MBEDTLS_ERR_X509_INVALID_ALG +
    165                          MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );
    166          
    167              p = (unsigned char *) alg->p;
    168              end = p + alg->len;
    169          
    170              if( p >= end )
    171                  return( MBEDTLS_ERR_X509_INVALID_ALG +
    172                          MBEDTLS_ERR_ASN1_OUT_OF_DATA );
    173          
    174              /* Parse md_oid */
    175              md_oid.tag = *p;
    176          
    177              if( ( ret = mbedtls_asn1_get_tag( &p, end, &md_oid.len, MBEDTLS_ASN1_OID ) ) != 0 )
    178                  return( MBEDTLS_ERR_X509_INVALID_ALG + ret );
    179          
    180              md_oid.p = p;
    181              p += md_oid.len;
    182          
    183              /* Get md_alg from md_oid */
    184              if( ( ret = mbedtls_oid_get_md_alg( &md_oid, md_alg ) ) != 0 )
    185                  return( MBEDTLS_ERR_X509_INVALID_ALG + ret );
    186          
    187              /* Make sure params is absent of NULL */
    188              if( p == end )
    189                  return( 0 );
    190          
    191              if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_NULL ) ) != 0 || len != 0 )
    192                  return( MBEDTLS_ERR_X509_INVALID_ALG + ret );
    193          
    194              if( p != end )
    195                  return( MBEDTLS_ERR_X509_INVALID_ALG +
    196                          MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
    197          
    198              return( 0 );
    199          }
    200          
    201          /*
    202           *    RSASSA-PSS-params  ::=  SEQUENCE  {
    203           *       hashAlgorithm     [0] HashAlgorithm DEFAULT sha1Identifier,
    204           *       maskGenAlgorithm  [1] MaskGenAlgorithm DEFAULT mgf1SHA1Identifier,
    205           *       saltLength        [2] INTEGER DEFAULT 20,
    206           *       trailerField      [3] INTEGER DEFAULT 1  }
    207           *    -- Note that the tags in this Sequence are explicit.
    208           *
    209           * RFC 4055 (which defines use of RSASSA-PSS in PKIX) states that the value
    210           * of trailerField MUST be 1, and PKCS#1 v2.2 doesn't even define any other
    211           * option. Enfore this at parsing time.
    212           */
    213          int mbedtls_x509_get_rsassa_pss_params( const mbedtls_x509_buf *params,
    214                                          mbedtls_md_type_t *md_alg, mbedtls_md_type_t *mgf_md,
    215                                          int *salt_len )
    216          {
    217              int ret;
    218              unsigned char *p;
    219              const unsigned char *end, *end2;
    220              size_t len;
    221              mbedtls_x509_buf alg_id, alg_params;
    222          
    223              /* First set everything to defaults */
    224              *md_alg = MBEDTLS_MD_SHA1;
    225              *mgf_md = MBEDTLS_MD_SHA1;
    226              *salt_len = 20;
    227          
    228              /* Make sure params is a SEQUENCE and setup bounds */
    229              if( params->tag != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) )
    230                  return( MBEDTLS_ERR_X509_INVALID_ALG +
    231                          MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );
    232          
    233              p = (unsigned char *) params->p;
    234              end = p + params->len;
    235          
    236              if( p == end )
    237                  return( 0 );
    238          
    239              /*
    240               * HashAlgorithm
    241               */
    242              if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    243                              MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 0 ) ) == 0 )
    244              {
    245                  end2 = p + len;
    246          
    247                  /* HashAlgorithm ::= AlgorithmIdentifier (without parameters) */
    248                  if( ( ret = mbedtls_x509_get_alg_null( &p, end2, &alg_id ) ) != 0 )
    249                      return( ret );
    250          
    251                  if( ( ret = mbedtls_oid_get_md_alg( &alg_id, md_alg ) ) != 0 )
    252                      return( MBEDTLS_ERR_X509_INVALID_ALG + ret );
    253          
    254                  if( p != end2 )
    255                      return( MBEDTLS_ERR_X509_INVALID_ALG +
    256                              MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
    257              }
    258              else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
    259                  return( MBEDTLS_ERR_X509_INVALID_ALG + ret );
    260          
    261              if( p == end )
    262                  return( 0 );
    263          
    264              /*
    265               * MaskGenAlgorithm
    266               */
    267              if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    268                              MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 1 ) ) == 0 )
    269              {
    270                  end2 = p + len;
    271          
    272                  /* MaskGenAlgorithm ::= AlgorithmIdentifier (params = HashAlgorithm) */
    273                  if( ( ret = mbedtls_x509_get_alg( &p, end2, &alg_id, &alg_params ) ) != 0 )
    274                      return( ret );
    275          
    276                  /* Only MFG1 is recognised for now */
    277                  if( MBEDTLS_OID_CMP( MBEDTLS_OID_MGF1, &alg_id ) != 0 )
    278                      return( MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE +
    279                              MBEDTLS_ERR_OID_NOT_FOUND );
    280          
    281                  /* Parse HashAlgorithm */
    282                  if( ( ret = x509_get_hash_alg( &alg_params, mgf_md ) ) != 0 )
    283                      return( ret );
    284          
    285                  if( p != end2 )
    286                      return( MBEDTLS_ERR_X509_INVALID_ALG +
    287                              MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
    288              }
    289              else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
    290                  return( MBEDTLS_ERR_X509_INVALID_ALG + ret );
    291          
    292              if( p == end )
    293                  return( 0 );
    294          
    295              /*
    296               * salt_len
    297               */
    298              if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    299                              MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 2 ) ) == 0 )
    300              {
    301                  end2 = p + len;
    302          
    303                  if( ( ret = mbedtls_asn1_get_int( &p, end2, salt_len ) ) != 0 )
    304                      return( MBEDTLS_ERR_X509_INVALID_ALG + ret );
    305          
    306                  if( p != end2 )
    307                      return( MBEDTLS_ERR_X509_INVALID_ALG +
    308                              MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
    309              }
    310              else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
    311                  return( MBEDTLS_ERR_X509_INVALID_ALG + ret );
    312          
    313              if( p == end )
    314                  return( 0 );
    315          
    316              /*
    317               * trailer_field (if present, must be 1)
    318               */
    319              if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    320                              MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 3 ) ) == 0 )
    321              {
    322                  int trailer_field;
    323          
    324                  end2 = p + len;
    325          
    326                  if( ( ret = mbedtls_asn1_get_int( &p, end2, &trailer_field ) ) != 0 )
    327                      return( MBEDTLS_ERR_X509_INVALID_ALG + ret );
    328          
    329                  if( p != end2 )
    330                      return( MBEDTLS_ERR_X509_INVALID_ALG +
    331                              MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
    332          
    333                  if( trailer_field != 1 )
    334                      return( MBEDTLS_ERR_X509_INVALID_ALG );
    335              }
    336              else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
    337                  return( MBEDTLS_ERR_X509_INVALID_ALG + ret );
    338          
    339              if( p != end )
    340                  return( MBEDTLS_ERR_X509_INVALID_ALG +
    341                          MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
    342          
    343              return( 0 );
    344          }
    345          #endif /* MBEDTLS_X509_RSASSA_PSS_SUPPORT */
    346          
    347          /*
    348           *  AttributeTypeAndValue ::= SEQUENCE {
    349           *    type     AttributeType,
    350           *    value    AttributeValue }
    351           *
    352           *  AttributeType ::= OBJECT IDENTIFIER
    353           *
    354           *  AttributeValue ::= ANY DEFINED BY AttributeType
    355           */

   \                                 In section .text, align 2, keep-with-next
    356          static int x509_get_attr_type_value( unsigned char **p,
    357                                               const unsigned char *end,
    358                                               mbedtls_x509_name *cur )
    359          {
   \                     x509_get_attr_type_value: (+1)
   \   00000000   0xB5B0             PUSH     {R4,R5,R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x0014             MOVS     R4,R2
    360              int ret;
    361              size_t len;
    362              mbedtls_x509_buf *oid;
    363              mbedtls_x509_buf *val;
    364          
    365              if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
    366                      MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
   \   0000000A   0x2330             MOVS     R3,#+48
   \   0000000C   0x466A             MOV      R2,SP
   \   0000000E   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD135             BNE      ??x509_get_attr_type_value_0
    367                  return( MBEDTLS_ERR_X509_INVALID_NAME + ret );
    368          
    369              if( ( end - *p ) < 1 )
   \   00000016   0x6828             LDR      R0,[R5, #+0]
   \   00000018   0x1A39             SUBS     R1,R7,R0
   \   0000001A   0x2901             CMP      R1,#+1
   \   0000001C   0xDB12             BLT      ??x509_get_attr_type_value_1
    370                  return( MBEDTLS_ERR_X509_INVALID_NAME +
    371                          MBEDTLS_ERR_ASN1_OUT_OF_DATA );
    372          
    373              oid = &cur->oid;
    374              oid->tag = **p;
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x6020             STR      R0,[R4, #+0]
    375          
    376              if( ( ret = mbedtls_asn1_get_tag( p, end, &oid->len, MBEDTLS_ASN1_OID ) ) != 0 )
   \   00000022   0x2306             MOVS     R3,#+6
   \   00000024   0x1D22             ADDS     R2,R4,#+4
   \   00000026   0x0039             MOVS     R1,R7
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD127             BNE      ??x509_get_attr_type_value_0
    377                  return( MBEDTLS_ERR_X509_INVALID_NAME + ret );
    378          
    379              oid->p = *p;
   \   00000032   0x6828             LDR      R0,[R5, #+0]
   \   00000034   0x60A0             STR      R0,[R4, #+8]
    380              *p += oid->len;
   \   00000036   0x6828             LDR      R0,[R5, #+0]
   \   00000038   0x6861             LDR      R1,[R4, #+4]
   \   0000003A   0x1840             ADDS     R0,R0,R1
   \   0000003C   0x6028             STR      R0,[R5, #+0]
    381          
    382              if( ( end - *p ) < 1 )
   \   0000003E   0x1A39             SUBS     R1,R7,R0
   \   00000040   0x2901             CMP      R1,#+1
   \   00000042   0xDA01             BGE      ??x509_get_attr_type_value_2
    383                  return( MBEDTLS_ERR_X509_INVALID_NAME +
    384                          MBEDTLS_ERR_ASN1_OUT_OF_DATA );
   \                     ??x509_get_attr_type_value_1: (+1)
   \   00000044   0x....             LDR      R0,??DataTable16  ;; 0xffffdc20
   \   00000046   0xBDB6             POP      {R1,R2,R4,R5,R7,PC}
   \                     ??x509_get_attr_type_value_2: (+1)
   \   00000048   0x7801             LDRB     R1,[R0, #+0]
   \   0000004A   0x291E             CMP      R1,#+30
   \   0000004C   0xD00D             BEQ      ??x509_get_attr_type_value_3
   \   0000004E   0x290C             CMP      R1,#+12
   \   00000050   0xD00B             BEQ      ??x509_get_attr_type_value_3
   \   00000052   0x2914             CMP      R1,#+20
   \   00000054   0xD009             BEQ      ??x509_get_attr_type_value_3
   \   00000056   0x2913             CMP      R1,#+19
   \   00000058   0xD007             BEQ      ??x509_get_attr_type_value_3
   \   0000005A   0x2916             CMP      R1,#+22
   \   0000005C   0xD005             BEQ      ??x509_get_attr_type_value_3
   \   0000005E   0x291C             CMP      R1,#+28
   \   00000060   0xD003             BEQ      ??x509_get_attr_type_value_3
   \   00000062   0x2903             CMP      R1,#+3
   \   00000064   0xD001             BEQ      ??x509_get_attr_type_value_3
    385          
    386              if( **p != MBEDTLS_ASN1_BMP_STRING && **p != MBEDTLS_ASN1_UTF8_STRING      &&
    387                  **p != MBEDTLS_ASN1_T61_STRING && **p != MBEDTLS_ASN1_PRINTABLE_STRING &&
    388                  **p != MBEDTLS_ASN1_IA5_STRING && **p != MBEDTLS_ASN1_UNIVERSAL_STRING &&
    389                  **p != MBEDTLS_ASN1_BIT_STRING )
    390                  return( MBEDTLS_ERR_X509_INVALID_NAME +
    391                          MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );
   \   00000066   0x....             LDR      R0,??DataTable16_1  ;; 0xffffdc1e
   \   00000068   0xBDB6             POP      {R1,R2,R4,R5,R7,PC}
    392          
    393              val = &cur->val;
    394              val->tag = *(*p)++;
   \                     ??x509_get_attr_type_value_3: (+1)
   \   0000006A   0x1C41             ADDS     R1,R0,#+1
   \   0000006C   0x6029             STR      R1,[R5, #+0]
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0x60E0             STR      R0,[R4, #+12]
    395          
    396              if( ( ret = mbedtls_asn1_get_len( p, end, &val->len ) ) != 0 )
   \   00000072   0x0022             MOVS     R2,R4
   \   00000074   0x3210             ADDS     R2,R2,#+16
   \   00000076   0x0039             MOVS     R1,R7
   \   00000078   0x0028             MOVS     R0,R5
   \   0000007A   0x.... 0x....      BL       mbedtls_asn1_get_len
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD002             BEQ      ??x509_get_attr_type_value_4
    397                  return( MBEDTLS_ERR_X509_INVALID_NAME + ret );
   \                     ??x509_get_attr_type_value_0: (+1)
   \   00000082   0x....             LDR      R1,??DataTable17  ;; 0xffffdc80
   \   00000084   0x1840             ADDS     R0,R0,R1
   \   00000086   0xBDB6             POP      {R1,R2,R4,R5,R7,PC}
    398          
    399              val->p = *p;
   \                     ??x509_get_attr_type_value_4: (+1)
   \   00000088   0x6828             LDR      R0,[R5, #+0]
   \   0000008A   0x6160             STR      R0,[R4, #+20]
    400              *p += val->len;
   \   0000008C   0x6828             LDR      R0,[R5, #+0]
   \   0000008E   0x6921             LDR      R1,[R4, #+16]
   \   00000090   0x1840             ADDS     R0,R0,R1
   \   00000092   0x6028             STR      R0,[R5, #+0]
    401          
    402              cur->next = NULL;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x61A0             STR      R0,[R4, #+24]
    403          
    404              return( 0 );
   \   00000098   0xBDB6             POP      {R1,R2,R4,R5,R7,PC}  ;; return
    405          }
    406          
    407          /*
    408           *  Name ::= CHOICE { -- only one possibility for now --
    409           *       rdnSequence  RDNSequence }
    410           *
    411           *  RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
    412           *
    413           *  RelativeDistinguishedName ::=
    414           *    SET OF AttributeTypeAndValue
    415           *
    416           *  AttributeTypeAndValue ::= SEQUENCE {
    417           *    type     AttributeType,
    418           *    value    AttributeValue }
    419           *
    420           *  AttributeType ::= OBJECT IDENTIFIER
    421           *
    422           *  AttributeValue ::= ANY DEFINED BY AttributeType
    423           *
    424           * The data structure is optimized for the common case where each RDN has only
    425           * one element, which is represented as a list of AttributeTypeAndValue.
    426           * For the general case we still use a flat list, but we mark elements of the
    427           * same set so that they are "merged" together in the functions that consume
    428           * this list, eg mbedtls_x509_dn_gets().
    429           */

   \                                 In section .text, align 2, keep-with-next
    430          int mbedtls_x509_get_name( unsigned char **p, const unsigned char *end,
    431                             mbedtls_x509_name *cur )
    432          {
   \                     mbedtls_x509_get_name: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0014             MOVS     R4,R2
   \   00000008   0xE000             B        ??mbedtls_x509_get_name_0
    433              int ret;
    434              size_t set_len;
    435              const unsigned char *end_set;
    436          
    437              /* don't use recursion, we'd risk stack overflow if not optimized */
    438              while( 1 )
    439              {
    440                  /*
    441                   * parse SET
    442                   */
    443                  if( ( ret = mbedtls_asn1_get_tag( p, end, &set_len,
    444                          MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SET ) ) != 0 )
    445                      return( MBEDTLS_ERR_X509_INVALID_NAME + ret );
    446          
    447                  end_set  = *p + set_len;
    448          
    449                  while( 1 )
    450                  {
    451                      if( ( ret = x509_get_attr_type_value( p, end_set, cur ) ) != 0 )
    452                          return( ret );
    453          
    454                      if( *p == end_set )
    455                          break;
    456          
    457                      /* Mark this item as being no the only one in a set */
    458                      cur->next_merged = 1;
    459          
    460                      cur->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_name ) );
    461          
    462                      if( cur->next == NULL )
    463                          return( MBEDTLS_ERR_X509_ALLOC_FAILED );
    464          
    465                      cur = cur->next;
    466                  }
    467          
    468                  /*
    469                   * continue until end of SEQUENCE is reached
    470                   */
    471                  if( *p == end )
    472                      return( 0 );
    473          
    474                  cur->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_name ) );
    475          
    476                  if( cur->next == NULL )
    477                      return( MBEDTLS_ERR_X509_ALLOC_FAILED );
    478          
    479                  cur = cur->next;
   \                     ??mbedtls_x509_get_name_1: (+1)
   \   0000000A   0x0004             MOVS     R4,R0
   \                     ??mbedtls_x509_get_name_0: (+1)
   \   0000000C   0x2331             MOVS     R3,#+49
   \   0000000E   0x466A             MOV      R2,SP
   \   00000010   0x0039             MOVS     R1,R7
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD002             BEQ      ??mbedtls_x509_get_name_2
   \   0000001C   0x....             LDR      R1,??DataTable17  ;; 0xffffdc80
   \   0000001E   0x1840             ADDS     R0,R0,R1
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??mbedtls_x509_get_name_2: (+1)
   \   00000022   0x6828             LDR      R0,[R5, #+0]
   \   00000024   0x9900             LDR      R1,[SP, #+0]
   \   00000026   0x1846             ADDS     R6,R0,R1
   \   00000028   0xE008             B        ??mbedtls_x509_get_name_3
   \                     ??mbedtls_x509_get_name_4: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x7720             STRB     R0,[R4, #+28]
   \   0000002E   0x2120             MOVS     R1,#+32
   \   00000030   0x.... 0x....      BL       calloc
   \   00000034   0x61A0             STR      R0,[R4, #+24]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD015             BEQ      ??mbedtls_x509_get_name_5
   \   0000003A   0x0004             MOVS     R4,R0
   \                     ??mbedtls_x509_get_name_3: (+1)
   \   0000003C   0x0022             MOVS     R2,R4
   \   0000003E   0x0031             MOVS     R1,R6
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0x.... 0x....      BL       x509_get_attr_type_value
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD10E             BNE      ??mbedtls_x509_get_name_6
   \   0000004A   0x6828             LDR      R0,[R5, #+0]
   \   0000004C   0x42B0             CMP      R0,R6
   \   0000004E   0xD1EC             BNE      ??mbedtls_x509_get_name_4
   \   00000050   0x42B8             CMP      R0,R7
   \   00000052   0xD101             BNE      ??mbedtls_x509_get_name_7
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??mbedtls_x509_get_name_7: (+1)
   \   00000058   0x2120             MOVS     R1,#+32
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x.... 0x....      BL       calloc
   \   00000060   0x61A0             STR      R0,[R4, #+24]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD1D1             BNE      ??mbedtls_x509_get_name_1
   \                     ??mbedtls_x509_get_name_5: (+1)
   \   00000066   0x....             LDR      R0,??DataTable18  ;; 0xffffd780
   \                     ??mbedtls_x509_get_name_6: (+1)
   \   00000068   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    480              }
    481          }
    482          
    483          static int x509_parse_int( unsigned char **p, size_t n, int *res )
    484          {
    485              *res = 0;
    486          
    487              for( ; n > 0; --n )
    488              {
    489                  if( ( **p < '0') || ( **p > '9' ) )
    490                      return ( MBEDTLS_ERR_X509_INVALID_DATE );
    491          
    492                  *res *= 10;
    493                  *res += ( *(*p)++ - '0' );
    494              }
    495          
    496              return( 0 );
    497          }
    498          
    499          static int x509_date_is_valid(const mbedtls_x509_time *t)
    500          {
    501              int ret = MBEDTLS_ERR_X509_INVALID_DATE;
    502          
    503              CHECK_RANGE( 0, 9999, t->year );
    504              CHECK_RANGE( 0, 23,   t->hour );
    505              CHECK_RANGE( 0, 59,   t->min  );
    506              CHECK_RANGE( 0, 59,   t->sec  );
    507          
    508              switch( t->mon )
    509              {
    510                  case 1: case 3: case 5: case 7: case 8: case 10: case 12:
    511                      CHECK_RANGE( 1, 31, t->day );
    512                      break;
    513                  case 4: case 6: case 9: case 11:
    514                      CHECK_RANGE( 1, 30, t->day );
    515                      break;
    516                  case 2:
    517                      CHECK_RANGE( 1, 28 + (t->year % 4 == 0), t->day );
    518                      break;
    519                  default:
    520                      return( ret );
    521              }
    522          
    523              return( 0 );
    524          }
    525          
    526          /*
    527           * Parse an ASN1_UTC_TIME (yearlen=2) or ASN1_GENERALIZED_TIME (yearlen=4)
    528           * field.
    529           */

   \                                 In section .text, align 4, keep-with-next
    530          static int x509_parse_time( unsigned char **p, size_t len, size_t yearlen,
    531                                      mbedtls_x509_time *tm )
    532          {
   \                     x509_parse_time: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    533              int ret;
    534          
    535              /*
    536               * Minimum length is 10 or 12 depending on yearlen
    537               */
    538              if ( len < yearlen + 8 )
   \   00000002   0x0014             MOVS     R4,R2
   \   00000004   0x3408             ADDS     R4,R4,#+8
   \   00000006   0x42A1             CMP      R1,R4
   \   00000008   0xD318             BCC      ??x509_parse_time_1
    539                  return ( MBEDTLS_ERR_X509_INVALID_DATE );
    540              len -= yearlen + 8;
   \   0000000A   0x1A89             SUBS     R1,R1,R2
   \   0000000C   0x3908             SUBS     R1,R1,#+8
    541          
    542              /*
    543               * Parse year, month, day, hour, minute
    544               */
    545              CHECK( x509_parse_int( p, yearlen, &tm->year ) );
   \   0000000E   0x0014             MOVS     R4,R2
   \   00000010   0x2500             MOVS     R5,#+0
   \   00000012   0x601D             STR      R5,[R3, #+0]
   \   00000014   0xE00B             B        ??x509_parse_time_2
   \                     ??x509_parse_time_3: (+1)
   \   00000016   0x681E             LDR      R6,[R3, #+0]
   \   00000018   0x00B7             LSLS     R7,R6,#+2
   \   0000001A   0x19BE             ADDS     R6,R7,R6
   \   0000001C   0x0076             LSLS     R6,R6,#+1
   \   0000001E   0x601E             STR      R6,[R3, #+0]
   \   00000020   0x1C6F             ADDS     R7,R5,#+1
   \   00000022   0x6007             STR      R7,[R0, #+0]
   \   00000024   0x782D             LDRB     R5,[R5, #+0]
   \   00000026   0x3D30             SUBS     R5,R5,#+48
   \   00000028   0x1975             ADDS     R5,R6,R5
   \   0000002A   0x601D             STR      R5,[R3, #+0]
   \   0000002C   0x1E64             SUBS     R4,R4,#+1
   \                     ??x509_parse_time_2: (+1)
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD006             BEQ      ??x509_parse_time_4
   \   00000032   0x6805             LDR      R5,[R0, #+0]
   \   00000034   0x782E             LDRB     R6,[R5, #+0]
   \   00000036   0x3E30             SUBS     R6,R6,#+48
   \   00000038   0x2E0A             CMP      R6,#+10
   \   0000003A   0xD3EC             BCC      ??x509_parse_time_3
   \                     ??x509_parse_time_1: (+1)
   \   0000003C   0x....             LDR      R0,??DataTable19  ;; 0xffffdc00
   \   0000003E   0xE0C1             B        ??x509_parse_time_5
    546              if ( 2 == yearlen )
   \                     ??x509_parse_time_4: (+1)
   \   00000040   0x2A02             CMP      R2,#+2
   \   00000042   0xD108             BNE      ??x509_parse_time_6
    547              {
    548                  if ( tm->year < 50 )
   \   00000044   0x681E             LDR      R6,[R3, #+0]
   \   00000046   0x2E32             CMP      R6,#+50
   \   00000048   0xDA01             BGE      ??x509_parse_time_7
    549                      tm->year += 100;
   \   0000004A   0x3664             ADDS     R6,R6,#+100
   \   0000004C   0x601E             STR      R6,[R3, #+0]
    550          
    551                  tm->year += 1900;
   \                     ??x509_parse_time_7: (+1)
   \   0000004E   0x681A             LDR      R2,[R3, #+0]
   \   00000050   0x....             LDR      R4,??DataTable19_1  ;; 0x76c
   \   00000052   0x1912             ADDS     R2,R2,R4
   \   00000054   0x601A             STR      R2,[R3, #+0]
    552              }
    553          
    554              CHECK( x509_parse_int( p, 2, &tm->mon ) );
   \                     ??x509_parse_time_6: (+1)
   \   00000056   0x2200             MOVS     R2,#+0
   \   00000058   0x605A             STR      R2,[R3, #+4]
   \   0000005A   0x2202             MOVS     R2,#+2
   \   0000005C   0x2402             MOVS     R4,#+2
   \                     ??x509_parse_time_8: (+1)
   \   0000005E   0x6805             LDR      R5,[R0, #+0]
   \   00000060   0x782E             LDRB     R6,[R5, #+0]
   \   00000062   0x3E30             SUBS     R6,R6,#+48
   \   00000064   0x2E0A             CMP      R6,#+10
   \   00000066   0xD2E9             BCS      ??x509_parse_time_1
   \   00000068   0x685E             LDR      R6,[R3, #+4]
   \   0000006A   0x00B7             LSLS     R7,R6,#+2
   \   0000006C   0x19BE             ADDS     R6,R7,R6
   \   0000006E   0x0076             LSLS     R6,R6,#+1
   \   00000070   0x605E             STR      R6,[R3, #+4]
   \   00000072   0x1C6F             ADDS     R7,R5,#+1
   \   00000074   0x6007             STR      R7,[R0, #+0]
   \   00000076   0x782D             LDRB     R5,[R5, #+0]
   \   00000078   0x3D30             SUBS     R5,R5,#+48
   \   0000007A   0x1975             ADDS     R5,R6,R5
   \   0000007C   0x605D             STR      R5,[R3, #+4]
   \   0000007E   0x1E64             SUBS     R4,R4,#+1
   \   00000080   0xD1ED             BNE      ??x509_parse_time_8
    555              CHECK( x509_parse_int( p, 2, &tm->day ) );
   \   00000082   0x609C             STR      R4,[R3, #+8]
   \   00000084   0x2402             MOVS     R4,#+2
   \                     ??x509_parse_time_9: (+1)
   \   00000086   0x6805             LDR      R5,[R0, #+0]
   \   00000088   0x782E             LDRB     R6,[R5, #+0]
   \   0000008A   0x3E30             SUBS     R6,R6,#+48
   \   0000008C   0x2E0A             CMP      R6,#+10
   \   0000008E   0xD2D5             BCS      ??x509_parse_time_1
   \   00000090   0x689E             LDR      R6,[R3, #+8]
   \   00000092   0x00B7             LSLS     R7,R6,#+2
   \   00000094   0x19BE             ADDS     R6,R7,R6
   \   00000096   0x0076             LSLS     R6,R6,#+1
   \   00000098   0x609E             STR      R6,[R3, #+8]
   \   0000009A   0x1C6F             ADDS     R7,R5,#+1
   \   0000009C   0x6007             STR      R7,[R0, #+0]
   \   0000009E   0x782D             LDRB     R5,[R5, #+0]
   \   000000A0   0x3D30             SUBS     R5,R5,#+48
   \   000000A2   0x1975             ADDS     R5,R6,R5
   \   000000A4   0x609D             STR      R5,[R3, #+8]
   \   000000A6   0x1E64             SUBS     R4,R4,#+1
   \   000000A8   0xD1ED             BNE      ??x509_parse_time_9
    556              CHECK( x509_parse_int( p, 2, &tm->hour ) );
   \   000000AA   0x60DC             STR      R4,[R3, #+12]
   \   000000AC   0x2402             MOVS     R4,#+2
   \                     ??x509_parse_time_10: (+1)
   \   000000AE   0x6805             LDR      R5,[R0, #+0]
   \   000000B0   0x782E             LDRB     R6,[R5, #+0]
   \   000000B2   0x3E30             SUBS     R6,R6,#+48
   \   000000B4   0x2E0A             CMP      R6,#+10
   \   000000B6   0xD2C1             BCS      ??x509_parse_time_1
   \   000000B8   0x68DE             LDR      R6,[R3, #+12]
   \   000000BA   0x00B7             LSLS     R7,R6,#+2
   \   000000BC   0x19BE             ADDS     R6,R7,R6
   \   000000BE   0x0076             LSLS     R6,R6,#+1
   \   000000C0   0x60DE             STR      R6,[R3, #+12]
   \   000000C2   0x1C6F             ADDS     R7,R5,#+1
   \   000000C4   0x6007             STR      R7,[R0, #+0]
   \   000000C6   0x782D             LDRB     R5,[R5, #+0]
   \   000000C8   0x3D30             SUBS     R5,R5,#+48
   \   000000CA   0x1975             ADDS     R5,R6,R5
   \   000000CC   0x60DD             STR      R5,[R3, #+12]
   \   000000CE   0x1E64             SUBS     R4,R4,#+1
   \   000000D0   0xD1ED             BNE      ??x509_parse_time_10
    557              CHECK( x509_parse_int( p, 2, &tm->min ) );
   \   000000D2   0x611C             STR      R4,[R3, #+16]
   \   000000D4   0x2402             MOVS     R4,#+2
   \                     ??x509_parse_time_11: (+1)
   \   000000D6   0x6805             LDR      R5,[R0, #+0]
   \   000000D8   0x782E             LDRB     R6,[R5, #+0]
   \   000000DA   0x3E30             SUBS     R6,R6,#+48
   \   000000DC   0x2E0A             CMP      R6,#+10
   \   000000DE   0xD2AD             BCS      ??x509_parse_time_1
   \   000000E0   0x691E             LDR      R6,[R3, #+16]
   \   000000E2   0x00B7             LSLS     R7,R6,#+2
   \   000000E4   0x19BE             ADDS     R6,R7,R6
   \   000000E6   0x0076             LSLS     R6,R6,#+1
   \   000000E8   0x611E             STR      R6,[R3, #+16]
   \   000000EA   0x1C6F             ADDS     R7,R5,#+1
   \   000000EC   0x6007             STR      R7,[R0, #+0]
   \   000000EE   0x782D             LDRB     R5,[R5, #+0]
   \   000000F0   0x3D30             SUBS     R5,R5,#+48
   \   000000F2   0x1975             ADDS     R5,R6,R5
   \   000000F4   0x611D             STR      R5,[R3, #+16]
   \   000000F6   0x1E64             SUBS     R4,R4,#+1
   \   000000F8   0xD1ED             BNE      ??x509_parse_time_11
    558          
    559              /*
    560               * Parse seconds if present
    561               */
    562              if ( len >= 2 )
   \   000000FA   0x2902             CMP      R1,#+2
   \   000000FC   0xD39E             BCC      ??x509_parse_time_1
    563              {
    564                  CHECK( x509_parse_int( p, 2, &tm->sec ) );
   \   000000FE   0x615C             STR      R4,[R3, #+20]
   \                     ??x509_parse_time_12: (+1)
   \   00000100   0x6804             LDR      R4,[R0, #+0]
   \   00000102   0x7825             LDRB     R5,[R4, #+0]
   \   00000104   0x3D30             SUBS     R5,R5,#+48
   \   00000106   0x2D0A             CMP      R5,#+10
   \   00000108   0xD298             BCS      ??x509_parse_time_1
   \   0000010A   0x695D             LDR      R5,[R3, #+20]
   \   0000010C   0x00AE             LSLS     R6,R5,#+2
   \   0000010E   0x1975             ADDS     R5,R6,R5
   \   00000110   0x006D             LSLS     R5,R5,#+1
   \   00000112   0x615D             STR      R5,[R3, #+20]
   \   00000114   0x1C66             ADDS     R6,R4,#+1
   \   00000116   0x6006             STR      R6,[R0, #+0]
   \   00000118   0x7824             LDRB     R4,[R4, #+0]
   \   0000011A   0x3C30             SUBS     R4,R4,#+48
   \   0000011C   0x192C             ADDS     R4,R5,R4
   \   0000011E   0x615C             STR      R4,[R3, #+20]
   \   00000120   0x1E52             SUBS     R2,R2,#+1
   \   00000122   0xD1ED             BNE      ??x509_parse_time_12
    565                  len -= 2;
   \   00000124   0x1E89             SUBS     R1,R1,#+2
    566              }
    567              else
    568                  return ( MBEDTLS_ERR_X509_INVALID_DATE );
    569          
    570              /*
    571               * Parse trailing 'Z' if present
    572               */
    573              if ( 1 == len && 'Z' == **p )
   \   00000126   0x2901             CMP      R1,#+1
   \   00000128   0xD106             BNE      ??x509_parse_time_13
   \   0000012A   0x6801             LDR      R1,[R0, #+0]
   \   0000012C   0x780A             LDRB     R2,[R1, #+0]
   \   0000012E   0x2A5A             CMP      R2,#+90
   \   00000130   0xD184             BNE      ??x509_parse_time_1
    574              {
    575                  (*p)++;
   \   00000132   0x1C49             ADDS     R1,R1,#+1
   \   00000134   0x6001             STR      R1,[R0, #+0]
    576                  len--;
   \   00000136   0xE002             B        ??x509_parse_time_14
    577              }
    578          
    579              /*
    580               * We should have parsed all characters at this point
    581               */
    582              if ( 0 != len )
   \                     ??x509_parse_time_13: (+1)
   \   00000138   0x2900             CMP      R1,#+0
   \   0000013A   0xD000             BEQ      .+4
   \   0000013C   0xE77E             B        ??x509_parse_time_1
    583                  return ( MBEDTLS_ERR_X509_INVALID_DATE );
    584          
    585              CHECK( x509_date_is_valid( tm ) );
   \                     ??x509_parse_time_14: (+1)
   \   0000013E   0x6818             LDR      R0,[R3, #+0]
   \   00000140   0x....             LDR      R1,??DataTable20  ;; 0x2710
   \   00000142   0x4288             CMP      R0,R1
   \   00000144   0xD300             BCC      .+4
   \   00000146   0xE779             B        ??x509_parse_time_1
   \   00000148   0x68D9             LDR      R1,[R3, #+12]
   \   0000014A   0x2918             CMP      R1,#+24
   \   0000014C   0xD300             BCC      .+4
   \   0000014E   0xE775             B        ??x509_parse_time_1
   \   00000150   0x6919             LDR      R1,[R3, #+16]
   \   00000152   0x293C             CMP      R1,#+60
   \   00000154   0xD300             BCC      .+4
   \   00000156   0xE771             B        ??x509_parse_time_1
   \   00000158   0x6959             LDR      R1,[R3, #+20]
   \   0000015A   0x293C             CMP      R1,#+60
   \   0000015C   0xD300             BCC      .+4
   \   0000015E   0xE76D             B        ??x509_parse_time_1
   \   00000160   0x6859             LDR      R1,[R3, #+4]
   \   00000162   0x1E49             SUBS     R1,R1,#+1
   \   00000164   0x290B             CMP      R1,#+11
   \   00000166   0xD900             BLS      .+4
   \   00000168   0xE768             B        ??x509_parse_time_1
   \   0000016A   0xA202             ADR      R2,??x509_parse_time_0
   \   0000016C   0x0049             LSLS     R1,R1,#+1
   \   0000016E   0x5E52             LDRSH    R2,[R2, R1]
   \   00000170   0x4497             ADD      PC,PC,R2
   \   00000172   0xBF00             Nop      
   \                     ??x509_parse_time_0:
   \   00000174   0x0044 0x0018      DC16     0x44,0x18,0x44,0x3A
   \              0x0044 0x003A
   \   0000017C   0x0044 0x003A      DC16     0x44,0x3A,0x44,0x44
   \              0x0044 0x0044
   \   00000184   0x003A 0x0044      DC16     0x3A,0x44,0x3A,0x44
   \              0x003A 0x0044
   \                     ??x509_parse_time_15: (+1)
   \   0000018C   0x6899             LDR      R1,[R3, #+8]
   \   0000018E   0x2901             CMP      R1,#+1
   \   00000190   0xDA00             BGE      .+4
   \   00000192   0xE753             B        ??x509_parse_time_1
   \   00000194   0x1042             ASRS     R2,R0,#+1
   \   00000196   0x0F92             LSRS     R2,R2,#+30
   \   00000198   0x1812             ADDS     R2,R2,R0
   \   0000019A   0x1092             ASRS     R2,R2,#+2
   \   0000019C   0x0092             LSLS     R2,R2,#+2
   \   0000019E   0x1A80             SUBS     R0,R0,R2
   \   000001A0   0xD101             BNE      ??x509_parse_time_16
   \   000001A2   0x201D             MOVS     R0,#+29
   \   000001A4   0xE000             B        ??x509_parse_time_17
   \                     ??x509_parse_time_16: (+1)
   \   000001A6   0x201C             MOVS     R0,#+28
   \                     ??x509_parse_time_17: (+1)
   \   000001A8   0x4288             CMP      R0,R1
   \   000001AA   0xDA0A             BGE      ??x509_parse_time_18
   \   000001AC   0xE746             B        ??x509_parse_time_1
   \                     ??x509_parse_time_19: (+1)
   \   000001AE   0x6898             LDR      R0,[R3, #+8]
   \   000001B0   0x1E40             SUBS     R0,R0,#+1
   \   000001B2   0x281E             CMP      R0,#+30
   \   000001B4   0xD305             BCC      ??x509_parse_time_18
   \   000001B6   0xE741             B        ??x509_parse_time_1
   \                     ??x509_parse_time_20: (+1)
   \   000001B8   0x6898             LDR      R0,[R3, #+8]
   \   000001BA   0x1E40             SUBS     R0,R0,#+1
   \   000001BC   0x281F             CMP      R0,#+31
   \   000001BE   0xD300             BCC      .+4
   \   000001C0   0xE73C             B        ??x509_parse_time_1
    586          
    587              return ( 0 );
   \                     ??x509_parse_time_18: (+1)
   \   000001C2   0x2000             MOVS     R0,#+0
   \                     ??x509_parse_time_5: (+1)
   \   000001C4   0xBCF0             POP      {R4-R7}
   \   000001C6   0x4770             BX       LR               ;; return
    588          }
    589          
    590          /*
    591           *  Time ::= CHOICE {
    592           *       utcTime        UTCTime,
    593           *       generalTime    GeneralizedTime }
    594           */

   \                                 In section .text, align 2, keep-with-next
    595          int mbedtls_x509_get_time( unsigned char **p, const unsigned char *end,
    596                                     mbedtls_x509_time *tm )
    597          {
   \                     mbedtls_x509_get_time: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x0016             MOVS     R6,R2
    598              int ret;
    599              size_t len, year_len;
    600              unsigned char tag;
    601          
    602              if( ( end - *p ) < 1 )
   \   00000008   0x6828             LDR      R0,[R5, #+0]
   \   0000000A   0x1A0A             SUBS     R2,R1,R0
   \   0000000C   0x2A01             CMP      R2,#+1
   \   0000000E   0xDA01             BGE      ??mbedtls_x509_get_time_0
    603                  return( MBEDTLS_ERR_X509_INVALID_DATE +
    604                          MBEDTLS_ERR_ASN1_OUT_OF_DATA );
   \   00000010   0x....             LDR      R0,??DataTable21  ;; 0xffffdba0
   \   00000012   0xBD76             POP      {R1,R2,R4-R6,PC}
    605          
    606              tag = **p;
   \                     ??mbedtls_x509_get_time_0: (+1)
   \   00000014   0x7802             LDRB     R2,[R0, #+0]
    607          
    608              if( tag == MBEDTLS_ASN1_UTC_TIME )
   \   00000016   0x2A17             CMP      R2,#+23
   \   00000018   0xD10B             BNE      ??mbedtls_x509_get_time_1
    609                  year_len = 2;
   \   0000001A   0x2402             MOVS     R4,#+2
    610              else if( tag == MBEDTLS_ASN1_GENERALIZED_TIME )
    611                  year_len = 4;
    612              else
    613                  return( MBEDTLS_ERR_X509_INVALID_DATE +
    614                          MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );
    615          
    616              (*p)++;
   \                     ??mbedtls_x509_get_time_2: (+1)
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x6028             STR      R0,[R5, #+0]
    617              ret = mbedtls_asn1_get_len( p, end, &len );
   \   00000020   0x466A             MOV      R2,SP
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0x.... 0x....      BL       mbedtls_asn1_get_len
    618          
    619              if( ret != 0 )
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD008             BEQ      ??mbedtls_x509_get_time_3
    620                  return( MBEDTLS_ERR_X509_INVALID_DATE + ret );
   \   0000002C   0x....             LDR      R1,??DataTable19  ;; 0xffffdc00
   \   0000002E   0x1840             ADDS     R0,R0,R1
   \   00000030   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??mbedtls_x509_get_time_1: (+1)
   \   00000032   0x2A18             CMP      R2,#+24
   \   00000034   0xD101             BNE      ??mbedtls_x509_get_time_4
   \   00000036   0x2404             MOVS     R4,#+4
   \   00000038   0xE7F0             B        ??mbedtls_x509_get_time_2
   \                     ??mbedtls_x509_get_time_4: (+1)
   \   0000003A   0x....             LDR      R0,??DataTable22  ;; 0xffffdb9e
   \   0000003C   0xBD76             POP      {R1,R2,R4-R6,PC}
    621          
    622              return x509_parse_time( p, len, year_len, tm );
   \                     ??mbedtls_x509_get_time_3: (+1)
   \   0000003E   0x0033             MOVS     R3,R6
   \   00000040   0x0022             MOVS     R2,R4
   \   00000042   0x9900             LDR      R1,[SP, #+0]
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0x.... 0x....      BL       x509_parse_time
   \   0000004A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    623          }
    624          

   \                                 In section .text, align 2, keep-with-next
    625          int mbedtls_x509_get_sig( unsigned char **p, const unsigned char *end, mbedtls_x509_buf *sig )
    626          {
   \                     mbedtls_x509_get_sig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x0014             MOVS     R4,R2
    627              int ret;
    628              size_t len;
    629              int tag_type;
    630          
    631              if( ( end - *p ) < 1 )
   \   00000008   0x6828             LDR      R0,[R5, #+0]
   \   0000000A   0x1A0A             SUBS     R2,R1,R0
   \   0000000C   0x2A01             CMP      R2,#+1
   \   0000000E   0xDA01             BGE      ??mbedtls_x509_get_sig_0
    632                  return( MBEDTLS_ERR_X509_INVALID_SIGNATURE +
    633                          MBEDTLS_ERR_ASN1_OUT_OF_DATA );
   \   00000010   0x....             LDR      R0,??DataTable23  ;; 0xffffdb20
   \   00000012   0xBD76             POP      {R1,R2,R4-R6,PC}
    634          
    635              tag_type = **p;
   \                     ??mbedtls_x509_get_sig_0: (+1)
   \   00000014   0x7806             LDRB     R6,[R0, #+0]
    636          
    637              if( ( ret = mbedtls_asn1_get_bitstring_null( p, end, &len ) ) != 0 )
   \   00000016   0x466A             MOV      R2,SP
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       mbedtls_asn1_get_bitstring_null
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD002             BEQ      ??mbedtls_x509_get_sig_1
    638                  return( MBEDTLS_ERR_X509_INVALID_SIGNATURE + ret );
   \   00000022   0x....             LDR      R1,??DataTable23_1  ;; 0xffffdb80
   \   00000024   0x1840             ADDS     R0,R0,R1
   \   00000026   0xBD76             POP      {R1,R2,R4-R6,PC}
    639          
    640              sig->tag = tag_type;
   \                     ??mbedtls_x509_get_sig_1: (+1)
   \   00000028   0x6026             STR      R6,[R4, #+0]
    641              sig->len = len;
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x6060             STR      R0,[R4, #+4]
    642              sig->p = *p;
   \   0000002E   0x6828             LDR      R0,[R5, #+0]
   \   00000030   0x60A0             STR      R0,[R4, #+8]
    643          
    644              *p += len;
   \   00000032   0x6828             LDR      R0,[R5, #+0]
   \   00000034   0x9900             LDR      R1,[SP, #+0]
   \   00000036   0x1840             ADDS     R0,R0,R1
   \   00000038   0x6028             STR      R0,[R5, #+0]
    645          
    646              return( 0 );
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    647          }
    648          
    649          /*
    650           * Get signature algorithm from alg OID and optional parameters
    651           */

   \                                 In section .text, align 2, keep-with-next
    652          int mbedtls_x509_get_sig_alg( const mbedtls_x509_buf *sig_oid, const mbedtls_x509_buf *sig_params,
    653                                mbedtls_md_type_t *md_alg, mbedtls_pk_type_t *pk_alg,
    654                                void **sig_opts )
    655          {
   \                     mbedtls_x509_get_sig_alg: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
   \   00000004   0x0011             MOVS     R1,R2
   \   00000006   0x001A             MOVS     R2,R3
    656              int ret;
    657          
    658              if( *sig_opts != NULL )
   \   00000008   0x9B02             LDR      R3,[SP, #+8]
   \   0000000A   0x681B             LDR      R3,[R3, #+0]
   \   0000000C   0x2B00             CMP      R3,#+0
   \   0000000E   0xD001             BEQ      ??mbedtls_x509_get_sig_alg_0
    659                  return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
   \   00000010   0x....             LDR      R0,??DataTable23_2  ;; 0xffffd800
   \   00000012   0xBD10             POP      {R4,PC}
    660          
    661              if( ( ret = mbedtls_oid_get_sig_alg( sig_oid, md_alg, pk_alg ) ) != 0 )
   \                     ??mbedtls_x509_get_sig_alg_0: (+1)
   \   00000014   0x.... 0x....      BL       mbedtls_oid_get_sig_alg
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD002             BEQ      ??mbedtls_x509_get_sig_alg_1
    662                  return( MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG + ret );
   \   0000001C   0x....             LDR      R1,??DataTable23_3  ;; 0xffffda00
   \   0000001E   0x1840             ADDS     R0,R0,R1
   \   00000020   0xBD10             POP      {R4,PC}
    663          
    664          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
    665              if( *pk_alg == MBEDTLS_PK_RSASSA_PSS )
    666              {
    667                  mbedtls_pk_rsassa_pss_options *pss_opts;
    668          
    669                  pss_opts = mbedtls_calloc( 1, sizeof( mbedtls_pk_rsassa_pss_options ) );
    670                  if( pss_opts == NULL )
    671                      return( MBEDTLS_ERR_X509_ALLOC_FAILED );
    672          
    673                  ret = mbedtls_x509_get_rsassa_pss_params( sig_params,
    674                                                    md_alg,
    675                                                    &pss_opts->mgf1_hash_id,
    676                                                    &pss_opts->expected_salt_len );
    677                  if( ret != 0 )
    678                  {
    679                      mbedtls_free( pss_opts );
    680                      return( ret );
    681                  }
    682          
    683                  *sig_opts = (void *) pss_opts;
    684              }
    685              else
    686          #endif /* MBEDTLS_X509_RSASSA_PSS_SUPPORT */
    687              {
    688                  /* Make sure parameters are absent or NULL */
    689                  if( ( sig_params->tag != MBEDTLS_ASN1_NULL && sig_params->tag != 0 ) ||
    690                        sig_params->len != 0 )
   \                     ??mbedtls_x509_get_sig_alg_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x2805             CMP      R0,#+5
   \   00000026   0xD001             BEQ      ??mbedtls_x509_get_sig_alg_2
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD102             BNE      ??mbedtls_x509_get_sig_alg_3
   \                     ??mbedtls_x509_get_sig_alg_2: (+1)
   \   0000002C   0x6860             LDR      R0,[R4, #+4]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD000             BEQ      ??mbedtls_x509_get_sig_alg_4
    691                  return( MBEDTLS_ERR_X509_INVALID_ALG );
   \                     ??mbedtls_x509_get_sig_alg_3: (+1)
   \   00000032   0x....             LDR      R0,??DataTable23_4  ;; 0xffffdd00
    692              }
    693          
    694              return( 0 );
   \                     ??mbedtls_x509_get_sig_alg_4: (+1)
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    695          }
    696          
    697          /*
    698           * X.509 Extensions (No parsing of extensions, pointer should
    699           * be either manually updated or extensions should be parsed!)
    700           */

   \                                 In section .text, align 2, keep-with-next
    701          int mbedtls_x509_get_ext( unsigned char **p, const unsigned char *end,
    702                            mbedtls_x509_buf *ext, int tag )
    703          {
   \                     mbedtls_x509_get_ext: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x0015             MOVS     R5,R2
    704              int ret;
    705              size_t len;
    706          
    707              if( *p == end )
   \   00000008   0x6830             LDR      R0,[R6, #+0]
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD021             BEQ      ??mbedtls_x509_get_ext_0
    708                  return( 0 );
    709          
    710              ext->tag = **p;
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x6028             STR      R0,[R5, #+0]
    711          
    712              if( ( ret = mbedtls_asn1_get_tag( p, end, &ext->len,
    713                      MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | tag ) ) != 0 )
   \   00000012   0x20A0             MOVS     R0,#+160
   \   00000014   0x4318             ORRS     R0,R0,R3
   \   00000016   0x0003             MOVS     R3,R0
   \   00000018   0x1D2A             ADDS     R2,R5,#+4
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD117             BNE      ??mbedtls_x509_get_ext_1
    714                  return( ret );
    715          
    716              ext->p = *p;
   \   00000024   0x6830             LDR      R0,[R6, #+0]
   \   00000026   0x60A8             STR      R0,[R5, #+8]
    717              end = *p + ext->len;
   \   00000028   0x6830             LDR      R0,[R6, #+0]
   \   0000002A   0x6869             LDR      R1,[R5, #+4]
   \   0000002C   0x1844             ADDS     R4,R0,R1
    718          
    719              /*
    720               * Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension
    721               *
    722               * Extension  ::=  SEQUENCE  {
    723               *      extnID      OBJECT IDENTIFIER,
    724               *      critical    BOOLEAN DEFAULT FALSE,
    725               *      extnValue   OCTET STRING  }
    726               */
    727              if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
    728                      MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
   \   0000002E   0x2330             MOVS     R3,#+48
   \   00000030   0x466A             MOV      R2,SP
   \   00000032   0x0021             MOVS     R1,R4
   \   00000034   0x0030             MOVS     R0,R6
   \   00000036   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD002             BEQ      ??mbedtls_x509_get_ext_2
    729                  return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
   \   0000003E   0x....             LDR      R1,??DataTable23_5  ;; 0xffffdb00
   \   00000040   0x1840             ADDS     R0,R0,R1
   \   00000042   0xBD76             POP      {R1,R2,R4-R6,PC}
    730          
    731              if( end != *p + len )
   \                     ??mbedtls_x509_get_ext_2: (+1)
   \   00000044   0x6830             LDR      R0,[R6, #+0]
   \   00000046   0x9900             LDR      R1,[SP, #+0]
   \   00000048   0x1840             ADDS     R0,R0,R1
   \   0000004A   0x4284             CMP      R4,R0
   \   0000004C   0xD001             BEQ      ??mbedtls_x509_get_ext_0
    732                  return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
    733                          MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
   \   0000004E   0x....             LDR      R0,??DataTable23_6  ;; 0xffffda9a
   \   00000050   0xBD76             POP      {R1,R2,R4-R6,PC}
    734          
    735              return( 0 );
   \                     ??mbedtls_x509_get_ext_0: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_x509_get_ext_1: (+1)
   \   00000054   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    736          }
    737          
    738          /*
    739           * Store the name in printable form into buf; no more
    740           * than size characters will be written
    741           */

   \                                 In section .text, align 2, keep-with-next
    742          int mbedtls_x509_dn_gets( char *buf, size_t size, const mbedtls_x509_name *dn )
    743          {
   \                     mbedtls_x509_dn_gets: (+1)
   \   00000000   0xB5F6             PUSH     {R1,R2,R4-R7,LR}
   \   00000002   0xB0C1             SUB      SP,SP,#+260
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x2700             MOVS     R7,#+0
    744              int ret;
    745              size_t i, n;
    746              unsigned char c, merge = 0;
    747              const mbedtls_x509_name *name;
    748              const char *short_name = NULL;
   \   00000008   0x9700             STR      R7,[SP, #+0]
    749              char s[MBEDTLS_X509_MAX_DN_NAME_SIZE], *p;
    750          
    751              memset( s, 0, sizeof( s ) );
   \   0000000A   0x2180             MOVS     R1,#+128
   \   0000000C   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       __aeabi_memclr4
    752          
    753              name = dn;
   \   00000014   0x9E42             LDR      R6,[SP, #+264]
    754              p = buf;
    755              n = size;
   \   00000016   0x9C41             LDR      R4,[SP, #+260]
   \   00000018   0xE000             B        ??mbedtls_x509_dn_gets_0
    756          
    757              while( name != NULL )
    758              {
    759                  if( !name->oid.p )
    760                  {
    761                      name = name->next;
   \                     ??mbedtls_x509_dn_gets_1: (+1)
   \   0000001A   0x69B6             LDR      R6,[R6, #+24]
    762                      continue;
    763                  }
   \                     ??mbedtls_x509_dn_gets_0: (+1)
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD056             BEQ      ??mbedtls_x509_dn_gets_2
   \   00000020   0x68B0             LDR      R0,[R6, #+8]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD0F9             BEQ      ??mbedtls_x509_dn_gets_1
    764          
    765                  if( name != dn )
   \   00000026   0x9842             LDR      R0,[SP, #+264]
   \   00000028   0x4286             CMP      R6,R0
   \   0000002A   0xD00E             BEQ      ??mbedtls_x509_dn_gets_3
    766                  {
    767                      ret = mbedtls_snprintf( p, n, merge ? " + " : ", " );
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD001             BEQ      ??mbedtls_x509_dn_gets_4
   \   00000030   0x....             ADR      R2,??DataTable23_7  ;; " + "
   \   00000032   0xE000             B        ??mbedtls_x509_dn_gets_5
   \                     ??mbedtls_x509_dn_gets_4: (+1)
   \   00000034   0x....             ADR      R2,??DataTable23_8  ;; 0x2C, 0x20, 0x00, 0x00
   \                     ??mbedtls_x509_dn_gets_5: (+1)
   \   00000036   0x0021             MOVS     R1,R4
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0x.... 0x....      BL       snprintf
    768                      MBEDTLS_X509_SAFE_SNPRINTF;
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD43F             BMI      ??mbedtls_x509_dn_gets_6
   \   00000042   0x42A0             CMP      R0,R4
   \   00000044   0xD23D             BCS      ??mbedtls_x509_dn_gets_6
   \   00000046   0x1A24             SUBS     R4,R4,R0
   \   00000048   0x182D             ADDS     R5,R5,R0
    769                  }
    770          
    771                  ret = mbedtls_oid_get_attr_short_name( &name->oid, &short_name );
    772          
    773                  if( ret == 0 )
   \                     ??mbedtls_x509_dn_gets_3: (+1)
   \   0000004A   0x4669             MOV      R1,SP
   \   0000004C   0x0030             MOVS     R0,R6
   \   0000004E   0x.... 0x....      BL       mbedtls_oid_get_attr_short_name
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD106             BNE      ??mbedtls_x509_dn_gets_7
    774                      ret = mbedtls_snprintf( p, n, "%s=", short_name );
   \   00000056   0x9B00             LDR      R3,[SP, #+0]
   \   00000058   0x....             ADR      R2,??DataTable23_9  ;; "%s="
   \   0000005A   0x0021             MOVS     R1,R4
   \   0000005C   0x0028             MOVS     R0,R5
   \   0000005E   0x.... 0x....      BL       snprintf
   \   00000062   0xE004             B        ??mbedtls_x509_dn_gets_8
    775                  else
    776                      ret = mbedtls_snprintf( p, n, "\?\?=" );
   \                     ??mbedtls_x509_dn_gets_7: (+1)
   \   00000064   0x....             ADR      R2,??DataTable23_10  ;; "\?\?="
   \   00000066   0x0021             MOVS     R1,R4
   \   00000068   0x0028             MOVS     R0,R5
   \   0000006A   0x.... 0x....      BL       snprintf
    777                  MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??mbedtls_x509_dn_gets_8: (+1)
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD427             BMI      ??mbedtls_x509_dn_gets_6
   \   00000072   0x42A0             CMP      R0,R4
   \   00000074   0xD225             BCS      ??mbedtls_x509_dn_gets_6
   \   00000076   0x1A24             SUBS     R4,R4,R0
   \   00000078   0x182D             ADDS     R5,R5,R0
    778          
    779                  for( i = 0; i < name->val.len; i++ )
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xA901             ADD      R1,SP,#+4
   \   0000007E   0xE002             B        ??mbedtls_x509_dn_gets_9
    780                  {
    781                      if( i >= sizeof( s ) - 1 )
    782                          break;
    783          
    784                      c = name->val.p[i];
    785                      if( c < 32 || c == 127 || ( c > 128 && c < 160 ) )
    786                           s[i] = '?';
    787                      else s[i] = c;
   \                     ??mbedtls_x509_dn_gets_10: (+1)
   \   00000080   0x700A             STRB     R2,[R1, #+0]
   \   00000082   0x1C40             ADDS     R0,R0,#+1
   \   00000084   0x1C49             ADDS     R1,R1,#+1
   \                     ??mbedtls_x509_dn_gets_9: (+1)
   \   00000086   0x6932             LDR      R2,[R6, #+16]
   \   00000088   0x4290             CMP      R0,R2
   \   0000008A   0xD20D             BCS      ??mbedtls_x509_dn_gets_11
   \   0000008C   0x28FF             CMP      R0,#+255
   \   0000008E   0xD20B             BCS      ??mbedtls_x509_dn_gets_11
   \   00000090   0x6972             LDR      R2,[R6, #+20]
   \   00000092   0x5C12             LDRB     R2,[R2, R0]
   \   00000094   0x2A20             CMP      R2,#+32
   \   00000096   0xDB05             BLT      ??mbedtls_x509_dn_gets_12
   \   00000098   0x2A7F             CMP      R2,#+127
   \   0000009A   0xD003             BEQ      ??mbedtls_x509_dn_gets_12
   \   0000009C   0x0013             MOVS     R3,R2
   \   0000009E   0x3B81             SUBS     R3,R3,#+129
   \   000000A0   0x2B1F             CMP      R3,#+31
   \   000000A2   0xD2ED             BCS      ??mbedtls_x509_dn_gets_10
   \                     ??mbedtls_x509_dn_gets_12: (+1)
   \   000000A4   0x223F             MOVS     R2,#+63
   \   000000A6   0xE7EB             B        ??mbedtls_x509_dn_gets_10
    788                  }
    789                  s[i] = '\0';
   \                     ??mbedtls_x509_dn_gets_11: (+1)
   \   000000A8   0x2100             MOVS     R1,#+0
   \   000000AA   0xAA01             ADD      R2,SP,#+4
   \   000000AC   0x5411             STRB     R1,[R2, R0]
    790                  ret = mbedtls_snprintf( p, n, "%s", s );
   \   000000AE   0xAB01             ADD      R3,SP,#+4
   \   000000B0   0x....             ADR      R2,??DataTable23_11  ;; 0x25, 0x73, 0x00, 0x00
   \   000000B2   0x0021             MOVS     R1,R4
   \   000000B4   0x0028             MOVS     R0,R5
   \   000000B6   0x.... 0x....      BL       snprintf
    791                  MBEDTLS_X509_SAFE_SNPRINTF;
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD401             BMI      ??mbedtls_x509_dn_gets_6
   \   000000BE   0x42A0             CMP      R0,R4
   \   000000C0   0xD301             BCC      ??mbedtls_x509_dn_gets_13
   \                     ??mbedtls_x509_dn_gets_6: (+1)
   \   000000C2   0x....             LDR      R0,??DataTable23_12  ;; 0xffffd680
   \   000000C4   0xE005             B        ??mbedtls_x509_dn_gets_14
   \                     ??mbedtls_x509_dn_gets_13: (+1)
   \   000000C6   0x1A24             SUBS     R4,R4,R0
   \   000000C8   0x182D             ADDS     R5,R5,R0
    792          
    793                  merge = name->next_merged;
   \   000000CA   0x7F37             LDRB     R7,[R6, #+28]
    794                  name = name->next;
   \   000000CC   0xE7A5             B        ??mbedtls_x509_dn_gets_1
    795              }
    796          
    797              return( (int) ( size - n ) );
   \                     ??mbedtls_x509_dn_gets_2: (+1)
   \   000000CE   0x9841             LDR      R0,[SP, #+260]
   \   000000D0   0x1B00             SUBS     R0,R0,R4
   \                     ??mbedtls_x509_dn_gets_14: (+1)
   \   000000D2   0xB043             ADD      SP,SP,#+268
   \   000000D4   0xBDF0             POP      {R4-R7,PC}       ;; return
    798          }
    799          
    800          /*
    801           * Store the serial in printable form into buf; no more
    802           * than size characters will be written
    803           */

   \                                 In section .text, align 4, keep-with-next
    804          int mbedtls_x509_serial_gets( char *buf, size_t size, const mbedtls_x509_buf *serial )
    805          {
   \                     mbedtls_x509_serial_gets: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0017             MOVS     R7,R2
    806              int ret;
    807              size_t i, n, nr;
    808              char *p;
    809          
    810              p = buf;
   \   00000006   0x9001             STR      R0,[SP, #+4]
    811              n = size;
   \   00000008   0x9C02             LDR      R4,[SP, #+8]
    812          
    813              nr = ( serial->len <= 32 )
    814                  ? serial->len  : 28;
   \   0000000A   0x687E             LDR      R6,[R7, #+4]
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0x2E21             CMP      R6,#+33
   \   00000010   0xD202             BCS      ??mbedtls_x509_serial_gets_0
    815          
    816              for( i = 0; i < nr; i++ )
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD104             BNE      ??mbedtls_x509_serial_gets_1
   \   00000016   0xE023             B        ??mbedtls_x509_serial_gets_2
   \                     ??mbedtls_x509_serial_gets_0: (+1)
   \   00000018   0x261C             MOVS     R6,#+28
   \   0000001A   0xE001             B        ??mbedtls_x509_serial_gets_1
    817              {
    818                  if( i == 0 && nr > 1 && serial->p[i] == 0x0 )
   \                     ??mbedtls_x509_serial_gets_3: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD105             BNE      ??mbedtls_x509_serial_gets_4
   \                     ??mbedtls_x509_serial_gets_1: (+1)
   \   00000020   0x2E02             CMP      R6,#+2
   \   00000022   0xD303             BCC      ??mbedtls_x509_serial_gets_4
   \   00000024   0x68B8             LDR      R0,[R7, #+8]
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD016             BEQ      ??mbedtls_x509_serial_gets_5
    819                      continue;
    820          
    821                  ret = mbedtls_snprintf( p, n, "%02X%s",
    822                          serial->p[i], ( i < nr - 1 ) ? ":" : "" );
   \                     ??mbedtls_x509_serial_gets_4: (+1)
   \   0000002C   0x1E70             SUBS     R0,R6,#+1
   \   0000002E   0x4285             CMP      R5,R0
   \   00000030   0xD201             BCS      ??mbedtls_x509_serial_gets_6
   \   00000032   0x....             ADR      R0,??DataTable23_13  ;; ":"
   \   00000034   0xE000             B        ??mbedtls_x509_serial_gets_7
   \                     ??mbedtls_x509_serial_gets_6: (+1)
   \   00000036   0x....             ADR      R0,??DataTable23_14  ;; ""
   \                     ??mbedtls_x509_serial_gets_7: (+1)
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0x68B8             LDR      R0,[R7, #+8]
   \   0000003C   0x5D43             LDRB     R3,[R0, R5]
   \   0000003E   0xBF00             Nop      
   \   00000040   0x....             ADR.N    R2,?_5
   \   00000042   0x0021             MOVS     R1,R4
   \   00000044   0x9801             LDR      R0,[SP, #+4]
   \   00000046   0x.... 0x....      BL       snprintf
    823                  MBEDTLS_X509_SAFE_SNPRINTF;
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD415             BMI      ??mbedtls_x509_serial_gets_8
   \   0000004E   0x42A0             CMP      R0,R4
   \   00000050   0xD213             BCS      ??mbedtls_x509_serial_gets_8
   \   00000052   0x1A24             SUBS     R4,R4,R0
   \   00000054   0x9901             LDR      R1,[SP, #+4]
   \   00000056   0x1808             ADDS     R0,R1,R0
   \   00000058   0x9001             STR      R0,[SP, #+4]
    824              }
   \                     ??mbedtls_x509_serial_gets_5: (+1)
   \   0000005A   0x1C6D             ADDS     R5,R5,#+1
   \   0000005C   0x42B5             CMP      R5,R6
   \   0000005E   0xD3DD             BCC      ??mbedtls_x509_serial_gets_3
    825          
    826              if( nr != serial->len )
   \                     ??mbedtls_x509_serial_gets_2: (+1)
   \   00000060   0x6878             LDR      R0,[R7, #+4]
   \   00000062   0x4286             CMP      R6,R0
   \   00000064   0xD00C             BEQ      ??mbedtls_x509_serial_gets_9
    827              {
    828                  ret = mbedtls_snprintf( p, n, "...." );
   \   00000066   0xBF00             Nop      
   \   00000068   0x....             ADR.N    R2,?_8
   \   0000006A   0x0021             MOVS     R1,R4
   \   0000006C   0x9801             LDR      R0,[SP, #+4]
   \   0000006E   0x.... 0x....      BL       snprintf
    829                  MBEDTLS_X509_SAFE_SNPRINTF;
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD401             BMI      ??mbedtls_x509_serial_gets_8
   \   00000076   0x42A0             CMP      R0,R4
   \   00000078   0xD301             BCC      ??mbedtls_x509_serial_gets_10
   \                     ??mbedtls_x509_serial_gets_8: (+1)
   \   0000007A   0x....             LDR      R0,??DataTable23_12  ;; 0xffffd680
   \   0000007C   0xE002             B        ??mbedtls_x509_serial_gets_11
   \                     ??mbedtls_x509_serial_gets_10: (+1)
   \   0000007E   0x1A24             SUBS     R4,R4,R0
    830              }
    831          
    832              return( (int) ( size - n ) );
   \                     ??mbedtls_x509_serial_gets_9: (+1)
   \   00000080   0x9802             LDR      R0,[SP, #+8]
   \   00000082   0x1B00             SUBS     R0,R0,R4
   \                     ??mbedtls_x509_serial_gets_11: (+1)
   \   00000084   0xB003             ADD      SP,SP,#+12
   \   00000086   0xBDF0             POP      {R4-R7,PC}       ;; return
    833          }
    834          
    835          /*
    836           * Helper for writing signature algorithms
    837           */

   \                                 In section .text, align 2, keep-with-next
    838          int mbedtls_x509_sig_alg_gets( char *buf, size_t size, const mbedtls_x509_buf *sig_oid,
    839                                 mbedtls_pk_type_t pk_alg, mbedtls_md_type_t md_alg,
    840                                 const void *sig_opts )
    841          {
   \                     mbedtls_x509_sig_alg_gets: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    842              int ret;
    843              char *p = buf;
    844              size_t n = size;
    845              const char *desc = NULL;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    846          
    847              ret = mbedtls_oid_get_sig_alg_desc( sig_oid, &desc );
    848              if( ret != 0 )
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x0010             MOVS     R0,R2
   \   0000000E   0x.... 0x....      BL       mbedtls_oid_get_sig_alg_desc
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD005             BEQ      ??mbedtls_x509_sig_alg_gets_0
    849                  ret = mbedtls_snprintf( p, n, "???"  );
   \   00000016   0x....             ADR      R2,??DataTable23_15  ;; "\?\?\?"
   \   00000018   0x0021             MOVS     R1,R4
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0x.... 0x....      BL       snprintf
   \   00000020   0xE005             B        ??mbedtls_x509_sig_alg_gets_1
    850              else
    851                  ret = mbedtls_snprintf( p, n, "%s", desc );
   \                     ??mbedtls_x509_sig_alg_gets_0: (+1)
   \   00000022   0x9B00             LDR      R3,[SP, #+0]
   \   00000024   0x....             ADR      R2,??DataTable23_11  ;; 0x25, 0x73, 0x00, 0x00
   \   00000026   0x0021             MOVS     R1,R4
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0x.... 0x....      BL       snprintf
    852              MBEDTLS_X509_SAFE_SNPRINTF;
   \                     ??mbedtls_x509_sig_alg_gets_1: (+1)
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD401             BMI      ??mbedtls_x509_sig_alg_gets_2
   \   00000032   0x42A0             CMP      R0,R4
   \   00000034   0xD300             BCC      ??mbedtls_x509_sig_alg_gets_3
   \                     ??mbedtls_x509_sig_alg_gets_2: (+1)
   \   00000036   0x....             LDR      R0,??DataTable23_12  ;; 0xffffd680
    853          
    854          #if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
    855              if( pk_alg == MBEDTLS_PK_RSASSA_PSS )
    856              {
    857                  const mbedtls_pk_rsassa_pss_options *pss_opts;
    858                  const mbedtls_md_info_t *md_info, *mgf_md_info;
    859          
    860                  pss_opts = (const mbedtls_pk_rsassa_pss_options *) sig_opts;
    861          
    862                  md_info = mbedtls_md_info_from_type( md_alg );
    863                  mgf_md_info = mbedtls_md_info_from_type( pss_opts->mgf1_hash_id );
    864          
    865                  ret = mbedtls_snprintf( p, n, " (%s, MGF1-%s, 0x%02X)",
    866                                        md_info ? mbedtls_md_get_name( md_info ) : "???",
    867                                        mgf_md_info ? mbedtls_md_get_name( mgf_md_info ) : "???",
    868                                        pss_opts->expected_salt_len );
    869                  MBEDTLS_X509_SAFE_SNPRINTF;
    870              }
    871          #else
    872              ((void) pk_alg);
    873              ((void) md_alg);
    874              ((void) sig_opts);
    875          #endif /* MBEDTLS_X509_RSASSA_PSS_SUPPORT */
    876          
    877              return( (int)( size - n ) );
   \                     ??mbedtls_x509_sig_alg_gets_3: (+1)
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    878          }
    879          
    880          /*
    881           * Helper for writing "RSA key size", "EC key size", etc
    882           */

   \                                 In section .text, align 4, keep-with-next
    883          int mbedtls_x509_key_size_helper( char *buf, size_t buf_size, const char *name )
    884          {
   \                     mbedtls_x509_key_size_helper: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
    885              char *p = buf;
    886              size_t n = buf_size;
    887              int ret;
    888          
    889              ret = mbedtls_snprintf( p, n, "%s key size", name );
   \   00000004   0x0013             MOVS     R3,R2
   \   00000006   0xBF00             Nop      
   \   00000008   0x....             ADR.N    R2,?_10
   \   0000000A   0x.... 0x....      BL       snprintf
    890              MBEDTLS_X509_SAFE_SNPRINTF;
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD401             BMI      ??mbedtls_x509_key_size_helper_0
   \   00000012   0x42A0             CMP      R0,R4
   \   00000014   0xD301             BCC      ??mbedtls_x509_key_size_helper_1
   \                     ??mbedtls_x509_key_size_helper_0: (+1)
   \   00000016   0x....             LDR      R0,??DataTable23_12  ;; 0xffffd680
   \   00000018   0xBD10             POP      {R4,PC}
    891          
    892              return( 0 );
   \                     ??mbedtls_x509_key_size_helper_1: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    893          }
    894          
    895          #if defined(MBEDTLS_HAVE_TIME_DATE)
    896          /*
    897           * Set the time structure to the current time.
    898           * Return 0 on success, non-zero on failure.
    899           */
    900          #if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)
    901          static int x509_get_current_time( mbedtls_x509_time *now )
    902          {
    903              SYSTEMTIME st;
    904          
    905              GetSystemTime( &st );
    906          
    907              now->year = st.wYear;
    908              now->mon  = st.wMonth;
    909              now->day  = st.wDay;
    910              now->hour = st.wHour;
    911              now->min  = st.wMinute;
    912              now->sec  = st.wSecond;
    913          
    914              return( 0 );
    915          }
    916          #else
    917          static int x509_get_current_time( mbedtls_x509_time *now )
    918          {
    919              struct tm *lt;
    920              mbedtls_time_t tt;
    921              int ret = 0;
    922          
    923          #if defined(MBEDTLS_THREADING_C)
    924              if( mbedtls_mutex_lock( &mbedtls_threading_gmtime_mutex ) != 0 )
    925                  return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
    926          #endif
    927          
    928              tt = mbedtls_time( NULL );
    929              lt = gmtime( &tt );
    930          
    931              if( lt == NULL )
    932                  ret = -1;
    933              else
    934              {
    935                  now->year = lt->tm_year + 1900;
    936                  now->mon  = lt->tm_mon  + 1;
    937                  now->day  = lt->tm_mday;
    938                  now->hour = lt->tm_hour;
    939                  now->min  = lt->tm_min;
    940                  now->sec  = lt->tm_sec;
    941              }
    942          
    943          #if defined(MBEDTLS_THREADING_C)
    944              if( mbedtls_mutex_unlock( &mbedtls_threading_gmtime_mutex ) != 0 )
    945                  return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
    946          #endif
    947          
    948              return( ret );
    949          }
    950          #endif /* _WIN32 && !EFIX64 && !EFI32 */
    951          
    952          /*
    953           * Return 0 if before <= after, 1 otherwise
    954           */
    955          static int x509_check_time( const mbedtls_x509_time *before, const mbedtls_x509_time *after )
    956          {
    957              if( before->year  > after->year )
    958                  return( 1 );
    959          
    960              if( before->year == after->year &&
    961                  before->mon   > after->mon )
    962                  return( 1 );
    963          
    964              if( before->year == after->year &&
    965                  before->mon  == after->mon  &&
    966                  before->day   > after->day )
    967                  return( 1 );
    968          
    969              if( before->year == after->year &&
    970                  before->mon  == after->mon  &&
    971                  before->day  == after->day  &&
    972                  before->hour  > after->hour )
    973                  return( 1 );
    974          
    975              if( before->year == after->year &&
    976                  before->mon  == after->mon  &&
    977                  before->day  == after->day  &&
    978                  before->hour == after->hour &&
    979                  before->min   > after->min  )
    980                  return( 1 );
    981          
    982              if( before->year == after->year &&
    983                  before->mon  == after->mon  &&
    984                  before->day  == after->day  &&
    985                  before->hour == after->hour &&
    986                  before->min  == after->min  &&
    987                  before->sec   > after->sec  )
    988                  return( 1 );
    989          
    990              return( 0 );
    991          }
    992          
    993          int mbedtls_x509_time_is_past( const mbedtls_x509_time *to )
    994          {
    995              mbedtls_x509_time now;
    996          
    997              if( x509_get_current_time( &now ) != 0 )
    998                  return( 1 );
    999          
   1000              return( x509_check_time( &now, to ) );
   1001          }
   1002          
   1003          int mbedtls_x509_time_is_future( const mbedtls_x509_time *from )
   1004          {
   1005              mbedtls_x509_time now;
   1006          
   1007              if( x509_get_current_time( &now ) != 0 )
   1008                  return( 1 );
   1009          
   1010              return( x509_check_time( from, &now ) );
   1011          }
   1012          
   1013          #else  /* MBEDTLS_HAVE_TIME_DATE */
   1014          

   \                                 In section .text, align 2, keep-with-next
   1015          int mbedtls_x509_time_is_past( const mbedtls_x509_time *to )
   1016          {
   1017              ((void) to);
   1018              return( 0 );
   \                     mbedtls_x509_time_is_past: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
   1019          }
   1020          

   \                                 In section .text, align 2, keep-with-next
   1021          int mbedtls_x509_time_is_future( const mbedtls_x509_time *from )
   1022          {
   1023              ((void) from);
   1024              return( 0 );
   \                     mbedtls_x509_time_is_future: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
   1025          }
   1026          #endif /* MBEDTLS_HAVE_TIME_DATE */
   1027          
   1028          #if defined(MBEDTLS_SELF_TEST)
   1029          
   1030          #include "mbedtls/x509_crt.h"
   1031          #include "mbedtls/certs.h"
   1032          
   1033          /*
   1034           * Checkup routine
   1035           */

   \                                 In section .text, align 2, keep-with-next
   1036          int mbedtls_x509_self_test( int verbose )
   1037          {
   1038          #if defined(MBEDTLS_CERTS_C) && defined(MBEDTLS_SHA256_C)
   1039              int ret;
   1040              uint32_t flags;
   1041              mbedtls_x509_crt cacert;
   1042              mbedtls_x509_crt clicert;
   1043          
   1044              if( verbose != 0 )
   1045                  mbedtls_printf( "  X.509 certificate load: " );
   1046          
   1047              mbedtls_x509_crt_init( &clicert );
   1048          
   1049              ret = mbedtls_x509_crt_parse( &clicert, (const unsigned char *) mbedtls_test_cli_crt,
   1050                                     mbedtls_test_cli_crt_len );
   1051              if( ret != 0 )
   1052              {
   1053                  if( verbose != 0 )
   1054                      mbedtls_printf( "failed\n" );
   1055          
   1056                  return( ret );
   1057              }
   1058          
   1059              mbedtls_x509_crt_init( &cacert );
   1060          
   1061              ret = mbedtls_x509_crt_parse( &cacert, (const unsigned char *) mbedtls_test_ca_crt,
   1062                                    mbedtls_test_ca_crt_len );
   1063              if( ret != 0 )
   1064              {
   1065                  if( verbose != 0 )
   1066                      mbedtls_printf( "failed\n" );
   1067          
   1068                  return( ret );
   1069              }
   1070          
   1071              if( verbose != 0 )
   1072                  mbedtls_printf( "passed\n  X.509 signature verify: ");
   1073          
   1074              ret = mbedtls_x509_crt_verify( &clicert, &cacert, NULL, NULL, &flags, NULL, NULL );
   1075              if( ret != 0 )
   1076              {
   1077                  if( verbose != 0 )
   1078                      mbedtls_printf( "failed\n" );
   1079          
   1080                  return( ret );
   1081              }
   1082          
   1083              if( verbose != 0 )
   1084                  mbedtls_printf( "passed\n\n");
   1085          
   1086              mbedtls_x509_crt_free( &cacert  );
   1087              mbedtls_x509_crt_free( &clicert );
   1088          
   1089              return( 0 );
   1090          #else
   1091              ((void) verbose);
   1092              return( 0 );
   \                     mbedtls_x509_self_test: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
   1093          #endif /* MBEDTLS_CERTS_C && MBEDTLS_SHA1_C */
   1094          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0xFFFFDD20         DC32     0xffffdd20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0xFFFFDD1E         DC32     0xffffdd1e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0xFFFFDD80         DC32     0xffffdd80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0xFFFFDD00         DC32     0xffffdd00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0xFFFFDC20         DC32     0xffffdc20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0xFFFFDC1E         DC32     0xffffdc1e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0xFFFFDC80         DC32     0xffffdc80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0xFFFFD780         DC32     0xffffd780

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0xFFFFDC00         DC32     0xffffdc00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x0000076C         DC32     0x76c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0xFFFFDBA0         DC32     0xffffdba0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0xFFFFDB9E         DC32     0xffffdb9e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0xFFFFDB20         DC32     0xffffdb20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0xFFFFDB80         DC32     0xffffdb80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   0xFFFFD800         DC32     0xffffd800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \   00000000   0xFFFFDA00         DC32     0xffffda00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \   00000000   0xFFFFDD00         DC32     0xffffdd00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \   00000000   0xFFFFDB00         DC32     0xffffdb00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_6:
   \   00000000   0xFFFFDA9A         DC32     0xffffda9a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_7:
   \   00000000   0x20 0x2B          DC8      " + "
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_8:
   \   00000000   0x2C 0x20          DC8      0x2C, 0x20, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_9:
   \   00000000   0x25 0x73          DC8      "%s="
   \              0x3D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_10:
   \   00000000   0x3F 0x3F          DC8      "\?\?="
   \              0x3D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_11:
   \   00000000   0x25 0x73          DC8      0x25, 0x73, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_12:
   \   00000000   0xFFFFD680         DC32     0xffffd680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_13:
   \   00000000   0x3A 0x00          DC8      ":",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_14:
   \   00000000   0x00 0x00          DC8      "",0x0,0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_15:
   \   00000000   0x3F 0x3F          DC8      "\?\?\?"
   \              0x3F 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x20 0x2B          DC8 " + "
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x25 0x30          DC8 "%02X%s"
   \              0x32 0x58    
   \              0x25 0x73    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x2C 0x20          DC8 ", "
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x25 0x73          DC8 "%s="
   \              0x3D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x2E 0x2E          DC8 "...."
   \              0x2E 0x2E    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x25 0x73          DC8 "%s key size"
   \              0x20 0x6B    
   \              0x65 0x79    
   \              0x20 0x73    
   \              0x69 0x7A    
   \              0x65 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x3F 0x3F          DC8 "??="
   \              0x3D 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x25 0x73          DC8 "%s"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_6:
   \   00000000   0x3A 0x00          DC8 ":"

   \                                 In section .rodata, align 1, keep-with-next
   \                     ?_7:
   \   00000000   0x00               DC8 ""

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x3F 0x3F          DC8 "???"
   \              0x3F 0x00    
   1095          
   1096          #endif /* MBEDTLS_SELF_TEST */
   1097          
   1098          #endif /* MBEDTLS_X509_USE_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     288   mbedtls_x509_dn_gets
       288   -> __aeabi_memclr4
       288   -> mbedtls_oid_get_attr_short_name
       288   -> snprintf
       8   mbedtls_x509_get_alg
         8   -> mbedtls_asn1_get_alg
       8   mbedtls_x509_get_alg_null
         8   -> mbedtls_asn1_get_alg_null
      24   mbedtls_x509_get_ext
        24   -> mbedtls_asn1_get_tag
      24   mbedtls_x509_get_name
        24   -> calloc
        24   -> mbedtls_asn1_get_tag
        24   -> x509_get_attr_type_value
      16   mbedtls_x509_get_serial
        16   -> mbedtls_asn1_get_len
      24   mbedtls_x509_get_sig
        24   -> mbedtls_asn1_get_bitstring_null
       8   mbedtls_x509_get_sig_alg
         8   -> mbedtls_oid_get_sig_alg
      24   mbedtls_x509_get_time
        24   -> mbedtls_asn1_get_len
        24   -> x509_parse_time
       8   mbedtls_x509_key_size_helper
         8   -> snprintf
       0   mbedtls_x509_self_test
      32   mbedtls_x509_serial_gets
        32   -> snprintf
      16   mbedtls_x509_sig_alg_gets
        16   -> mbedtls_oid_get_sig_alg_desc
        16   -> snprintf
       0   mbedtls_x509_time_is_future
       0   mbedtls_x509_time_is_past
      24   x509_get_attr_type_value
        24   -> mbedtls_asn1_get_len
        24   -> mbedtls_asn1_get_tag
      16   x509_parse_time


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable17
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable22
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_10
       4  ??DataTable23_11
       4  ??DataTable23_12
       4  ??DataTable23_13
       4  ??DataTable23_14
       4  ??DataTable23_15
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable23_7
       4  ??DataTable23_8
       4  ??DataTable23_9
      10  ?Subroutine0
       4  ?_0
       4  ?_1
      12  ?_10
       4  ?_2
       4  ?_3
       4  ?_4
       8  ?_5
       2  ?_6
       1  ?_7
       8  ?_8
       4  ?_9
     214  mbedtls_x509_dn_gets
       6  mbedtls_x509_get_alg
       8  mbedtls_x509_get_alg_null
      86  mbedtls_x509_get_ext
     106  mbedtls_x509_get_name
      74  mbedtls_x509_get_serial
      62  mbedtls_x509_get_sig
      54  mbedtls_x509_get_sig_alg
      76  mbedtls_x509_get_time
      30  mbedtls_x509_key_size_helper
       4  mbedtls_x509_self_test
     136  mbedtls_x509_serial_gets
      58  mbedtls_x509_sig_alg_gets
       4  mbedtls_x509_time_is_future
       4  mbedtls_x509_time_is_past
     154  x509_get_attr_type_value
     456  x509_parse_time

 
    27 bytes in section .rodata
 1 686 bytes in section .text
 
 1 686 bytes of CODE  memory
    27 bytes of CONST memory

Errors: none
Warnings: none

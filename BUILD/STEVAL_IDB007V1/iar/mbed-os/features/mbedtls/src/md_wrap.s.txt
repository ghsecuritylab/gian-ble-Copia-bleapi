###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:30
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\features\mbedtls\src\md_wrap.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\md_wrap.d -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\md_wrap.s.txt
#        -o .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\md_wrap.o
#        .\mbed-os\features\mbedtls\src\md_wrap.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\md_wrap.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\md_wrap.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\features\mbedtls\src\md_wrap.c
      1          /**
      2           * \file md_wrap.c
      3           *
      4           * \brief Generic message digest wrapper for mbed TLS
      5           *
      6           * \author Adriaan de Jong <dejong@fox-it.com>
      7           *
      8           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      9           *  SPDX-License-Identifier: Apache-2.0
     10           *
     11           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
     12           *  not use this file except in compliance with the License.
     13           *  You may obtain a copy of the License at
     14           *
     15           *  http://www.apache.org/licenses/LICENSE-2.0
     16           *
     17           *  Unless required by applicable law or agreed to in writing, software
     18           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     19           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     20           *  See the License for the specific language governing permissions and
     21           *  limitations under the License.
     22           *
     23           *  This file is part of mbed TLS (https://tls.mbed.org)
     24           */
     25          
     26          #if !defined(MBEDTLS_CONFIG_FILE)
     27          #include "mbedtls/config.h"
     28          #else
     29          #include MBEDTLS_CONFIG_FILE
     30          #endif
     31          
     32          #if defined(MBEDTLS_MD_C)
     33          
     34          #include "mbedtls/md_internal.h"
     35          
     36          #if defined(MBEDTLS_MD2_C)
     37          #include "mbedtls/md2.h"
     38          #endif
     39          
     40          #if defined(MBEDTLS_MD4_C)
     41          #include "mbedtls/md4.h"
     42          #endif
     43          
     44          #if defined(MBEDTLS_MD5_C)
     45          #include "mbedtls/md5.h"
     46          #endif
     47          
     48          #if defined(MBEDTLS_RIPEMD160_C)
     49          #include "mbedtls/ripemd160.h"
     50          #endif
     51          
     52          #if defined(MBEDTLS_SHA1_C)
     53          #include "mbedtls/sha1.h"
     54          #endif
     55          
     56          #if defined(MBEDTLS_SHA256_C)
     57          #include "mbedtls/sha256.h"
     58          #endif
     59          
     60          #if defined(MBEDTLS_SHA512_C)
     61          #include "mbedtls/sha512.h"
     62          #endif
     63          
     64          #if defined(MBEDTLS_PLATFORM_C)
     65          #include "mbedtls/platform.h"
     66          #else
     67          #include <stdlib.h>
     68          #define mbedtls_calloc    calloc
     69          #define mbedtls_free       free
     70          #endif
     71          
     72          #if defined(MBEDTLS_MD2_C)
     73          
     74          static void md2_starts_wrap( void *ctx )
     75          {
     76              mbedtls_md2_starts( (mbedtls_md2_context *) ctx );
     77          }
     78          
     79          static void md2_update_wrap( void *ctx, const unsigned char *input,
     80                                       size_t ilen )
     81          {
     82              mbedtls_md2_update( (mbedtls_md2_context *) ctx, input, ilen );
     83          }
     84          
     85          static void md2_finish_wrap( void *ctx, unsigned char *output )
     86          {
     87              mbedtls_md2_finish( (mbedtls_md2_context *) ctx, output );
     88          }
     89          
     90          static void *md2_ctx_alloc( void )
     91          {
     92              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_md2_context ) );
     93          
     94              if( ctx != NULL )
     95                  mbedtls_md2_init( (mbedtls_md2_context *) ctx );
     96          
     97              return( ctx );
     98          }
     99          
    100          static void md2_ctx_free( void *ctx )
    101          {
    102              mbedtls_md2_free( (mbedtls_md2_context *) ctx );
    103              mbedtls_free( ctx );
    104          }
    105          
    106          static void md2_clone_wrap( void *dst, const void *src )
    107          {
    108              mbedtls_md2_clone( (mbedtls_md2_context *) dst,
    109                           (const mbedtls_md2_context *) src );
    110          }
    111          
    112          static void md2_process_wrap( void *ctx, const unsigned char *data )
    113          {
    114              ((void) data);
    115          
    116              mbedtls_md2_process( (mbedtls_md2_context *) ctx );
    117          }
    118          
    119          const mbedtls_md_info_t mbedtls_md2_info = {
    120              MBEDTLS_MD_MD2,
    121              "MD2",
    122              16,
    123              16,
    124              md2_starts_wrap,
    125              md2_update_wrap,
    126              md2_finish_wrap,
    127              mbedtls_md2,
    128              md2_ctx_alloc,
    129              md2_ctx_free,
    130              md2_clone_wrap,
    131              md2_process_wrap,
    132          };
    133          
    134          #endif /* MBEDTLS_MD2_C */
    135          
    136          #if defined(MBEDTLS_MD4_C)
    137          
    138          static void md4_starts_wrap( void *ctx )
    139          {
    140              mbedtls_md4_starts( (mbedtls_md4_context *) ctx );
    141          }
    142          
    143          static void md4_update_wrap( void *ctx, const unsigned char *input,
    144                                       size_t ilen )
    145          {
    146              mbedtls_md4_update( (mbedtls_md4_context *) ctx, input, ilen );
    147          }
    148          
    149          static void md4_finish_wrap( void *ctx, unsigned char *output )
    150          {
    151              mbedtls_md4_finish( (mbedtls_md4_context *) ctx, output );
    152          }
    153          
    154          static void *md4_ctx_alloc( void )
    155          {
    156              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_md4_context ) );
    157          
    158              if( ctx != NULL )
    159                  mbedtls_md4_init( (mbedtls_md4_context *) ctx );
    160          
    161              return( ctx );
    162          }
    163          
    164          static void md4_ctx_free( void *ctx )
    165          {
    166              mbedtls_md4_free( (mbedtls_md4_context *) ctx );
    167              mbedtls_free( ctx );
    168          }
    169          
    170          static void md4_clone_wrap( void *dst, const void *src )
    171          {
    172              mbedtls_md4_clone( (mbedtls_md4_context *) dst,
    173                           (const mbedtls_md4_context *) src );
    174          }
    175          
    176          static void md4_process_wrap( void *ctx, const unsigned char *data )
    177          {
    178              mbedtls_md4_process( (mbedtls_md4_context *) ctx, data );
    179          }
    180          
    181          const mbedtls_md_info_t mbedtls_md4_info = {
    182              MBEDTLS_MD_MD4,
    183              "MD4",
    184              16,
    185              64,
    186              md4_starts_wrap,
    187              md4_update_wrap,
    188              md4_finish_wrap,
    189              mbedtls_md4,
    190              md4_ctx_alloc,
    191              md4_ctx_free,
    192              md4_clone_wrap,
    193              md4_process_wrap,
    194          };
    195          
    196          #endif /* MBEDTLS_MD4_C */
    197          
    198          #if defined(MBEDTLS_MD5_C)
    199          
    200          static void md5_starts_wrap( void *ctx )
    201          {
    202              mbedtls_md5_starts( (mbedtls_md5_context *) ctx );
    203          }
    204          
    205          static void md5_update_wrap( void *ctx, const unsigned char *input,
    206                                       size_t ilen )
    207          {
    208              mbedtls_md5_update( (mbedtls_md5_context *) ctx, input, ilen );
    209          }
    210          
    211          static void md5_finish_wrap( void *ctx, unsigned char *output )
    212          {
    213              mbedtls_md5_finish( (mbedtls_md5_context *) ctx, output );
    214          }
    215          
    216          static void *md5_ctx_alloc( void )
    217          {
    218              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_md5_context ) );
    219          
    220              if( ctx != NULL )
    221                  mbedtls_md5_init( (mbedtls_md5_context *) ctx );
    222          
    223              return( ctx );
    224          }
    225          
    226          static void md5_ctx_free( void *ctx )
    227          {
    228              mbedtls_md5_free( (mbedtls_md5_context *) ctx );
    229              mbedtls_free( ctx );
    230          }
    231          
    232          static void md5_clone_wrap( void *dst, const void *src )
    233          {
    234              mbedtls_md5_clone( (mbedtls_md5_context *) dst,
    235                           (const mbedtls_md5_context *) src );
    236          }
    237          
    238          static void md5_process_wrap( void *ctx, const unsigned char *data )
    239          {
    240              mbedtls_md5_process( (mbedtls_md5_context *) ctx, data );
    241          }
    242          
    243          const mbedtls_md_info_t mbedtls_md5_info = {
    244              MBEDTLS_MD_MD5,
    245              "MD5",
    246              16,
    247              64,
    248              md5_starts_wrap,
    249              md5_update_wrap,
    250              md5_finish_wrap,
    251              mbedtls_md5,
    252              md5_ctx_alloc,
    253              md5_ctx_free,
    254              md5_clone_wrap,
    255              md5_process_wrap,
    256          };
    257          
    258          #endif /* MBEDTLS_MD5_C */
    259          
    260          #if defined(MBEDTLS_RIPEMD160_C)
    261          
    262          static void ripemd160_starts_wrap( void *ctx )
    263          {
    264              mbedtls_ripemd160_starts( (mbedtls_ripemd160_context *) ctx );
    265          }
    266          
    267          static void ripemd160_update_wrap( void *ctx, const unsigned char *input,
    268                                             size_t ilen )
    269          {
    270              mbedtls_ripemd160_update( (mbedtls_ripemd160_context *) ctx, input, ilen );
    271          }
    272          
    273          static void ripemd160_finish_wrap( void *ctx, unsigned char *output )
    274          {
    275              mbedtls_ripemd160_finish( (mbedtls_ripemd160_context *) ctx, output );
    276          }
    277          
    278          static void *ripemd160_ctx_alloc( void )
    279          {
    280              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ripemd160_context ) );
    281          
    282              if( ctx != NULL )
    283                  mbedtls_ripemd160_init( (mbedtls_ripemd160_context *) ctx );
    284          
    285              return( ctx );
    286          }
    287          
    288          static void ripemd160_ctx_free( void *ctx )
    289          {
    290              mbedtls_ripemd160_free( (mbedtls_ripemd160_context *) ctx );
    291              mbedtls_free( ctx );
    292          }
    293          
    294          static void ripemd160_clone_wrap( void *dst, const void *src )
    295          {
    296              mbedtls_ripemd160_clone( (mbedtls_ripemd160_context *) dst,
    297                                 (const mbedtls_ripemd160_context *) src );
    298          }
    299          
    300          static void ripemd160_process_wrap( void *ctx, const unsigned char *data )
    301          {
    302              mbedtls_ripemd160_process( (mbedtls_ripemd160_context *) ctx, data );
    303          }
    304          
    305          const mbedtls_md_info_t mbedtls_ripemd160_info = {
    306              MBEDTLS_MD_RIPEMD160,
    307              "RIPEMD160",
    308              20,
    309              64,
    310              ripemd160_starts_wrap,
    311              ripemd160_update_wrap,
    312              ripemd160_finish_wrap,
    313              mbedtls_ripemd160,
    314              ripemd160_ctx_alloc,
    315              ripemd160_ctx_free,
    316              ripemd160_clone_wrap,
    317              ripemd160_process_wrap,
    318          };
    319          
    320          #endif /* MBEDTLS_RIPEMD160_C */
    321          
    322          #if defined(MBEDTLS_SHA1_C)
    323          
    324          static void sha1_starts_wrap( void *ctx )
    325          {
    326              mbedtls_sha1_starts( (mbedtls_sha1_context *) ctx );
    327          }
    328          
    329          static void sha1_update_wrap( void *ctx, const unsigned char *input,
    330                                        size_t ilen )
    331          {
    332              mbedtls_sha1_update( (mbedtls_sha1_context *) ctx, input, ilen );
    333          }
    334          
    335          static void sha1_finish_wrap( void *ctx, unsigned char *output )
    336          {
    337              mbedtls_sha1_finish( (mbedtls_sha1_context *) ctx, output );
    338          }
    339          
    340          static void *sha1_ctx_alloc( void )
    341          {
    342              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_sha1_context ) );
    343          
    344              if( ctx != NULL )
    345                  mbedtls_sha1_init( (mbedtls_sha1_context *) ctx );
    346          
    347              return( ctx );
    348          }
    349          
    350          static void sha1_clone_wrap( void *dst, const void *src )
    351          {
    352              mbedtls_sha1_clone( (mbedtls_sha1_context *) dst,
    353                            (const mbedtls_sha1_context *) src );
    354          }
    355          
    356          static void sha1_ctx_free( void *ctx )
    357          {
    358              mbedtls_sha1_free( (mbedtls_sha1_context *) ctx );
    359              mbedtls_free( ctx );
    360          }
    361          
    362          static void sha1_process_wrap( void *ctx, const unsigned char *data )
    363          {
    364              mbedtls_sha1_process( (mbedtls_sha1_context *) ctx, data );
    365          }
    366          
    367          const mbedtls_md_info_t mbedtls_sha1_info = {
    368              MBEDTLS_MD_SHA1,
    369              "SHA1",
    370              20,
    371              64,
    372              sha1_starts_wrap,
    373              sha1_update_wrap,
    374              sha1_finish_wrap,
    375              mbedtls_sha1,
    376              sha1_ctx_alloc,
    377              sha1_ctx_free,
    378              sha1_clone_wrap,
    379              sha1_process_wrap,
    380          };
    381          
    382          #endif /* MBEDTLS_SHA1_C */
    383          
    384          /*
    385           * Wrappers for generic message digests
    386           */
    387          #if defined(MBEDTLS_SHA256_C)
    388          

   \                                 In section .text, align 2, keep-with-next
    389          static void sha224_starts_wrap( void *ctx )
    390          {
   \                     sha224_starts_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    391              mbedtls_sha256_starts( (mbedtls_sha256_context *) ctx, 1 );
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x.... 0x....      BL       mbedtls_sha256_starts
    392          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    393          

   \                                 In section .text, align 2, keep-with-next
    394          static void sha224_update_wrap( void *ctx, const unsigned char *input,
    395                                          size_t ilen )
    396          {
   \                     sha224_update_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    397              mbedtls_sha256_update( (mbedtls_sha256_context *) ctx, input, ilen );
   \   00000002   0x.... 0x....      BL       mbedtls_sha256_update
    398          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    399          

   \                                 In section .text, align 2, keep-with-next
    400          static void sha224_finish_wrap( void *ctx, unsigned char *output )
    401          {
   \                     sha224_finish_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    402              mbedtls_sha256_finish( (mbedtls_sha256_context *) ctx, output );
   \   00000002   0x.... 0x....      BL       mbedtls_sha256_finish
    403          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    404          

   \                                 In section .text, align 2, keep-with-next
    405          static void sha224_wrap( const unsigned char *input, size_t ilen,
    406                              unsigned char *output )
    407          {
   \                     sha224_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    408              mbedtls_sha256( input, ilen, output, 1 );
   \   00000002   0x2301             MOVS     R3,#+1
   \   00000004   0x.... 0x....      BL       mbedtls_sha256
    409          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    410          

   \                                 In section .text, align 2, keep-with-next
    411          static void *sha224_ctx_alloc( void )
    412          {
   \                     sha224_ctx_alloc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    413              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_sha256_context ) );
   \   00000002   0x216C             MOVS     R1,#+108
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       calloc
   \   0000000A   0x0004             MOVS     R4,R0
    414          
    415              if( ctx != NULL )
   \   0000000C   0xD001             BEQ      ??sha224_ctx_alloc_0
    416                  mbedtls_sha256_init( (mbedtls_sha256_context *) ctx );
   \   0000000E   0x.... 0x....      BL       mbedtls_sha256_init
    417          
    418              return( ctx );
   \                     ??sha224_ctx_alloc_0: (+1)
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    419          }
    420          

   \                                 In section .text, align 2, keep-with-next
    421          static void sha224_ctx_free( void *ctx )
    422          {
   \                     sha224_ctx_free: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    423              mbedtls_sha256_free( (mbedtls_sha256_context *) ctx );
   \   00000004   0x.... 0x....      BL       mbedtls_sha256_free
    424              mbedtls_free( ctx );
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       free
    425          }
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    426          

   \                                 In section .text, align 2, keep-with-next
    427          static void sha224_clone_wrap( void *dst, const void *src )
    428          {
   \                     sha224_clone_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    429              mbedtls_sha256_clone( (mbedtls_sha256_context *) dst,
    430                              (const mbedtls_sha256_context *) src );
   \   00000002   0x.... 0x....      BL       mbedtls_sha256_clone
    431          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    432          

   \                                 In section .text, align 2, keep-with-next
    433          static void sha224_process_wrap( void *ctx, const unsigned char *data )
    434          {
   \                     sha224_process_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    435              mbedtls_sha256_process( (mbedtls_sha256_context *) ctx, data );
   \   00000002   0x.... 0x....      BL       mbedtls_sha256_process
    436          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    437          

   \                                 In section .rodata, align 4, keep-with-next
    438          const mbedtls_md_info_t mbedtls_sha224_info = {
   \                     mbedtls_sha224_info:
   \   00000000   0x05 0x00          DC8 5, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x........         DC32 ?_0, 28, 64, sha224_starts_wrap, sha224_update_wrap
   \              0x0000001C   
   \              0x00000040   
   \              0x........   
   \              0x........   
   \   00000018   0x........         DC32 sha224_finish_wrap, sha224_wrap, sha224_ctx_alloc, sha224_ctx_free
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000028   0x........         DC32 sha224_clone_wrap, sha224_process_wrap
   \              0x........   
    439              MBEDTLS_MD_SHA224,
    440              "SHA224",
    441              28,
    442              64,
    443              sha224_starts_wrap,
    444              sha224_update_wrap,
    445              sha224_finish_wrap,
    446              sha224_wrap,
    447              sha224_ctx_alloc,
    448              sha224_ctx_free,
    449              sha224_clone_wrap,
    450              sha224_process_wrap,
    451          };
    452          

   \                                 In section .text, align 2, keep-with-next
    453          static void sha256_starts_wrap( void *ctx )
    454          {
   \                     sha256_starts_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    455              mbedtls_sha256_starts( (mbedtls_sha256_context *) ctx, 0 );
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      BL       mbedtls_sha256_starts
    456          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    457          

   \                                 In section .text, align 2, keep-with-next
    458          static void sha256_wrap( const unsigned char *input, size_t ilen,
    459                              unsigned char *output )
    460          {
   \                     sha256_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    461              mbedtls_sha256( input, ilen, output, 0 );
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x.... 0x....      BL       mbedtls_sha256
    462          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    463          

   \                                 In section .rodata, align 4, keep-with-next
    464          const mbedtls_md_info_t mbedtls_sha256_info = {
   \                     mbedtls_sha256_info:
   \   00000000   0x06 0x00          DC8 6, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x........         DC32 ?_1, 32, 64, sha256_starts_wrap, sha224_update_wrap
   \              0x00000020   
   \              0x00000040   
   \              0x........   
   \              0x........   
   \   00000018   0x........         DC32 sha224_finish_wrap, sha256_wrap, sha224_ctx_alloc, sha224_ctx_free
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000028   0x........         DC32 sha224_clone_wrap, sha224_process_wrap
   \              0x........   
    465              MBEDTLS_MD_SHA256,
    466              "SHA256",
    467              32,
    468              64,
    469              sha256_starts_wrap,
    470              sha224_update_wrap,
    471              sha224_finish_wrap,
    472              sha256_wrap,
    473              sha224_ctx_alloc,
    474              sha224_ctx_free,
    475              sha224_clone_wrap,
    476              sha224_process_wrap,
    477          };
    478          
    479          #endif /* MBEDTLS_SHA256_C */
    480          
    481          #if defined(MBEDTLS_SHA512_C)
    482          

   \                                 In section .text, align 2, keep-with-next
    483          static void sha384_starts_wrap( void *ctx )
    484          {
   \                     sha384_starts_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    485              mbedtls_sha512_starts( (mbedtls_sha512_context *) ctx, 1 );
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x.... 0x....      BL       mbedtls_sha512_starts
    486          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    487          

   \                                 In section .text, align 2, keep-with-next
    488          static void sha384_update_wrap( void *ctx, const unsigned char *input,
    489                                          size_t ilen )
    490          {
   \                     sha384_update_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    491              mbedtls_sha512_update( (mbedtls_sha512_context *) ctx, input, ilen );
   \   00000002   0x.... 0x....      BL       mbedtls_sha512_update
    492          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    493          

   \                                 In section .text, align 2, keep-with-next
    494          static void sha384_finish_wrap( void *ctx, unsigned char *output )
    495          {
   \                     sha384_finish_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    496              mbedtls_sha512_finish( (mbedtls_sha512_context *) ctx, output );
   \   00000002   0x.... 0x....      BL       mbedtls_sha512_finish
    497          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    498          

   \                                 In section .text, align 2, keep-with-next
    499          static void sha384_wrap( const unsigned char *input, size_t ilen,
    500                              unsigned char *output )
    501          {
   \                     sha384_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    502              mbedtls_sha512( input, ilen, output, 1 );
   \   00000002   0x2301             MOVS     R3,#+1
   \   00000004   0x.... 0x....      BL       mbedtls_sha512
    503          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    504          

   \                                 In section .text, align 2, keep-with-next
    505          static void *sha384_ctx_alloc( void )
    506          {
   \                     sha384_ctx_alloc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    507              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_sha512_context ) );
   \   00000002   0x21D8             MOVS     R1,#+216
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       calloc
   \   0000000A   0x0004             MOVS     R4,R0
    508          
    509              if( ctx != NULL )
   \   0000000C   0xD001             BEQ      ??sha384_ctx_alloc_0
    510                  mbedtls_sha512_init( (mbedtls_sha512_context *) ctx );
   \   0000000E   0x.... 0x....      BL       mbedtls_sha512_init
    511          
    512              return( ctx );
   \                     ??sha384_ctx_alloc_0: (+1)
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    513          }
    514          

   \                                 In section .text, align 2, keep-with-next
    515          static void sha384_ctx_free( void *ctx )
    516          {
   \                     sha384_ctx_free: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    517              mbedtls_sha512_free( (mbedtls_sha512_context *) ctx );
   \   00000004   0x.... 0x....      BL       mbedtls_sha512_free
    518              mbedtls_free( ctx );
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       free
    519          }
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    520          

   \                                 In section .text, align 2, keep-with-next
    521          static void sha384_clone_wrap( void *dst, const void *src )
    522          {
   \                     sha384_clone_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    523              mbedtls_sha512_clone( (mbedtls_sha512_context *) dst,
    524                              (const mbedtls_sha512_context *) src );
   \   00000002   0x.... 0x....      BL       mbedtls_sha512_clone
    525          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    526          

   \                                 In section .text, align 2, keep-with-next
    527          static void sha384_process_wrap( void *ctx, const unsigned char *data )
    528          {
   \                     sha384_process_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    529              mbedtls_sha512_process( (mbedtls_sha512_context *) ctx, data );
   \   00000002   0x.... 0x....      BL       mbedtls_sha512_process
    530          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    531          

   \                                 In section .rodata, align 4, keep-with-next
    532          const mbedtls_md_info_t mbedtls_sha384_info = {
   \                     mbedtls_sha384_info:
   \   00000000   0x07 0x00          DC8 7, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x........         DC32 ?_2, 48, 128, sha384_starts_wrap, sha384_update_wrap
   \              0x00000030   
   \              0x00000080   
   \              0x........   
   \              0x........   
   \   00000018   0x........         DC32 sha384_finish_wrap, sha384_wrap, sha384_ctx_alloc, sha384_ctx_free
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000028   0x........         DC32 sha384_clone_wrap, sha384_process_wrap
   \              0x........   
    533              MBEDTLS_MD_SHA384,
    534              "SHA384",
    535              48,
    536              128,
    537              sha384_starts_wrap,
    538              sha384_update_wrap,
    539              sha384_finish_wrap,
    540              sha384_wrap,
    541              sha384_ctx_alloc,
    542              sha384_ctx_free,
    543              sha384_clone_wrap,
    544              sha384_process_wrap,
    545          };
    546          

   \                                 In section .text, align 2, keep-with-next
    547          static void sha512_starts_wrap( void *ctx )
    548          {
   \                     sha512_starts_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    549              mbedtls_sha512_starts( (mbedtls_sha512_context *) ctx, 0 );
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      BL       mbedtls_sha512_starts
    550          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    551          

   \                                 In section .text, align 2, keep-with-next
    552          static void sha512_wrap( const unsigned char *input, size_t ilen,
    553                              unsigned char *output )
    554          {
   \                     sha512_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    555              mbedtls_sha512( input, ilen, output, 0 );
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x.... 0x....      BL       mbedtls_sha512
    556          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    557          

   \                                 In section .rodata, align 4, keep-with-next
    558          const mbedtls_md_info_t mbedtls_sha512_info = {
   \                     mbedtls_sha512_info:
   \   00000000   0x08 0x00          DC8 8, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x........         DC32 ?_3, 64, 128, sha512_starts_wrap, sha384_update_wrap
   \              0x00000040   
   \              0x00000080   
   \              0x........   
   \              0x........   
   \   00000018   0x........         DC32 sha384_finish_wrap, sha512_wrap, sha384_ctx_alloc, sha384_ctx_free
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000028   0x........         DC32 sha384_clone_wrap, sha384_process_wrap
   \              0x........   

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x53 0x48          DC8 "SHA224"
   \              0x41 0x32    
   \              0x32 0x34    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x53 0x48          DC8 "SHA256"
   \              0x41 0x32    
   \              0x35 0x36    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x53 0x48          DC8 "SHA384"
   \              0x41 0x33    
   \              0x38 0x34    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x53 0x48          DC8 "SHA512"
   \              0x41 0x35    
   \              0x31 0x32    
   \              0x00         
   \   00000007   0x00               DC8 0
    559              MBEDTLS_MD_SHA512,
    560              "SHA512",
    561              64,
    562              128,
    563              sha512_starts_wrap,
    564              sha384_update_wrap,
    565              sha384_finish_wrap,
    566              sha512_wrap,
    567              sha384_ctx_alloc,
    568              sha384_ctx_free,
    569              sha384_clone_wrap,
    570              sha384_process_wrap,
    571          };
    572          
    573          #endif /* MBEDTLS_SHA512_C */
    574          
    575          #endif /* MBEDTLS_MD_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   sha224_clone_wrap
         8   -> mbedtls_sha256_clone
       8   sha224_ctx_alloc
         8   -> calloc
         8   -> mbedtls_sha256_init
       8   sha224_ctx_free
         8   -> free
         8   -> mbedtls_sha256_free
       8   sha224_finish_wrap
         8   -> mbedtls_sha256_finish
       8   sha224_process_wrap
         8   -> mbedtls_sha256_process
       8   sha224_starts_wrap
         8   -> mbedtls_sha256_starts
       8   sha224_update_wrap
         8   -> mbedtls_sha256_update
       8   sha224_wrap
         8   -> mbedtls_sha256
       8   sha256_starts_wrap
         8   -> mbedtls_sha256_starts
       8   sha256_wrap
         8   -> mbedtls_sha256
       8   sha384_clone_wrap
         8   -> mbedtls_sha512_clone
       8   sha384_ctx_alloc
         8   -> calloc
         8   -> mbedtls_sha512_init
       8   sha384_ctx_free
         8   -> free
         8   -> mbedtls_sha512_free
       8   sha384_finish_wrap
         8   -> mbedtls_sha512_finish
       8   sha384_process_wrap
         8   -> mbedtls_sha512_process
       8   sha384_starts_wrap
         8   -> mbedtls_sha512_starts
       8   sha384_update_wrap
         8   -> mbedtls_sha512_update
       8   sha384_wrap
         8   -> mbedtls_sha512
       8   sha512_starts_wrap
         8   -> mbedtls_sha512_starts
       8   sha512_wrap
         8   -> mbedtls_sha512


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?_0
       8  ?_1
       8  ?_2
       8  ?_3
      48  mbedtls_sha224_info
      48  mbedtls_sha256_info
      48  mbedtls_sha384_info
      48  mbedtls_sha512_info
       8  sha224_clone_wrap
      22  sha224_ctx_alloc
      16  sha224_ctx_free
       8  sha224_finish_wrap
       8  sha224_process_wrap
      10  sha224_starts_wrap
       8  sha224_update_wrap
      10  sha224_wrap
      10  sha256_starts_wrap
      10  sha256_wrap
       8  sha384_clone_wrap
      22  sha384_ctx_alloc
      16  sha384_ctx_free
       8  sha384_finish_wrap
       8  sha384_process_wrap
      10  sha384_starts_wrap
       8  sha384_update_wrap
      10  sha384_wrap
      10  sha512_starts_wrap
      10  sha512_wrap

 
 224 bytes in section .rodata
 220 bytes in section .text
 
 220 bytes of CODE  memory
 224 bytes of CONST memory

Errors: none
Warnings: none

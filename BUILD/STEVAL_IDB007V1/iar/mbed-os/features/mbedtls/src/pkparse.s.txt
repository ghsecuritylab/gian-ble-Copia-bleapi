###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:32
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\features\mbedtls\src\pkparse.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\pkparse.d -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\pkparse.s.txt
#        -o .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\pkparse.o
#        .\mbed-os\features\mbedtls\src\pkparse.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\pkparse.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\pkparse.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\features\mbedtls\src\pkparse.c
      1          /*
      2           *  Public Key layer for parsing key files and structures
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          
     22          #if !defined(MBEDTLS_CONFIG_FILE)
     23          #include "mbedtls/config.h"
     24          #else
     25          #include MBEDTLS_CONFIG_FILE
     26          #endif
     27          
     28          #if defined(MBEDTLS_PK_PARSE_C)
     29          
     30          #include "mbedtls/pk.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp struct <unnamed> *mbedtls_pk_rsa(struct <unnamed> const)
   \                     mbedtls_pk_rsa: (+1)
   \   00000000   0x0008             MOVS     R0,R1
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp struct <unnamed> *mbedtls_pk_ec(struct <unnamed> const)
   \                     mbedtls_pk_ec: (+1)
   \   00000000   0x0008             MOVS     R0,R1
   \   00000002   0x4770             BX       LR               ;; return
     31          #include "mbedtls/asn1.h"
     32          #include "mbedtls/oid.h"
     33          
     34          #include <string.h>
     35          
     36          #if defined(MBEDTLS_RSA_C)
     37          #include "mbedtls/rsa.h"
     38          #endif
     39          #if defined(MBEDTLS_ECP_C)
     40          #include "mbedtls/ecp.h"
     41          #endif
     42          #if defined(MBEDTLS_ECDSA_C)
     43          #include "mbedtls/ecdsa.h"
     44          #endif
     45          #if defined(MBEDTLS_PEM_PARSE_C)
     46          #include "mbedtls/pem.h"
     47          #endif
     48          #if defined(MBEDTLS_PKCS5_C)
     49          #include "mbedtls/pkcs5.h"
     50          #endif
     51          #if defined(MBEDTLS_PKCS12_C)
     52          #include "mbedtls/pkcs12.h"
     53          #endif
     54          
     55          #if defined(MBEDTLS_PLATFORM_C)
     56          #include "mbedtls/platform.h"
     57          #else
     58          #include <stdlib.h>
     59          #define mbedtls_calloc    calloc
     60          #define mbedtls_free       free
     61          #endif
     62          
     63          #if defined(MBEDTLS_FS_IO)
     64          /* Implementation that should never be optimized out by the compiler */
     65          static void mbedtls_zeroize( void *v, size_t n ) {
     66              volatile unsigned char *p = v; while( n-- ) *p++ = 0;
     67          }
     68          
     69          /*
     70           * Load all data from a file into a given buffer.
     71           *
     72           * The file is expected to contain either PEM or DER encoded data.
     73           * A terminating null byte is always appended. It is included in the announced
     74           * length only if the data looks like it is PEM encoded.
     75           */
     76          int mbedtls_pk_load_file( const char *path, unsigned char **buf, size_t *n )
     77          {
     78              FILE *f;
     79              long size;
     80          
     81              if( ( f = fopen( path, "rb" ) ) == NULL )
     82                  return( MBEDTLS_ERR_PK_FILE_IO_ERROR );
     83          
     84              fseek( f, 0, SEEK_END );
     85              if( ( size = ftell( f ) ) == -1 )
     86              {
     87                  fclose( f );
     88                  return( MBEDTLS_ERR_PK_FILE_IO_ERROR );
     89              }
     90              fseek( f, 0, SEEK_SET );
     91          
     92              *n = (size_t) size;
     93          
     94              if( *n + 1 == 0 ||
     95                  ( *buf = mbedtls_calloc( 1, *n + 1 ) ) == NULL )
     96              {
     97                  fclose( f );
     98                  return( MBEDTLS_ERR_PK_ALLOC_FAILED );
     99              }
    100          
    101              if( fread( *buf, 1, *n, f ) != *n )
    102              {
    103                  fclose( f );
    104                  mbedtls_free( *buf );
    105                  return( MBEDTLS_ERR_PK_FILE_IO_ERROR );
    106              }
    107          
    108              fclose( f );
    109          
    110              (*buf)[*n] = '\0';
    111          
    112              if( strstr( (const char *) *buf, "-----BEGIN " ) != NULL )
    113                  ++*n;
    114          
    115              return( 0 );
    116          }
    117          
    118          /*
    119           * Load and parse a private key
    120           */
    121          int mbedtls_pk_parse_keyfile( mbedtls_pk_context *ctx,
    122                                const char *path, const char *pwd )
    123          {
    124              int ret;
    125              size_t n;
    126              unsigned char *buf;
    127          
    128              if( ( ret = mbedtls_pk_load_file( path, &buf, &n ) ) != 0 )
    129                  return( ret );
    130          
    131              if( pwd == NULL )
    132                  ret = mbedtls_pk_parse_key( ctx, buf, n, NULL, 0 );
    133              else
    134                  ret = mbedtls_pk_parse_key( ctx, buf, n,
    135                          (const unsigned char *) pwd, strlen( pwd ) );
    136          
    137              mbedtls_zeroize( buf, n );
    138              mbedtls_free( buf );
    139          
    140              return( ret );
    141          }
    142          
    143          /*
    144           * Load and parse a public key
    145           */
    146          int mbedtls_pk_parse_public_keyfile( mbedtls_pk_context *ctx, const char *path )
    147          {
    148              int ret;
    149              size_t n;
    150              unsigned char *buf;
    151          
    152              if( ( ret = mbedtls_pk_load_file( path, &buf, &n ) ) != 0 )
    153                  return( ret );
    154          
    155              ret = mbedtls_pk_parse_public_key( ctx, buf, n );
    156          
    157              mbedtls_zeroize( buf, n );
    158              mbedtls_free( buf );
    159          
    160              return( ret );
    161          }
    162          #endif /* MBEDTLS_FS_IO */
    163          
    164          #if defined(MBEDTLS_ECP_C)
    165          /* Minimally parse an ECParameters buffer to and mbedtls_asn1_buf
    166           *
    167           * ECParameters ::= CHOICE {
    168           *   namedCurve         OBJECT IDENTIFIER
    169           *   specifiedCurve     SpecifiedECDomain -- = SEQUENCE { ... }
    170           *   -- implicitCurve   NULL
    171           * }
    172           */
    173          static int pk_get_ecparams( unsigned char **p, const unsigned char *end,
    174                                      mbedtls_asn1_buf *params )
    175          {
    176              int ret;
    177          
    178              /* Tag may be either OID or SEQUENCE */
    179              params->tag = **p;
    180              if( params->tag != MBEDTLS_ASN1_OID
    181          #if defined(MBEDTLS_PK_PARSE_EC_EXTENDED)
    182                      && params->tag != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE )
    183          #endif
    184                      )
    185              {
    186                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
    187                          MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );
    188              }
    189          
    190              if( ( ret = mbedtls_asn1_get_tag( p, end, &params->len, params->tag ) ) != 0 )
    191              {
    192                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    193              }
    194          
    195              params->p = *p;
    196              *p += params->len;
    197          
    198              if( *p != end )
    199                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
    200                          MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
    201          
    202              return( 0 );
    203          }
    204          
    205          #if defined(MBEDTLS_PK_PARSE_EC_EXTENDED)
    206          /*
    207           * Parse a SpecifiedECDomain (SEC 1 C.2) and (mostly) fill the group with it.
    208           * WARNING: the resulting group should only be used with
    209           * pk_group_id_from_specified(), since its base point may not be set correctly
    210           * if it was encoded compressed.
    211           *
    212           *  SpecifiedECDomain ::= SEQUENCE {
    213           *      version SpecifiedECDomainVersion(ecdpVer1 | ecdpVer2 | ecdpVer3, ...),
    214           *      fieldID FieldID {{FieldTypes}},
    215           *      curve Curve,
    216           *      base ECPoint,
    217           *      order INTEGER,
    218           *      cofactor INTEGER OPTIONAL,
    219           *      hash HashAlgorithm OPTIONAL,
    220           *      ...
    221           *  }
    222           *
    223           * We only support prime-field as field type, and ignore hash and cofactor.
    224           */
    225          static int pk_group_from_specified( const mbedtls_asn1_buf *params, mbedtls_ecp_group *grp )
    226          {
    227              int ret;
    228              unsigned char *p = params->p;
    229              const unsigned char * const end = params->p + params->len;
    230              const unsigned char *end_field, *end_curve;
    231              size_t len;
    232              int ver;
    233          
    234              /* SpecifiedECDomainVersion ::= INTEGER { 1, 2, 3 } */
    235              if( ( ret = mbedtls_asn1_get_int( &p, end, &ver ) ) != 0 )
    236                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    237          
    238              if( ver < 1 || ver > 3 )
    239                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
    240          
    241              /*
    242               * FieldID { FIELD-ID:IOSet } ::= SEQUENCE { -- Finite field
    243               *       fieldType FIELD-ID.&id({IOSet}),
    244               *       parameters FIELD-ID.&Type({IOSet}{@fieldType})
    245               * }
    246               */
    247              if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    248                      MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
    249                  return( ret );
    250          
    251              end_field = p + len;
    252          
    253              /*
    254               * FIELD-ID ::= TYPE-IDENTIFIER
    255               * FieldTypes FIELD-ID ::= {
    256               *       { Prime-p IDENTIFIED BY prime-field } |
    257               *       { Characteristic-two IDENTIFIED BY characteristic-two-field }
    258               * }
    259               * prime-field OBJECT IDENTIFIER ::= { id-fieldType 1 }
    260               */
    261              if( ( ret = mbedtls_asn1_get_tag( &p, end_field, &len, MBEDTLS_ASN1_OID ) ) != 0 )
    262                  return( ret );
    263          
    264              if( len != MBEDTLS_OID_SIZE( MBEDTLS_OID_ANSI_X9_62_PRIME_FIELD ) ||
    265                  memcmp( p, MBEDTLS_OID_ANSI_X9_62_PRIME_FIELD, len ) != 0 )
    266              {
    267                  return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );
    268              }
    269          
    270              p += len;
    271          
    272              /* Prime-p ::= INTEGER -- Field of size p. */
    273              if( ( ret = mbedtls_asn1_get_mpi( &p, end_field, &grp->P ) ) != 0 )
    274                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    275          
    276              grp->pbits = mbedtls_mpi_bitlen( &grp->P );
    277          
    278              if( p != end_field )
    279                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
    280                          MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
    281          
    282              /*
    283               * Curve ::= SEQUENCE {
    284               *       a FieldElement,
    285               *       b FieldElement,
    286               *       seed BIT STRING OPTIONAL
    287               *       -- Shall be present if used in SpecifiedECDomain
    288               *       -- with version equal to ecdpVer2 or ecdpVer3
    289               * }
    290               */
    291              if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    292                      MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
    293                  return( ret );
    294          
    295              end_curve = p + len;
    296          
    297              /*
    298               * FieldElement ::= OCTET STRING
    299               * containing an integer in the case of a prime field
    300               */
    301              if( ( ret = mbedtls_asn1_get_tag( &p, end_curve, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 ||
    302                  ( ret = mbedtls_mpi_read_binary( &grp->A, p, len ) ) != 0 )
    303              {
    304                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    305              }
    306          
    307              p += len;
    308          
    309              if( ( ret = mbedtls_asn1_get_tag( &p, end_curve, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 ||
    310                  ( ret = mbedtls_mpi_read_binary( &grp->B, p, len ) ) != 0 )
    311              {
    312                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    313              }
    314          
    315              p += len;
    316          
    317              /* Ignore seed BIT STRING OPTIONAL */
    318              if( ( ret = mbedtls_asn1_get_tag( &p, end_curve, &len, MBEDTLS_ASN1_BIT_STRING ) ) == 0 )
    319                  p += len;
    320          
    321              if( p != end_curve )
    322                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
    323                          MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
    324          
    325              /*
    326               * ECPoint ::= OCTET STRING
    327               */
    328              if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
    329                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    330          
    331              if( ( ret = mbedtls_ecp_point_read_binary( grp, &grp->G,
    332                                                ( const unsigned char *) p, len ) ) != 0 )
    333              {
    334                  /*
    335                   * If we can't read the point because it's compressed, cheat by
    336                   * reading only the X coordinate and the parity bit of Y.
    337                   */
    338                  if( ret != MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE ||
    339                      ( p[0] != 0x02 && p[0] != 0x03 ) ||
    340                      len != mbedtls_mpi_size( &grp->P ) + 1 ||
    341                      mbedtls_mpi_read_binary( &grp->G.X, p + 1, len - 1 ) != 0 ||
    342                      mbedtls_mpi_lset( &grp->G.Y, p[0] - 2 ) != 0 ||
    343                      mbedtls_mpi_lset( &grp->G.Z, 1 ) != 0 )
    344                  {
    345                      return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
    346                  }
    347              }
    348          
    349              p += len;
    350          
    351              /*
    352               * order INTEGER
    353               */
    354              if( ( ret = mbedtls_asn1_get_mpi( &p, end, &grp->N ) ) != 0 )
    355                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    356          
    357              grp->nbits = mbedtls_mpi_bitlen( &grp->N );
    358          
    359              /*
    360               * Allow optional elements by purposefully not enforcing p == end here.
    361               */
    362          
    363              return( 0 );
    364          }
    365          
    366          /*
    367           * Find the group id associated with an (almost filled) group as generated by
    368           * pk_group_from_specified(), or return an error if unknown.
    369           */
    370          static int pk_group_id_from_group( const mbedtls_ecp_group *grp, mbedtls_ecp_group_id *grp_id )
    371          {
    372              int ret = 0;
    373              mbedtls_ecp_group ref;
    374              const mbedtls_ecp_group_id *id;
    375          
    376              mbedtls_ecp_group_init( &ref );
    377          
    378              for( id = mbedtls_ecp_grp_id_list(); *id != MBEDTLS_ECP_DP_NONE; id++ )
    379              {
    380                  /* Load the group associated to that id */
    381                  mbedtls_ecp_group_free( &ref );
    382                  MBEDTLS_MPI_CHK( mbedtls_ecp_group_load( &ref, *id ) );
    383          
    384                  /* Compare to the group we were given, starting with easy tests */
    385                  if( grp->pbits == ref.pbits && grp->nbits == ref.nbits &&
    386                      mbedtls_mpi_cmp_mpi( &grp->P, &ref.P ) == 0 &&
    387                      mbedtls_mpi_cmp_mpi( &grp->A, &ref.A ) == 0 &&
    388                      mbedtls_mpi_cmp_mpi( &grp->B, &ref.B ) == 0 &&
    389                      mbedtls_mpi_cmp_mpi( &grp->N, &ref.N ) == 0 &&
    390                      mbedtls_mpi_cmp_mpi( &grp->G.X, &ref.G.X ) == 0 &&
    391                      mbedtls_mpi_cmp_mpi( &grp->G.Z, &ref.G.Z ) == 0 &&
    392                      /* For Y we may only know the parity bit, so compare only that */
    393                      mbedtls_mpi_get_bit( &grp->G.Y, 0 ) == mbedtls_mpi_get_bit( &ref.G.Y, 0 ) )
    394                  {
    395                      break;
    396                  }
    397          
    398              }
    399          
    400          cleanup:
    401              mbedtls_ecp_group_free( &ref );
    402          
    403              *grp_id = *id;
    404          
    405              if( ret == 0 && *id == MBEDTLS_ECP_DP_NONE )
    406                  ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
    407          
    408              return( ret );
    409          }
    410          
    411          /*
    412           * Parse a SpecifiedECDomain (SEC 1 C.2) and find the associated group ID
    413           */
    414          static int pk_group_id_from_specified( const mbedtls_asn1_buf *params,
    415                                                 mbedtls_ecp_group_id *grp_id )
    416          {
    417              int ret;
    418              mbedtls_ecp_group grp;
    419          
    420              mbedtls_ecp_group_init( &grp );
    421          
    422              if( ( ret = pk_group_from_specified( params, &grp ) ) != 0 )
    423                  goto cleanup;
    424          
    425              ret = pk_group_id_from_group( &grp, grp_id );
    426          
    427          cleanup:
    428              mbedtls_ecp_group_free( &grp );
    429          
    430              return( ret );
    431          }
    432          #endif /* MBEDTLS_PK_PARSE_EC_EXTENDED */
    433          
    434          /*
    435           * Use EC parameters to initialise an EC group
    436           *
    437           * ECParameters ::= CHOICE {
    438           *   namedCurve         OBJECT IDENTIFIER
    439           *   specifiedCurve     SpecifiedECDomain -- = SEQUENCE { ... }
    440           *   -- implicitCurve   NULL
    441           */

   \                                 In section .text, align 2, keep-with-next
    442          static int pk_use_ecparams( const mbedtls_asn1_buf *params, mbedtls_ecp_group *grp )
    443          {
   \                     pk_use_ecparams: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x000C             MOVS     R4,R1
    444              int ret;
    445              mbedtls_ecp_group_id grp_id;
    446          
    447              if( params->tag == MBEDTLS_ASN1_OID )
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x2906             CMP      R1,#+6
   \   0000000A   0xD10D             BNE      ??pk_use_ecparams_0
    448              {
    449                  if( mbedtls_oid_get_ec_grp( params, &grp_id ) != 0 )
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x.... 0x....      BL       mbedtls_oid_get_ec_grp
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ      ??pk_use_ecparams_1
    450                      return( MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE );
   \   00000016   0x....             LDR      R0,??DataTable11  ;; 0xffffc600
   \   00000018   0xBD16             POP      {R1,R2,R4,PC}
    451              }
    452              else
    453              {
    454          #if defined(MBEDTLS_PK_PARSE_EC_EXTENDED)
    455                  if( ( ret = pk_group_id_from_specified( params, &grp_id ) ) != 0 )
    456                      return( ret );
    457          #else
    458                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
    459          #endif
    460              }
    461          
    462              /*
    463               * grp may already be initilialized; if so, make sure IDs match
    464               */
    465              if( grp->id != MBEDTLS_ECP_DP_NONE && grp->id != grp_id )
   \                     ??pk_use_ecparams_1: (+1)
   \   0000001A   0x7820             LDRB     R0,[R4, #+0]
   \   0000001C   0x0001             MOVS     R1,R0
   \   0000001E   0xD005             BEQ      ??pk_use_ecparams_2
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x7809             LDRB     R1,[R1, #+0]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD001             BEQ      ??pk_use_ecparams_2
    466                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
   \                     ??pk_use_ecparams_0: (+1)
   \   00000028   0x....             LDR      R0,??DataTable11_1  ;; 0xffffc300
   \   0000002A   0xBD16             POP      {R1,R2,R4,PC}
    467          
    468              if( ( ret = mbedtls_ecp_group_load( grp, grp_id ) ) != 0 )
   \                     ??pk_use_ecparams_2: (+1)
   \   0000002C   0x4668             MOV      R0,SP
   \   0000002E   0x7801             LDRB     R1,[R0, #+0]
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       mbedtls_ecp_group_load
   \   00000036   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    469                  return( ret );
    470          
    471              return( 0 );
    472          }
    473          
    474          /*
    475           * EC public key is an EC point
    476           *
    477           * The caller is responsible for clearing the structure upon failure if
    478           * desired. Take care to pass along the possible ECP_FEATURE_UNAVAILABLE
    479           * return code of mbedtls_ecp_point_read_binary() and leave p in a usable state.
    480           */

   \                                 In section .text, align 2, keep-with-next
    481          static int pk_get_ecpubkey( unsigned char **p, const unsigned char *end,
    482                                      mbedtls_ecp_keypair *key )
    483          {
   \                     pk_get_ecpubkey: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
    484              int ret;
    485          
    486              if( ( ret = mbedtls_ecp_point_read_binary( &key->grp, &key->Q,
    487                              (const unsigned char *) *p, end - *p ) ) == 0 )
   \   00000008   0x002F             MOVS     R7,R5
   \   0000000A   0x3788             ADDS     R7,R7,#+136
   \   0000000C   0x6832             LDR      R2,[R6, #+0]
   \   0000000E   0x1AA3             SUBS     R3,R4,R2
   \   00000010   0x0039             MOVS     R1,R7
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       mbedtls_ecp_point_read_binary
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD103             BNE      ??pk_get_ecpubkey_0
    488              {
    489                  ret = mbedtls_ecp_check_pubkey( &key->grp, &key->Q );
   \   0000001C   0x0039             MOVS     R1,R7
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0x.... 0x....      BL       mbedtls_ecp_check_pubkey
    490              }
    491          
    492              /*
    493               * We know mbedtls_ecp_point_read_binary consumed all bytes or failed
    494               */
    495              *p = (unsigned char *) end;
   \                     ??pk_get_ecpubkey_0: (+1)
   \   00000024   0x6034             STR      R4,[R6, #+0]
    496          
    497              return( ret );
   \   00000026   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    498          }
    499          #endif /* MBEDTLS_ECP_C */
    500          
    501          #if defined(MBEDTLS_RSA_C)
    502          /*
    503           *  RSAPublicKey ::= SEQUENCE {
    504           *      modulus           INTEGER,  -- n
    505           *      publicExponent    INTEGER   -- e
    506           *  }
    507           */
    508          static int pk_get_rsapubkey( unsigned char **p,
    509                                       const unsigned char *end,
    510                                       mbedtls_rsa_context *rsa )
    511          {
    512              int ret;
    513              size_t len;
    514          
    515              if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
    516                      MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
    517                  return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );
    518          
    519              if( *p + len != end )
    520                  return( MBEDTLS_ERR_PK_INVALID_PUBKEY +
    521                          MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
    522          
    523              if( ( ret = mbedtls_asn1_get_mpi( p, end, &rsa->N ) ) != 0 ||
    524                  ( ret = mbedtls_asn1_get_mpi( p, end, &rsa->E ) ) != 0 )
    525                  return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );
    526          
    527              if( *p != end )
    528                  return( MBEDTLS_ERR_PK_INVALID_PUBKEY +
    529                          MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
    530          
    531              if( ( ret = mbedtls_rsa_check_pubkey( rsa ) ) != 0 )
    532                  return( MBEDTLS_ERR_PK_INVALID_PUBKEY );
    533          
    534              rsa->len = mbedtls_mpi_size( &rsa->N );
    535          
    536              return( 0 );
    537          }
    538          #endif /* MBEDTLS_RSA_C */
    539          
    540          /* Get a PK algorithm identifier
    541           *
    542           *  AlgorithmIdentifier  ::=  SEQUENCE  {
    543           *       algorithm               OBJECT IDENTIFIER,
    544           *       parameters              ANY DEFINED BY algorithm OPTIONAL  }
    545           */

   \                                 In section .text, align 2, keep-with-next
    546          static int pk_get_pk_alg( unsigned char **p,
    547                                    const unsigned char *end,
    548                                    mbedtls_pk_type_t *pk_alg, mbedtls_asn1_buf *params )
    549          {
   \                     pk_get_pk_alg: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0015             MOVS     R5,R2
   \   00000006   0x001C             MOVS     R4,R3
    550              int ret;
    551              mbedtls_asn1_buf alg_oid;
    552          
    553              memset( params, 0, sizeof(mbedtls_asn1_buf) );
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0xC44C             STM      R4!,{R2,R3,R6}
   \   00000010   0x3C0C             SUBS     R4,R4,#+12
    554          
    555              if( ( ret = mbedtls_asn1_get_alg( p, end, &alg_oid, params ) ) != 0 )
   \   00000012   0x0023             MOVS     R3,R4
   \   00000014   0x466A             MOV      R2,SP
   \   00000016   0x.... 0x....      BL       mbedtls_asn1_get_alg
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD002             BEQ      ??pk_get_pk_alg_0
    556                  return( MBEDTLS_ERR_PK_INVALID_ALG + ret );
   \   0000001E   0x....             LDR      R1,??DataTable11_2  ;; 0xffffc580
   \   00000020   0x1840             ADDS     R0,R0,R1
   \   00000022   0xE015             B        ??pk_get_pk_alg_1
    557          
    558              if( mbedtls_oid_get_pk_alg( &alg_oid, pk_alg ) != 0 )
   \                     ??pk_get_pk_alg_0: (+1)
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x.... 0x....      BL       mbedtls_oid_get_pk_alg
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD001             BEQ      ??pk_get_pk_alg_2
    559                  return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
   \   00000030   0x....             LDR      R0,??DataTable11_3  ;; 0xffffc380
   \   00000032   0xE00D             B        ??pk_get_pk_alg_1
    560          
    561              /*
    562               * No parameters with RSA (only for EC)
    563               */
    564              if( *pk_alg == MBEDTLS_PK_RSA &&
    565                      ( ( params->tag != MBEDTLS_ASN1_NULL && params->tag != 0 ) ||
    566                          params->len != 0 ) )
   \                     ??pk_get_pk_alg_2: (+1)
   \   00000034   0x7828             LDRB     R0,[R5, #+0]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD109             BNE      ??pk_get_pk_alg_3
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x2805             CMP      R0,#+5
   \   0000003E   0xD001             BEQ      ??pk_get_pk_alg_4
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD102             BNE      ??pk_get_pk_alg_5
   \                     ??pk_get_pk_alg_4: (+1)
   \   00000044   0x6860             LDR      R0,[R4, #+4]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD001             BEQ      ??pk_get_pk_alg_3
    567              {
    568                  return( MBEDTLS_ERR_PK_INVALID_ALG );
   \                     ??pk_get_pk_alg_5: (+1)
   \   0000004A   0x....             LDR      R0,??DataTable11_2  ;; 0xffffc580
   \   0000004C   0xE000             B        ??pk_get_pk_alg_1
    569              }
    570          
    571              return( 0 );
   \                     ??pk_get_pk_alg_3: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??pk_get_pk_alg_1: (+1)
   \   00000050   0xB004             ADD      SP,SP,#+16
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
    572          }
    573          
    574          /*
    575           *  SubjectPublicKeyInfo  ::=  SEQUENCE  {
    576           *       algorithm            AlgorithmIdentifier,
    577           *       subjectPublicKey     BIT STRING }
    578           */

   \                                 In section .text, align 2, keep-with-next
    579          int mbedtls_pk_parse_subpubkey( unsigned char **p, const unsigned char *end,
    580                                  mbedtls_pk_context *pk )
    581          {
   \                     mbedtls_pk_parse_subpubkey: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000C             MOVS     R4,R1
    582              int ret;
    583              size_t len;
    584              mbedtls_asn1_buf alg_params;
    585              mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x710F             STRB     R7,[R1, #+4]
    586              const mbedtls_pk_info_t *pk_info;
    587          
    588              if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
    589                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
   \   0000000E   0x2330             MOVS     R3,#+48
   \   00000010   0x466A             MOV      R2,SP
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ      ??mbedtls_pk_parse_subpubkey_0
    590              {
    591                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
   \   0000001C   0x....             LDR      R1,??DataTable11_1  ;; 0xffffc300
   \   0000001E   0xE012             B.N      ??mbedtls_pk_parse_subpubkey_1
    592              }
    593          
    594              end = *p + len;
   \                     ??mbedtls_pk_parse_subpubkey_0: (+1)
   \   00000020   0x6830             LDR      R0,[R6, #+0]
   \   00000022   0x9900             LDR      R1,[SP, #+0]
   \   00000024   0x1844             ADDS     R4,R0,R1
    595          
    596              if( ( ret = pk_get_pk_alg( p, end, &pk_alg, &alg_params ) ) != 0 )
   \   00000026   0xAB03             ADD      R3,SP,#+12
   \   00000028   0xAA01             ADD      R2,SP,#+4
   \   0000002A   0x0021             MOVS     R1,R4
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0x.... 0x....      BL       pk_get_pk_alg
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD17A             BNE      ??mbedtls_pk_parse_subpubkey_2
    597                  return( ret );
    598          
    599              if( ( ret = mbedtls_asn1_get_bitstring_null( p, end, &len ) ) != 0 )
   \   00000036   0x466A             MOV      R2,SP
   \   00000038   0x0021             MOVS     R1,R4
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0x.... 0x....      BL       mbedtls_asn1_get_bitstring_null
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD002             BEQ      ??mbedtls_pk_parse_subpubkey_3
    600                  return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );
   \   00000044   0x....             LDR      R1,??DataTable11_4  ;; 0xffffc500
   \                     ??mbedtls_pk_parse_subpubkey_1: (+1)
   \   00000046   0x1840             ADDS     R0,R0,R1
   \   00000048   0xE070             B        ??mbedtls_pk_parse_subpubkey_2
    601          
    602              if( *p + len != end )
   \                     ??mbedtls_pk_parse_subpubkey_3: (+1)
   \   0000004A   0x6830             LDR      R0,[R6, #+0]
   \   0000004C   0x9900             LDR      R1,[SP, #+0]
   \   0000004E   0x1840             ADDS     R0,R0,R1
   \   00000050   0x42A0             CMP      R0,R4
   \   00000052   0xD001             BEQ      ??mbedtls_pk_parse_subpubkey_4
    603                  return( MBEDTLS_ERR_PK_INVALID_PUBKEY +
    604                          MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
   \   00000054   0x....             LDR      R0,??DataTable11_5  ;; 0xffffc49a
   \   00000056   0xE069             B        ??mbedtls_pk_parse_subpubkey_2
    605          
    606              if( ( pk_info = mbedtls_pk_info_from_type( pk_alg ) ) == NULL )
   \                     ??mbedtls_pk_parse_subpubkey_4: (+1)
   \   00000058   0x4668             MOV      R0,SP
   \   0000005A   0x7900             LDRB     R0,[R0, #+4]
   \   0000005C   0x.... 0x....      BL       mbedtls_pk_info_from_type
   \   00000060   0x0001             MOVS     R1,R0
   \   00000062   0xD101             BNE      ??mbedtls_pk_parse_subpubkey_5
    607                  return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
   \   00000064   0x....             LDR      R0,??DataTable11_3  ;; 0xffffc380
   \   00000066   0xE061             B        ??mbedtls_pk_parse_subpubkey_2
    608          
    609              if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 )
   \                     ??mbedtls_pk_parse_subpubkey_5: (+1)
   \   00000068   0x9806             LDR      R0,[SP, #+24]
   \   0000006A   0x.... 0x....      BL       mbedtls_pk_setup
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD15C             BNE      ??mbedtls_pk_parse_subpubkey_2
    610                  return( ret );
    611          
    612          #if defined(MBEDTLS_RSA_C)
    613              if( pk_alg == MBEDTLS_PK_RSA )
   \   00000072   0x4668             MOV      R0,SP
   \   00000074   0x7900             LDRB     R0,[R0, #+4]
   \   00000076   0x2801             CMP      R0,#+1
   \   00000078   0xD13A             BNE      ??mbedtls_pk_parse_subpubkey_6
    614              {
    615                  ret = pk_get_rsapubkey( p, end, mbedtls_pk_rsa( *pk ) );
   \   0000007A   0x9806             LDR      R0,[SP, #+24]
   \   0000007C   0xC803             LDM      R0,{R0,R1}
   \   0000007E   0x.... 0x....      BL       mbedtls_pk_rsa
   \   00000082   0x0005             MOVS     R5,R0
   \   00000084   0x2330             MOVS     R3,#+48
   \   00000086   0xAA02             ADD      R2,SP,#+8
   \   00000088   0x0021             MOVS     R1,R4
   \   0000008A   0x0030             MOVS     R0,R6
   \   0000008C   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD008             BEQ      ??mbedtls_pk_parse_subpubkey_7
   \                     ??mbedtls_pk_parse_subpubkey_8: (+1)
   \   00000094   0x....             LDR      R1,??DataTable11_4  ;; 0xffffc500
   \   00000096   0x1847             ADDS     R7,R0,R1
    616              } else
    617          #endif /* MBEDTLS_RSA_C */
    618          #if defined(MBEDTLS_ECP_C)
    619              if( pk_alg == MBEDTLS_PK_ECKEY_DH || pk_alg == MBEDTLS_PK_ECKEY )
    620              {
    621                  ret = pk_use_ecparams( &alg_params, &mbedtls_pk_ec( *pk )->grp );
    622                  if( ret == 0 )
    623                      ret = pk_get_ecpubkey( p, end, mbedtls_pk_ec( *pk ) );
    624              } else
    625          #endif /* MBEDTLS_ECP_C */
    626                  ret = MBEDTLS_ERR_PK_UNKNOWN_PK_ALG;
    627          
    628              if( ret == 0 && *p != end )
   \                     ??mbedtls_pk_parse_subpubkey_9: (+1)
   \   00000098   0x2F00             CMP      R7,#+0
   \   0000009A   0xD143             BNE      ??mbedtls_pk_parse_subpubkey_10
   \                     ??mbedtls_pk_parse_subpubkey_11: (+1)
   \   0000009C   0x6830             LDR      R0,[R6, #+0]
   \   0000009E   0x42A0             CMP      R0,R4
   \   000000A0   0xD043             BEQ      ??mbedtls_pk_parse_subpubkey_12
   \                     ??mbedtls_pk_parse_subpubkey_13: (+1)
   \   000000A2   0x....             LDR      R7,??DataTable11_5  ;; 0xffffc49a
   \   000000A4   0xE03E             B        ??mbedtls_pk_parse_subpubkey_10
   \                     ??mbedtls_pk_parse_subpubkey_7: (+1)
   \   000000A6   0x6830             LDR      R0,[R6, #+0]
   \   000000A8   0x9902             LDR      R1,[SP, #+8]
   \   000000AA   0x1840             ADDS     R0,R0,R1
   \   000000AC   0x42A0             CMP      R0,R4
   \   000000AE   0xD1F8             BNE      ??mbedtls_pk_parse_subpubkey_13
   \   000000B0   0x002A             MOVS     R2,R5
   \   000000B2   0x3208             ADDS     R2,R2,#+8
   \   000000B4   0x0021             MOVS     R1,R4
   \   000000B6   0x0030             MOVS     R0,R6
   \   000000B8   0x.... 0x....      BL       mbedtls_asn1_get_mpi
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD1E9             BNE      ??mbedtls_pk_parse_subpubkey_8
   \   000000C0   0x002A             MOVS     R2,R5
   \   000000C2   0x3214             ADDS     R2,R2,#+20
   \   000000C4   0x0021             MOVS     R1,R4
   \   000000C6   0x0030             MOVS     R0,R6
   \   000000C8   0x.... 0x....      BL       mbedtls_asn1_get_mpi
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD1E1             BNE      ??mbedtls_pk_parse_subpubkey_8
   \   000000D0   0x6830             LDR      R0,[R6, #+0]
   \   000000D2   0x42A0             CMP      R0,R4
   \   000000D4   0xD1E5             BNE      ??mbedtls_pk_parse_subpubkey_13
   \   000000D6   0x0028             MOVS     R0,R5
   \   000000D8   0x.... 0x....      BL       mbedtls_rsa_check_pubkey
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD001             BEQ      ??mbedtls_pk_parse_subpubkey_14
   \   000000E0   0x....             LDR      R7,??DataTable11_4  ;; 0xffffc500
   \   000000E2   0xE01F             B        ??mbedtls_pk_parse_subpubkey_10
   \                     ??mbedtls_pk_parse_subpubkey_14: (+1)
   \   000000E4   0x0028             MOVS     R0,R5
   \   000000E6   0x3008             ADDS     R0,R0,#+8
   \   000000E8   0x.... 0x....      BL       mbedtls_mpi_size
   \   000000EC   0x6068             STR      R0,[R5, #+4]
   \   000000EE   0xE7D5             B        ??mbedtls_pk_parse_subpubkey_11
   \                     ??mbedtls_pk_parse_subpubkey_6: (+1)
   \   000000F0   0x2803             CMP      R0,#+3
   \   000000F2   0xD001             BEQ      ??mbedtls_pk_parse_subpubkey_15
   \   000000F4   0x2802             CMP      R0,#+2
   \   000000F6   0xD114             BNE      ??mbedtls_pk_parse_subpubkey_16
   \                     ??mbedtls_pk_parse_subpubkey_15: (+1)
   \   000000F8   0x9806             LDR      R0,[SP, #+24]
   \   000000FA   0xC803             LDM      R0,{R0,R1}
   \   000000FC   0x.... 0x....      BL       mbedtls_pk_ec
   \   00000100   0x0001             MOVS     R1,R0
   \   00000102   0xA803             ADD      R0,SP,#+12
   \   00000104   0x.... 0x....      BL       pk_use_ecparams
   \   00000108   0x0007             MOVS     R7,R0
   \   0000010A   0xD1C5             BNE      ??mbedtls_pk_parse_subpubkey_9
   \   0000010C   0x9806             LDR      R0,[SP, #+24]
   \   0000010E   0xC803             LDM      R0,{R0,R1}
   \   00000110   0x.... 0x....      BL       mbedtls_pk_ec
   \   00000114   0x0002             MOVS     R2,R0
   \   00000116   0x0021             MOVS     R1,R4
   \   00000118   0x0030             MOVS     R0,R6
   \   0000011A   0x.... 0x....      BL       pk_get_ecpubkey
   \   0000011E   0x0007             MOVS     R7,R0
   \   00000120   0xE7BA             B        ??mbedtls_pk_parse_subpubkey_9
   \                     ??mbedtls_pk_parse_subpubkey_16: (+1)
   \   00000122   0x....             LDR      R7,??DataTable11_3  ;; 0xffffc380
    629                  ret = MBEDTLS_ERR_PK_INVALID_PUBKEY
    630                        MBEDTLS_ERR_ASN1_LENGTH_MISMATCH;
    631          
    632              if( ret != 0 )
    633                  mbedtls_pk_free( pk );
   \                     ??mbedtls_pk_parse_subpubkey_10: (+1)
   \   00000124   0x9806             LDR      R0,[SP, #+24]
   \   00000126   0x.... 0x....      BL       mbedtls_pk_free
    634          
    635              return( ret );
   \                     ??mbedtls_pk_parse_subpubkey_12: (+1)
   \   0000012A   0x0038             MOVS     R0,R7
   \                     ??mbedtls_pk_parse_subpubkey_2: (+1)
   \   0000012C   0xB007             ADD      SP,SP,#+28
   \   0000012E   0xBDF0             POP      {R4-R7,PC}       ;; return
    636          }
    637          
    638          #if defined(MBEDTLS_RSA_C)
    639          /*
    640           * Parse a PKCS#1 encoded private RSA key
    641           */

   \                                 In section .text, align 2, keep-with-next
    642          static int pk_parse_key_pkcs1_der( mbedtls_rsa_context *rsa,
    643                                             const unsigned char *key,
    644                                             size_t keylen )
    645          {
   \                     pk_parse_key_pkcs1_der: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0010             MOVS     R0,R2
    646              int ret;
    647              size_t len;
    648              unsigned char *p, *end;
    649          
    650              p = (unsigned char *) key;
   \   00000006   0x9100             STR      R1,[SP, #+0]
    651              end = p + keylen;
    652          
    653              /*
    654               * This function parses the RSAPrivateKey (PKCS#1)
    655               *
    656               *  RSAPrivateKey ::= SEQUENCE {
    657               *      version           Version,
    658               *      modulus           INTEGER,  -- n
    659               *      publicExponent    INTEGER,  -- e
    660               *      privateExponent   INTEGER,  -- d
    661               *      prime1            INTEGER,  -- p
    662               *      prime2            INTEGER,  -- q
    663               *      exponent1         INTEGER,  -- d mod (p-1)
    664               *      exponent2         INTEGER,  -- d mod (q-1)
    665               *      coefficient       INTEGER,  -- (inverse of q) mod p
    666               *      otherPrimeInfos   OtherPrimeInfos OPTIONAL
    667               *  }
    668               */
    669              if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    670                      MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
   \   00000008   0x2330             MOVS     R3,#+48
   \   0000000A   0xAA01             ADD      R2,SP,#+4
   \   0000000C   0x1809             ADDS     R1,R1,R0
   \   0000000E   0x4668             MOV      R0,SP
   \   00000010   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD109             BNE      ??pk_parse_key_pkcs1_der_0
    671              {
    672                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    673              }
    674          
    675              end = p + len;
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0x9901             LDR      R1,[SP, #+4]
   \   0000001C   0x1845             ADDS     R5,R0,R1
    676          
    677              if( ( ret = mbedtls_asn1_get_int( &p, end, &rsa->ver ) ) != 0 )
   \   0000001E   0x0022             MOVS     R2,R4
   \   00000020   0x0029             MOVS     R1,R5
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x.... 0x....      BL       mbedtls_asn1_get_int
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD002             BEQ      ??pk_parse_key_pkcs1_der_1
    678              {
    679                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
   \                     ??pk_parse_key_pkcs1_der_0: (+1)
   \   0000002C   0x....             LDR      R1,??DataTable11_1  ;; 0xffffc300
   \   0000002E   0x1840             ADDS     R0,R0,R1
   \   00000030   0xBD76             POP      {R1,R2,R4-R6,PC}
    680              }
    681          
    682              if( rsa->ver != 0 )
   \                     ??pk_parse_key_pkcs1_der_1: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD001             BEQ      ??pk_parse_key_pkcs1_der_2
    683              {
    684                  return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION );
   \   00000038   0x....             LDR      R0,??DataTable12  ;; 0xffffc280
   \   0000003A   0xBD76             POP      {R1,R2,R4-R6,PC}
    685              }
    686          
    687              if( ( ret = mbedtls_asn1_get_mpi( &p, end, &rsa->N  ) ) != 0 ||
    688                  ( ret = mbedtls_asn1_get_mpi( &p, end, &rsa->E  ) ) != 0 ||
    689                  ( ret = mbedtls_asn1_get_mpi( &p, end, &rsa->D  ) ) != 0 ||
    690                  ( ret = mbedtls_asn1_get_mpi( &p, end, &rsa->P  ) ) != 0 ||
    691                  ( ret = mbedtls_asn1_get_mpi( &p, end, &rsa->Q  ) ) != 0 ||
    692                  ( ret = mbedtls_asn1_get_mpi( &p, end, &rsa->DP ) ) != 0 ||
    693                  ( ret = mbedtls_asn1_get_mpi( &p, end, &rsa->DQ ) ) != 0 ||
    694                  ( ret = mbedtls_asn1_get_mpi( &p, end, &rsa->QP ) ) != 0 )
   \                     ??pk_parse_key_pkcs1_der_2: (+1)
   \   0000003C   0x0022             MOVS     R2,R4
   \   0000003E   0x3208             ADDS     R2,R2,#+8
   \   00000040   0x0029             MOVS     R1,R5
   \   00000042   0x4668             MOV      R0,SP
   \   00000044   0x.... 0x....      BL       mbedtls_asn1_get_mpi
   \   00000048   0x0006             MOVS     R6,R0
   \   0000004A   0xD137             BNE      ??pk_parse_key_pkcs1_der_3
   \   0000004C   0x0022             MOVS     R2,R4
   \   0000004E   0x3214             ADDS     R2,R2,#+20
   \   00000050   0x0029             MOVS     R1,R5
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0x.... 0x....      BL       mbedtls_asn1_get_mpi
   \   00000058   0x0006             MOVS     R6,R0
   \   0000005A   0xD12F             BNE      ??pk_parse_key_pkcs1_der_3
   \   0000005C   0x0022             MOVS     R2,R4
   \   0000005E   0x3220             ADDS     R2,R2,#+32
   \   00000060   0x0029             MOVS     R1,R5
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x.... 0x....      BL       mbedtls_asn1_get_mpi
   \   00000068   0x0006             MOVS     R6,R0
   \   0000006A   0xD127             BNE      ??pk_parse_key_pkcs1_der_3
   \   0000006C   0x0022             MOVS     R2,R4
   \   0000006E   0x322C             ADDS     R2,R2,#+44
   \   00000070   0x0029             MOVS     R1,R5
   \   00000072   0x4668             MOV      R0,SP
   \   00000074   0x.... 0x....      BL       mbedtls_asn1_get_mpi
   \   00000078   0x0006             MOVS     R6,R0
   \   0000007A   0xD11F             BNE      ??pk_parse_key_pkcs1_der_3
   \   0000007C   0x0022             MOVS     R2,R4
   \   0000007E   0x3238             ADDS     R2,R2,#+56
   \   00000080   0x0029             MOVS     R1,R5
   \   00000082   0x4668             MOV      R0,SP
   \   00000084   0x.... 0x....      BL       mbedtls_asn1_get_mpi
   \   00000088   0x0006             MOVS     R6,R0
   \   0000008A   0xD117             BNE      ??pk_parse_key_pkcs1_der_3
   \   0000008C   0x0022             MOVS     R2,R4
   \   0000008E   0x3244             ADDS     R2,R2,#+68
   \   00000090   0x0029             MOVS     R1,R5
   \   00000092   0x4668             MOV      R0,SP
   \   00000094   0x.... 0x....      BL       mbedtls_asn1_get_mpi
   \   00000098   0x0006             MOVS     R6,R0
   \   0000009A   0xD10F             BNE      ??pk_parse_key_pkcs1_der_3
   \   0000009C   0x0022             MOVS     R2,R4
   \   0000009E   0x3250             ADDS     R2,R2,#+80
   \   000000A0   0x0029             MOVS     R1,R5
   \   000000A2   0x4668             MOV      R0,SP
   \   000000A4   0x.... 0x....      BL       mbedtls_asn1_get_mpi
   \   000000A8   0x0006             MOVS     R6,R0
   \   000000AA   0xD107             BNE      ??pk_parse_key_pkcs1_der_3
   \   000000AC   0x0022             MOVS     R2,R4
   \   000000AE   0x325C             ADDS     R2,R2,#+92
   \   000000B0   0x0029             MOVS     R1,R5
   \   000000B2   0x4668             MOV      R0,SP
   \   000000B4   0x.... 0x....      BL       mbedtls_asn1_get_mpi
   \   000000B8   0x0006             MOVS     R6,R0
   \   000000BA   0xD005             BEQ      ??pk_parse_key_pkcs1_der_4
    695              {
    696                  mbedtls_rsa_free( rsa );
   \                     ??pk_parse_key_pkcs1_der_3: (+1)
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0x.... 0x....      BL       mbedtls_rsa_free
    697                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
   \   000000C2   0x....             LDR      R0,??DataTable11_1  ;; 0xffffc300
   \   000000C4   0x1830             ADDS     R0,R6,R0
   \   000000C6   0xBD76             POP      {R1,R2,R4-R6,PC}
    698              }
    699          
    700              rsa->len = mbedtls_mpi_size( &rsa->N );
   \                     ??pk_parse_key_pkcs1_der_4: (+1)
   \   000000C8   0x0020             MOVS     R0,R4
   \   000000CA   0x3008             ADDS     R0,R0,#+8
   \   000000CC   0x.... 0x....      BL       mbedtls_mpi_size
   \   000000D0   0x6060             STR      R0,[R4, #+4]
    701          
    702              if( p != end )
   \   000000D2   0x9800             LDR      R0,[SP, #+0]
   \   000000D4   0x42A8             CMP      R0,R5
   \   000000D6   0xD004             BEQ      ??pk_parse_key_pkcs1_der_5
    703              {
    704                  mbedtls_rsa_free( rsa );
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0x.... 0x....      BL       mbedtls_rsa_free
    705                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
    706                          MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
   \   000000DE   0x....             LDR      R0,??DataTable13  ;; 0xffffc29a
   \   000000E0   0xBD76             POP      {R1,R2,R4-R6,PC}
    707              }
    708          
    709              if( ( ret = mbedtls_rsa_check_privkey( rsa ) ) != 0 )
   \                     ??pk_parse_key_pkcs1_der_5: (+1)
   \   000000E2   0x0020             MOVS     R0,R4
   \   000000E4   0x.... 0x....      BL       mbedtls_rsa_check_privkey
   \   000000E8   0x0005             MOVS     R5,R0
   \   000000EA   0xD004             BEQ      ??pk_parse_key_pkcs1_der_6
    710              {
    711                  mbedtls_rsa_free( rsa );
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0x.... 0x....      BL       mbedtls_rsa_free
    712                  return( ret );
   \   000000F2   0x0028             MOVS     R0,R5
   \   000000F4   0xBD76             POP      {R1,R2,R4-R6,PC}
    713              }
    714          
    715              return( 0 );
   \                     ??pk_parse_key_pkcs1_der_6: (+1)
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    716          }
    717          #endif /* MBEDTLS_RSA_C */
    718          
    719          #if defined(MBEDTLS_ECP_C)
    720          /*
    721           * Parse a SEC1 encoded private EC key
    722           */

   \                                 In section .text, align 2, keep-with-next
    723          static int pk_parse_key_sec1_der( mbedtls_ecp_keypair *eck,
    724                                            const unsigned char *key,
    725                                            size_t keylen )
    726          {
   \                     pk_parse_key_sec1_der: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0010             MOVS     R0,R2
    727              int ret;
    728              int version, pubkey_done;
    729              size_t len;
    730              mbedtls_asn1_buf params;
    731              unsigned char *p = (unsigned char *) key;
   \   00000008   0x9102             STR      R1,[SP, #+8]
    732              unsigned char *end = p + keylen;
    733              unsigned char *end2;
    734          
    735              /*
    736               * RFC 5915, or SEC1 Appendix C.4
    737               *
    738               * ECPrivateKey ::= SEQUENCE {
    739               *      version        INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
    740               *      privateKey     OCTET STRING,
    741               *      parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,
    742               *      publicKey  [1] BIT STRING OPTIONAL
    743               *    }
    744               */
    745              if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    746                      MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
   \   0000000A   0x2330             MOVS     R3,#+48
   \   0000000C   0xAA03             ADD      R2,SP,#+12
   \   0000000E   0x1809             ADDS     R1,R1,R0
   \   00000010   0xA802             ADD      R0,SP,#+8
   \   00000012   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD172             BNE      ??pk_parse_key_sec1_der_0
    747              {
    748                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    749              }
    750          
    751              end = p + len;
   \   0000001A   0x9802             LDR      R0,[SP, #+8]
   \   0000001C   0x9903             LDR      R1,[SP, #+12]
   \   0000001E   0x1845             ADDS     R5,R0,R1
    752          
    753              if( ( ret = mbedtls_asn1_get_int( &p, end, &version ) ) != 0 )
   \   00000020   0xAA04             ADD      R2,SP,#+16
   \   00000022   0x0029             MOVS     R1,R5
   \   00000024   0xA802             ADD      R0,SP,#+8
   \   00000026   0x.... 0x....      BL       mbedtls_asn1_get_int
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD168             BNE      ??pk_parse_key_sec1_der_0
    754                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    755          
    756              if( version != 1 )
   \   0000002E   0x9804             LDR      R0,[SP, #+16]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD001             BEQ      ??pk_parse_key_sec1_der_1
    757                  return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION );
   \   00000034   0x....             LDR      R0,??DataTable12  ;; 0xffffc280
   \   00000036   0xE09E             B        ??pk_parse_key_sec1_der_2
    758          
    759              if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
   \                     ??pk_parse_key_sec1_der_1: (+1)
   \   00000038   0x2304             MOVS     R3,#+4
   \   0000003A   0xAA03             ADD      R2,SP,#+12
   \   0000003C   0x0029             MOVS     R1,R5
   \   0000003E   0xA802             ADD      R0,SP,#+8
   \   00000040   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD15B             BNE      ??pk_parse_key_sec1_der_0
    760                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    761          
    762              if( ( ret = mbedtls_mpi_read_binary( &eck->d, p, len ) ) != 0 )
   \   00000048   0x9A03             LDR      R2,[SP, #+12]
   \   0000004A   0x9902             LDR      R1,[SP, #+8]
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x307C             ADDS     R0,R0,#+124
   \   00000050   0x.... 0x....      BL       mbedtls_mpi_read_binary
   \   00000054   0x0006             MOVS     R6,R0
   \   00000056   0xD13B             BNE      ??pk_parse_key_sec1_der_3
    763              {
    764                  mbedtls_ecp_keypair_free( eck );
    765                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    766              }
    767          
    768              p += len;
   \   00000058   0x9802             LDR      R0,[SP, #+8]
   \   0000005A   0x9903             LDR      R1,[SP, #+12]
   \   0000005C   0x1840             ADDS     R0,R0,R1
   \   0000005E   0x9002             STR      R0,[SP, #+8]
    769          
    770              pubkey_done = 0;
    771              if( p != end )
   \   00000060   0x42A8             CMP      R0,R5
   \   00000062   0xD067             BEQ      ??pk_parse_key_sec1_der_4
    772              {
    773                  /*
    774                   * Is 'parameters' present?
    775                   */
    776                  if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    777                                  MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 0 ) ) == 0 )
   \   00000064   0x23A0             MOVS     R3,#+160
   \   00000066   0xAA03             ADD      R2,SP,#+12
   \   00000068   0x0029             MOVS     R1,R5
   \   0000006A   0xA802             ADD      R0,SP,#+8
   \   0000006C   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \   00000070   0x0006             MOVS     R6,R0
   \   00000072   0xD129             BNE      ??pk_parse_key_sec1_der_5
    778                  {
    779                      if( ( ret = pk_get_ecparams( &p, p + len, &params) ) != 0 ||
    780                          ( ret = pk_use_ecparams( &params, &eck->grp )  ) != 0 )
   \   00000074   0x9802             LDR      R0,[SP, #+8]
   \   00000076   0x9903             LDR      R1,[SP, #+12]
   \   00000078   0x1846             ADDS     R6,R0,R1
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0x9005             STR      R0,[SP, #+20]
   \   0000007E   0x2806             CMP      R0,#+6
   \   00000080   0xD001             BEQ      ??pk_parse_key_sec1_der_6
   \   00000082   0x....             LDR      R6,??DataTable13_1  ;; 0xffffc29e
   \   00000084   0xE011             B        ??pk_parse_key_sec1_der_7
   \                     ??pk_parse_key_sec1_der_6: (+1)
   \   00000086   0x2306             MOVS     R3,#+6
   \   00000088   0xA805             ADD      R0,SP,#+20
   \   0000008A   0x1D02             ADDS     R2,R0,#+4
   \   0000008C   0x0031             MOVS     R1,R6
   \   0000008E   0xA802             ADD      R0,SP,#+8
   \   00000090   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD00D             BEQ      ??pk_parse_key_sec1_der_8
   \   00000098   0x....             LDR      R1,??DataTable13_2  ;; 0xffffc300
   \   0000009A   0x1846             ADDS     R6,R0,R1
   \   0000009C   0xD105             BNE      ??pk_parse_key_sec1_der_7
   \                     ??pk_parse_key_sec1_der_9: (+1)
   \   0000009E   0x0021             MOVS     R1,R4
   \   000000A0   0xA805             ADD      R0,SP,#+20
   \   000000A2   0x.... 0x....      BL       pk_use_ecparams
   \   000000A6   0x0006             MOVS     R6,R0
   \   000000A8   0xD018             BEQ      ??pk_parse_key_sec1_der_10
    781                      {
    782                          mbedtls_ecp_keypair_free( eck );
   \                     ??pk_parse_key_sec1_der_7: (+1)
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       mbedtls_ecp_keypair_free
    783                          return( ret );
   \   000000B0   0x0030             MOVS     R0,R6
   \   000000B2   0xE060             B        ??pk_parse_key_sec1_der_2
   \                     ??pk_parse_key_sec1_der_8: (+1)
   \   000000B4   0x9802             LDR      R0,[SP, #+8]
   \   000000B6   0x9007             STR      R0,[SP, #+28]
   \   000000B8   0x9802             LDR      R0,[SP, #+8]
   \   000000BA   0x9906             LDR      R1,[SP, #+24]
   \   000000BC   0x1840             ADDS     R0,R0,R1
   \   000000BE   0x9002             STR      R0,[SP, #+8]
   \   000000C0   0x42B0             CMP      R0,R6
   \   000000C2   0xD0EC             BEQ      ??pk_parse_key_sec1_der_9
   \   000000C4   0x....             LDR      R6,??DataTable13  ;; 0xffffc29a
   \   000000C6   0xE7F0             B        ??pk_parse_key_sec1_der_7
    784                      }
    785                  }
    786                  else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
   \                     ??pk_parse_key_sec1_der_5: (+1)
   \   000000C8   0x2061             MOVS     R0,#+97
   \   000000CA   0x43C0             MVNS     R0,R0            ;; #-98
   \   000000CC   0x4286             CMP      R6,R0
   \   000000CE   0xD005             BEQ      ??pk_parse_key_sec1_der_10
    787                  {
    788                      mbedtls_ecp_keypair_free( eck );
   \                     ??pk_parse_key_sec1_der_3: (+1)
   \   000000D0   0x0020             MOVS     R0,R4
   \   000000D2   0x.... 0x....      BL       mbedtls_ecp_keypair_free
    789                      return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
   \   000000D6   0x....             LDR      R0,??DataTable13_2  ;; 0xffffc300
   \   000000D8   0x1830             ADDS     R0,R6,R0
   \   000000DA   0xE04C             B        ??pk_parse_key_sec1_der_2
    790                  }
    791          
    792                  /*
    793                   * Is 'publickey' present? If not, or if we can't read it (eg because it
    794                   * is compressed), create it from the private key.
    795                   */
    796                  if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    797                                  MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 1 ) ) == 0 )
   \                     ??pk_parse_key_sec1_der_10: (+1)
   \   000000DC   0x23A1             MOVS     R3,#+161
   \   000000DE   0xAA03             ADD      R2,SP,#+12
   \   000000E0   0x0029             MOVS     R1,R5
   \   000000E2   0xA802             ADD      R0,SP,#+8
   \   000000E4   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \   000000E8   0x0005             MOVS     R5,R0
   \   000000EA   0xD11F             BNE      ??pk_parse_key_sec1_der_11
    798                  {
    799                      end2 = p + len;
   \   000000EC   0x9802             LDR      R0,[SP, #+8]
   \   000000EE   0x9903             LDR      R1,[SP, #+12]
   \   000000F0   0x1845             ADDS     R5,R0,R1
    800          
    801                      if( ( ret = mbedtls_asn1_get_bitstring_null( &p, end2, &len ) ) != 0 )
   \   000000F2   0xAA03             ADD      R2,SP,#+12
   \   000000F4   0x0029             MOVS     R1,R5
   \   000000F6   0xA802             ADD      R0,SP,#+8
   \   000000F8   0x.... 0x....      BL       mbedtls_asn1_get_bitstring_null
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD002             BEQ      ??pk_parse_key_sec1_der_12
    802                          return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
   \                     ??pk_parse_key_sec1_der_0: (+1)
   \   00000100   0x....             LDR      R1,??DataTable13_2  ;; 0xffffc300
   \   00000102   0x1840             ADDS     R0,R0,R1
   \   00000104   0xE037             B        ??pk_parse_key_sec1_der_2
    803          
    804                      if( p + len != end2 )
   \                     ??pk_parse_key_sec1_der_12: (+1)
   \   00000106   0x9802             LDR      R0,[SP, #+8]
   \   00000108   0x9903             LDR      R1,[SP, #+12]
   \   0000010A   0x1840             ADDS     R0,R0,R1
   \   0000010C   0x42A8             CMP      R0,R5
   \   0000010E   0xD001             BEQ      ??pk_parse_key_sec1_der_13
    805                          return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
    806                                  MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
   \   00000110   0x....             LDR      R0,??DataTable13  ;; 0xffffc29a
   \   00000112   0xE030             B        ??pk_parse_key_sec1_der_2
    807          
    808                      if( ( ret = pk_get_ecpubkey( &p, end2, eck ) ) == 0 )
   \                     ??pk_parse_key_sec1_der_13: (+1)
   \   00000114   0x0022             MOVS     R2,R4
   \   00000116   0x0029             MOVS     R1,R5
   \   00000118   0xA802             ADD      R0,SP,#+8
   \   0000011A   0x.... 0x....      BL       pk_get_ecpubkey
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD01C             BEQ      ??pk_parse_key_sec1_der_14
    809                          pubkey_done = 1;
    810                      else
    811                      {
    812                          /*
    813                           * The only acceptable failure mode of pk_get_ecpubkey() above
    814                           * is if the point format is not recognized.
    815                           */
    816                          if( ret != MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE )
   \   00000122   0x....             LDR      R1,??DataTable13_3  ;; 0xffffb180
   \   00000124   0x4288             CMP      R0,R1
   \   00000126   0xD005             BEQ      ??pk_parse_key_sec1_der_4
    817                              return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
   \   00000128   0x....             LDR      R0,??DataTable13_2  ;; 0xffffc300
   \   0000012A   0xE024             B        ??pk_parse_key_sec1_der_2
    818                      }
    819                  }
    820                  else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
   \                     ??pk_parse_key_sec1_der_11: (+1)
   \   0000012C   0x2061             MOVS     R0,#+97
   \   0000012E   0x43C0             MVNS     R0,R0            ;; #-98
   \   00000130   0x4285             CMP      R5,R0
   \   00000132   0xD10D             BNE      ??pk_parse_key_sec1_der_15
   \                     ??pk_parse_key_sec1_der_4: (+1)
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0x9001             STR      R0,[SP, #+4]
   \   00000138   0x9000             STR      R0,[SP, #+0]
   \   0000013A   0x0023             MOVS     R3,R4
   \   0000013C   0x3328             ADDS     R3,R3,#+40
   \   0000013E   0x0022             MOVS     R2,R4
   \   00000140   0x327C             ADDS     R2,R2,#+124
   \   00000142   0x0021             MOVS     R1,R4
   \   00000144   0x3188             ADDS     R1,R1,#+136
   \   00000146   0x0020             MOVS     R0,R4
   \   00000148   0x.... 0x....      BL       mbedtls_ecp_mul
   \   0000014C   0x0005             MOVS     R5,R0
   \   0000014E   0xD005             BEQ      ??pk_parse_key_sec1_der_14
    821                  {
    822                      mbedtls_ecp_keypair_free( eck );
    823                      return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    824                  }
    825              }
    826          
    827              if( ! pubkey_done &&
    828                  ( ret = mbedtls_ecp_mul( &eck->grp, &eck->Q, &eck->d, &eck->grp.G,
    829                                                                NULL, NULL ) ) != 0 )
    830              {
    831                  mbedtls_ecp_keypair_free( eck );
   \                     ??pk_parse_key_sec1_der_15: (+1)
   \   00000150   0x0020             MOVS     R0,R4
   \   00000152   0x.... 0x....      BL       mbedtls_ecp_keypair_free
    832                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
   \   00000156   0x....             LDR      R0,??DataTable13_2  ;; 0xffffc300
   \   00000158   0x1828             ADDS     R0,R5,R0
   \   0000015A   0xE00C             B        ??pk_parse_key_sec1_der_2
    833              }
    834          
    835              if( ( ret = mbedtls_ecp_check_privkey( &eck->grp, &eck->d ) ) != 0 )
   \                     ??pk_parse_key_sec1_der_14: (+1)
   \   0000015C   0x0021             MOVS     R1,R4
   \   0000015E   0x317C             ADDS     R1,R1,#+124
   \   00000160   0x0020             MOVS     R0,R4
   \   00000162   0x.... 0x....      BL       mbedtls_ecp_check_privkey
   \   00000166   0x0005             MOVS     R5,R0
   \   00000168   0xD004             BEQ      ??pk_parse_key_sec1_der_16
    836              {
    837                  mbedtls_ecp_keypair_free( eck );
   \   0000016A   0x0020             MOVS     R0,R4
   \   0000016C   0x.... 0x....      BL       mbedtls_ecp_keypair_free
    838                  return( ret );
   \   00000170   0x0028             MOVS     R0,R5
   \   00000172   0xE000             B        ??pk_parse_key_sec1_der_2
    839              }
    840          
    841              return( 0 );
   \                     ??pk_parse_key_sec1_der_16: (+1)
   \   00000174   0x2000             MOVS     R0,#+0
   \                     ??pk_parse_key_sec1_der_2: (+1)
   \   00000176   0xB008             ADD      SP,SP,#+32
   \   00000178   0xBD70             POP      {R4-R6,PC}       ;; return
    842          }
    843          #endif /* MBEDTLS_ECP_C */
    844          
    845          /*
    846           * Parse an unencrypted PKCS#8 encoded private key
    847           */

   \                                 In section .text, align 2, keep-with-next
    848          static int pk_parse_key_pkcs8_unencrypted_der(
    849                                              mbedtls_pk_context *pk,
    850                                              const unsigned char* key,
    851                                              size_t keylen )
    852          {
   \                     pk_parse_key_pkcs8_unencrypted_der: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0010             MOVS     R0,R2
    853              int ret, version;
    854              size_t len;
    855              mbedtls_asn1_buf params;
    856              unsigned char *p = (unsigned char *) key;
   \   00000008   0x9100             STR      R1,[SP, #+0]
    857              unsigned char *end = p + keylen;
    858              mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x466A             MOV      R2,SP
   \   0000000E   0x7211             STRB     R1,[R2, #+8]
    859              const mbedtls_pk_info_t *pk_info;
    860          
    861              /*
    862               * This function parses the PrivatKeyInfo object (PKCS#8 v1.2 = RFC 5208)
    863               *
    864               *    PrivateKeyInfo ::= SEQUENCE {
    865               *      version                   Version,
    866               *      privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
    867               *      privateKey                PrivateKey,
    868               *      attributes           [0]  IMPLICIT Attributes OPTIONAL }
    869               *
    870               *    Version ::= INTEGER
    871               *    PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
    872               *    PrivateKey ::= OCTET STRING
    873               *
    874               *  The PrivateKey OCTET STRING is a SEC1 ECPrivateKey
    875               */
    876          
    877              if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    878                      MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
   \   00000010   0x2330             MOVS     R3,#+48
   \   00000012   0xAA01             ADD      R2,SP,#+4
   \   00000014   0x9900             LDR      R1,[SP, #+0]
   \   00000016   0x1809             ADDS     R1,R1,R0
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD11E             BNE      ??pk_parse_key_pkcs8_unencrypted_der_0
    879              {
    880                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    881              }
    882          
    883              end = p + len;
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0x9901             LDR      R1,[SP, #+4]
   \   00000026   0x1845             ADDS     R5,R0,R1
    884          
    885              if( ( ret = mbedtls_asn1_get_int( &p, end, &version ) ) != 0 )
   \   00000028   0xAA03             ADD      R2,SP,#+12
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0x4668             MOV      R0,SP
   \   0000002E   0x.... 0x....      BL       mbedtls_asn1_get_int
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD114             BNE      ??pk_parse_key_pkcs8_unencrypted_der_0
    886                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    887          
    888              if( version != 0 )
   \   00000036   0x9803             LDR      R0,[SP, #+12]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD001             BEQ      ??pk_parse_key_pkcs8_unencrypted_der_1
    889                  return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION + ret );
   \   0000003C   0x....             LDR      R0,??DataTable14  ;; 0xffffc280
   \   0000003E   0xE051             B        ??pk_parse_key_pkcs8_unencrypted_der_2
    890          
    891              if( ( ret = pk_get_pk_alg( &p, end, &pk_alg, &params ) ) != 0 )
   \                     ??pk_parse_key_pkcs8_unencrypted_der_1: (+1)
   \   00000040   0xAB04             ADD      R3,SP,#+16
   \   00000042   0xAA02             ADD      R2,SP,#+8
   \   00000044   0x0029             MOVS     R1,R5
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x.... 0x....      BL       pk_get_pk_alg
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD107             BNE      ??pk_parse_key_pkcs8_unencrypted_der_0
    892                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    893          
    894              if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
   \   00000050   0x2304             MOVS     R3,#+4
   \   00000052   0xAA01             ADD      R2,SP,#+4
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x4668             MOV      R0,SP
   \   00000058   0x.... 0x....      BL       mbedtls_asn1_get_tag
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD002             BEQ      ??pk_parse_key_pkcs8_unencrypted_der_3
    895                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
   \                     ??pk_parse_key_pkcs8_unencrypted_der_0: (+1)
   \   00000060   0x....             LDR      R1,??DataTable13_2  ;; 0xffffc300
   \   00000062   0x1840             ADDS     R0,R0,R1
   \   00000064   0xE03E             B        ??pk_parse_key_pkcs8_unencrypted_der_2
    896          
    897              if( len < 1 )
   \                     ??pk_parse_key_pkcs8_unencrypted_der_3: (+1)
   \   00000066   0x9801             LDR      R0,[SP, #+4]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD101             BNE      ??pk_parse_key_pkcs8_unencrypted_der_4
    898                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
    899                          MBEDTLS_ERR_ASN1_OUT_OF_DATA );
   \   0000006C   0x....             LDR      R0,??DataTable15  ;; 0xffffc2a0
   \   0000006E   0xE039             B        ??pk_parse_key_pkcs8_unencrypted_der_2
    900          
    901              if( ( pk_info = mbedtls_pk_info_from_type( pk_alg ) ) == NULL )
   \                     ??pk_parse_key_pkcs8_unencrypted_der_4: (+1)
   \   00000070   0x4668             MOV      R0,SP
   \   00000072   0x7A00             LDRB     R0,[R0, #+8]
   \   00000074   0x.... 0x....      BL       mbedtls_pk_info_from_type
   \   00000078   0x0001             MOVS     R1,R0
   \   0000007A   0xD030             BEQ      ??pk_parse_key_pkcs8_unencrypted_der_5
    902                  return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
    903          
    904              if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 )
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       mbedtls_pk_setup
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD12E             BNE      ??pk_parse_key_pkcs8_unencrypted_der_2
    905                  return( ret );
    906          
    907          #if defined(MBEDTLS_RSA_C)
    908              if( pk_alg == MBEDTLS_PK_RSA )
   \   00000086   0x4668             MOV      R0,SP
   \   00000088   0x7A00             LDRB     R0,[R0, #+8]
   \   0000008A   0x2801             CMP      R0,#+1
   \   0000008C   0xD10A             BNE      ??pk_parse_key_pkcs8_unencrypted_der_6
    909              {
    910                  if( ( ret = pk_parse_key_pkcs1_der( mbedtls_pk_rsa( *pk ), p, len ) ) != 0 )
   \   0000008E   0xCC03             LDM      R4!,{R0,R1}
   \   00000090   0x3C08             SUBS     R4,R4,#+8
   \   00000092   0x.... 0x....      BL       mbedtls_pk_rsa
   \   00000096   0x9A01             LDR      R2,[SP, #+4]
   \   00000098   0x9900             LDR      R1,[SP, #+0]
   \   0000009A   0x.... 0x....      BL       pk_parse_key_pkcs1_der
   \   0000009E   0x0005             MOVS     R5,R0
   \   000000A0   0xD01F             BEQ      ??pk_parse_key_pkcs8_unencrypted_der_7
    911                  {
    912                      mbedtls_pk_free( pk );
   \   000000A2   0xE017             B.N      ??pk_parse_key_pkcs8_unencrypted_der_8
    913                      return( ret );
    914                  }
    915              } else
    916          #endif /* MBEDTLS_RSA_C */
    917          #if defined(MBEDTLS_ECP_C)
    918              if( pk_alg == MBEDTLS_PK_ECKEY || pk_alg == MBEDTLS_PK_ECKEY_DH )
   \                     ??pk_parse_key_pkcs8_unencrypted_der_6: (+1)
   \   000000A4   0x2802             CMP      R0,#+2
   \   000000A6   0xD001             BEQ      ??pk_parse_key_pkcs8_unencrypted_der_9
   \   000000A8   0x2803             CMP      R0,#+3
   \   000000AA   0xD118             BNE      ??pk_parse_key_pkcs8_unencrypted_der_5
    919              {
    920                  if( ( ret = pk_use_ecparams( &params, &mbedtls_pk_ec( *pk )->grp ) ) != 0 ||
    921                      ( ret = pk_parse_key_sec1_der( mbedtls_pk_ec( *pk ), p, len )  ) != 0 )
   \                     ??pk_parse_key_pkcs8_unencrypted_der_9: (+1)
   \   000000AC   0xCC03             LDM      R4!,{R0,R1}
   \   000000AE   0x3C08             SUBS     R4,R4,#+8
   \   000000B0   0x.... 0x....      BL       mbedtls_pk_ec
   \   000000B4   0x0001             MOVS     R1,R0
   \   000000B6   0xA804             ADD      R0,SP,#+16
   \   000000B8   0x.... 0x....      BL       pk_use_ecparams
   \   000000BC   0x0005             MOVS     R5,R0
   \   000000BE   0xD109             BNE      ??pk_parse_key_pkcs8_unencrypted_der_8
   \   000000C0   0xCC03             LDM      R4!,{R0,R1}
   \   000000C2   0x3C08             SUBS     R4,R4,#+8
   \   000000C4   0x.... 0x....      BL       mbedtls_pk_ec
   \   000000C8   0x9A01             LDR      R2,[SP, #+4]
   \   000000CA   0x9900             LDR      R1,[SP, #+0]
   \   000000CC   0x.... 0x....      BL       pk_parse_key_sec1_der
   \   000000D0   0x0005             MOVS     R5,R0
   \   000000D2   0xD006             BEQ      ??pk_parse_key_pkcs8_unencrypted_der_7
    922                  {
    923                      mbedtls_pk_free( pk );
   \                     ??pk_parse_key_pkcs8_unencrypted_der_8: (+1)
   \   000000D4   0x0020             MOVS     R0,R4
   \   000000D6   0x.... 0x....      BL       mbedtls_pk_free
    924                      return( ret );
   \   000000DA   0x0028             MOVS     R0,R5
   \   000000DC   0xE002             B        ??pk_parse_key_pkcs8_unencrypted_der_2
    925                  }
    926              } else
    927          #endif /* MBEDTLS_ECP_C */
    928                  return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
   \                     ??pk_parse_key_pkcs8_unencrypted_der_5: (+1)
   \   000000DE   0x....             LDR      R0,??DataTable15_1  ;; 0xffffc380
   \   000000E0   0xE000             B        ??pk_parse_key_pkcs8_unencrypted_der_2
    929          
    930              return( 0 );
   \                     ??pk_parse_key_pkcs8_unencrypted_der_7: (+1)
   \   000000E2   0x2000             MOVS     R0,#+0
   \                     ??pk_parse_key_pkcs8_unencrypted_der_2: (+1)
   \   000000E4   0xB007             ADD      SP,SP,#+28
   \   000000E6   0xBD30             POP      {R4,R5,PC}       ;; return
    931          }
    932          
    933          /*
    934           * Parse an encrypted PKCS#8 encoded private key
    935           */
    936          #if defined(MBEDTLS_PKCS12_C) || defined(MBEDTLS_PKCS5_C)
    937          static int pk_parse_key_pkcs8_encrypted_der(
    938                                              mbedtls_pk_context *pk,
    939                                              const unsigned char *key, size_t keylen,
    940                                              const unsigned char *pwd, size_t pwdlen )
    941          {
    942              int ret, decrypted = 0;
    943              size_t len;
    944              unsigned char buf[2048];
    945              unsigned char *p, *end;
    946              mbedtls_asn1_buf pbe_alg_oid, pbe_params;
    947          #if defined(MBEDTLS_PKCS12_C)
    948              mbedtls_cipher_type_t cipher_alg;
    949              mbedtls_md_type_t md_alg;
    950          #endif
    951          
    952              memset( buf, 0, sizeof( buf ) );
    953          
    954              p = (unsigned char *) key;
    955              end = p + keylen;
    956          
    957              if( pwdlen == 0 )
    958                  return( MBEDTLS_ERR_PK_PASSWORD_REQUIRED );
    959          
    960              /*
    961               * This function parses the EncryptedPrivatKeyInfo object (PKCS#8)
    962               *
    963               *  EncryptedPrivateKeyInfo ::= SEQUENCE {
    964               *    encryptionAlgorithm  EncryptionAlgorithmIdentifier,
    965               *    encryptedData        EncryptedData
    966               *  }
    967               *
    968               *  EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
    969               *
    970               *  EncryptedData ::= OCTET STRING
    971               *
    972               *  The EncryptedData OCTET STRING is a PKCS#8 PrivateKeyInfo
    973               */
    974              if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    975                      MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
    976              {
    977                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    978              }
    979          
    980              end = p + len;
    981          
    982              if( ( ret = mbedtls_asn1_get_alg( &p, end, &pbe_alg_oid, &pbe_params ) ) != 0 )
    983                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    984          
    985              if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
    986                  return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
    987          
    988              if( len > sizeof( buf ) )
    989                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
    990          
    991              /*
    992               * Decrypt EncryptedData with appropriate PDE
    993               */
    994          #if defined(MBEDTLS_PKCS12_C)
    995              if( mbedtls_oid_get_pkcs12_pbe_alg( &pbe_alg_oid, &md_alg, &cipher_alg ) == 0 )
    996              {
    997                  if( ( ret = mbedtls_pkcs12_pbe( &pbe_params, MBEDTLS_PKCS12_PBE_DECRYPT,
    998                                          cipher_alg, md_alg,
    999                                          pwd, pwdlen, p, len, buf ) ) != 0 )
   1000                  {
   1001                      if( ret == MBEDTLS_ERR_PKCS12_PASSWORD_MISMATCH )
   1002                          return( MBEDTLS_ERR_PK_PASSWORD_MISMATCH );
   1003          
   1004                      return( ret );
   1005                  }
   1006          
   1007                  decrypted = 1;
   1008              }
   1009              else if( MBEDTLS_OID_CMP( MBEDTLS_OID_PKCS12_PBE_SHA1_RC4_128, &pbe_alg_oid ) == 0 )
   1010              {
   1011                  if( ( ret = mbedtls_pkcs12_pbe_sha1_rc4_128( &pbe_params,
   1012                                                       MBEDTLS_PKCS12_PBE_DECRYPT,
   1013                                                       pwd, pwdlen,
   1014                                                       p, len, buf ) ) != 0 )
   1015                  {
   1016                      return( ret );
   1017                  }
   1018          
   1019                  // Best guess for password mismatch when using RC4. If first tag is
   1020                  // not MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE
   1021                  //
   1022                  if( *buf != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) )
   1023                      return( MBEDTLS_ERR_PK_PASSWORD_MISMATCH );
   1024          
   1025                  decrypted = 1;
   1026              }
   1027              else
   1028          #endif /* MBEDTLS_PKCS12_C */
   1029          #if defined(MBEDTLS_PKCS5_C)
   1030              if( MBEDTLS_OID_CMP( MBEDTLS_OID_PKCS5_PBES2, &pbe_alg_oid ) == 0 )
   1031              {
   1032                  if( ( ret = mbedtls_pkcs5_pbes2( &pbe_params, MBEDTLS_PKCS5_DECRYPT, pwd, pwdlen,
   1033                                            p, len, buf ) ) != 0 )
   1034                  {
   1035                      if( ret == MBEDTLS_ERR_PKCS5_PASSWORD_MISMATCH )
   1036                          return( MBEDTLS_ERR_PK_PASSWORD_MISMATCH );
   1037          
   1038                      return( ret );
   1039                  }
   1040          
   1041                  decrypted = 1;
   1042              }
   1043              else
   1044          #endif /* MBEDTLS_PKCS5_C */
   1045              {
   1046                  ((void) pwd);
   1047              }
   1048          
   1049              if( decrypted == 0 )
   1050                  return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );
   1051          
   1052              return( pk_parse_key_pkcs8_unencrypted_der( pk, buf, len ) );
   1053          }
   1054          #endif /* MBEDTLS_PKCS12_C || MBEDTLS_PKCS5_C */
   1055          
   1056          /*
   1057           * Parse a private key
   1058           */

   \                                 In section .text, align 4, keep-with-next
   1059          int mbedtls_pk_parse_key( mbedtls_pk_context *pk,
   1060                            const unsigned char *key, size_t keylen,
   1061                            const unsigned char *pwd, size_t pwdlen )
   1062          {
   \                     mbedtls_pk_parse_key: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0017             MOVS     R7,R2
   1063              int ret;
   1064              const mbedtls_pk_info_t *pk_info;
   1065          
   1066          #if defined(MBEDTLS_PEM_PARSE_C)
   1067              size_t len;
   1068              mbedtls_pem_context pem;
   1069          
   1070              mbedtls_pem_init( &pem );
   \   0000000A   0xA804             ADD      R0,SP,#+16
   \   0000000C   0x.... 0x....      BL       mbedtls_pem_init
   1071          
   1072          #if defined(MBEDTLS_RSA_C)
   1073              /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */
   1074              if( keylen == 0 || key[keylen - 1] != '\0' )
   \   00000010   0x2F00             CMP      R7,#+0
   \   00000012   0xD100             BNE      .+4
   \   00000014   0xE096             B        ??mbedtls_pk_parse_key_0
   \   00000016   0x19E8             ADDS     R0,R5,R7
   \   00000018   0x1E40             SUBS     R0,R0,#+1
   \   0000001A   0x9003             STR      R0,[SP, #+12]
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD12E             BNE      ??mbedtls_pk_parse_key_1
   1075                  ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;
   1076              else
   1077                  ret = mbedtls_pem_read_buffer( &pem,
   1078                                         "-----BEGIN RSA PRIVATE KEY-----",
   1079                                         "-----END RSA PRIVATE KEY-----",
   1080                                         key, pwd, pwdlen, &len );
   \   00000022   0xA807             ADD      R0,SP,#+28
   \   00000024   0x9002             STR      R0,[SP, #+8]
   \   00000026   0x980E             LDR      R0,[SP, #+56]
   \   00000028   0x9001             STR      R0,[SP, #+4]
   \   0000002A   0x9808             LDR      R0,[SP, #+32]
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0x002B             MOVS     R3,R5
   \   00000030   0x....             ADR.N    R2,?_1
   \   00000032   0xBF00             Nop      
   \   00000034   0x....             ADR.N    R1,?_0
   \   00000036   0xA804             ADD      R0,SP,#+16
   \   00000038   0x.... 0x....      BL       mbedtls_pem_read_buffer
   \   0000003C   0x0006             MOVS     R6,R0
   1081          
   1082              if( ret == 0 )
   \   0000003E   0xD116             BNE      ??mbedtls_pk_parse_key_2
   1083              {
   1084                  if( ( pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA ) ) == NULL )
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       mbedtls_pk_info_from_type
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD100             BNE      .+4
   \   0000004A   0xE0A2             B        ??mbedtls_pk_parse_key_3
   1085                      return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
   1086          
   1087                  if( ( ret = mbedtls_pk_setup( pk, pk_info                    ) ) != 0 ||
   1088                      ( ret = pk_parse_key_pkcs1_der( mbedtls_pk_rsa( *pk ),
   1089                                                      pem.buf, pem.buflen ) ) != 0 )
   \   0000004C   0x0001             MOVS     R1,R0
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       mbedtls_pk_setup
   \   00000054   0x0006             MOVS     R6,R0
   \   00000056   0xD13B             BNE      ??mbedtls_pk_parse_key_4
   \   00000058   0xCC03             LDM      R4!,{R0,R1}
   \   0000005A   0x3C08             SUBS     R4,R4,#+8
   \   0000005C   0x.... 0x....      BL       mbedtls_pk_rsa
   \   00000060   0x9A05             LDR      R2,[SP, #+20]
   \   00000062   0x9904             LDR      R1,[SP, #+16]
   \   00000064   0x.... 0x....      BL       pk_parse_key_pkcs1_der
   \   00000068   0x0006             MOVS     R6,R0
   \   0000006A   0xD131             BNE      ??mbedtls_pk_parse_key_4
   \   0000006C   0xE033             B        ??mbedtls_pk_parse_key_5
   1090                  {
   1091                      mbedtls_pk_free( pk );
   1092                  }
   1093          
   1094                  mbedtls_pem_free( &pem );
   1095                  return( ret );
   1096              }
   1097              else if( ret == MBEDTLS_ERR_PEM_PASSWORD_MISMATCH )
   \                     ??mbedtls_pk_parse_key_2: (+1)
   \   0000006E   0x....             LDR      R0,??DataTable15_2  ;; 0xffffec80
   \   00000070   0x4286             CMP      R6,R0
   \   00000072   0xD037             BEQ      ??mbedtls_pk_parse_key_6
   1098                  return( MBEDTLS_ERR_PK_PASSWORD_MISMATCH );
   1099              else if( ret == MBEDTLS_ERR_PEM_PASSWORD_REQUIRED )
   \   00000074   0x....             LDR      R0,??DataTable15_3  ;; 0xffffed00
   \   00000076   0x4286             CMP      R6,R0
   \   00000078   0xD039             BEQ      ??mbedtls_pk_parse_key_7
   1100                  return( MBEDTLS_ERR_PK_PASSWORD_REQUIRED );
   1101              else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
   \   0000007A   0x....             LDR      R0,??DataTable15_4  ;; 0xffffef80
   \   0000007C   0x4286             CMP      R6,R0
   \   0000007E   0xD15F             BNE      ??mbedtls_pk_parse_key_8
   \                     ??mbedtls_pk_parse_key_1: (+1)
   \   00000080   0x9803             LDR      R0,[SP, #+12]
   \   00000082   0x7800             LDRB     R0,[R0, #+0]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD137             BNE      ??mbedtls_pk_parse_key_9
   1102                  return( ret );
   1103          #endif /* MBEDTLS_RSA_C */
   1104          
   1105          #if defined(MBEDTLS_ECP_C)
   1106              /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */
   1107              if( keylen == 0 || key[keylen - 1] != '\0' )
   1108                  ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;
   1109              else
   1110                  ret = mbedtls_pem_read_buffer( &pem,
   1111                                         "-----BEGIN EC PRIVATE KEY-----",
   1112                                         "-----END EC PRIVATE KEY-----",
   1113                                         key, pwd, pwdlen, &len );
   \   00000088   0xA807             ADD      R0,SP,#+28
   \   0000008A   0x9002             STR      R0,[SP, #+8]
   \   0000008C   0x980E             LDR      R0,[SP, #+56]
   \   0000008E   0x9001             STR      R0,[SP, #+4]
   \   00000090   0x9808             LDR      R0,[SP, #+32]
   \   00000092   0x9000             STR      R0,[SP, #+0]
   \   00000094   0x002B             MOVS     R3,R5
   \   00000096   0xBF00             Nop      
   \   00000098   0x....             ADR.N    R2,?_3
   \   0000009A   0xBF00             Nop      
   \   0000009C   0x....             ADR.N    R1,?_2
   \   0000009E   0xA804             ADD      R0,SP,#+16
   \   000000A0   0x.... 0x....      BL       mbedtls_pem_read_buffer
   \   000000A4   0x0006             MOVS     R6,R0
   1114              if( ret == 0 )
   \   000000A6   0xD11A             BNE      ??mbedtls_pk_parse_key_10
   1115              {
   1116                  if( ( pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_ECKEY ) ) == NULL )
   \   000000A8   0x2002             MOVS     R0,#+2
   \   000000AA   0x.... 0x....      BL       mbedtls_pk_info_from_type
   \   000000AE   0x0001             MOVS     R1,R0
   \   000000B0   0xD06F             BEQ      ??mbedtls_pk_parse_key_3
   1117                      return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
   1118          
   1119                  if( ( ret = mbedtls_pk_setup( pk, pk_info                   ) ) != 0 ||
   1120                      ( ret = pk_parse_key_sec1_der( mbedtls_pk_ec( *pk ),
   1121                                                     pem.buf, pem.buflen ) ) != 0 )
   \   000000B2   0x0020             MOVS     R0,R4
   \   000000B4   0x.... 0x....      BL       mbedtls_pk_setup
   \   000000B8   0x0006             MOVS     R6,R0
   \   000000BA   0xD109             BNE      ??mbedtls_pk_parse_key_4
   \   000000BC   0xCC03             LDM      R4!,{R0,R1}
   \   000000BE   0x3C08             SUBS     R4,R4,#+8
   \   000000C0   0x.... 0x....      BL       mbedtls_pk_ec
   \   000000C4   0x9A05             LDR      R2,[SP, #+20]
   \   000000C6   0x9904             LDR      R1,[SP, #+16]
   \   000000C8   0x.... 0x....      BL       pk_parse_key_sec1_der
   \   000000CC   0x0006             MOVS     R6,R0
   \   000000CE   0xD002             BEQ      ??mbedtls_pk_parse_key_5
   1122                  {
   1123                      mbedtls_pk_free( pk );
   \                     ??mbedtls_pk_parse_key_4: (+1)
   \   000000D0   0x0020             MOVS     R0,R4
   \   000000D2   0x.... 0x....      BL       mbedtls_pk_free
   1124                  }
   1125          
   1126                  mbedtls_pem_free( &pem );
   \                     ??mbedtls_pk_parse_key_5: (+1)
   \   000000D6   0xA804             ADD      R0,SP,#+16
   \   000000D8   0x.... 0x....      BL       mbedtls_pem_free
   1127                  return( ret );
   \   000000DC   0xE030             B.N      ??mbedtls_pk_parse_key_8
   1128              }
   1129              else if( ret == MBEDTLS_ERR_PEM_PASSWORD_MISMATCH )
   \                     ??mbedtls_pk_parse_key_10: (+1)
   \   000000DE   0x....             LDR      R0,??DataTable15_2  ;; 0xffffec80
   \   000000E0   0x4286             CMP      R6,R0
   \   000000E2   0xD101             BNE      ??mbedtls_pk_parse_key_11
   1130                  return( MBEDTLS_ERR_PK_PASSWORD_MISMATCH );
   \                     ??mbedtls_pk_parse_key_6: (+1)
   \   000000E4   0x....             LDR      R0,??DataTable15_5  ;; 0xffffc480
   \   000000E6   0xE06C             B        ??mbedtls_pk_parse_key_12
   1131              else if( ret == MBEDTLS_ERR_PEM_PASSWORD_REQUIRED )
   \                     ??mbedtls_pk_parse_key_11: (+1)
   \   000000E8   0x....             LDR      R0,??DataTable15_3  ;; 0xffffed00
   \   000000EA   0x4286             CMP      R6,R0
   \   000000EC   0xD101             BNE      ??mbedtls_pk_parse_key_13
   1132                  return( MBEDTLS_ERR_PK_PASSWORD_REQUIRED );
   \                     ??mbedtls_pk_parse_key_7: (+1)
   \   000000EE   0x....             LDR      R0,??DataTable15_6  ;; 0xffffc400
   \   000000F0   0xE067             B        ??mbedtls_pk_parse_key_12
   1133              else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
   \                     ??mbedtls_pk_parse_key_13: (+1)
   \   000000F2   0x....             LDR      R0,??DataTable15_4  ;; 0xffffef80
   \   000000F4   0x4286             CMP      R6,R0
   \   000000F6   0xD123             BNE      ??mbedtls_pk_parse_key_8
   \                     ??mbedtls_pk_parse_key_9: (+1)
   \   000000F8   0x9803             LDR      R0,[SP, #+12]
   \   000000FA   0x7800             LDRB     R0,[R0, #+0]
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD121             BNE      ??mbedtls_pk_parse_key_0
   1134                  return( ret );
   1135          #endif /* MBEDTLS_ECP_C */
   1136          
   1137              /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */
   1138              if( keylen == 0 || key[keylen - 1] != '\0' )
   1139                  ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;
   1140              else
   1141                  ret = mbedtls_pem_read_buffer( &pem,
   1142                                         "-----BEGIN PRIVATE KEY-----",
   1143                                         "-----END PRIVATE KEY-----",
   1144                                         key, NULL, 0, &len );
   \   00000100   0xA807             ADD      R0,SP,#+28
   \   00000102   0x9002             STR      R0,[SP, #+8]
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0x9001             STR      R0,[SP, #+4]
   \   00000108   0x9000             STR      R0,[SP, #+0]
   \   0000010A   0x002B             MOVS     R3,R5
   \   0000010C   0x....             ADR.N    R2,?_5
   \   0000010E   0xBF00             Nop      
   \   00000110   0x....             ADR.N    R1,?_4
   \   00000112   0xA804             ADD      R0,SP,#+16
   \   00000114   0x.... 0x....      BL       mbedtls_pem_read_buffer
   \   00000118   0x0006             MOVS     R6,R0
   1145              if( ret == 0 )
   \   0000011A   0xD10E             BNE      ??mbedtls_pk_parse_key_14
   1146              {
   1147                  if( ( ret = pk_parse_key_pkcs8_unencrypted_der( pk,
   1148                                                          pem.buf, pem.buflen ) ) != 0 )
   \   0000011C   0x9A05             LDR      R2,[SP, #+20]
   \   0000011E   0x9904             LDR      R1,[SP, #+16]
   \   00000120   0x0020             MOVS     R0,R4
   \   00000122   0x.... 0x....      BL       pk_parse_key_pkcs8_unencrypted_der
   \   00000126   0x0005             MOVS     R5,R0
   \   00000128   0xD002             BEQ      ??mbedtls_pk_parse_key_15
   1149                  {
   1150                      mbedtls_pk_free( pk );
   \   0000012A   0x0020             MOVS     R0,R4
   \   0000012C   0x.... 0x....      BL       mbedtls_pk_free
   1151                  }
   1152          
   1153                  mbedtls_pem_free( &pem );
   \                     ??mbedtls_pk_parse_key_15: (+1)
   \   00000130   0xA804             ADD      R0,SP,#+16
   \   00000132   0x.... 0x....      BL       mbedtls_pem_free
   1154                  return( ret );
   \   00000136   0x0028             MOVS     R0,R5
   \   00000138   0xE043             B        ??mbedtls_pk_parse_key_12
   1155              }
   1156              else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
   \                     ??mbedtls_pk_parse_key_14: (+1)
   \   0000013A   0x....             LDR      R0,??DataTable15_4  ;; 0xffffef80
   \   0000013C   0x4286             CMP      R6,R0
   \   0000013E   0xD001             BEQ      ??mbedtls_pk_parse_key_0
   1157                  return( ret );
   \                     ??mbedtls_pk_parse_key_8: (+1)
   \   00000140   0x0030             MOVS     R0,R6
   \   00000142   0xE03E             B        ??mbedtls_pk_parse_key_12
   1158          
   1159          #if defined(MBEDTLS_PKCS12_C) || defined(MBEDTLS_PKCS5_C)
   1160              /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */
   1161              if( keylen == 0 || key[keylen - 1] != '\0' )
   1162                  ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;
   1163              else
   1164                  ret = mbedtls_pem_read_buffer( &pem,
   1165                                         "-----BEGIN ENCRYPTED PRIVATE KEY-----",
   1166                                         "-----END ENCRYPTED PRIVATE KEY-----",
   1167                                         key, NULL, 0, &len );
   1168              if( ret == 0 )
   1169              {
   1170                  if( ( ret = pk_parse_key_pkcs8_encrypted_der( pk,
   1171                                                                pem.buf, pem.buflen,
   1172                                                                pwd, pwdlen ) ) != 0 )
   1173                  {
   1174                      mbedtls_pk_free( pk );
   1175                  }
   1176          
   1177                  mbedtls_pem_free( &pem );
   1178                  return( ret );
   1179              }
   1180              else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
   1181                  return( ret );
   1182          #endif /* MBEDTLS_PKCS12_C || MBEDTLS_PKCS5_C */
   1183          #else
   1184              ((void) ret);
   1185              ((void) pwd);
   1186              ((void) pwdlen);
   1187          #endif /* MBEDTLS_PEM_PARSE_C */
   1188          
   1189              /*
   1190               * At this point we only know it's not a PEM formatted key. Could be any
   1191               * of the known DER encoded private key formats
   1192               *
   1193               * We try the different DER format parsers to see if one passes without
   1194               * error
   1195               */
   1196          #if defined(MBEDTLS_PKCS12_C) || defined(MBEDTLS_PKCS5_C)
   1197              if( ( ret = pk_parse_key_pkcs8_encrypted_der( pk, key, keylen,
   1198                                                            pwd, pwdlen ) ) == 0 )
   1199              {
   1200                  return( 0 );
   1201              }
   1202          
   1203              mbedtls_pk_free( pk );
   1204          
   1205              if( ret == MBEDTLS_ERR_PK_PASSWORD_MISMATCH )
   1206              {
   1207                  return( ret );
   1208              }
   1209          #endif /* MBEDTLS_PKCS12_C || MBEDTLS_PKCS5_C */
   1210          
   1211              if( ( ret = pk_parse_key_pkcs8_unencrypted_der( pk, key, keylen ) ) == 0 )
   \                     ??mbedtls_pk_parse_key_0: (+1)
   \   00000144   0x003A             MOVS     R2,R7
   \   00000146   0x0029             MOVS     R1,R5
   \   00000148   0x0020             MOVS     R0,R4
   \   0000014A   0x.... 0x....      BL       pk_parse_key_pkcs8_unencrypted_der
   \   0000014E   0x2800             CMP      R0,#+0
   \   00000150   0xD031             BEQ      ??mbedtls_pk_parse_key_16
   1212                  return( 0 );
   1213          
   1214              mbedtls_pk_free( pk );
   \   00000152   0x0020             MOVS     R0,R4
   \   00000154   0x.... 0x....      BL       mbedtls_pk_free
   1215          
   1216          #if defined(MBEDTLS_RSA_C)
   1217              if( ( pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA ) ) == NULL )
   \   00000158   0x2001             MOVS     R0,#+1
   \   0000015A   0x.... 0x....      BL       mbedtls_pk_info_from_type
   \   0000015E   0x2800             CMP      R0,#+0
   \   00000160   0xD017             BEQ      ??mbedtls_pk_parse_key_3
   1218                  return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
   1219          
   1220              if( ( ret = mbedtls_pk_setup( pk, pk_info                           ) ) != 0 ||
   1221                  ( ret = pk_parse_key_pkcs1_der( mbedtls_pk_rsa( *pk ), key, keylen ) ) == 0 )
   \   00000162   0x0001             MOVS     R1,R0
   \   00000164   0x0020             MOVS     R0,R4
   \   00000166   0x.... 0x....      BL       mbedtls_pk_setup
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD123             BNE      ??mbedtls_pk_parse_key_16
   \   0000016E   0xCC03             LDM      R4!,{R0,R1}
   \   00000170   0x3C08             SUBS     R4,R4,#+8
   \   00000172   0x.... 0x....      BL       mbedtls_pk_rsa
   \   00000176   0x003A             MOVS     R2,R7
   \   00000178   0x0029             MOVS     R1,R5
   \   0000017A   0x.... 0x....      BL       pk_parse_key_pkcs1_der
   \   0000017E   0x2800             CMP      R0,#+0
   \   00000180   0xD019             BEQ      ??mbedtls_pk_parse_key_16
   1222              {
   1223                  return( 0 );
   1224              }
   1225          
   1226              mbedtls_pk_free( pk );
   \   00000182   0x0020             MOVS     R0,R4
   \   00000184   0x.... 0x....      BL       mbedtls_pk_free
   1227          #endif /* MBEDTLS_RSA_C */
   1228          
   1229          #if defined(MBEDTLS_ECP_C)
   1230              if( ( pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_ECKEY ) ) == NULL )
   \   00000188   0x2002             MOVS     R0,#+2
   \   0000018A   0x.... 0x....      BL       mbedtls_pk_info_from_type
   \   0000018E   0x2800             CMP      R0,#+0
   \   00000190   0xD101             BNE      ??mbedtls_pk_parse_key_17
   1231                  return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
   \                     ??mbedtls_pk_parse_key_3: (+1)
   \   00000192   0x....             LDR      R0,??DataTable15_1  ;; 0xffffc380
   \   00000194   0xE015             B        ??mbedtls_pk_parse_key_12
   1232          
   1233              if( ( ret = mbedtls_pk_setup( pk, pk_info                         ) ) != 0 ||
   1234                  ( ret = pk_parse_key_sec1_der( mbedtls_pk_ec( *pk ), key, keylen ) ) == 0 )
   \                     ??mbedtls_pk_parse_key_17: (+1)
   \   00000196   0x0001             MOVS     R1,R0
   \   00000198   0x0020             MOVS     R0,R4
   \   0000019A   0x.... 0x....      BL       mbedtls_pk_setup
   \   0000019E   0x2800             CMP      R0,#+0
   \   000001A0   0xD109             BNE      ??mbedtls_pk_parse_key_16
   \   000001A2   0xCC03             LDM      R4!,{R0,R1}
   \   000001A4   0x3C08             SUBS     R4,R4,#+8
   \   000001A6   0x.... 0x....      BL       mbedtls_pk_ec
   \   000001AA   0x003A             MOVS     R2,R7
   \   000001AC   0x0029             MOVS     R1,R5
   \   000001AE   0x.... 0x....      BL       pk_parse_key_sec1_der
   \   000001B2   0x2800             CMP      R0,#+0
   \   000001B4   0xD101             BNE      ??mbedtls_pk_parse_key_18
   1235              {
   1236                  return( 0 );
   \                     ??mbedtls_pk_parse_key_16: (+1)
   \   000001B6   0x2000             MOVS     R0,#+0
   \   000001B8   0xE003             B        ??mbedtls_pk_parse_key_12
   1237              }
   1238          
   1239              mbedtls_pk_free( pk );
   \                     ??mbedtls_pk_parse_key_18: (+1)
   \   000001BA   0x0020             MOVS     R0,R4
   \   000001BC   0x.... 0x....      BL       mbedtls_pk_free
   1240          #endif /* MBEDTLS_ECP_C */
   1241          
   1242              return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
   \   000001C0   0x....             LDR      R0,??DataTable15_7  ;; 0xffffc300
   \                     ??mbedtls_pk_parse_key_12: (+1)
   \   000001C2   0xB009             ADD      SP,SP,#+36
   \   000001C4   0xBDF0             POP      {R4-R7,PC}       ;; return
   1243          }
   1244          
   1245          /*
   1246           * Parse a public key
   1247           */

   \                                 In section .text, align 4, keep-with-next
   1248          int mbedtls_pk_parse_public_key( mbedtls_pk_context *ctx,
   1249                                   const unsigned char *key, size_t keylen )
   1250          {
   \                     mbedtls_pk_parse_public_key: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
   1251              int ret;
   1252              unsigned char *p;
   1253          #if defined(MBEDTLS_PEM_PARSE_C)
   1254              size_t len;
   1255              mbedtls_pem_context pem;
   1256          
   1257              mbedtls_pem_init( &pem );
   \   0000000A   0xA804             ADD      R0,SP,#+16
   \   0000000C   0x.... 0x....      BL       mbedtls_pem_init
   1258          
   1259              /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */
   1260              if( keylen == 0 || key[keylen - 1] != '\0' )
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD015             BEQ      ??mbedtls_pk_parse_public_key_0
   \   00000014   0x1960             ADDS     R0,R4,R5
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD110             BNE      ??mbedtls_pk_parse_public_key_0
   1261                  ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;
   1262              else
   1263                  ret = mbedtls_pem_read_buffer( &pem,
   1264                          "-----BEGIN PUBLIC KEY-----",
   1265                          "-----END PUBLIC KEY-----",
   1266                          key, NULL, 0, &len );
   \   0000001E   0xA807             ADD      R0,SP,#+28
   \   00000020   0x9002             STR      R0,[SP, #+8]
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x9001             STR      R0,[SP, #+4]
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0x0023             MOVS     R3,R4
   \   0000002A   0xBF00             Nop      
   \   0000002C   0x....             ADR.N    R2,?_7
   \   0000002E   0xBF00             Nop      
   \   00000030   0x....             ADR.N    R1,?_6
   \   00000032   0xA804             ADD      R0,SP,#+16
   \   00000034   0x.... 0x....      BL       mbedtls_pem_read_buffer
   \   00000038   0x0006             MOVS     R6,R0
   1267          
   1268              if( ret == 0 )
   \   0000003A   0xD10E             BNE      ??mbedtls_pk_parse_public_key_1
   1269              {
   1270                  /*
   1271                   * Was PEM encoded
   1272                   */
   1273                  key = pem.buf;
   \   0000003C   0x9C04             LDR      R4,[SP, #+16]
   1274                  keylen = pem.buflen;
   \   0000003E   0x9D05             LDR      R5,[SP, #+20]
   1275              }
   1276              else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
   1277              {
   1278                  mbedtls_pem_free( &pem );
   1279                  return( ret );
   1280              }
   1281          #endif /* MBEDTLS_PEM_PARSE_C */
   1282              p = (unsigned char *) key;
   \                     ??mbedtls_pk_parse_public_key_0: (+1)
   \   00000040   0x9403             STR      R4,[SP, #+12]
   1283          
   1284              ret = mbedtls_pk_parse_subpubkey( &p, p + keylen, ctx );
   \   00000042   0x003A             MOVS     R2,R7
   \   00000044   0x1961             ADDS     R1,R4,R5
   \   00000046   0xA803             ADD      R0,SP,#+12
   \   00000048   0x.... 0x....      BL       mbedtls_pk_parse_subpubkey
   \   0000004C   0x0006             MOVS     R6,R0
   1285          
   1286          #if defined(MBEDTLS_PEM_PARSE_C)
   1287              mbedtls_pem_free( &pem );
   \                     ??mbedtls_pk_parse_public_key_2: (+1)
   \   0000004E   0xA804             ADD      R0,SP,#+16
   \   00000050   0x.... 0x....      BL       mbedtls_pem_free
   1288          #endif
   1289          
   1290              return( ret );
   \   00000054   0x0030             MOVS     R0,R6
   \   00000056   0xB009             ADD      SP,SP,#+36
   \   00000058   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??mbedtls_pk_parse_public_key_1: (+1)
   \   0000005A   0x....             LDR      R0,??DataTable15_4  ;; 0xffffef80
   \   0000005C   0x4286             CMP      R6,R0
   \   0000005E   0xD0EF             BEQ      ??mbedtls_pk_parse_public_key_0
   \   00000060   0xE7F5             B        ??mbedtls_pk_parse_public_key_2
   1291          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0xFFFFC600         DC32     0xffffc600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0xFFFFC300         DC32     0xffffc300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0xFFFFC580         DC32     0xffffc580

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0xFFFFC380         DC32     0xffffc380

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0xFFFFC500         DC32     0xffffc500

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0xFFFFC49A         DC32     0xffffc49a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0xFFFFC280         DC32     0xffffc280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0xFFFFC29A         DC32     0xffffc29a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0xFFFFC29E         DC32     0xffffc29e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0xFFFFC300         DC32     0xffffc300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0xFFFFB180         DC32     0xffffb180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0xFFFFC280         DC32     0xffffc280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0xFFFFC2A0         DC32     0xffffc2a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0xFFFFC380         DC32     0xffffc380

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0xFFFFEC80         DC32     0xffffec80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0xFFFFED00         DC32     0xffffed00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0xFFFFEF80         DC32     0xffffef80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0xFFFFC480         DC32     0xffffc480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0xFFFFC400         DC32     0xffffc400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0xFFFFC300         DC32     0xffffc300

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x2D 0x2D          DC8 "-----BEGIN RSA PRIVATE KEY-----"
   \              0x2D 0x2D    
   \              0x2D 0x42    
   \              0x45 0x47    
   \              0x49 0x4E    
   \              0x20 0x52    
   \              0x53 0x41    
   \              0x20 0x50    
   \              0x52 0x49    
   \              0x56 0x41    
   \              0x54 0x45    
   \              0x20 0x4B    
   \              0x45 0x59    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x2D 0x2D          DC8 "-----END RSA PRIVATE KEY-----"
   \              0x2D 0x2D    
   \              0x2D 0x45    
   \              0x4E 0x44    
   \              0x20 0x52    
   \              0x53 0x41    
   \              0x20 0x50    
   \              0x52 0x49    
   \              0x56 0x41    
   \              0x54 0x45    
   \              0x20 0x4B    
   \              0x45 0x59    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x2D 0x2D          DC8 "-----BEGIN EC PRIVATE KEY-----"
   \              0x2D 0x2D    
   \              0x2D 0x42    
   \              0x45 0x47    
   \              0x49 0x4E    
   \              0x20 0x45    
   \              0x43 0x20    
   \              0x50 0x52    
   \              0x49 0x56    
   \              0x41 0x54    
   \              0x45 0x20    
   \              0x4B 0x45    
   \              0x59 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x2D 0x2D          DC8 "-----END EC PRIVATE KEY-----"
   \              0x2D 0x2D    
   \              0x2D 0x45    
   \              0x4E 0x44    
   \              0x20 0x45    
   \              0x43 0x20    
   \              0x50 0x52    
   \              0x49 0x56    
   \              0x41 0x54    
   \              0x45 0x20    
   \              0x4B 0x45    
   \              0x59 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x2D 0x2D          DC8 "-----BEGIN PRIVATE KEY-----"
   \              0x2D 0x2D    
   \              0x2D 0x42    
   \              0x45 0x47    
   \              0x49 0x4E    
   \              0x20 0x50    
   \              0x52 0x49    
   \              0x56 0x41    
   \              0x54 0x45    
   \              0x20 0x4B    
   \              0x45 0x59    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x2D 0x2D          DC8 "-----END PRIVATE KEY-----"
   \              0x2D 0x2D    
   \              0x2D 0x45    
   \              0x4E 0x44    
   \              0x20 0x50    
   \              0x52 0x49    
   \              0x56 0x41    
   \              0x54 0x45    
   \              0x20 0x4B    
   \              0x45 0x59    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x2D 0x2D          DC8 "-----BEGIN PUBLIC KEY-----"
   \              0x2D 0x2D    
   \              0x2D 0x42    
   \              0x45 0x47    
   \              0x49 0x4E    
   \              0x20 0x50    
   \              0x55 0x42    
   \              0x4C 0x49    
   \              0x43 0x20    
   \              0x4B 0x45    
   \              0x59 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x2D 0x2D          DC8 "-----END PUBLIC KEY-----"
   \              0x2D 0x2D    
   \              0x2D 0x45    
   \              0x4E 0x44    
   \              0x20 0x50    
   \              0x55 0x42    
   \              0x4C 0x49    
   \              0x43 0x20    
   \              0x4B 0x45    
   \              0x59 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1292          
   1293          #endif /* MBEDTLS_PK_PARSE_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   mbedtls_pk_ec
      56   mbedtls_pk_parse_key
        56   -> mbedtls_pem_free
        56   -> mbedtls_pem_init
        56   -> mbedtls_pem_read_buffer
        56   -> mbedtls_pk_ec
        56   -> mbedtls_pk_free
        56   -> mbedtls_pk_info_from_type
        56   -> mbedtls_pk_rsa
        56   -> mbedtls_pk_setup
        56   -> pk_parse_key_pkcs1_der
        56   -> pk_parse_key_pkcs8_unencrypted_der
        56   -> pk_parse_key_sec1_der
      56   mbedtls_pk_parse_public_key
        56   -> mbedtls_pem_free
        56   -> mbedtls_pem_init
        56   -> mbedtls_pem_read_buffer
        56   -> mbedtls_pk_parse_subpubkey
      48   mbedtls_pk_parse_subpubkey
        48   -> mbedtls_asn1_get_bitstring_null
        48   -> mbedtls_asn1_get_mpi
        48   -> mbedtls_asn1_get_tag
        48   -> mbedtls_mpi_size
        48   -> mbedtls_pk_ec
        48   -> mbedtls_pk_free
        48   -> mbedtls_pk_info_from_type
        48   -> mbedtls_pk_rsa
        48   -> mbedtls_pk_setup
        48   -> mbedtls_rsa_check_pubkey
        48   -> pk_get_ecpubkey
        48   -> pk_get_pk_alg
        48   -> pk_use_ecparams
       0   mbedtls_pk_rsa
      24   pk_get_ecpubkey
        24   -> mbedtls_ecp_check_pubkey
        24   -> mbedtls_ecp_point_read_binary
      32   pk_get_pk_alg
        32   -> mbedtls_asn1_get_alg
        32   -> mbedtls_oid_get_pk_alg
      24   pk_parse_key_pkcs1_der
        24   -> mbedtls_asn1_get_int
        24   -> mbedtls_asn1_get_mpi
        24   -> mbedtls_asn1_get_tag
        24   -> mbedtls_mpi_size
        24   -> mbedtls_rsa_check_privkey
        24   -> mbedtls_rsa_free
      40   pk_parse_key_pkcs8_unencrypted_der
        40   -> mbedtls_asn1_get_int
        40   -> mbedtls_asn1_get_tag
        40   -> mbedtls_pk_ec
        40   -> mbedtls_pk_free
        40   -> mbedtls_pk_info_from_type
        40   -> mbedtls_pk_rsa
        40   -> mbedtls_pk_setup
        40   -> pk_get_pk_alg
        40   -> pk_parse_key_pkcs1_der
        40   -> pk_parse_key_sec1_der
        40   -> pk_use_ecparams
      48   pk_parse_key_sec1_der
        48   -> mbedtls_asn1_get_bitstring_null
        48   -> mbedtls_asn1_get_int
        48   -> mbedtls_asn1_get_tag
        48   -> mbedtls_ecp_check_privkey
        48   -> mbedtls_ecp_keypair_free
        48   -> mbedtls_ecp_mul
        48   -> mbedtls_mpi_read_binary
        48   -> pk_get_ecpubkey
        48   -> pk_use_ecparams
      16   pk_use_ecparams
        16   -> mbedtls_ecp_group_load
        16   -> mbedtls_oid_get_ec_grp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
      32  ?_0
      32  ?_1
      32  ?_2
      32  ?_3
      28  ?_4
      28  ?_5
      28  ?_6
      28  ?_7
       4  mbedtls_pk_ec
     454  mbedtls_pk_parse_key
      98  mbedtls_pk_parse_public_key
     304  mbedtls_pk_parse_subpubkey
       4  mbedtls_pk_rsa
      40  pk_get_ecpubkey
      84  pk_get_pk_alg
     250  pk_parse_key_pkcs1_der
     232  pk_parse_key_pkcs8_unencrypted_der
     378  pk_parse_key_sec1_der
      56  pk_use_ecparams

 
 2 224 bytes in section .text
 
 2 224 bytes of CODE memory

Errors: none
Warnings: none

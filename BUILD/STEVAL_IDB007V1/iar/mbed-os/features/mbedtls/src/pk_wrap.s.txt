###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:31
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\features\mbedtls\src\pk_wrap.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\pk_wrap.d -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\pk_wrap.s.txt
#        -o .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\pk_wrap.o
#        .\mbed-os\features\mbedtls\src\pk_wrap.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\pk_wrap.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\pk_wrap.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\features\mbedtls\src\pk_wrap.c
      1          /*
      2           *  Public Key abstraction layer: wrapper functions
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          
     22          #if !defined(MBEDTLS_CONFIG_FILE)
     23          #include "mbedtls/config.h"
     24          #else
     25          #include MBEDTLS_CONFIG_FILE
     26          #endif
     27          
     28          #if defined(MBEDTLS_PK_C)
     29          #include "mbedtls/pk_internal.h"
     30          
     31          /* Even if RSA not activated, for the sake of RSA-alt */
     32          #include "mbedtls/rsa.h"
     33          #include "mbedtls/bignum.h"
     34          
     35          #include <string.h>
     36          
     37          #if defined(MBEDTLS_ECP_C)
     38          #include "mbedtls/ecp.h"
     39          #endif
     40          
     41          #if defined(MBEDTLS_ECDSA_C)
     42          #include "mbedtls/ecdsa.h"
     43          #endif
     44          
     45          #if defined(MBEDTLS_PLATFORM_C)
     46          #include "mbedtls/platform.h"
     47          #else
     48          #include <stdlib.h>
     49          #define mbedtls_calloc    calloc
     50          #define mbedtls_free       free
     51          #endif
     52          
     53          #include <limits.h>
     54          
     55          #if defined(MBEDTLS_PK_RSA_ALT_SUPPORT)
     56          /* Implementation that should never be optimized out by the compiler */
     57          static void mbedtls_zeroize( void *v, size_t n ) {
     58              volatile unsigned char *p = v; while( n-- ) *p++ = 0;
     59          }
     60          #endif
     61          
     62          #if defined(MBEDTLS_RSA_C)

   \                                 In section .text, align 2, keep-with-next
     63          static int rsa_can_do( mbedtls_pk_type_t type )
     64          {
     65              return( type == MBEDTLS_PK_RSA ||
     66                      type == MBEDTLS_PK_RSASSA_PSS );
   \                     rsa_can_do: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD001             BEQ      ??rsa_can_do_0
   \   00000004   0x2806             CMP      R0,#+6
   \   00000006   0xD101             BNE      ??rsa_can_do_1
   \                     ??rsa_can_do_0: (+1)
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??rsa_can_do_1: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
     67          }
     68          

   \                                 In section .text, align 2, keep-with-next
     69          static size_t rsa_get_bitlen( const void *ctx )
     70          {
     71              return( 8 * ((const mbedtls_rsa_context *) ctx)->len );
   \                     rsa_get_bitlen: (+1)
   \   00000000   0x6840             LDR      R0,[R0, #+4]
   \   00000002   0x00C0             LSLS     R0,R0,#+3
   \   00000004   0x4770             BX       LR               ;; return
     72          }
     73          

   \                                 In section .text, align 2, keep-with-next
     74          static int rsa_verify_wrap( void *ctx, mbedtls_md_type_t md_alg,
     75                             const unsigned char *hash, size_t hash_len,
     76                             const unsigned char *sig, size_t sig_len )
     77          {
   \                     rsa_verify_wrap: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x9D09             LDR      R5,[SP, #+36]
     78              int ret;
     79          
     80          #if defined(MBEDTLS_HAVE_INT64)
     81              if( md_alg == MBEDTLS_MD_NONE && UINT_MAX < hash_len )
     82                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
     83          #endif /* MBEDTLS_HAVE_INT64 */
     84          
     85              if( sig_len < ((mbedtls_rsa_context *) ctx)->len )
   \   00000008   0x6860             LDR      R0,[R4, #+4]
   \   0000000A   0x4285             CMP      R5,R0
   \   0000000C   0xD201             BCS      ??rsa_verify_wrap_0
     86                  return( MBEDTLS_ERR_RSA_VERIFY_FAILED );
   \   0000000E   0x....             LDR      R0,??DataTable18  ;; 0xffffbc80
   \   00000010   0xE012             B        ??rsa_verify_wrap_1
     87          
     88              if( ( ret = mbedtls_rsa_pkcs1_verify( (mbedtls_rsa_context *) ctx, NULL, NULL,
     89                                            MBEDTLS_RSA_PUBLIC, md_alg,
     90                                            (unsigned int) hash_len, hash, sig ) ) != 0 )
   \                     ??rsa_verify_wrap_0: (+1)
   \   00000012   0x9808             LDR      R0,[SP, #+32]
   \   00000014   0x9003             STR      R0,[SP, #+12]
   \   00000016   0x9202             STR      R2,[SP, #+8]
   \   00000018   0x9301             STR      R3,[SP, #+4]
   \   0000001A   0x9100             STR      R1,[SP, #+0]
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       mbedtls_rsa_pkcs1_verify
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD105             BNE      ??rsa_verify_wrap_1
     91                  return( ret );
     92          
     93              if( sig_len > ((mbedtls_rsa_context *) ctx)->len )
   \   0000002C   0x6860             LDR      R0,[R4, #+4]
   \   0000002E   0x42A8             CMP      R0,R5
   \   00000030   0xD201             BCS      ??rsa_verify_wrap_2
     94                  return( MBEDTLS_ERR_PK_SIG_LEN_MISMATCH );
   \   00000032   0x....             LDR      R0,??DataTable19  ;; 0xffffc700
   \   00000034   0xE000             B        ??rsa_verify_wrap_1
     95          
     96              return( 0 );
   \                     ??rsa_verify_wrap_2: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??rsa_verify_wrap_1: (+1)
   \   00000038   0xB005             ADD      SP,SP,#+20
   \   0000003A   0xBD30             POP      {R4,R5,PC}       ;; return
     97          }
     98          

   \                                 In section .text, align 2, keep-with-next
     99          static int rsa_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
    100                             const unsigned char *hash, size_t hash_len,
    101                             unsigned char *sig, size_t *sig_len,
    102                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    103          {
   \                     rsa_sign_wrap: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    104          #if defined(MBEDTLS_HAVE_INT64)
    105              if( md_alg == MBEDTLS_MD_NONE && UINT_MAX < hash_len )
    106                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
    107          #endif /* MBEDTLS_HAVE_INT64 */
    108          
    109              *sig_len = ((mbedtls_rsa_context *) ctx)->len;
   \   00000004   0x6844             LDR      R4,[R0, #+4]
   \   00000006   0x9D09             LDR      R5,[SP, #+36]
   \   00000008   0x602C             STR      R4,[R5, #+0]
    110          
    111              return( mbedtls_rsa_pkcs1_sign( (mbedtls_rsa_context *) ctx, f_rng, p_rng, MBEDTLS_RSA_PRIVATE,
    112                          md_alg, (unsigned int) hash_len, hash, sig ) );
   \   0000000A   0x9C08             LDR      R4,[SP, #+32]
   \   0000000C   0x9403             STR      R4,[SP, #+12]
   \   0000000E   0x9202             STR      R2,[SP, #+8]
   \   00000010   0x9301             STR      R3,[SP, #+4]
   \   00000012   0x9100             STR      R1,[SP, #+0]
   \   00000014   0x2301             MOVS     R3,#+1
   \   00000016   0x9A0B             LDR      R2,[SP, #+44]
   \   00000018   0x990A             LDR      R1,[SP, #+40]
   \   0000001A   0x.... 0x....      BL       mbedtls_rsa_pkcs1_sign
   \   0000001E   0xB005             ADD      SP,SP,#+20
   \   00000020   0xBD30             POP      {R4,R5,PC}       ;; return
    113          }
    114          

   \                                 In section .text, align 2, keep-with-next
    115          static int rsa_decrypt_wrap( void *ctx,
    116                              const unsigned char *input, size_t ilen,
    117                              unsigned char *output, size_t *olen, size_t osize,
    118                              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    119          {
   \                     rsa_decrypt_wrap: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    120              if( ilen != ((mbedtls_rsa_context *) ctx)->len )
   \   00000004   0x6844             LDR      R4,[R0, #+4]
   \   00000006   0x42A2             CMP      R2,R4
   \   00000008   0xD001             BEQ      ??rsa_decrypt_wrap_0
    121                  return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
   \   0000000A   0x....             LDR      R0,??DataTable19_1  ;; 0xffffbf80
   \   0000000C   0xE00A             B        ??rsa_decrypt_wrap_1
    122          
    123              return( mbedtls_rsa_pkcs1_decrypt( (mbedtls_rsa_context *) ctx, f_rng, p_rng,
    124                          MBEDTLS_RSA_PRIVATE, olen, input, output, osize ) );
   \                     ??rsa_decrypt_wrap_0: (+1)
   \   0000000E   0x9A07             LDR      R2,[SP, #+28]
   \   00000010   0x9203             STR      R2,[SP, #+12]
   \   00000012   0x9302             STR      R3,[SP, #+8]
   \   00000014   0x9101             STR      R1,[SP, #+4]
   \   00000016   0x9906             LDR      R1,[SP, #+24]
   \   00000018   0x9100             STR      R1,[SP, #+0]
   \   0000001A   0x2301             MOVS     R3,#+1
   \   0000001C   0x9A09             LDR      R2,[SP, #+36]
   \   0000001E   0x9908             LDR      R1,[SP, #+32]
   \   00000020   0x.... 0x....      BL       mbedtls_rsa_pkcs1_decrypt
   \                     ??rsa_decrypt_wrap_1: (+1)
   \   00000024   0xB004             ADD      SP,SP,#+16
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    125          }
    126          

   \                                 In section .text, align 2, keep-with-next
    127          static int rsa_encrypt_wrap( void *ctx,
    128                              const unsigned char *input, size_t ilen,
    129                              unsigned char *output, size_t *olen, size_t osize,
    130                              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    131          {
   \                     rsa_encrypt_wrap: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    132              *olen = ((mbedtls_rsa_context *) ctx)->len;
   \   00000004   0x6845             LDR      R5,[R0, #+4]
   \   00000006   0x9C06             LDR      R4,[SP, #+24]
   \   00000008   0x6025             STR      R5,[R4, #+0]
    133          
    134              if( *olen > osize )
   \   0000000A   0x9C07             LDR      R4,[SP, #+28]
   \   0000000C   0x42AC             CMP      R4,R5
   \   0000000E   0xD201             BCS      ??rsa_encrypt_wrap_0
    135                  return( MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE );
   \   00000010   0x....             LDR      R0,??DataTable19_2  ;; 0xffffbc00
   \   00000012   0xE007             B        ??rsa_encrypt_wrap_1
    136          
    137              return( mbedtls_rsa_pkcs1_encrypt( (mbedtls_rsa_context *) ctx,
    138                          f_rng, p_rng, MBEDTLS_RSA_PUBLIC, ilen, input, output ) );
   \                     ??rsa_encrypt_wrap_0: (+1)
   \   00000014   0x9302             STR      R3,[SP, #+8]
   \   00000016   0x9101             STR      R1,[SP, #+4]
   \   00000018   0x9200             STR      R2,[SP, #+0]
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x9A09             LDR      R2,[SP, #+36]
   \   0000001E   0x9908             LDR      R1,[SP, #+32]
   \   00000020   0x.... 0x....      BL       mbedtls_rsa_pkcs1_encrypt
   \                     ??rsa_encrypt_wrap_1: (+1)
   \   00000024   0xB003             ADD      SP,SP,#+12
   \   00000026   0xBD30             POP      {R4,R5,PC}       ;; return
    139          }
    140          

   \                                 In section .text, align 2, keep-with-next
    141          static int rsa_check_pair_wrap( const void *pub, const void *prv )
    142          {
   \                     rsa_check_pair_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    143              return( mbedtls_rsa_check_pub_priv( (const mbedtls_rsa_context *) pub,
    144                                          (const mbedtls_rsa_context *) prv ) );
   \   00000002   0x.... 0x....      BL       mbedtls_rsa_check_pub_priv
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    145          }
    146          

   \                                 In section .text, align 2, keep-with-next
    147          static void *rsa_alloc_wrap( void )
    148          {
   \                     rsa_alloc_wrap: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    149              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_rsa_context ) );
   \   00000002   0x21AC             MOVS     R1,#+172
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       calloc
   \   0000000A   0x0004             MOVS     R4,R0
    150          
    151              if( ctx != NULL )
   \   0000000C   0xD003             BEQ      ??rsa_alloc_wrap_0
    152                  mbedtls_rsa_init( (mbedtls_rsa_context *) ctx, 0, 0 );
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x.... 0x....      BL       mbedtls_rsa_init
    153          
    154              return( ctx );
   \                     ??rsa_alloc_wrap_0: (+1)
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    155          }
    156          

   \                                 In section .text, align 2, keep-with-next
    157          static void rsa_free_wrap( void *ctx )
    158          {
   \                     rsa_free_wrap: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    159              mbedtls_rsa_free( (mbedtls_rsa_context *) ctx );
   \   00000004   0x.... 0x....      BL       mbedtls_rsa_free
    160              mbedtls_free( ctx );
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       free
    161          }
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    162          

   \                                 In section .text, align 4, keep-with-next
    163          static void rsa_debug( const void *ctx, mbedtls_pk_debug_item *items )
    164          {
    165              items->type = MBEDTLS_PK_DEBUG_MPI;
   \                     rsa_debug: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x700A             STRB     R2,[R1, #+0]
    166              items->name = "rsa.N";
   \   00000004   0x....             ADR.N    R3,?_5
   \   00000006   0x604B             STR      R3,[R1, #+4]
    167              items->value = &( ((mbedtls_rsa_context *) ctx)->N );
   \   00000008   0x0003             MOVS     R3,R0
   \   0000000A   0x3308             ADDS     R3,R3,#+8
   \   0000000C   0x608B             STR      R3,[R1, #+8]
    168          
    169              items++;
   \   0000000E   0x310C             ADDS     R1,R1,#+12
    170          
    171              items->type = MBEDTLS_PK_DEBUG_MPI;
   \   00000010   0x700A             STRB     R2,[R1, #+0]
    172              items->name = "rsa.E";
   \   00000012   0xBF00             Nop      
   \   00000014   0x....             ADR.N    R2,?_6
   \   00000016   0x604A             STR      R2,[R1, #+4]
    173              items->value = &( ((mbedtls_rsa_context *) ctx)->E );
   \   00000018   0x3014             ADDS     R0,R0,#+20
   \   0000001A   0x6088             STR      R0,[R1, #+8]
    174          }
   \   0000001C   0x4770             BX       LR               ;; return
    175          

   \                                 In section .rodata, align 4, keep-with-next
    176          const mbedtls_pk_info_t mbedtls_rsa_info = {
   \                     mbedtls_rsa_info:
   \   00000000   0x01 0x00          DC8 1, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x........         DC32 ?_0, rsa_get_bitlen, rsa_can_do, rsa_verify_wrap, rsa_sign_wrap
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000018   0x........         DC32 rsa_decrypt_wrap, rsa_encrypt_wrap, rsa_check_pair_wrap
   \              0x........   
   \              0x........   
   \   00000024   0x........         DC32 rsa_alloc_wrap, rsa_free_wrap, rsa_debug
   \              0x........   
   \              0x........   
    177              MBEDTLS_PK_RSA,
    178              "RSA",
    179              rsa_get_bitlen,
    180              rsa_can_do,
    181              rsa_verify_wrap,
    182              rsa_sign_wrap,
    183              rsa_decrypt_wrap,
    184              rsa_encrypt_wrap,
    185              rsa_check_pair_wrap,
    186              rsa_alloc_wrap,
    187              rsa_free_wrap,
    188              rsa_debug,
    189          };
    190          #endif /* MBEDTLS_RSA_C */
    191          
    192          #if defined(MBEDTLS_ECP_C)
    193          /*
    194           * Generic EC key
    195           */

   \                                 In section .text, align 2, keep-with-next
    196          static int eckey_can_do( mbedtls_pk_type_t type )
    197          {
    198              return( type == MBEDTLS_PK_ECKEY ||
    199                      type == MBEDTLS_PK_ECKEY_DH ||
    200                      type == MBEDTLS_PK_ECDSA );
   \                     eckey_can_do: (+1)
   \   00000000   0x2802             CMP      R0,#+2
   \   00000002   0xD003             BEQ      ??eckey_can_do_0
   \   00000004   0x2803             CMP      R0,#+3
   \   00000006   0xD001             BEQ      ??eckey_can_do_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD101             BNE      ??eckey_can_do_1
   \                     ??eckey_can_do_0: (+1)
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x4770             BX       LR
   \                     ??eckey_can_do_1: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
    201          }
    202          

   \                                 In section .text, align 2, keep-with-next
    203          static size_t eckey_get_bitlen( const void *ctx )
    204          {
    205              return( ((mbedtls_ecp_keypair *) ctx)->grp.pbits );
   \                     eckey_get_bitlen: (+1)
   \   00000000   0x6D80             LDR      R0,[R0, #+88]
   \   00000002   0x4770             BX       LR               ;; return
    206          }
    207          
    208          #if defined(MBEDTLS_ECDSA_C)
    209          /* Forward declarations */
    210          static int ecdsa_verify_wrap( void *ctx, mbedtls_md_type_t md_alg,
    211                                 const unsigned char *hash, size_t hash_len,
    212                                 const unsigned char *sig, size_t sig_len );
    213          
    214          static int ecdsa_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
    215                             const unsigned char *hash, size_t hash_len,
    216                             unsigned char *sig, size_t *sig_len,
    217                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng );
    218          

   \                                 In section .text, align 2, keep-with-next
    219          static int eckey_verify_wrap( void *ctx, mbedtls_md_type_t md_alg,
    220                                 const unsigned char *hash, size_t hash_len,
    221                                 const unsigned char *sig, size_t sig_len )
    222          {
   \                     eckey_verify_wrap: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0AC             SUB      SP,SP,#+176
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001C             MOVS     R4,R3
    223              int ret;
    224              mbedtls_ecdsa_context ecdsa;
    225          
    226              mbedtls_ecdsa_init( &ecdsa );
   \   0000000A   0xA801             ADD      R0,SP,#+4
   \   0000000C   0x.... 0x....      BL       mbedtls_ecdsa_init
    227          
    228              if( ( ret = mbedtls_ecdsa_from_keypair( &ecdsa, ctx ) ) == 0 )
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0xA801             ADD      R0,SP,#+4
   \   00000014   0x.... 0x....      BL       mbedtls_ecdsa_from_keypair
   \   00000018   0x0005             MOVS     R5,R0
   \   0000001A   0xD10C             BNE      ??eckey_verify_wrap_0
    229                  ret = ecdsa_verify_wrap( &ecdsa, md_alg, hash, hash_len, sig, sig_len );
   \   0000001C   0x9831             LDR      R0,[SP, #+196]
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0x9B30             LDR      R3,[SP, #+192]
   \   00000022   0x0022             MOVS     R2,R4
   \   00000024   0x0031             MOVS     R1,R6
   \   00000026   0xA801             ADD      R0,SP,#+4
   \   00000028   0x.... 0x....      BL       mbedtls_ecdsa_read_signature
   \   0000002C   0x0005             MOVS     R5,R0
   \   0000002E   0x....             LDR      R0,??DataTable19_3  ;; 0xffffb400
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD100             BNE      ??eckey_verify_wrap_0
   \   00000034   0x....             LDR      R5,??DataTable19  ;; 0xffffc700
    230          
    231              mbedtls_ecdsa_free( &ecdsa );
   \                     ??eckey_verify_wrap_0: (+1)
   \   00000036   0xA801             ADD      R0,SP,#+4
   \   00000038   0x.... 0x....      BL       mbedtls_ecdsa_free
    232          
    233              return( ret );
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0xB02C             ADD      SP,SP,#+176
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return
    234          }
    235          

   \                                 In section .text, align 2, keep-with-next
    236          static int eckey_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
    237                             const unsigned char *hash, size_t hash_len,
    238                             unsigned char *sig, size_t *sig_len,
    239                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    240          {
   \                     eckey_sign_wrap: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0AF             SUB      SP,SP,#+188
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x001E             MOVS     R6,R3
    241              int ret;
    242              mbedtls_ecdsa_context ecdsa;
    243          
    244              mbedtls_ecdsa_init( &ecdsa );
   \   0000000C   0xA804             ADD      R0,SP,#+16
   \   0000000E   0x.... 0x....      BL       mbedtls_ecdsa_init
    245          
    246              if( ( ret = mbedtls_ecdsa_from_keypair( &ecdsa, ctx ) ) == 0 )
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0xA804             ADD      R0,SP,#+16
   \   00000016   0x.... 0x....      BL       mbedtls_ecdsa_from_keypair
   \   0000001A   0x0005             MOVS     R5,R0
   \   0000001C   0xD10E             BNE      ??eckey_sign_wrap_0
    247                  ret = ecdsa_sign_wrap( &ecdsa, md_alg, hash, hash_len, sig, sig_len,
    248                                         f_rng, p_rng );
   \   0000001E   0x9837             LDR      R0,[SP, #+220]
   \   00000020   0x9003             STR      R0,[SP, #+12]
   \   00000022   0x9836             LDR      R0,[SP, #+216]
   \   00000024   0x9002             STR      R0,[SP, #+8]
   \   00000026   0x9835             LDR      R0,[SP, #+212]
   \   00000028   0x9001             STR      R0,[SP, #+4]
   \   0000002A   0x9834             LDR      R0,[SP, #+208]
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0x0033             MOVS     R3,R6
   \   00000030   0x003A             MOVS     R2,R7
   \   00000032   0x0021             MOVS     R1,R4
   \   00000034   0xA804             ADD      R0,SP,#+16
   \   00000036   0x.... 0x....      BL       mbedtls_ecdsa_write_signature
   \   0000003A   0x0005             MOVS     R5,R0
    249          
    250              mbedtls_ecdsa_free( &ecdsa );
   \                     ??eckey_sign_wrap_0: (+1)
   \   0000003C   0xA804             ADD      R0,SP,#+16
   \   0000003E   0x.... 0x....      BL       mbedtls_ecdsa_free
    251          
    252              return( ret );
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0xB02F             ADD      SP,SP,#+188
   \   00000046   0xBDF0             POP      {R4-R7,PC}       ;; return
    253          }
    254          
    255          #endif /* MBEDTLS_ECDSA_C */
    256          

   \                                 In section .text, align 2, keep-with-next
    257          static int eckey_check_pair( const void *pub, const void *prv )
    258          {
   \                     eckey_check_pair: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    259              return( mbedtls_ecp_check_pub_priv( (const mbedtls_ecp_keypair *) pub,
    260                                          (const mbedtls_ecp_keypair *) prv ) );
   \   00000002   0x.... 0x....      BL       mbedtls_ecp_check_pub_priv
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    261          }
    262          

   \                                 In section .text, align 2, keep-with-next
    263          static void *eckey_alloc_wrap( void )
    264          {
   \                     eckey_alloc_wrap: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    265              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ecp_keypair ) );
   \   00000002   0x21AC             MOVS     R1,#+172
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       calloc
   \   0000000A   0x0004             MOVS     R4,R0
    266          
    267              if( ctx != NULL )
   \   0000000C   0xD001             BEQ      ??eckey_alloc_wrap_0
    268                  mbedtls_ecp_keypair_init( ctx );
   \   0000000E   0x.... 0x....      BL       mbedtls_ecp_keypair_init
    269          
    270              return( ctx );
   \                     ??eckey_alloc_wrap_0: (+1)
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    271          }
    272          

   \                                 In section .text, align 2, keep-with-next
    273          static void eckey_free_wrap( void *ctx )
    274          {
   \                     eckey_free_wrap: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    275              mbedtls_ecp_keypair_free( (mbedtls_ecp_keypair *) ctx );
   \   00000004   0x.... 0x....      BL       mbedtls_ecp_keypair_free
    276              mbedtls_free( ctx );
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       free
    277          }
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    278          

   \                                 In section .text, align 4, keep-with-next
    279          static void eckey_debug( const void *ctx, mbedtls_pk_debug_item *items )
    280          {
    281              items->type = MBEDTLS_PK_DEBUG_ECP;
   \                     eckey_debug: (+1)
   \   00000000   0x2202             MOVS     R2,#+2
   \   00000002   0x700A             STRB     R2,[R1, #+0]
    282              items->name = "eckey.Q";
   \   00000004   0x....             ADR.N    R2,?_7
   \   00000006   0x604A             STR      R2,[R1, #+4]
    283              items->value = &( ((mbedtls_ecp_keypair *) ctx)->Q );
   \   00000008   0x3088             ADDS     R0,R0,#+136
   \   0000000A   0x6088             STR      R0,[R1, #+8]
    284          }
   \   0000000C   0x4770             BX       LR               ;; return
    285          

   \                                 In section .rodata, align 4, keep-with-next
    286          const mbedtls_pk_info_t mbedtls_eckey_info = {
   \                     mbedtls_eckey_info:
   \   00000000   0x02 0x00          DC8 2, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x........         DC32 ?_1, eckey_get_bitlen, eckey_can_do, eckey_verify_wrap
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000014   0x........         DC32 eckey_sign_wrap, 0H, 0H, eckey_check_pair, eckey_alloc_wrap
   \              0x00000000   
   \              0x00000000   
   \              0x........   
   \              0x........   
   \   00000028   0x........         DC32 eckey_free_wrap, eckey_debug
   \              0x........   
    287              MBEDTLS_PK_ECKEY,
    288              "EC",
    289              eckey_get_bitlen,
    290              eckey_can_do,
    291          #if defined(MBEDTLS_ECDSA_C)
    292              eckey_verify_wrap,
    293              eckey_sign_wrap,
    294          #else
    295              NULL,
    296              NULL,
    297          #endif
    298              NULL,
    299              NULL,
    300              eckey_check_pair,
    301              eckey_alloc_wrap,
    302              eckey_free_wrap,
    303              eckey_debug,
    304          };
    305          
    306          /*
    307           * EC key restricted to ECDH
    308           */

   \                                 In section .text, align 2, keep-with-next
    309          static int eckeydh_can_do( mbedtls_pk_type_t type )
    310          {
    311              return( type == MBEDTLS_PK_ECKEY ||
    312                      type == MBEDTLS_PK_ECKEY_DH );
   \                     eckeydh_can_do: (+1)
   \   00000000   0x2802             CMP      R0,#+2
   \   00000002   0xD001             BEQ      ??eckeydh_can_do_0
   \   00000004   0x2803             CMP      R0,#+3
   \   00000006   0xD101             BNE      ??eckeydh_can_do_1
   \                     ??eckeydh_can_do_0: (+1)
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??eckeydh_can_do_1: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    313          }
    314          

   \                                 In section .rodata, align 4, keep-with-next
    315          const mbedtls_pk_info_t mbedtls_eckeydh_info = {
   \                     mbedtls_eckeydh_info:
   \   00000000   0x03 0x00          DC8 3, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x........         DC32 ?_2, eckey_get_bitlen, eckeydh_can_do, 0H, 0H, 0H, 0H
   \              0x........   
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \   00000020   0x........         DC32 eckey_check_pair, eckey_alloc_wrap, eckey_free_wrap, eckey_debug
   \              0x........   
   \              0x........   
   \              0x........   
    316              MBEDTLS_PK_ECKEY_DH,
    317              "EC_DH",
    318              eckey_get_bitlen,         /* Same underlying key structure */
    319              eckeydh_can_do,
    320              NULL,
    321              NULL,
    322              NULL,
    323              NULL,
    324              eckey_check_pair,
    325              eckey_alloc_wrap,       /* Same underlying key structure */
    326              eckey_free_wrap,        /* Same underlying key structure */
    327              eckey_debug,            /* Same underlying key structure */
    328          };
    329          #endif /* MBEDTLS_ECP_C */
    330          
    331          #if defined(MBEDTLS_ECDSA_C)

   \                                 In section .text, align 2, keep-with-next
    332          static int ecdsa_can_do( mbedtls_pk_type_t type )
    333          {
    334              return( type == MBEDTLS_PK_ECDSA );
   \                     ecdsa_can_do: (+1)
   \   00000000   0x2804             CMP      R0,#+4
   \   00000002   0xD101             BNE      ??ecdsa_can_do_0
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x4770             BX       LR
   \                     ??ecdsa_can_do_0: (+1)
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR               ;; return
    335          }
    336          

   \                                 In section .text, align 2, keep-with-next
    337          static int ecdsa_verify_wrap( void *ctx, mbedtls_md_type_t md_alg,
    338                                 const unsigned char *hash, size_t hash_len,
    339                                 const unsigned char *sig, size_t sig_len )
    340          {
   \                     ecdsa_verify_wrap: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0011             MOVS     R1,R2
   \   00000004   0x001A             MOVS     R2,R3
    341              int ret;
    342              ((void) md_alg);
    343          
    344              ret = mbedtls_ecdsa_read_signature( (mbedtls_ecdsa_context *) ctx,
    345                                          hash, hash_len, sig, sig_len );
   \   00000006   0x9B03             LDR      R3,[SP, #+12]
   \   00000008   0x9300             STR      R3,[SP, #+0]
   \   0000000A   0x9B02             LDR      R3,[SP, #+8]
   \   0000000C   0x.... 0x....      BL       mbedtls_ecdsa_read_signature
    346          
    347              if( ret == MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH )
   \   00000010   0x....             LDR      R1,??DataTable19_3  ;; 0xffffb400
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD100             BNE      ??ecdsa_verify_wrap_0
    348                  return( MBEDTLS_ERR_PK_SIG_LEN_MISMATCH );
   \   00000016   0x....             LDR      R0,??DataTable19  ;; 0xffffc700
    349          
    350              return( ret );
   \                     ??ecdsa_verify_wrap_0: (+1)
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    351          }
    352          

   \                                 In section .text, align 2, keep-with-next
    353          static int ecdsa_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
    354                             const unsigned char *hash, size_t hash_len,
    355                             unsigned char *sig, size_t *sig_len,
    356                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    357          {
   \                     ecdsa_sign_wrap: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    358              return( mbedtls_ecdsa_write_signature( (mbedtls_ecdsa_context *) ctx,
    359                          md_alg, hash, hash_len, sig, sig_len, f_rng, p_rng ) );
   \   00000004   0x9C09             LDR      R4,[SP, #+36]
   \   00000006   0x9403             STR      R4,[SP, #+12]
   \   00000008   0x9C08             LDR      R4,[SP, #+32]
   \   0000000A   0x9402             STR      R4,[SP, #+8]
   \   0000000C   0x9C07             LDR      R4,[SP, #+28]
   \   0000000E   0x9401             STR      R4,[SP, #+4]
   \   00000010   0x9C06             LDR      R4,[SP, #+24]
   \   00000012   0x9400             STR      R4,[SP, #+0]
   \   00000014   0x.... 0x....      BL       mbedtls_ecdsa_write_signature
   \   00000018   0xB004             ADD      SP,SP,#+16
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    360          }
    361          

   \                                 In section .text, align 2, keep-with-next
    362          static void *ecdsa_alloc_wrap( void )
    363          {
   \                     ecdsa_alloc_wrap: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    364              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ecdsa_context ) );
   \   00000002   0x21AC             MOVS     R1,#+172
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       calloc
   \   0000000A   0x0004             MOVS     R4,R0
    365          
    366              if( ctx != NULL )
   \   0000000C   0xD001             BEQ      ??ecdsa_alloc_wrap_0
    367                  mbedtls_ecdsa_init( (mbedtls_ecdsa_context *) ctx );
   \   0000000E   0x.... 0x....      BL       mbedtls_ecdsa_init
    368          
    369              return( ctx );
   \                     ??ecdsa_alloc_wrap_0: (+1)
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    370          }
    371          

   \                                 In section .text, align 2, keep-with-next
    372          static void ecdsa_free_wrap( void *ctx )
    373          {
   \                     ecdsa_free_wrap: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    374              mbedtls_ecdsa_free( (mbedtls_ecdsa_context *) ctx );
   \   00000004   0x.... 0x....      BL       mbedtls_ecdsa_free
    375              mbedtls_free( ctx );
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       free
    376          }
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    377          

   \                                 In section .rodata, align 4, keep-with-next
    378          const mbedtls_pk_info_t mbedtls_ecdsa_info = {
   \                     mbedtls_ecdsa_info:
   \   00000000   0x04 0x00          DC8 4, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x........         DC32 ?_3, eckey_get_bitlen, ecdsa_can_do, ecdsa_verify_wrap
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000014   0x........         DC32 ecdsa_sign_wrap, 0H, 0H, eckey_check_pair, ecdsa_alloc_wrap
   \              0x00000000   
   \              0x00000000   
   \              0x........   
   \              0x........   
   \   00000028   0x........         DC32 ecdsa_free_wrap, eckey_debug
   \              0x........   
    379              MBEDTLS_PK_ECDSA,
    380              "ECDSA",
    381              eckey_get_bitlen,     /* Compatible key structures */
    382              ecdsa_can_do,
    383              ecdsa_verify_wrap,
    384              ecdsa_sign_wrap,
    385              NULL,
    386              NULL,
    387              eckey_check_pair,   /* Compatible key structures */
    388              ecdsa_alloc_wrap,
    389              ecdsa_free_wrap,
    390              eckey_debug,        /* Compatible key structures */
    391          };
    392          #endif /* MBEDTLS_ECDSA_C */
    393          
    394          #if defined(MBEDTLS_PK_RSA_ALT_SUPPORT)
    395          /*
    396           * Support for alternative RSA-private implementations
    397           */
    398          

   \                                 In section .text, align 2, keep-with-next
    399          static int rsa_alt_can_do( mbedtls_pk_type_t type )
    400          {
    401              return( type == MBEDTLS_PK_RSA );
   \                     rsa_alt_can_do: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD000             BEQ      ??rsa_alt_can_do_0
   \   00000004   0x2000             MOVS     R0,#+0
   \                     ??rsa_alt_can_do_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    402          }
    403          

   \                                 In section .text, align 2, keep-with-next
    404          static size_t rsa_alt_get_bitlen( const void *ctx )
    405          {
   \                     rsa_alt_get_bitlen: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0001             MOVS     R1,R0
    406              const mbedtls_rsa_alt_context *rsa_alt = (const mbedtls_rsa_alt_context *) ctx;
    407          
    408              return( 8 * rsa_alt->key_len_func( rsa_alt->key ) );
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0x68C9             LDR      R1,[R1, #+12]
   \   00000008   0x4788             BLX      R1
   \   0000000A   0x00C0             LSLS     R0,R0,#+3
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    409          }
    410          

   \                                 In section .text, align 2, keep-with-next
    411          static int rsa_alt_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
    412                             const unsigned char *hash, size_t hash_len,
    413                             unsigned char *sig, size_t *sig_len,
    414                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    415          {
   \                     rsa_alt_sign_wrap: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x001E             MOVS     R6,R3
    416              mbedtls_rsa_alt_context *rsa_alt = (mbedtls_rsa_alt_context *) ctx;
    417          
    418          #if defined(MBEDTLS_HAVE_INT64)
    419              if( UINT_MAX < hash_len )
    420                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
    421          #endif /* MBEDTLS_HAVE_INT64 */
    422          
    423              *sig_len = rsa_alt->key_len_func( rsa_alt->key );
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x68E1             LDR      R1,[R4, #+12]
   \   00000010   0x4788             BLX      R1
   \   00000012   0x990B             LDR      R1,[SP, #+44]
   \   00000014   0x6008             STR      R0,[R1, #+0]
    424          
    425              return( rsa_alt->sign_func( rsa_alt->key, f_rng, p_rng, MBEDTLS_RSA_PRIVATE,
    426                          md_alg, (unsigned int) hash_len, hash, sig ) );
   \   00000016   0x980A             LDR      R0,[SP, #+40]
   \   00000018   0x9003             STR      R0,[SP, #+12]
   \   0000001A   0x9502             STR      R5,[SP, #+8]
   \   0000001C   0x9601             STR      R6,[SP, #+4]
   \   0000001E   0x9700             STR      R7,[SP, #+0]
   \   00000020   0x2301             MOVS     R3,#+1
   \   00000022   0x9A0D             LDR      R2,[SP, #+52]
   \   00000024   0x990C             LDR      R1,[SP, #+48]
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68A4             LDR      R4,[R4, #+8]
   \   0000002A   0x47A0             BLX      R4
   \   0000002C   0xB005             ADD      SP,SP,#+20
   \   0000002E   0xBDF0             POP      {R4-R7,PC}       ;; return
    427          }
    428          

   \                                 In section .text, align 2, keep-with-next
    429          static int rsa_alt_decrypt_wrap( void *ctx,
    430                              const unsigned char *input, size_t ilen,
    431                              unsigned char *output, size_t *olen, size_t osize,
    432                              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    433          {
   \                     rsa_alt_decrypt_wrap: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x001E             MOVS     R6,R3
    434              mbedtls_rsa_alt_context *rsa_alt = (mbedtls_rsa_alt_context *) ctx;
    435          
    436              ((void) f_rng);
    437              ((void) p_rng);
    438          
    439              if( ilen != rsa_alt->key_len_func( rsa_alt->key ) )
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x68E1             LDR      R1,[R4, #+12]
   \   00000010   0x4788             BLX      R1
   \   00000012   0x4287             CMP      R7,R0
   \   00000014   0xD001             BEQ      ??rsa_alt_decrypt_wrap_0
    440                  return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
   \   00000016   0x....             LDR      R0,??DataTable19_1  ;; 0xffffbf80
   \   00000018   0xE008             B        ??rsa_alt_decrypt_wrap_1
    441          
    442              return( rsa_alt->decrypt_func( rsa_alt->key,
    443                          MBEDTLS_RSA_PRIVATE, olen, input, output, osize ) );
   \                     ??rsa_alt_decrypt_wrap_0: (+1)
   \   0000001A   0x9809             LDR      R0,[SP, #+36]
   \   0000001C   0x9001             STR      R0,[SP, #+4]
   \   0000001E   0x9600             STR      R6,[SP, #+0]
   \   00000020   0x002B             MOVS     R3,R5
   \   00000022   0x9A08             LDR      R2,[SP, #+32]
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6864             LDR      R4,[R4, #+4]
   \   0000002A   0x47A0             BLX      R4
   \                     ??rsa_alt_decrypt_wrap_1: (+1)
   \   0000002C   0xB003             ADD      SP,SP,#+12
   \   0000002E   0xBDF0             POP      {R4-R7,PC}       ;; return
    444          }
    445          
    446          #if defined(MBEDTLS_RSA_C)

   \                                 In section .text, align 2, keep-with-next
    447          static int rsa_alt_check_pair( const void *pub, const void *prv )
    448          {
   \                     rsa_alt_check_pair: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x....             LDR      R4,??DataTable19_4  ;; 0xfffffbd0
   \   00000004   0x44A5             ADD      SP,SP,R4
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x000C             MOVS     R4,R1
    449              unsigned char sig[MBEDTLS_MPI_MAX_SIZE];
    450              unsigned char hash[32];
    451              size_t sig_len = 0;
    452              int ret;
    453          
    454              if( rsa_alt_get_bitlen( prv ) != rsa_get_bitlen( pub ) )
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x68E1             LDR      R1,[R4, #+12]
   \   0000000E   0x4788             BLX      R1
   \   00000010   0x00C0             LSLS     R0,R0,#+3
   \   00000012   0x6869             LDR      R1,[R5, #+4]
   \   00000014   0x00C9             LSLS     R1,R1,#+3
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD123             BNE      ??rsa_alt_check_pair_0
    455                  return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
    456          
    457              memset( hash, 0x2a, sizeof( hash ) );
   \   0000001A   0x222A             MOVS     R2,#+42
   \   0000001C   0x2120             MOVS     R1,#+32
   \   0000001E   0xA804             ADD      R0,SP,#+16
   \   00000020   0x.... 0x....      BL       __aeabi_memset4
    458          
    459              if( ( ret = rsa_alt_sign_wrap( (void *) prv, MBEDTLS_MD_NONE,
    460                                             hash, sizeof( hash ),
    461                                             sig, &sig_len, NULL, NULL ) ) != 0 )
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x68E1             LDR      R1,[R4, #+12]
   \   00000028   0x4788             BLX      R1
   \   0000002A   0x0006             MOVS     R6,R0
   \   0000002C   0xA80C             ADD      R0,SP,#+48
   \   0000002E   0x9003             STR      R0,[SP, #+12]
   \   00000030   0xA804             ADD      R0,SP,#+16
   \   00000032   0x9002             STR      R0,[SP, #+8]
   \   00000034   0x2020             MOVS     R0,#+32
   \   00000036   0x9001             STR      R0,[SP, #+4]
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0x2301             MOVS     R3,#+1
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x68A4             LDR      R4,[R4, #+8]
   \   00000046   0x47A0             BLX      R4
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD10B             BNE      ??rsa_alt_check_pair_1
    462              {
    463                  return( ret );
    464              }
    465          
    466              if( rsa_verify_wrap( (void *) pub, MBEDTLS_MD_NONE,
    467                                   hash, sizeof( hash ), sig, sig_len ) != 0 )
   \   0000004C   0x9601             STR      R6,[SP, #+4]
   \   0000004E   0xA80C             ADD      R0,SP,#+48
   \   00000050   0x9000             STR      R0,[SP, #+0]
   \   00000052   0x2320             MOVS     R3,#+32
   \   00000054   0xAA04             ADD      R2,SP,#+16
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0x.... 0x....      BL       rsa_verify_wrap
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD000             BEQ      ??rsa_alt_check_pair_1
    468              {
    469                  return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
   \                     ??rsa_alt_check_pair_0: (+1)
   \   00000062   0x....             LDR      R0,??DataTable19_5  ;; 0xffffbe00
    470              }
    471          
    472              return( 0 );
   \                     ??rsa_alt_check_pair_1: (+1)
   \   00000064   0x2186             MOVS     R1,#+134
   \   00000066   0x00C9             LSLS     R1,R1,#+3        ;; #+1072
   \   00000068   0x448D             ADD      SP,SP,R1
   \   0000006A   0xBD70             POP      {R4-R6,PC}       ;; return
    473          }
    474          #endif /* MBEDTLS_RSA_C */
    475          

   \                                 In section .text, align 2, keep-with-next
    476          static void *rsa_alt_alloc_wrap( void )
    477          {
   \                     rsa_alt_alloc_wrap: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    478              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_rsa_alt_context ) );
   \   00000002   0x2110             MOVS     R1,#+16
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       calloc
   \   0000000A   0x0004             MOVS     R4,R0
    479          
    480              if( ctx != NULL )
   \   0000000C   0xD002             BEQ      ??rsa_alt_alloc_wrap_0
    481                  memset( ctx, 0, sizeof( mbedtls_rsa_alt_context ) );
   \   0000000E   0x2110             MOVS     R1,#+16
   \   00000010   0x.... 0x....      BL       __aeabi_memclr
    482          
    483              return( ctx );
   \                     ??rsa_alt_alloc_wrap_0: (+1)
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    484          }
    485          

   \                                 In section .text, align 2, keep-with-next
    486          static void rsa_alt_free_wrap( void *ctx )
    487          {
   \                     rsa_alt_free_wrap: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    488              mbedtls_zeroize( ctx, sizeof( mbedtls_rsa_alt_context ) );
   \   00000004   0x2110             MOVS     R1,#+16
   \   00000006   0x.... 0x....      BL       __aeabi_memclr
    489              mbedtls_free( ctx );
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       free
    490          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    491          

   \                                 In section .rodata, align 4, keep-with-next
    492          const mbedtls_pk_info_t mbedtls_rsa_alt_info = {
   \                     mbedtls_rsa_alt_info:
   \   00000000   0x05 0x00          DC8 5, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x........         DC32 ?_4, rsa_alt_get_bitlen, rsa_alt_can_do, 0H, rsa_alt_sign_wrap
   \              0x........   
   \              0x........   
   \              0x00000000   
   \              0x........   
   \   00000018   0x........         DC32 rsa_alt_decrypt_wrap, 0H, rsa_alt_check_pair, rsa_alt_alloc_wrap
   \              0x00000000   
   \              0x........   
   \              0x........   
   \   00000028   0x........         DC32 rsa_alt_free_wrap, 0H
   \              0x00000000   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0xFFFFBC80         DC32     0xffffbc80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0xFFFFC700         DC32     0xffffc700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0xFFFFBF80         DC32     0xffffbf80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0xFFFFBC00         DC32     0xffffbc00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0xFFFFB400         DC32     0xffffb400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0xFFFFFBD0         DC32     0xfffffbd0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \   00000000   0xFFFFBE00         DC32     0xffffbe00

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x52 0x53          DC8 "RSA"
   \              0x41 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x45 0x43          DC8 "EC"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x45 0x43          DC8 "EC_DH"
   \              0x5F 0x44    
   \              0x48 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x45 0x43          DC8 "ECDSA"
   \              0x44 0x53    
   \              0x41 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x52 0x53          DC8 "RSA-alt"
   \              0x41 0x2D    
   \              0x61 0x6C    
   \              0x74 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x72 0x73          DC8 "rsa.N"
   \              0x61 0x2E    
   \              0x4E 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x72 0x73          DC8 "rsa.E"
   \              0x61 0x2E    
   \              0x45 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x65 0x63          DC8 "eckey.Q"
   \              0x6B 0x65    
   \              0x79 0x2E    
   \              0x51 0x00    
    493              MBEDTLS_PK_RSA_ALT,
    494              "RSA-alt",
    495              rsa_alt_get_bitlen,
    496              rsa_alt_can_do,
    497              NULL,
    498              rsa_alt_sign_wrap,
    499              rsa_alt_decrypt_wrap,
    500              NULL,
    501          #if defined(MBEDTLS_RSA_C)
    502              rsa_alt_check_pair,
    503          #else
    504              NULL,
    505          #endif
    506              rsa_alt_alloc_wrap,
    507              rsa_alt_free_wrap,
    508              NULL,
    509          };
    510          
    511          #endif /* MBEDTLS_PK_RSA_ALT_SUPPORT */
    512          
    513          #endif /* MBEDTLS_PK_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ecdsa_alloc_wrap
         8   -> calloc
         8   -> mbedtls_ecdsa_init
       0   ecdsa_can_do
       8   ecdsa_free_wrap
         8   -> free
         8   -> mbedtls_ecdsa_free
      24   ecdsa_sign_wrap
        24   -> mbedtls_ecdsa_write_signature
       8   ecdsa_verify_wrap
         8   -> mbedtls_ecdsa_read_signature
       8   eckey_alloc_wrap
         8   -> calloc
         8   -> mbedtls_ecp_keypair_init
       0   eckey_can_do
       8   eckey_check_pair
         8   -> mbedtls_ecp_check_pub_priv
       0   eckey_debug
       8   eckey_free_wrap
         8   -> free
         8   -> mbedtls_ecp_keypair_free
       0   eckey_get_bitlen
     208   eckey_sign_wrap
       208   -> mbedtls_ecdsa_free
       208   -> mbedtls_ecdsa_from_keypair
       208   -> mbedtls_ecdsa_init
       208   -> mbedtls_ecdsa_write_signature
     192   eckey_verify_wrap
       192   -> mbedtls_ecdsa_free
       192   -> mbedtls_ecdsa_from_keypair
       192   -> mbedtls_ecdsa_init
       192   -> mbedtls_ecdsa_read_signature
       0   eckeydh_can_do
       8   rsa_alloc_wrap
         8   -> calloc
         8   -> mbedtls_rsa_init
       8   rsa_alt_alloc_wrap
         8   -> __aeabi_memclr
         8   -> calloc
       0   rsa_alt_can_do
    1088   rsa_alt_check_pair
      1088   -- Indirect call
      1088   -> __aeabi_memset4
      1088   -> rsa_verify_wrap
      32   rsa_alt_decrypt_wrap
        32   -- Indirect call
       8   rsa_alt_free_wrap
         8   -> __aeabi_memclr
         8   -> free
       8   rsa_alt_get_bitlen
         8   -- Indirect call
      40   rsa_alt_sign_wrap
        40   -- Indirect call
       0   rsa_can_do
       8   rsa_check_pair_wrap
         8   -> mbedtls_rsa_check_pub_priv
       0   rsa_debug
      24   rsa_decrypt_wrap
        24   -> mbedtls_rsa_pkcs1_decrypt
      24   rsa_encrypt_wrap
        24   -> mbedtls_rsa_pkcs1_encrypt
       8   rsa_free_wrap
         8   -> free
         8   -> mbedtls_rsa_free
       0   rsa_get_bitlen
      32   rsa_sign_wrap
        32   -> mbedtls_rsa_pkcs1_sign
      32   rsa_verify_wrap
        32   -> mbedtls_rsa_pkcs1_verify


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ?_0
       4  ?_1
       8  ?_2
       8  ?_3
       8  ?_4
       8  ?_5
       8  ?_6
       8  ?_7
      22  ecdsa_alloc_wrap
      12  ecdsa_can_do
      16  ecdsa_free_wrap
      28  ecdsa_sign_wrap
      26  ecdsa_verify_wrap
      22  eckey_alloc_wrap
      20  eckey_can_do
       8  eckey_check_pair
      14  eckey_debug
      16  eckey_free_wrap
       4  eckey_get_bitlen
      72  eckey_sign_wrap
      66  eckey_verify_wrap
      16  eckeydh_can_do
      48  mbedtls_ecdsa_info
      48  mbedtls_eckey_info
      48  mbedtls_eckeydh_info
      48  mbedtls_rsa_alt_info
      48  mbedtls_rsa_info
      26  rsa_alloc_wrap
      24  rsa_alt_alloc_wrap
       8  rsa_alt_can_do
     108  rsa_alt_check_pair
      48  rsa_alt_decrypt_wrap
      18  rsa_alt_free_wrap
      14  rsa_alt_get_bitlen
      48  rsa_alt_sign_wrap
      16  rsa_can_do
       8  rsa_check_pair_wrap
      30  rsa_debug
      40  rsa_decrypt_wrap
      40  rsa_encrypt_wrap
      16  rsa_free_wrap
       6  rsa_get_bitlen
      34  rsa_sign_wrap
      60  rsa_verify_wrap

 
 272 bytes in section .rodata
 938 bytes in section .text
 
 938 bytes of CODE  memory
 272 bytes of CONST memory

Errors: none
Warnings: none

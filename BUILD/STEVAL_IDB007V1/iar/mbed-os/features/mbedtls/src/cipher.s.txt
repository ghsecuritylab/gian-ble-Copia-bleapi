###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:24
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\features\mbedtls\src\cipher.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\cipher.d -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\cipher.s.txt
#        -o .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\cipher.o
#        .\mbed-os\features\mbedtls\src\cipher.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\cipher.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\cipher.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\features\mbedtls\src\cipher.c
      1          /**
      2           * \file cipher.c
      3           *
      4           * \brief Generic cipher wrapper for mbed TLS
      5           *
      6           * \author Adriaan de Jong <dejong@fox-it.com>
      7           *
      8           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      9           *  SPDX-License-Identifier: Apache-2.0
     10           *
     11           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
     12           *  not use this file except in compliance with the License.
     13           *  You may obtain a copy of the License at
     14           *
     15           *  http://www.apache.org/licenses/LICENSE-2.0
     16           *
     17           *  Unless required by applicable law or agreed to in writing, software
     18           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     19           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     20           *  See the License for the specific language governing permissions and
     21           *  limitations under the License.
     22           *
     23           *  This file is part of mbed TLS (https://tls.mbed.org)
     24           */
     25          
     26          #if !defined(MBEDTLS_CONFIG_FILE)
     27          #include "mbedtls/config.h"
     28          #else
     29          #include MBEDTLS_CONFIG_FILE
     30          #endif
     31          
     32          #if defined(MBEDTLS_CIPHER_C)
     33          
     34          #include "mbedtls/cipher.h"
     35          #include "mbedtls/cipher_internal.h"
     36          
     37          #include <stdlib.h>
     38          #include <string.h>
     39          
     40          #if defined(MBEDTLS_GCM_C)
     41          #include "mbedtls/gcm.h"
     42          #endif
     43          
     44          #if defined(MBEDTLS_CCM_C)
     45          #include "mbedtls/ccm.h"
     46          #endif
     47          
     48          #if defined(MBEDTLS_CMAC_C)
     49          #include "mbedtls/cmac.h"
     50          #endif
     51          
     52          #if defined(MBEDTLS_PLATFORM_C)
     53          #include "mbedtls/platform.h"
     54          #else
     55          #define mbedtls_calloc calloc
     56          #define mbedtls_free   free
     57          #endif
     58          
     59          #if defined(MBEDTLS_ARC4_C) || defined(MBEDTLS_CIPHER_NULL_CIPHER)
     60          #define MBEDTLS_CIPHER_MODE_STREAM
     61          #endif
     62          
     63          /* Implementation that should never be optimized out by the compiler */
     64          static void mbedtls_zeroize( void *v, size_t n ) {
     65              volatile unsigned char *p = (unsigned char*)v; while( n-- ) *p++ = 0;
     66          }
     67          

   \                                 In section .bss, align 4
     68          static int supported_init = 0;
   \                     supported_init:
   \   00000000                      DS8 4
     69          

   \                                 In section .text, align 2, keep-with-next
     70          const int *mbedtls_cipher_list( void )
     71          {
     72              const mbedtls_cipher_definition_t *def;
     73              int *type;
     74          
     75              if( ! supported_init )
   \                     mbedtls_cipher_list: (+1)
   \   00000000   0x....             LDR      R0,??DataTable8
   \   00000002   0x....             LDR      R1,??DataTable8_1
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD000             BEQ      ??mbedtls_cipher_list_0
   \   0000000A   0x4770             BX       LR
     76              {
     77                  def = mbedtls_cipher_definitions;
   \                     ??mbedtls_cipher_list_0: (+1)
   \   0000000C   0xB430             PUSH     {R4,R5}
   \   0000000E   0x....             LDR      R2,??DataTable8_2
     78                  type = mbedtls_cipher_supported;
   \   00000010   0x0003             MOVS     R3,R0
   \   00000012   0xE002             B        ??mbedtls_cipher_list_1
     79          
     80                  while( def->type != 0 )
     81                      *type++ = (*def++).type;
   \                     ??mbedtls_cipher_list_2: (+1)
   \   00000014   0x601C             STR      R4,[R3, #+0]
   \   00000016   0x3208             ADDS     R2,R2,#+8
   \   00000018   0x1D1B             ADDS     R3,R3,#+4
   \                     ??mbedtls_cipher_list_1: (+1)
   \   0000001A   0x7814             LDRB     R4,[R2, #+0]
   \   0000001C   0x0025             MOVS     R5,R4
   \   0000001E   0xD1F9             BNE      ??mbedtls_cipher_list_2
     82          
     83                  *type = 0;
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x601A             STR      R2,[R3, #+0]
     84          
     85                  supported_init = 1;
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0x600A             STR      R2,[R1, #+0]
     86              }
     87          
     88              return( mbedtls_cipher_supported );
   \   00000028   0xBC30             POP      {R4,R5}
   \   0000002A   0x4770             BX       LR               ;; return
     89          }
     90          

   \                                 In section .text, align 2, keep-with-next
     91          const mbedtls_cipher_info_t *mbedtls_cipher_info_from_type( const mbedtls_cipher_type_t cipher_type )
     92          {
   \                     mbedtls_cipher_info_from_type: (+1)
   \   00000000   0xB410             PUSH     {R4}
     93              const mbedtls_cipher_definition_t *def;
     94          
     95              for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )
   \   00000002   0x....             LDR      R2,??DataTable8_2
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0xE000             B        ??mbedtls_cipher_info_from_type_0
   \                     ??mbedtls_cipher_info_from_type_1: (+1)
   \   00000008   0x3208             ADDS     R2,R2,#+8
   \                     ??mbedtls_cipher_info_from_type_0: (+1)
   \   0000000A   0x6850             LDR      R0,[R2, #+4]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD002             BEQ      ??mbedtls_cipher_info_from_type_2
     96                  if( def->type == cipher_type )
   \   00000010   0x7813             LDRB     R3,[R2, #+0]
   \   00000012   0x42A3             CMP      R3,R4
   \   00000014   0xD1F8             BNE      ??mbedtls_cipher_info_from_type_1
     97                      return( def->info );
     98          
     99              return( NULL );
   \                     ??mbedtls_cipher_info_from_type_2: (+1)
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
    100          }
    101          

   \                                 In section .text, align 2, keep-with-next
    102          const mbedtls_cipher_info_t *mbedtls_cipher_info_from_string( const char *cipher_name )
    103          {
   \                     mbedtls_cipher_info_from_string: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    104              const mbedtls_cipher_definition_t *def;
    105          
    106              if( NULL == cipher_name )
   \   00000004   0xD00D             BEQ      ??mbedtls_cipher_info_from_string_0
    107                  return( NULL );
    108          
    109              for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )
   \   00000006   0x....             LDR      R5,??DataTable8_2
   \   00000008   0xE000             B        ??mbedtls_cipher_info_from_string_1
   \                     ??mbedtls_cipher_info_from_string_2: (+1)
   \   0000000A   0x3508             ADDS     R5,R5,#+8
   \                     ??mbedtls_cipher_info_from_string_1: (+1)
   \   0000000C   0x6868             LDR      R0,[R5, #+4]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD007             BEQ      ??mbedtls_cipher_info_from_string_0
    110                  if( !  strcmp( def->info->name, cipher_name ) )
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x6880             LDR      R0,[R0, #+8]
   \   00000016   0x.... 0x....      BL       strcmp
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD1F5             BNE      ??mbedtls_cipher_info_from_string_2
    111                      return( def->info );
   \   0000001E   0x6868             LDR      R0,[R5, #+4]
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}
    112          
    113              return( NULL );
   \                     ??mbedtls_cipher_info_from_string_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    114          }
    115          

   \                                 In section .text, align 2, keep-with-next
    116          const mbedtls_cipher_info_t *mbedtls_cipher_info_from_values( const mbedtls_cipher_id_t cipher_id,
    117                                                        int key_bitlen,
    118                                                        const mbedtls_cipher_mode_t mode )
    119          {
   \                     mbedtls_cipher_info_from_values: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    120              const mbedtls_cipher_definition_t *def;
    121          
    122              for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )
   \   00000002   0x....             LDR      R3,??DataTable8_2
   \   00000004   0xE000             B        ??mbedtls_cipher_info_from_values_0
   \                     ??mbedtls_cipher_info_from_values_1: (+1)
   \   00000006   0x3308             ADDS     R3,R3,#+8
   \                     ??mbedtls_cipher_info_from_values_0: (+1)
   \   00000008   0x685C             LDR      R4,[R3, #+4]
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD00B             BEQ      ??mbedtls_cipher_info_from_values_2
    123                  if( def->info->base->cipher == cipher_id &&
    124                      def->info->key_bitlen == (unsigned) key_bitlen &&
    125                      def->info->mode == mode )
   \   0000000E   0x69A5             LDR      R5,[R4, #+24]
   \   00000010   0x782D             LDRB     R5,[R5, #+0]
   \   00000012   0x4285             CMP      R5,R0
   \   00000014   0xD1F7             BNE      ??mbedtls_cipher_info_from_values_1
   \   00000016   0x6865             LDR      R5,[R4, #+4]
   \   00000018   0x428D             CMP      R5,R1
   \   0000001A   0xD1F4             BNE      ??mbedtls_cipher_info_from_values_1
   \   0000001C   0x7864             LDRB     R4,[R4, #+1]
   \   0000001E   0x4294             CMP      R4,R2
   \   00000020   0xD1F1             BNE      ??mbedtls_cipher_info_from_values_1
    126                      return( def->info );
   \   00000022   0x6858             LDR      R0,[R3, #+4]
   \   00000024   0xE000             B        ??mbedtls_cipher_info_from_values_3
    127          
    128              return( NULL );
   \                     ??mbedtls_cipher_info_from_values_2: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_cipher_info_from_values_3: (+1)
   \   00000028   0xBC30             POP      {R4,R5}
   \   0000002A   0x4770             BX       LR               ;; return
    129          }
    130          

   \                                 In section .text, align 2, keep-with-next
    131          void mbedtls_cipher_init( mbedtls_cipher_context_t *ctx )
    132          {
   \                     mbedtls_cipher_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    133              memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );
   \   00000002   0x2140             MOVS     R1,#+64
   \   00000004   0x.... 0x....      BL       __aeabi_memclr4
    134          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    135          

   \                                 In section .text, align 2, keep-with-next
    136          void mbedtls_cipher_free( mbedtls_cipher_context_t *ctx )
    137          {
   \                     mbedtls_cipher_free: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    138              if( ctx == NULL )
   \   00000004   0xD00A             BEQ      ??mbedtls_cipher_free_0
    139                  return;
    140          
    141          #if defined(MBEDTLS_CMAC_C)
    142              if( ctx->cmac_ctx )
    143              {
    144                 mbedtls_zeroize( ctx->cmac_ctx, sizeof( mbedtls_cmac_context_t ) );
    145                 mbedtls_free( ctx->cmac_ctx );
    146              }
    147          #endif
    148          
    149              if( ctx->cipher_ctx )
   \   00000006   0x6BE0             LDR      R0,[R4, #+60]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ      ??mbedtls_cipher_free_1
    150                  ctx->cipher_info->base->ctx_free_func( ctx->cipher_ctx );
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x6989             LDR      R1,[R1, #+24]
   \   00000010   0x6989             LDR      R1,[R1, #+24]
   \   00000012   0x4788             BLX      R1
    151          
    152              mbedtls_zeroize( ctx, sizeof(mbedtls_cipher_context_t) );
   \                     ??mbedtls_cipher_free_1: (+1)
   \   00000014   0x2140             MOVS     R1,#+64
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       __aeabi_memclr
    153          }
   \                     ??mbedtls_cipher_free_0: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    154          

   \                                 In section .text, align 2, keep-with-next
    155          int mbedtls_cipher_setup( mbedtls_cipher_context_t *ctx, const mbedtls_cipher_info_t *cipher_info )
    156          {
   \                     mbedtls_cipher_setup: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    157              if( NULL == cipher_info || NULL == ctx )
   \   00000006   0xD001             BEQ      ??mbedtls_cipher_setup_0
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE      ??mbedtls_cipher_setup_1
    158                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
   \                     ??mbedtls_cipher_setup_0: (+1)
   \   0000000C   0x....             LDR      R0,??DataTable9  ;; 0xffff9f00
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    159          
    160              memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );
   \                     ??mbedtls_cipher_setup_1: (+1)
   \   00000010   0x2140             MOVS     R1,#+64
   \   00000012   0x.... 0x....      BL       __aeabi_memclr4
    161          
    162              if( NULL == ( ctx->cipher_ctx = cipher_info->base->ctx_alloc_func() ) )
   \   00000016   0x69A8             LDR      R0,[R5, #+24]
   \   00000018   0x6940             LDR      R0,[R0, #+20]
   \   0000001A   0x4780             BLX      R0
   \   0000001C   0x63E0             STR      R0,[R4, #+60]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD009             BEQ      ??mbedtls_cipher_setup_2
   \   00000022   0x6025             STR      R5,[R4, #+0]
   \   00000024   0x7868             LDRB     R0,[R5, #+1]
   \   00000026   0x2802             CMP      R0,#+2
   \   00000028   0xD103             BNE      ??mbedtls_cipher_setup_3
   \   0000002A   0x....             LDR      R0,??DataTable9_1
   \   0000002C   0x60E0             STR      R0,[R4, #+12]
   \   0000002E   0x....             LDR      R0,??DataTable9_2
   \   00000030   0x6120             STR      R0,[R4, #+16]
    163                  return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );
    164          
    165              ctx->cipher_info = cipher_info;
    166          
    167          #if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)
    168              /*
    169               * Ignore possible errors caused by a cipher mode that doesn't use padding
    170               */
    171          #if defined(MBEDTLS_CIPHER_PADDING_PKCS7)
    172              (void) mbedtls_cipher_set_padding_mode( ctx, MBEDTLS_PADDING_PKCS7 );
    173          #else
    174              (void) mbedtls_cipher_set_padding_mode( ctx, MBEDTLS_PADDING_NONE );
    175          #endif
    176          #endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */
    177          
    178              return( 0 );
   \                     ??mbedtls_cipher_setup_3: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??mbedtls_cipher_setup_2: (+1)
   \   00000036   0x....             LDR      R0,??DataTable9_3  ;; 0xffff9e80
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}
    179          }
    180          

   \                                 In section .text, align 2, keep-with-next
    181          int mbedtls_cipher_setkey( mbedtls_cipher_context_t *ctx, const unsigned char *key,
    182                  int key_bitlen, const mbedtls_operation_t operation )
    183          {
   \                     mbedtls_cipher_setkey: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    184              if( NULL == ctx || NULL == ctx->cipher_info )
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD01F             BEQ      ??mbedtls_cipher_setkey_0
   \   00000006   0x6804             LDR      R4,[R0, #+0]
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD01C             BEQ      ??mbedtls_cipher_setkey_0
    185                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    186          
    187              if( ( ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_KEY_LEN ) == 0 &&
    188                  (int) ctx->cipher_info->key_bitlen != key_bitlen )
   \   0000000C   0x7C25             LDRB     R5,[R4, #+16]
   \   0000000E   0x07AD             LSLS     R5,R5,#+30
   \   00000010   0xD402             BMI      ??mbedtls_cipher_setkey_1
   \   00000012   0x6865             LDR      R5,[R4, #+4]
   \   00000014   0x4295             CMP      R5,R2
   \   00000016   0xD116             BNE      ??mbedtls_cipher_setkey_0
    189              {
    190                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    191              }
    192          
    193              ctx->key_bitlen = key_bitlen;
   \                     ??mbedtls_cipher_setkey_1: (+1)
   \   00000018   0x6042             STR      R2,[R0, #+4]
    194              ctx->operation = operation;
   \   0000001A   0x7203             STRB     R3,[R0, #+8]
    195          
    196              /*
    197               * For CFB and CTR mode always use the encryption key schedule
    198               */
    199              if( MBEDTLS_ENCRYPT == operation ||
    200                  MBEDTLS_MODE_CFB == ctx->cipher_info->mode ||
    201                  MBEDTLS_MODE_CTR == ctx->cipher_info->mode )
   \   0000001C   0x2B01             CMP      R3,#+1
   \   0000001E   0xD004             BEQ      ??mbedtls_cipher_setkey_2
   \   00000020   0x7862             LDRB     R2,[R4, #+1]
   \   00000022   0x2A03             CMP      R2,#+3
   \   00000024   0xD001             BEQ      ??mbedtls_cipher_setkey_2
   \   00000026   0x2A05             CMP      R2,#+5
   \   00000028   0xD105             BNE      ??mbedtls_cipher_setkey_3
    202              {
    203                  return ctx->cipher_info->base->setkey_enc_func( ctx->cipher_ctx, key,
    204                          ctx->key_bitlen );
   \                     ??mbedtls_cipher_setkey_2: (+1)
   \   0000002A   0x6842             LDR      R2,[R0, #+4]
   \   0000002C   0x6BC0             LDR      R0,[R0, #+60]
   \   0000002E   0x69A3             LDR      R3,[R4, #+24]
   \   00000030   0x68DB             LDR      R3,[R3, #+12]
   \   00000032   0x4798             BLX      R3
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}
    205              }
    206          
    207              if( MBEDTLS_DECRYPT == operation )
   \                     ??mbedtls_cipher_setkey_3: (+1)
   \   00000036   0x2B00             CMP      R3,#+0
   \   00000038   0xD105             BNE      ??mbedtls_cipher_setkey_0
    208                  return ctx->cipher_info->base->setkey_dec_func( ctx->cipher_ctx, key,
    209                          ctx->key_bitlen );
   \   0000003A   0x6842             LDR      R2,[R0, #+4]
   \   0000003C   0x6BC0             LDR      R0,[R0, #+60]
   \   0000003E   0x69A3             LDR      R3,[R4, #+24]
   \   00000040   0x691B             LDR      R3,[R3, #+16]
   \   00000042   0x4798             BLX      R3
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}
    210          
    211              return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
   \                     ??mbedtls_cipher_setkey_0: (+1)
   \   00000046   0x....             LDR      R0,??DataTable9  ;; 0xffff9f00
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    212          }
    213          

   \                                 In section .text, align 2, keep-with-next
    214          int mbedtls_cipher_set_iv( mbedtls_cipher_context_t *ctx,
    215                             const unsigned char *iv, size_t iv_len )
    216          {
   \                     mbedtls_cipher_set_iv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    217              size_t actual_iv_size;
    218          
    219              if( NULL == ctx || NULL == ctx->cipher_info || NULL == iv )
   \   00000004   0xD017             BEQ      ??mbedtls_cipher_set_iv_0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD014             BEQ      ??mbedtls_cipher_set_iv_0
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD012             BEQ      ??mbedtls_cipher_set_iv_0
    220                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    221          
    222              /* avoid buffer overflow in ctx->iv */
    223              if( iv_len > MBEDTLS_MAX_IV_LENGTH )
   \   00000010   0x2A11             CMP      R2,#+17
   \   00000012   0xD301             BCC      ??mbedtls_cipher_set_iv_1
    224                  return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
   \   00000014   0x....             LDR      R0,??DataTable11  ;; 0xffff9f80
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}
    225          
    226              if( ( ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_IV_LEN ) != 0 )
   \                     ??mbedtls_cipher_set_iv_1: (+1)
   \   00000018   0x7C03             LDRB     R3,[R0, #+16]
   \   0000001A   0x07DB             LSLS     R3,R3,#+31
   \   0000001C   0xD508             BPL      ??mbedtls_cipher_set_iv_2
    227                  actual_iv_size = iv_len;
   \   0000001E   0x0015             MOVS     R5,R2
    228              else
    229              {
    230                  actual_iv_size = ctx->cipher_info->iv_size;
    231          
    232                  /* avoid reading past the end of input buffer */
    233                  if( actual_iv_size > iv_len )
    234                      return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    235              }
    236          
    237              memcpy( ctx->iv, iv, actual_iv_size );
   \                     ??mbedtls_cipher_set_iv_3: (+1)
   \   00000020   0x002A             MOVS     R2,R5
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x3028             ADDS     R0,R0,#+40
   \   00000026   0x.... 0x....      BL       __aeabi_memcpy
    238              ctx->iv_size = actual_iv_size;
   \   0000002A   0x63A5             STR      R5,[R4, #+56]
    239          
    240              return( 0 );
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??mbedtls_cipher_set_iv_2: (+1)
   \   00000030   0x68C5             LDR      R5,[R0, #+12]
   \   00000032   0x42AA             CMP      R2,R5
   \   00000034   0xD2F4             BCS      ??mbedtls_cipher_set_iv_3
   \                     ??mbedtls_cipher_set_iv_0: (+1)
   \   00000036   0x....             LDR      R0,??DataTable9  ;; 0xffff9f00
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}
    241          }
    242          

   \                                 In section .text, align 2, keep-with-next
    243          int mbedtls_cipher_reset( mbedtls_cipher_context_t *ctx )
    244          {
    245              if( NULL == ctx || NULL == ctx->cipher_info )
   \                     mbedtls_cipher_reset: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD002             BEQ      ??mbedtls_cipher_reset_0
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD101             BNE      ??mbedtls_cipher_reset_1
    246                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
   \                     ??mbedtls_cipher_reset_0: (+1)
   \   0000000A   0x....             LDR      R0,??DataTable9  ;; 0xffff9f00
   \   0000000C   0x4770             BX       LR
    247          
    248              ctx->unprocessed_len = 0;
   \                     ??mbedtls_cipher_reset_1: (+1)
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6241             STR      R1,[R0, #+36]
    249          
    250              return( 0 );
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
    251          }
    252          
    253          #if defined(MBEDTLS_GCM_C)

   \                                 In section .text, align 2, keep-with-next
    254          int mbedtls_cipher_update_ad( mbedtls_cipher_context_t *ctx,
    255                                const unsigned char *ad, size_t ad_len )
    256          {
   \                     mbedtls_cipher_update_ad: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    257              if( NULL == ctx || NULL == ctx->cipher_info )
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD002             BEQ      ??mbedtls_cipher_update_ad_0
   \   00000008   0x6803             LDR      R3,[R0, #+0]
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD101             BNE      ??mbedtls_cipher_update_ad_1
    258                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
   \                     ??mbedtls_cipher_update_ad_0: (+1)
   \   0000000E   0x....             LDR      R0,??DataTable9  ;; 0xffff9f00
   \   00000010   0xE00E             B        ??mbedtls_cipher_update_ad_2
    259          
    260              if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )
   \                     ??mbedtls_cipher_update_ad_1: (+1)
   \   00000012   0x785B             LDRB     R3,[R3, #+1]
   \   00000014   0x2B06             CMP      R3,#+6
   \   00000016   0xD10A             BNE      ??mbedtls_cipher_update_ad_3
    261              {
    262                  return mbedtls_gcm_starts( (mbedtls_gcm_context *) ctx->cipher_ctx, ctx->operation,
    263                                     ctx->iv, ctx->iv_size, ad, ad_len );
   \   00000018   0x9201             STR      R2,[SP, #+4]
   \   0000001A   0x9100             STR      R1,[SP, #+0]
   \   0000001C   0x6B83             LDR      R3,[R0, #+56]
   \   0000001E   0x0002             MOVS     R2,R0
   \   00000020   0x3228             ADDS     R2,R2,#+40
   \   00000022   0x2108             MOVS     R1,#+8
   \   00000024   0x5641             LDRSB    R1,[R0, R1]
   \   00000026   0x6BC0             LDR      R0,[R0, #+60]
   \   00000028   0x.... 0x....      BL       mbedtls_gcm_starts
   \   0000002C   0xE000             B        ??mbedtls_cipher_update_ad_2
    264              }
    265          
    266              return( 0 );
   \                     ??mbedtls_cipher_update_ad_3: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_cipher_update_ad_2: (+1)
   \   00000030   0xB003             ADD      SP,SP,#+12
   \   00000032   0xBD00             POP      {PC}             ;; return
    267          }
    268          #endif /* MBEDTLS_GCM_C */
    269          

   \                                 In section .text, align 2, keep-with-next
    270          int mbedtls_cipher_update( mbedtls_cipher_context_t *ctx, const unsigned char *input,
    271                             size_t ilen, unsigned char *output, size_t *olen )
    272          {
   \                     mbedtls_cipher_update: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0014             MOVS     R4,R2
    273              int ret;
    274              size_t block_size = 0;
    275          
    276              if( NULL == ctx || NULL == ctx->cipher_info || NULL == olen )
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD038             BEQ      ??mbedtls_cipher_update_0
   \   0000000E   0x682F             LDR      R7,[R5, #+0]
   \   00000010   0x2F00             CMP      R7,#+0
   \   00000012   0xD035             BEQ      ??mbedtls_cipher_update_0
   \   00000014   0x980A             LDR      R0,[SP, #+40]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD032             BEQ      ??mbedtls_cipher_update_0
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x990A             LDR      R1,[SP, #+40]
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    277              {
    278                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    279              }
    280          
    281              *olen = 0;
    282              block_size = mbedtls_cipher_get_block_size( ctx );
   \   00000020   0x6978             LDR      R0,[R7, #+20]
   \   00000022   0x9002             STR      R0,[SP, #+8]
   \   00000024   0x7878             LDRB     R0,[R7, #+1]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD10F             BNE      ??mbedtls_cipher_update_1
    283          
    284              if( ctx->cipher_info->mode == MBEDTLS_MODE_ECB )
    285              {
    286                  if( ilen != block_size )
   \   0000002A   0x9802             LDR      R0,[SP, #+8]
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD001             BEQ      ??mbedtls_cipher_update_2
    287                      return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
   \   00000030   0x....             LDR      R0,??DataTable11_1  ;; 0xffff9d80
   \   00000032   0xE0A5             B        ??mbedtls_cipher_update_3
    288          
    289                  *olen = ilen;
   \                     ??mbedtls_cipher_update_2: (+1)
   \   00000034   0x980A             LDR      R0,[SP, #+40]
   \   00000036   0x6004             STR      R4,[R0, #+0]
    290          
    291                  if( 0 != ( ret = ctx->cipher_info->base->ecb_func( ctx->cipher_ctx,
    292                              ctx->operation, input, output ) ) )
   \   00000038   0x9B04             LDR      R3,[SP, #+16]
   \   0000003A   0x0032             MOVS     R2,R6
   \   0000003C   0x2008             MOVS     R0,#+8
   \   0000003E   0x5629             LDRSB    R1,[R5, R0]
   \   00000040   0x6BE8             LDR      R0,[R5, #+60]
   \   00000042   0x69BC             LDR      R4,[R7, #+24]
   \   00000044   0x6864             LDR      R4,[R4, #+4]
   \   00000046   0x47A0             BLX      R4
    293                  {
    294                      return( ret );
    295                  }
    296          
    297                  return( 0 );
   \   00000048   0xE09A             B        ??mbedtls_cipher_update_3
    298              }
    299          
    300          #if defined(MBEDTLS_GCM_C)
    301              if( ctx->cipher_info->mode == MBEDTLS_MODE_GCM )
   \                     ??mbedtls_cipher_update_1: (+1)
   \   0000004A   0x2806             CMP      R0,#+6
   \   0000004C   0xD108             BNE      ??mbedtls_cipher_update_4
    302              {
    303                  *olen = ilen;
   \   0000004E   0x980A             LDR      R0,[SP, #+40]
   \   00000050   0x6004             STR      R4,[R0, #+0]
    304                  return mbedtls_gcm_update( (mbedtls_gcm_context *) ctx->cipher_ctx, ilen, input,
    305                                     output );
   \   00000052   0x9B04             LDR      R3,[SP, #+16]
   \   00000054   0x0032             MOVS     R2,R6
   \   00000056   0x0021             MOVS     R1,R4
   \   00000058   0x6BE8             LDR      R0,[R5, #+60]
   \   0000005A   0x.... 0x....      BL       mbedtls_gcm_update
   \   0000005E   0xE08F             B        ??mbedtls_cipher_update_3
    306              }
    307          #endif
    308          
    309              if ( 0 == block_size )
   \                     ??mbedtls_cipher_update_4: (+1)
   \   00000060   0x9802             LDR      R0,[SP, #+8]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD100             BNE      .+4
   \   00000066   0xE081             B        ??mbedtls_cipher_update_5
    310              {
    311                  return MBEDTLS_ERR_CIPHER_INVALID_CONTEXT;
    312              }
    313          
    314              if( input == output &&
    315                 ( ctx->unprocessed_len != 0 || ilen % block_size ) )
   \   00000068   0x9804             LDR      R0,[SP, #+16]
   \   0000006A   0x4286             CMP      R6,R0
   \   0000006C   0xD10A             BNE      ??mbedtls_cipher_update_6
   \   0000006E   0x6A68             LDR      R0,[R5, #+36]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD105             BNE      ??mbedtls_cipher_update_0
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x9902             LDR      R1,[SP, #+8]
   \   00000078   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000007C   0x2900             CMP      R1,#+0
   \   0000007E   0xD001             BEQ      ??mbedtls_cipher_update_6
    316              {
    317                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
   \                     ??mbedtls_cipher_update_0: (+1)
   \   00000080   0x....             LDR      R0,??DataTable9  ;; 0xffff9f00
   \   00000082   0xE07D             B        ??mbedtls_cipher_update_3
    318              }
    319          
    320          #if defined(MBEDTLS_CIPHER_MODE_CBC)
    321              if( ctx->cipher_info->mode == MBEDTLS_MODE_CBC )
   \                     ??mbedtls_cipher_update_6: (+1)
   \   00000084   0x7878             LDRB     R0,[R7, #+1]
   \   00000086   0x2802             CMP      R0,#+2
   \   00000088   0xD179             BNE      ??mbedtls_cipher_update_7
    322              {
    323                  size_t copy_len = 0;
    324          
    325                  /*
    326                   * If there is not enough data for a full block, cache it.
    327                   */
    328                  if( ( ctx->operation == MBEDTLS_DECRYPT &&
    329                          ilen <= block_size - ctx->unprocessed_len ) ||
    330                       ( ctx->operation == MBEDTLS_ENCRYPT &&
    331                          ilen < block_size - ctx->unprocessed_len ) )
   \   0000008A   0x2008             MOVS     R0,#+8
   \   0000008C   0x5629             LDRSB    R1,[R5, R0]
   \   0000008E   0x6A68             LDR      R0,[R5, #+36]
   \   00000090   0x000A             MOVS     R2,R1
   \   00000092   0xD103             BNE      ??mbedtls_cipher_update_8
   \   00000094   0x9A02             LDR      R2,[SP, #+8]
   \   00000096   0x1A12             SUBS     R2,R2,R0
   \   00000098   0x42A2             CMP      R2,R4
   \   0000009A   0xD205             BCS      ??mbedtls_cipher_update_9
   \                     ??mbedtls_cipher_update_8: (+1)
   \   0000009C   0x2901             CMP      R1,#+1
   \   0000009E   0xD10D             BNE      ??mbedtls_cipher_update_10
   \   000000A0   0x9902             LDR      R1,[SP, #+8]
   \   000000A2   0x1A09             SUBS     R1,R1,R0
   \   000000A4   0x428C             CMP      R4,R1
   \   000000A6   0xD209             BCS      ??mbedtls_cipher_update_10
    332                  {
    333                      memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ), input,
    334                              ilen );
   \                     ??mbedtls_cipher_update_9: (+1)
   \   000000A8   0x0022             MOVS     R2,R4
   \   000000AA   0x0031             MOVS     R1,R6
   \   000000AC   0x1828             ADDS     R0,R5,R0
   \   000000AE   0x3014             ADDS     R0,R0,#+20
   \   000000B0   0x.... 0x....      BL       __aeabi_memcpy
    335          
    336                      ctx->unprocessed_len += ilen;
   \   000000B4   0x6A68             LDR      R0,[R5, #+36]
   \   000000B6   0x1900             ADDS     R0,R0,R4
   \   000000B8   0x6268             STR      R0,[R5, #+36]
    337                      return( 0 );
   \   000000BA   0xE05E             B.N      ??mbedtls_cipher_update_11
    338                  }
    339          
    340                  /*
    341                   * Process cached data first
    342                   */
    343                  if( 0 != ctx->unprocessed_len )
   \                     ??mbedtls_cipher_update_10: (+1)
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD028             BEQ      ??mbedtls_cipher_update_12
    344                  {
    345                      copy_len = block_size - ctx->unprocessed_len;
   \   000000C0   0x9902             LDR      R1,[SP, #+8]
   \   000000C2   0x1A09             SUBS     R1,R1,R0
   \   000000C4   0x9103             STR      R1,[SP, #+12]
    346          
    347                      memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ), input,
    348                              copy_len );
   \   000000C6   0x460A             MOV      R2,R1
   \   000000C8   0x0031             MOVS     R1,R6
   \   000000CA   0x1828             ADDS     R0,R5,R0
   \   000000CC   0x3014             ADDS     R0,R0,#+20
   \   000000CE   0x.... 0x....      BL       __aeabi_memcpy
    349          
    350                      if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
    351                              ctx->operation, block_size, ctx->iv,
    352                              ctx->unprocessed_data, output ) ) )
   \   000000D2   0x9804             LDR      R0,[SP, #+16]
   \   000000D4   0x9001             STR      R0,[SP, #+4]
   \   000000D6   0x0028             MOVS     R0,R5
   \   000000D8   0x3014             ADDS     R0,R0,#+20
   \   000000DA   0x9000             STR      R0,[SP, #+0]
   \   000000DC   0x002B             MOVS     R3,R5
   \   000000DE   0x3328             ADDS     R3,R3,#+40
   \   000000E0   0x9A02             LDR      R2,[SP, #+8]
   \   000000E2   0x2008             MOVS     R0,#+8
   \   000000E4   0x5629             LDRSB    R1,[R5, R0]
   \   000000E6   0x6BE8             LDR      R0,[R5, #+60]
   \   000000E8   0x682F             LDR      R7,[R5, #+0]
   \   000000EA   0x69BF             LDR      R7,[R7, #+24]
   \   000000EC   0x68BF             LDR      R7,[R7, #+8]
   \   000000EE   0x47B8             BLX      R7
   \   000000F0   0x2800             CMP      R0,#+0
   \   000000F2   0xD145             BNE      ??mbedtls_cipher_update_3
    353                      {
    354                          return( ret );
    355                      }
    356          
    357                      *olen += block_size;
   \   000000F4   0x980A             LDR      R0,[SP, #+40]
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0x9902             LDR      R1,[SP, #+8]
   \   000000FA   0x1840             ADDS     R0,R0,R1
   \   000000FC   0x990A             LDR      R1,[SP, #+40]
   \   000000FE   0x6008             STR      R0,[R1, #+0]
    358                      output += block_size;
   \   00000100   0x9804             LDR      R0,[SP, #+16]
   \   00000102   0x9902             LDR      R1,[SP, #+8]
   \   00000104   0x1840             ADDS     R0,R0,R1
   \   00000106   0x9004             STR      R0,[SP, #+16]
    359                      ctx->unprocessed_len = 0;
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0x6268             STR      R0,[R5, #+36]
    360          
    361                      input += copy_len;
   \   0000010C   0x9803             LDR      R0,[SP, #+12]
   \   0000010E   0x1836             ADDS     R6,R6,R0
    362                      ilen -= copy_len;
   \   00000110   0x1A24             SUBS     R4,R4,R0
    363                  }
    364          
    365                  /*
    366                   * Cache final, incomplete block
    367                   */
    368                  if( 0 != ilen )
   \                     ??mbedtls_cipher_update_12: (+1)
   \   00000112   0x2C00             CMP      R4,#+0
   \   00000114   0xD031             BEQ      ??mbedtls_cipher_update_11
    369                  {
    370                      if( 0 == block_size )
    371                      {
    372                          return MBEDTLS_ERR_CIPHER_INVALID_CONTEXT;
    373                      }
    374          
    375                      copy_len = ilen % block_size;
   \   00000116   0x0020             MOVS     R0,R4
   \   00000118   0x9902             LDR      R1,[SP, #+8]
   \   0000011A   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000011E   0x9103             STR      R1,[SP, #+12]
    376                      if( copy_len == 0 && ctx->operation == MBEDTLS_DECRYPT )
   \   00000120   0x2900             CMP      R1,#+0
   \   00000122   0xD105             BNE      ??mbedtls_cipher_update_13
   \   00000124   0x2008             MOVS     R0,#+8
   \   00000126   0x5628             LDRSB    R0,[R5, R0]
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xD101             BNE      ??mbedtls_cipher_update_13
    377                          copy_len = block_size;
   \   0000012C   0x9802             LDR      R0,[SP, #+8]
   \   0000012E   0x9003             STR      R0,[SP, #+12]
    378          
    379                      memcpy( ctx->unprocessed_data, &( input[ilen - copy_len] ),
    380                              copy_len );
   \                     ??mbedtls_cipher_update_13: (+1)
   \   00000130   0x9803             LDR      R0,[SP, #+12]
   \   00000132   0x1A24             SUBS     R4,R4,R0
   \   00000134   0x4602             MOV      R2,R0
   \   00000136   0x1931             ADDS     R1,R6,R4
   \   00000138   0x0028             MOVS     R0,R5
   \   0000013A   0x3014             ADDS     R0,R0,#+20
   \   0000013C   0x.... 0x....      BL       __aeabi_memcpy
    381          
    382                      ctx->unprocessed_len += copy_len;
   \   00000140   0x6A68             LDR      R0,[R5, #+36]
   \   00000142   0x9903             LDR      R1,[SP, #+12]
   \   00000144   0x1840             ADDS     R0,R0,R1
   \   00000146   0x6268             STR      R0,[R5, #+36]
    383                      ilen -= copy_len;
    384                  }
    385          
    386                  /*
    387                   * Process remaining full blocks
    388                   */
    389                  if( ilen )
   \   00000148   0x2C00             CMP      R4,#+0
   \   0000014A   0xD016             BEQ      ??mbedtls_cipher_update_11
    390                  {
    391                      if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
    392                              ctx->operation, ilen, ctx->iv, input, output ) ) )
   \   0000014C   0x9804             LDR      R0,[SP, #+16]
   \   0000014E   0x9001             STR      R0,[SP, #+4]
   \   00000150   0x9600             STR      R6,[SP, #+0]
   \   00000152   0x002B             MOVS     R3,R5
   \   00000154   0x3328             ADDS     R3,R3,#+40
   \   00000156   0x0022             MOVS     R2,R4
   \   00000158   0x2008             MOVS     R0,#+8
   \   0000015A   0x5629             LDRSB    R1,[R5, R0]
   \   0000015C   0x6BE8             LDR      R0,[R5, #+60]
   \   0000015E   0x682D             LDR      R5,[R5, #+0]
   \   00000160   0x69AD             LDR      R5,[R5, #+24]
   \   00000162   0x68AD             LDR      R5,[R5, #+8]
   \   00000164   0x47A8             BLX      R5
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xD002             BEQ      ??mbedtls_cipher_update_14
    393                      {
    394                          return( ret );
   \   0000016A   0xE009             B        ??mbedtls_cipher_update_3
    395                      }
   \                     ??mbedtls_cipher_update_5: (+1)
   \   0000016C   0x....             LDR      R0,??DataTable15  ;; 0xffff9c80
   \   0000016E   0xE007             B        ??mbedtls_cipher_update_3
    396          
    397                      *olen += ilen;
   \                     ??mbedtls_cipher_update_14: (+1)
   \   00000170   0x980A             LDR      R0,[SP, #+40]
   \   00000172   0x6800             LDR      R0,[R0, #+0]
   \   00000174   0x1900             ADDS     R0,R0,R4
   \   00000176   0x990A             LDR      R1,[SP, #+40]
   \   00000178   0x6008             STR      R0,[R1, #+0]
    398                  }
    399          
    400                  return( 0 );
   \                     ??mbedtls_cipher_update_11: (+1)
   \   0000017A   0x2000             MOVS     R0,#+0
   \   0000017C   0xE000             B        ??mbedtls_cipher_update_3
    401              }
    402          #endif /* MBEDTLS_CIPHER_MODE_CBC */
    403          
    404          #if defined(MBEDTLS_CIPHER_MODE_CFB)
    405              if( ctx->cipher_info->mode == MBEDTLS_MODE_CFB )
    406              {
    407                  if( 0 != ( ret = ctx->cipher_info->base->cfb_func( ctx->cipher_ctx,
    408                          ctx->operation, ilen, &ctx->unprocessed_len, ctx->iv,
    409                          input, output ) ) )
    410                  {
    411                      return( ret );
    412                  }
    413          
    414                  *olen = ilen;
    415          
    416                  return( 0 );
    417              }
    418          #endif /* MBEDTLS_CIPHER_MODE_CFB */
    419          
    420          #if defined(MBEDTLS_CIPHER_MODE_CTR)
    421              if( ctx->cipher_info->mode == MBEDTLS_MODE_CTR )
    422              {
    423                  if( 0 != ( ret = ctx->cipher_info->base->ctr_func( ctx->cipher_ctx,
    424                          ilen, &ctx->unprocessed_len, ctx->iv,
    425                          ctx->unprocessed_data, input, output ) ) )
    426                  {
    427                      return( ret );
    428                  }
    429          
    430                  *olen = ilen;
    431          
    432                  return( 0 );
    433              }
    434          #endif /* MBEDTLS_CIPHER_MODE_CTR */
    435          
    436          #if defined(MBEDTLS_CIPHER_MODE_STREAM)
    437              if( ctx->cipher_info->mode == MBEDTLS_MODE_STREAM )
    438              {
    439                  if( 0 != ( ret = ctx->cipher_info->base->stream_func( ctx->cipher_ctx,
    440                                                              ilen, input, output ) ) )
    441                  {
    442                      return( ret );
    443                  }
    444          
    445                  *olen = ilen;
    446          
    447                  return( 0 );
    448              }
    449          #endif /* MBEDTLS_CIPHER_MODE_STREAM */
    450          
    451              return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
   \                     ??mbedtls_cipher_update_7: (+1)
   \   0000017E   0x....             LDR      R0,??DataTable11  ;; 0xffff9f80
   \                     ??mbedtls_cipher_update_3: (+1)
   \   00000180   0xB005             ADD      SP,SP,#+20
   \   00000182   0xBDF0             POP      {R4-R7,PC}       ;; return
    452          }
    453          
    454          #if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)
    455          #if defined(MBEDTLS_CIPHER_PADDING_PKCS7)
    456          /*
    457           * PKCS7 (and PKCS5) padding: fill with ll bytes, with ll = padding_len
    458           */

   \                                 In section .text, align 2, keep-with-next
    459          static void add_pkcs_padding( unsigned char *output, size_t output_len,
    460                  size_t data_len )
    461          {
   \                     add_pkcs_padding: (+1)
   \   00000000   0xB410             PUSH     {R4}
    462              size_t padding_len = output_len - data_len;
   \   00000002   0x1A89             SUBS     R1,R1,R2
    463              unsigned char i;
    464          
    465              for( i = 0; i < padding_len; i++ )
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0xE002             B        ??add_pkcs_padding_0
    466                  output[data_len + i] = (unsigned char) padding_len;
   \                     ??add_pkcs_padding_1: (+1)
   \   00000008   0x18D4             ADDS     R4,R2,R3
   \   0000000A   0x5501             STRB     R1,[R0, R4]
   \   0000000C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??add_pkcs_padding_0: (+1)
   \   0000000E   0xB2DB             UXTB     R3,R3
   \   00000010   0x428B             CMP      R3,R1
   \   00000012   0xD3F9             BCC      ??add_pkcs_padding_1
    467          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    468          

   \                                 In section .text, align 2, keep-with-next
    469          static int get_pkcs_padding( unsigned char *input, size_t input_len,
    470                  size_t *data_len )
    471          {
   \                     get_pkcs_padding: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0013             MOVS     R3,R2
    472              size_t i, pad_idx;
    473              unsigned char padding_len, bad = 0;
    474          
    475              if( NULL == input || NULL == data_len )
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD001             BEQ      ??get_pkcs_padding_0
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD101             BNE      ??get_pkcs_padding_1
    476                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
   \                     ??get_pkcs_padding_0: (+1)
   \   0000000E   0x....             LDR      R0,??DataTable16  ;; 0xffff9f00
   \   00000010   0xE023             B        ??get_pkcs_padding_2
    477          
    478              padding_len = input[input_len - 1];
   \                     ??get_pkcs_padding_1: (+1)
   \   00000012   0x1860             ADDS     R0,R4,R1
   \   00000014   0x1E40             SUBS     R0,R0,#+1
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
    479              *data_len = input_len - padding_len;
   \   00000018   0x1A0A             SUBS     R2,R1,R0
   \   0000001A   0x601A             STR      R2,[R3, #+0]
    480          
    481              /* Avoid logical || since it results in a branch */
    482              bad |= padding_len > input_len;
   \   0000001C   0x419B             SBCS     R3,R3,R3
   \   0000001E   0x0FDB             LSRS     R3,R3,#+31
    483              bad |= padding_len == 0;
   \   00000020   0x1E46             SUBS     R6,R0,#+1
   \   00000022   0x41B6             SBCS     R6,R6,R6
   \   00000024   0x0FF6             LSRS     R6,R6,#+31
   \   00000026   0x431E             ORRS     R6,R6,R3
    484          
    485              /* The number of bytes checked must be independent of padding_len,
    486               * so pick input_len, which is usually 8 or 16 (one block) */
    487              pad_idx = input_len - padding_len;
    488              for( i = 0; i < input_len; i++ )
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD00F             BEQ      ??get_pkcs_padding_3
    489                  bad |= ( input[i] ^ padding_len ) * ( i >= pad_idx );
   \                     ??get_pkcs_padding_4: (+1)
   \   0000002E   0x4293             CMP      R3,R2
   \   00000030   0x41AD             SBCS     R5,R5,R5
   \   00000032   0x43ED             MVNS     R5,R5
   \   00000034   0x0FED             LSRS     R5,R5,#+31
   \   00000036   0x46B4             MOV      R12,R6
   \   00000038   0x7827             LDRB     R7,[R4, #+0]
   \   0000003A   0x0006             MOVS     R6,R0
   \   0000003C   0x407E             EORS     R6,R6,R7
   \   0000003E   0x436E             MULS     R6,R5,R6
   \   00000040   0x4665             MOV      R5,R12
   \   00000042   0x432E             ORRS     R6,R6,R5
   \   00000044   0xB2F6             UXTB     R6,R6
   \   00000046   0x1C5B             ADDS     R3,R3,#+1
   \   00000048   0x1C64             ADDS     R4,R4,#+1
   \   0000004A   0x428B             CMP      R3,R1
   \   0000004C   0xD3EF             BCC      ??get_pkcs_padding_4
    490          
    491              return( MBEDTLS_ERR_CIPHER_INVALID_PADDING * ( bad != 0 ) );
   \                     ??get_pkcs_padding_3: (+1)
   \   0000004E   0x1E70             SUBS     R0,R6,#+1
   \   00000050   0x4180             SBCS     R0,R0,R0
   \   00000052   0x43C0             MVNS     R0,R0
   \   00000054   0x0FC0             LSRS     R0,R0,#+31
   \   00000056   0x....             LDR      R1,??DataTable17  ;; 0xffff9e00
   \   00000058   0x4348             MULS     R0,R1,R0
   \                     ??get_pkcs_padding_2: (+1)
   \   0000005A   0xBCF0             POP      {R4-R7}
   \   0000005C   0x4770             BX       LR               ;; return
    492          }
    493          #endif /* MBEDTLS_CIPHER_PADDING_PKCS7 */
    494          
    495          #if defined(MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS)
    496          /*
    497           * One and zeros padding: fill with 80 00 ... 00
    498           */
    499          static void add_one_and_zeros_padding( unsigned char *output,
    500                                                 size_t output_len, size_t data_len )
    501          {
    502              size_t padding_len = output_len - data_len;
    503              unsigned char i = 0;
    504          
    505              output[data_len] = 0x80;
    506              for( i = 1; i < padding_len; i++ )
    507                  output[data_len + i] = 0x00;
    508          }
    509          
    510          static int get_one_and_zeros_padding( unsigned char *input, size_t input_len,
    511                                                size_t *data_len )
    512          {
    513              size_t i;
    514              unsigned char done = 0, prev_done, bad;
    515          
    516              if( NULL == input || NULL == data_len )
    517                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    518          
    519              bad = 0xFF;
    520              *data_len = 0;
    521              for( i = input_len; i > 0; i-- )
    522              {
    523                  prev_done = done;
    524                  done |= ( input[i-1] != 0 );
    525                  *data_len |= ( i - 1 ) * ( done != prev_done );
    526                  bad &= ( input[i-1] ^ 0x80 ) | ( done == prev_done );
    527              }
    528          
    529              return( MBEDTLS_ERR_CIPHER_INVALID_PADDING * ( bad != 0 ) );
    530          
    531          }
    532          #endif /* MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS */
    533          
    534          #if defined(MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN)
    535          /*
    536           * Zeros and len padding: fill with 00 ... 00 ll, where ll is padding length
    537           */
    538          static void add_zeros_and_len_padding( unsigned char *output,
    539                                                 size_t output_len, size_t data_len )
    540          {
    541              size_t padding_len = output_len - data_len;
    542              unsigned char i = 0;
    543          
    544              for( i = 1; i < padding_len; i++ )
    545                  output[data_len + i - 1] = 0x00;
    546              output[output_len - 1] = (unsigned char) padding_len;
    547          }
    548          
    549          static int get_zeros_and_len_padding( unsigned char *input, size_t input_len,
    550                                                size_t *data_len )
    551          {
    552              size_t i, pad_idx;
    553              unsigned char padding_len, bad = 0;
    554          
    555              if( NULL == input || NULL == data_len )
    556                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    557          
    558              padding_len = input[input_len - 1];
    559              *data_len = input_len - padding_len;
    560          
    561              /* Avoid logical || since it results in a branch */
    562              bad |= padding_len > input_len;
    563              bad |= padding_len == 0;
    564          
    565              /* The number of bytes checked must be independent of padding_len */
    566              pad_idx = input_len - padding_len;
    567              for( i = 0; i < input_len - 1; i++ )
    568                  bad |= input[i] * ( i >= pad_idx );
    569          
    570              return( MBEDTLS_ERR_CIPHER_INVALID_PADDING * ( bad != 0 ) );
    571          }
    572          #endif /* MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN */
    573          
    574          #if defined(MBEDTLS_CIPHER_PADDING_ZEROS)
    575          /*
    576           * Zero padding: fill with 00 ... 00
    577           */
    578          static void add_zeros_padding( unsigned char *output,
    579                                         size_t output_len, size_t data_len )
    580          {
    581              size_t i;
    582          
    583              for( i = data_len; i < output_len; i++ )
    584                  output[i] = 0x00;
    585          }
    586          
    587          static int get_zeros_padding( unsigned char *input, size_t input_len,
    588                                        size_t *data_len )
    589          {
    590              size_t i;
    591              unsigned char done = 0, prev_done;
    592          
    593              if( NULL == input || NULL == data_len )
    594                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    595          
    596              *data_len = 0;
    597              for( i = input_len; i > 0; i-- )
    598              {
    599                  prev_done = done;
    600                  done |= ( input[i-1] != 0 );
    601                  *data_len |= i * ( done != prev_done );
    602              }
    603          
    604              return( 0 );
    605          }
    606          #endif /* MBEDTLS_CIPHER_PADDING_ZEROS */
    607          
    608          /*
    609           * No padding: don't pad :)
    610           *
    611           * There is no add_padding function (check for NULL in mbedtls_cipher_finish)
    612           * but a trivial get_padding function
    613           */

   \                                 In section .text, align 2, keep-with-next
    614          static int get_no_padding( unsigned char *input, size_t input_len,
    615                                        size_t *data_len )
    616          {
    617              if( NULL == input || NULL == data_len )
   \                     get_no_padding: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD001             BEQ      ??get_no_padding_0
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE      ??get_no_padding_1
    618                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
   \                     ??get_no_padding_0: (+1)
   \   00000008   0x....             LDR      R0,??DataTable16  ;; 0xffff9f00
   \   0000000A   0x4770             BX       LR
    619          
    620              *data_len = input_len;
   \                     ??get_no_padding_1: (+1)
   \   0000000C   0x6011             STR      R1,[R2, #+0]
    621          
    622              return( 0 );
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4770             BX       LR               ;; return
    623          }
    624          #endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */
    625          

   \                                 In section .text, align 2, keep-with-next
    626          int mbedtls_cipher_finish( mbedtls_cipher_context_t *ctx,
    627                             unsigned char *output, size_t *olen )
    628          {
   \                     mbedtls_cipher_finish: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0016             MOVS     R6,R2
    629              if( NULL == ctx || NULL == ctx->cipher_info || NULL == olen )
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD004             BEQ      ??mbedtls_cipher_finish_0
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD001             BEQ      ??mbedtls_cipher_finish_0
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD101             BNE      ??mbedtls_cipher_finish_1
    630                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
   \                     ??mbedtls_cipher_finish_0: (+1)
   \   00000016   0x....             LDR      R0,??DataTable16  ;; 0xffff9f00
   \   00000018   0xE05E             B        ??mbedtls_cipher_finish_2
    631          
    632              *olen = 0;
   \                     ??mbedtls_cipher_finish_1: (+1)
   \   0000001A   0x2500             MOVS     R5,#+0
   \   0000001C   0x6035             STR      R5,[R6, #+0]
   \   0000001E   0x7841             LDRB     R1,[R0, #+1]
   \   00000020   0x2903             CMP      R1,#+3
   \   00000022   0xD005             BEQ      ??mbedtls_cipher_finish_3
   \   00000024   0x2905             CMP      R1,#+5
   \   00000026   0xD003             BEQ      ??mbedtls_cipher_finish_3
   \   00000028   0x2906             CMP      R1,#+6
   \   0000002A   0xD001             BEQ      ??mbedtls_cipher_finish_3
   \   0000002C   0x2907             CMP      R1,#+7
   \   0000002E   0xD101             BNE      ??mbedtls_cipher_finish_4
    633          
    634              if( MBEDTLS_MODE_CFB == ctx->cipher_info->mode ||
    635                  MBEDTLS_MODE_CTR == ctx->cipher_info->mode ||
    636                  MBEDTLS_MODE_GCM == ctx->cipher_info->mode ||
    637                  MBEDTLS_MODE_STREAM == ctx->cipher_info->mode )
    638              {
    639                  return( 0 );
   \                     ??mbedtls_cipher_finish_3: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE051             B        ??mbedtls_cipher_finish_2
    640              }
    641          
    642              if( MBEDTLS_MODE_ECB == ctx->cipher_info->mode )
   \                     ??mbedtls_cipher_finish_4: (+1)
   \   00000034   0x2901             CMP      R1,#+1
   \   00000036   0xD103             BNE      ??mbedtls_cipher_finish_5
    643              {
    644                  if( ctx->unprocessed_len != 0 )
   \   00000038   0x6A60             LDR      R0,[R4, #+36]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD04C             BEQ      ??mbedtls_cipher_finish_2
    645                      return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
   \   0000003E   0xE032             B.N      ??mbedtls_cipher_finish_6
    646          
    647                  return( 0 );
    648              }
    649          
    650          #if defined(MBEDTLS_CIPHER_MODE_CBC)
    651              if( MBEDTLS_MODE_CBC == ctx->cipher_info->mode )
   \                     ??mbedtls_cipher_finish_5: (+1)
   \   00000040   0x2902             CMP      R1,#+2
   \   00000042   0xD148             BNE      ??mbedtls_cipher_finish_7
    652              {
    653                  int ret = 0;
    654          
    655                  if( MBEDTLS_ENCRYPT == ctx->operation )
   \   00000044   0x2108             MOVS     R1,#+8
   \   00000046   0x5661             LDRSB    R1,[R4, R1]
   \   00000048   0x2901             CMP      R1,#+1
   \   0000004A   0xD123             BNE      ??mbedtls_cipher_finish_8
    656                  {
    657                      /* check for 'no padding' mode */
    658                      if( NULL == ctx->add_padding )
   \   0000004C   0x68E3             LDR      R3,[R4, #+12]
   \   0000004E   0x0019             MOVS     R1,R3
   \   00000050   0xD103             BNE      ??mbedtls_cipher_finish_9
    659                      {
    660                          if( 0 != ctx->unprocessed_len )
   \   00000052   0x6A60             LDR      R0,[R4, #+36]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD03F             BEQ      ??mbedtls_cipher_finish_2
    661                              return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
   \   00000058   0xE025             B.N      ??mbedtls_cipher_finish_6
    662          
    663                          return( 0 );
    664                      }
    665          
    666                      ctx->add_padding( ctx->unprocessed_data, mbedtls_cipher_get_iv_size( ctx ),
    667                              ctx->unprocessed_len );
    668                  }
   \                     ??mbedtls_cipher_finish_9: (+1)
   \   0000005A   0x6BA1             LDR      R1,[R4, #+56]
   \   0000005C   0x2900             CMP      R1,#+0
   \   0000005E   0xD100             BNE      ??mbedtls_cipher_finish_10
   \   00000060   0x68C1             LDR      R1,[R0, #+12]
   \                     ??mbedtls_cipher_finish_10: (+1)
   \   00000062   0x6A62             LDR      R2,[R4, #+36]
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x3014             ADDS     R0,R0,#+20
   \   00000068   0x4798             BLX      R3
    669                  else if( mbedtls_cipher_get_block_size( ctx ) != ctx->unprocessed_len )
    670                  {
    671                      /*
    672                       * For decrypt operations, expect a full block,
    673                       * or an empty block if no padding
    674                       */
    675                      if( NULL == ctx->add_padding && 0 == ctx->unprocessed_len )
    676                          return( 0 );
    677          
    678                      return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
    679                  }
    680          
    681                  /* cipher block */
    682                  if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
    683                          ctx->operation, mbedtls_cipher_get_block_size( ctx ), ctx->iv,
    684                          ctx->unprocessed_data, output ) ) )
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD11C             BNE      ??mbedtls_cipher_finish_11
   \   00000070   0x2200             MOVS     R2,#+0
   \                     ??mbedtls_cipher_finish_12: (+1)
   \   00000072   0x9802             LDR      R0,[SP, #+8]
   \   00000074   0x9001             STR      R0,[SP, #+4]
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x3014             ADDS     R0,R0,#+20
   \   0000007A   0x9000             STR      R0,[SP, #+0]
   \   0000007C   0x0023             MOVS     R3,R4
   \   0000007E   0x3328             ADDS     R3,R3,#+40
   \   00000080   0x2008             MOVS     R0,#+8
   \   00000082   0x5621             LDRSB    R1,[R4, R0]
   \   00000084   0x6BE0             LDR      R0,[R4, #+60]
   \   00000086   0x6827             LDR      R7,[R4, #+0]
   \   00000088   0x69BF             LDR      R7,[R7, #+24]
   \   0000008A   0x68BF             LDR      R7,[R7, #+8]
   \   0000008C   0x47B8             BLX      R7
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD00E             BEQ      ??mbedtls_cipher_finish_13
    685                  {
    686                      return( ret );
   \   00000092   0xE021             B        ??mbedtls_cipher_finish_2
    687                  }
   \                     ??mbedtls_cipher_finish_8: (+1)
   \   00000094   0x6A61             LDR      R1,[R4, #+36]
   \   00000096   0x6940             LDR      R0,[R0, #+20]
   \   00000098   0x4288             CMP      R0,R1
   \   0000009A   0xD006             BEQ      ??mbedtls_cipher_finish_11
   \   0000009C   0x68E0             LDR      R0,[R4, #+12]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD101             BNE      ??mbedtls_cipher_finish_6
   \   000000A2   0x2900             CMP      R1,#+0
   \   000000A4   0xD018             BEQ      ??mbedtls_cipher_finish_2
   \                     ??mbedtls_cipher_finish_6: (+1)
   \   000000A6   0x....             LDR      R0,??DataTable18  ;; 0xffff9d80
   \   000000A8   0xE016             B        ??mbedtls_cipher_finish_2
   \                     ??mbedtls_cipher_finish_11: (+1)
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x6942             LDR      R2,[R0, #+20]
   \   000000AE   0xE7E0             B        ??mbedtls_cipher_finish_12
    688          
    689                  /* Set output size for decryption */
    690                  if( MBEDTLS_DECRYPT == ctx->operation )
   \                     ??mbedtls_cipher_finish_13: (+1)
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x2108             MOVS     R1,#+8
   \   000000B4   0x5661             LDRSB    R1,[R4, R1]
   \   000000B6   0x2900             CMP      R1,#+0
   \   000000B8   0xD107             BNE      ??mbedtls_cipher_finish_14
    691                      return ctx->get_padding( output, mbedtls_cipher_get_block_size( ctx ),
    692                                               olen );
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD000             BEQ      ??mbedtls_cipher_finish_15
   \   000000BE   0x6941             LDR      R1,[R0, #+20]
   \                     ??mbedtls_cipher_finish_15: (+1)
   \   000000C0   0x0032             MOVS     R2,R6
   \   000000C2   0x9802             LDR      R0,[SP, #+8]
   \   000000C4   0x6923             LDR      R3,[R4, #+16]
   \   000000C6   0x4798             BLX      R3
   \   000000C8   0xE006             B        ??mbedtls_cipher_finish_2
    693          
    694                  /* Set output size for encryption */
    695                  *olen = mbedtls_cipher_get_block_size( ctx );
   \                     ??mbedtls_cipher_finish_14: (+1)
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD000             BEQ      ??mbedtls_cipher_finish_16
   \   000000CE   0x6945             LDR      R5,[R0, #+20]
   \                     ??mbedtls_cipher_finish_16: (+1)
   \   000000D0   0x6035             STR      R5,[R6, #+0]
    696                  return( 0 );
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xE000             B        ??mbedtls_cipher_finish_2
    697              }
    698          #else
    699              ((void) output);
    700          #endif /* MBEDTLS_CIPHER_MODE_CBC */
    701          
    702              return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
   \                     ??mbedtls_cipher_finish_7: (+1)
   \   000000D6   0x....             LDR      R0,??DataTable18_1  ;; 0xffff9f80
   \                     ??mbedtls_cipher_finish_2: (+1)
   \   000000D8   0xB003             ADD      SP,SP,#+12
   \   000000DA   0xBDF0             POP      {R4-R7,PC}       ;; return
    703          }
    704          
    705          #if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)

   \                                 In section .text, align 2, keep-with-next
    706          int mbedtls_cipher_set_padding_mode( mbedtls_cipher_context_t *ctx, mbedtls_cipher_padding_t mode )
    707          {
    708              if( NULL == ctx ||
    709                  MBEDTLS_MODE_CBC != ctx->cipher_info->mode )
   \                     mbedtls_cipher_set_padding_mode: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD003             BEQ      ??mbedtls_cipher_set_padding_mode_0
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x7852             LDRB     R2,[R2, #+1]
   \   00000008   0x2A02             CMP      R2,#+2
   \   0000000A   0xD001             BEQ      ??mbedtls_cipher_set_padding_mode_1
    710              {
    711                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
   \                     ??mbedtls_cipher_set_padding_mode_0: (+1)
   \   0000000C   0x....             LDR      R0,??DataTable16  ;; 0xffff9f00
   \   0000000E   0x4770             BX       LR
    712              }
    713          
    714              switch( mode )
   \                     ??mbedtls_cipher_set_padding_mode_1: (+1)
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD002             BEQ      ??mbedtls_cipher_set_padding_mode_2
   \   00000014   0x2904             CMP      R1,#+4
   \   00000016   0xD006             BEQ      ??mbedtls_cipher_set_padding_mode_3
   \   00000018   0xE009             B        ??mbedtls_cipher_set_padding_mode_4
    715              {
    716          #if defined(MBEDTLS_CIPHER_PADDING_PKCS7)
    717              case MBEDTLS_PADDING_PKCS7:
    718                  ctx->add_padding = add_pkcs_padding;
   \                     ??mbedtls_cipher_set_padding_mode_2: (+1)
   \   0000001A   0x....             LDR      R1,??DataTable18_2
   \   0000001C   0x60C1             STR      R1,[R0, #+12]
    719                  ctx->get_padding = get_pkcs_padding;
   \   0000001E   0x....             LDR      R1,??DataTable18_3
   \                     ??mbedtls_cipher_set_padding_mode_5: (+1)
   \   00000020   0x6101             STR      R1,[R0, #+16]
    720                  break;
    721          #endif
    722          #if defined(MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS)
    723              case MBEDTLS_PADDING_ONE_AND_ZEROS:
    724                  ctx->add_padding = add_one_and_zeros_padding;
    725                  ctx->get_padding = get_one_and_zeros_padding;
    726                  break;
    727          #endif
    728          #if defined(MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN)
    729              case MBEDTLS_PADDING_ZEROS_AND_LEN:
    730                  ctx->add_padding = add_zeros_and_len_padding;
    731                  ctx->get_padding = get_zeros_and_len_padding;
    732                  break;
    733          #endif
    734          #if defined(MBEDTLS_CIPHER_PADDING_ZEROS)
    735              case MBEDTLS_PADDING_ZEROS:
    736                  ctx->add_padding = add_zeros_padding;
    737                  ctx->get_padding = get_zeros_padding;
    738                  break;
    739          #endif
    740              case MBEDTLS_PADDING_NONE:
    741                  ctx->add_padding = NULL;
    742                  ctx->get_padding = get_no_padding;
    743                  break;
    744          
    745              default:
    746                  return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
    747              }
    748          
    749              return( 0 );
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x4770             BX       LR               ;; return
   \                     ??mbedtls_cipher_set_padding_mode_3: (+1)
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x60C1             STR      R1,[R0, #+12]
   \   0000002A   0x....             LDR      R1,??DataTable18_4
   \   0000002C   0xE7F8             B        ??mbedtls_cipher_set_padding_mode_5
   \                     ??mbedtls_cipher_set_padding_mode_4: (+1)
   \   0000002E   0x....             LDR      R0,??DataTable18_1  ;; 0xffff9f80
   \   00000030   0x4770             BX       LR
    750          }
    751          #endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */
    752          
    753          #if defined(MBEDTLS_GCM_C)

   \                                 In section .text, align 2, keep-with-next
    754          int mbedtls_cipher_write_tag( mbedtls_cipher_context_t *ctx,
    755                                unsigned char *tag, size_t tag_len )
    756          {
   \                     mbedtls_cipher_write_tag: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    757              if( NULL == ctx || NULL == ctx->cipher_info || NULL == tag )
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD008             BEQ      ??mbedtls_cipher_write_tag_0
   \   00000006   0x6803             LDR      R3,[R0, #+0]
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD005             BEQ      ??mbedtls_cipher_write_tag_0
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD003             BEQ      ??mbedtls_cipher_write_tag_0
    758                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    759          
    760              if( MBEDTLS_ENCRYPT != ctx->operation )
   \   00000010   0x2408             MOVS     R4,#+8
   \   00000012   0x5704             LDRSB    R4,[R0, R4]
   \   00000014   0x2C01             CMP      R4,#+1
   \   00000016   0xD001             BEQ      ??mbedtls_cipher_write_tag_1
    761                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
   \                     ??mbedtls_cipher_write_tag_0: (+1)
   \   00000018   0x....             LDR      R0,??DataTable16  ;; 0xffff9f00
   \   0000001A   0xBD10             POP      {R4,PC}
    762          
    763              if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )
   \                     ??mbedtls_cipher_write_tag_1: (+1)
   \   0000001C   0x785B             LDRB     R3,[R3, #+1]
   \   0000001E   0x2B06             CMP      R3,#+6
   \   00000020   0xD103             BNE      ??mbedtls_cipher_write_tag_2
    764                  return mbedtls_gcm_finish( (mbedtls_gcm_context *) ctx->cipher_ctx, tag, tag_len );
   \   00000022   0x6BC0             LDR      R0,[R0, #+60]
   \   00000024   0x.... 0x....      BL       mbedtls_gcm_finish
   \   00000028   0xBD10             POP      {R4,PC}
    765          
    766              return( 0 );
   \                     ??mbedtls_cipher_write_tag_2: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    767          }
    768          

   \                                 In section .text, align 2, keep-with-next
    769          int mbedtls_cipher_check_tag( mbedtls_cipher_context_t *ctx,
    770                                const unsigned char *tag, size_t tag_len )
    771          {
   \                     mbedtls_cipher_check_tag: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
    772              int ret;
    773          
    774              if( NULL == ctx || NULL == ctx->cipher_info ||
    775                  MBEDTLS_DECRYPT != ctx->operation )
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00B             BEQ      ??mbedtls_cipher_check_tag_0
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD008             BEQ      ??mbedtls_cipher_check_tag_0
   \   00000012   0x2208             MOVS     R2,#+8
   \   00000014   0x5682             LDRSB    R2,[R0, R2]
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD104             BNE      ??mbedtls_cipher_check_tag_0
    776              {
    777                  return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    778              }
    779          
    780              if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )
   \   0000001A   0x7849             LDRB     R1,[R1, #+1]
   \   0000001C   0x2906             CMP      R1,#+6
   \   0000001E   0xD11B             BNE      ??mbedtls_cipher_check_tag_1
    781              {
    782                  unsigned char check_tag[16];
    783                  size_t i;
    784                  int diff;
    785          
    786                  if( tag_len > sizeof( check_tag ) )
   \   00000020   0x2D11             CMP      R5,#+17
   \   00000022   0xD301             BCC      ??mbedtls_cipher_check_tag_2
    787                      return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
   \                     ??mbedtls_cipher_check_tag_0: (+1)
   \   00000024   0x....             LDR      R0,??DataTable16  ;; 0xffff9f00
   \   00000026   0xE018             B        ??mbedtls_cipher_check_tag_3
    788          
    789                  if( 0 != ( ret = mbedtls_gcm_finish( (mbedtls_gcm_context *) ctx->cipher_ctx,
    790                                               check_tag, tag_len ) ) )
   \                     ??mbedtls_cipher_check_tag_2: (+1)
   \   00000028   0x002A             MOVS     R2,R5
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0x6BC0             LDR      R0,[R0, #+60]
   \   0000002E   0x.... 0x....      BL       mbedtls_gcm_finish
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD111             BNE      ??mbedtls_cipher_check_tag_3
    791                  {
    792                      return( ret );
    793                  }
    794          
    795                  /* Check the tag in "constant-time" */
    796                  for( diff = 0, i = 0; i < tag_len; i++ )
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD00D             BEQ      ??mbedtls_cipher_check_tag_1
   \   0000003C   0x466A             MOV      R2,SP
    797                      diff |= tag[i] ^ check_tag[i];
   \                     ??mbedtls_cipher_check_tag_4: (+1)
   \   0000003E   0x7823             LDRB     R3,[R4, #+0]
   \   00000040   0x7810             LDRB     R0,[R2, #+0]
   \   00000042   0x4058             EORS     R0,R0,R3
   \   00000044   0x4308             ORRS     R0,R0,R1
   \   00000046   0x0001             MOVS     R1,R0
   \   00000048   0x1C52             ADDS     R2,R2,#+1
   \   0000004A   0x1C64             ADDS     R4,R4,#+1
   \   0000004C   0x1E6D             SUBS     R5,R5,#+1
   \   0000004E   0xD1F6             BNE      ??mbedtls_cipher_check_tag_4
    798          
    799                  if( diff != 0 )
   \   00000050   0x2900             CMP      R1,#+0
   \   00000052   0xD001             BEQ      ??mbedtls_cipher_check_tag_1
    800                      return( MBEDTLS_ERR_CIPHER_AUTH_FAILED );
   \   00000054   0x....             LDR      R0,??DataTable18_5  ;; 0xffff9d00
   \   00000056   0xE000             B        ??mbedtls_cipher_check_tag_3
    801          
    802                  return( 0 );
    803              }
    804          
    805              return( 0 );
   \                     ??mbedtls_cipher_check_tag_1: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_cipher_check_tag_3: (+1)
   \   0000005A   0xB005             ADD      SP,SP,#+20
   \   0000005C   0xBD30             POP      {R4,R5,PC}       ;; return
    806          }
    807          #endif /* MBEDTLS_GCM_C */
    808          
    809          /*
    810           * Packet-oriented wrapper for non-AEAD modes
    811           */

   \                                 In section .text, align 2, keep-with-next
    812          int mbedtls_cipher_crypt( mbedtls_cipher_context_t *ctx,
    813                            const unsigned char *iv, size_t iv_len,
    814                            const unsigned char *input, size_t ilen,
    815                            unsigned char *output, size_t *olen )
    816          {
   \                     mbedtls_cipher_crypt: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x001F             MOVS     R7,R3
    817              int ret;
    818              size_t finish_olen;
    819          
    820              if( ( ret = mbedtls_cipher_set_iv( ctx, iv, iv_len ) ) != 0 )
   \   00000008   0x.... 0x....      BL       mbedtls_cipher_set_iv
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD121             BNE      ??mbedtls_cipher_crypt_0
    821                  return( ret );
    822          
    823              if( ( ret = mbedtls_cipher_reset( ctx ) ) != 0 )
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD018             BEQ      ??mbedtls_cipher_crypt_1
   \   00000014   0x6828             LDR      R0,[R5, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD015             BEQ      ??mbedtls_cipher_crypt_1
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x6268             STR      R0,[R5, #+36]
   \   0000001E   0x9C09             LDR      R4,[SP, #+36]
   \   00000020   0x9E0A             LDR      R6,[SP, #+40]
    824                  return( ret );
    825          
    826              if( ( ret = mbedtls_cipher_update( ctx, input, ilen, output, olen ) ) != 0 )
   \   00000022   0x9600             STR      R6,[SP, #+0]
   \   00000024   0x0023             MOVS     R3,R4
   \   00000026   0x9A08             LDR      R2,[SP, #+32]
   \   00000028   0x0039             MOVS     R1,R7
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x.... 0x....      BL       mbedtls_cipher_update
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD10F             BNE      ??mbedtls_cipher_crypt_0
    827                  return( ret );
    828          
    829              if( ( ret = mbedtls_cipher_finish( ctx, output + *olen, &finish_olen ) ) != 0 )
   \   00000034   0xAA01             ADD      R2,SP,#+4
   \   00000036   0x6830             LDR      R0,[R6, #+0]
   \   00000038   0x1821             ADDS     R1,R4,R0
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       mbedtls_cipher_finish
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD002             BEQ      ??mbedtls_cipher_crypt_2
    830                  return( ret );
   \   00000044   0xE006             B        ??mbedtls_cipher_crypt_0
   \                     ??mbedtls_cipher_crypt_1: (+1)
   \   00000046   0x....             LDR      R0,??DataTable16  ;; 0xffff9f00
   \   00000048   0xE004             B        ??mbedtls_cipher_crypt_0
    831          
    832              *olen += finish_olen;
   \                     ??mbedtls_cipher_crypt_2: (+1)
   \   0000004A   0x6830             LDR      R0,[R6, #+0]
   \   0000004C   0x9901             LDR      R1,[SP, #+4]
   \   0000004E   0x1840             ADDS     R0,R0,R1
   \   00000050   0x6030             STR      R0,[R6, #+0]
    833          
    834              return( 0 );
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_cipher_crypt_0: (+1)
   \   00000054   0xB003             ADD      SP,SP,#+12
   \   00000056   0xBDF0             POP      {R4-R7,PC}       ;; return
    835          }
    836          
    837          #if defined(MBEDTLS_CIPHER_MODE_AEAD)
    838          /*
    839           * Packet-oriented encryption for AEAD modes
    840           */

   \                                 In section .text, align 2, keep-with-next
    841          int mbedtls_cipher_auth_encrypt( mbedtls_cipher_context_t *ctx,
    842                                   const unsigned char *iv, size_t iv_len,
    843                                   const unsigned char *ad, size_t ad_len,
    844                                   const unsigned char *input, size_t ilen,
    845                                   unsigned char *output, size_t *olen,
    846                                   unsigned char *tag, size_t tag_len )
    847          {
   \                     mbedtls_cipher_auth_encrypt: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x9910             LDR      R1,[SP, #+64]
   \   00000006   0x9A11             LDR      R2,[SP, #+68]
   \   00000008   0x9B13             LDR      R3,[SP, #+76]
   \   0000000A   0x9C14             LDR      R4,[SP, #+80]
   \   0000000C   0x9D15             LDR      R5,[SP, #+84]
   \   0000000E   0x9E16             LDR      R6,[SP, #+88]
   \   00000010   0x6807             LDR      R7,[R0, #+0]
   \   00000012   0x787F             LDRB     R7,[R7, #+1]
   \   00000014   0x2F06             CMP      R7,#+6
   \   00000016   0xD111             BNE      ??mbedtls_cipher_auth_encrypt_0
    848          #if defined(MBEDTLS_GCM_C)
    849              if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )
    850              {
    851                  *olen = ilen;
   \   00000018   0x9F12             LDR      R7,[SP, #+72]
   \   0000001A   0x6027             STR      R7,[R4, #+0]
    852                  return( mbedtls_gcm_crypt_and_tag( ctx->cipher_ctx, MBEDTLS_GCM_ENCRYPT, ilen,
    853                                             iv, iv_len, ad, ad_len, input, output,
    854                                             tag_len, tag ) );
   \   0000001C   0x9506             STR      R5,[SP, #+24]
   \   0000001E   0x9605             STR      R6,[SP, #+20]
   \   00000020   0x9304             STR      R3,[SP, #+16]
   \   00000022   0x9203             STR      R2,[SP, #+12]
   \   00000024   0x9102             STR      R1,[SP, #+8]
   \   00000026   0x990A             LDR      R1,[SP, #+40]
   \   00000028   0x9101             STR      R1,[SP, #+4]
   \   0000002A   0x9909             LDR      R1,[SP, #+36]
   \   0000002C   0x9100             STR      R1,[SP, #+0]
   \   0000002E   0x9B08             LDR      R3,[SP, #+32]
   \   00000030   0x9A12             LDR      R2,[SP, #+72]
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x6BC0             LDR      R0,[R0, #+60]
   \   00000036   0x.... 0x....      BL       mbedtls_gcm_crypt_and_tag
   \   0000003A   0xE014             B        ??mbedtls_cipher_auth_encrypt_1
    855              }
    856          #endif /* MBEDTLS_GCM_C */
    857          #if defined(MBEDTLS_CCM_C)
    858              if( MBEDTLS_MODE_CCM == ctx->cipher_info->mode )
   \                     ??mbedtls_cipher_auth_encrypt_0: (+1)
   \   0000003C   0x6807             LDR      R7,[R0, #+0]
   \   0000003E   0x787F             LDRB     R7,[R7, #+1]
   \   00000040   0x2F08             CMP      R7,#+8
   \   00000042   0xD10F             BNE      ??mbedtls_cipher_auth_encrypt_2
    859              {
    860                  *olen = ilen;
   \   00000044   0x9F12             LDR      R7,[SP, #+72]
   \   00000046   0x6027             STR      R7,[R4, #+0]
    861                  return( mbedtls_ccm_encrypt_and_tag( ctx->cipher_ctx, ilen,
    862                                               iv, iv_len, ad, ad_len, input, output,
    863                                               tag, tag_len ) );
   \   00000048   0x9605             STR      R6,[SP, #+20]
   \   0000004A   0x9504             STR      R5,[SP, #+16]
   \   0000004C   0x9303             STR      R3,[SP, #+12]
   \   0000004E   0x9202             STR      R2,[SP, #+8]
   \   00000050   0x9101             STR      R1,[SP, #+4]
   \   00000052   0x990A             LDR      R1,[SP, #+40]
   \   00000054   0x9100             STR      R1,[SP, #+0]
   \   00000056   0x9B09             LDR      R3,[SP, #+36]
   \   00000058   0x9A08             LDR      R2,[SP, #+32]
   \   0000005A   0x9912             LDR      R1,[SP, #+72]
   \   0000005C   0x6BC0             LDR      R0,[R0, #+60]
   \   0000005E   0x.... 0x....      BL       mbedtls_ccm_encrypt_and_tag
   \   00000062   0xE000             B        ??mbedtls_cipher_auth_encrypt_1
    864              }
    865          #endif /* MBEDTLS_CCM_C */
    866          
    867              return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
   \                     ??mbedtls_cipher_auth_encrypt_2: (+1)
   \   00000064   0x....             LDR      R0,??DataTable18_1  ;; 0xffff9f80
   \                     ??mbedtls_cipher_auth_encrypt_1: (+1)
   \   00000066   0xB00B             ADD      SP,SP,#+44
   \   00000068   0xBDF0             POP      {R4-R7,PC}       ;; return
    868          }
    869          
    870          /*
    871           * Packet-oriented decryption for AEAD modes
    872           */

   \                                 In section .text, align 2, keep-with-next
    873          int mbedtls_cipher_auth_decrypt( mbedtls_cipher_context_t *ctx,
    874                                   const unsigned char *iv, size_t iv_len,
    875                                   const unsigned char *ad, size_t ad_len,
    876                                   const unsigned char *input, size_t ilen,
    877                                   unsigned char *output, size_t *olen,
    878                                   const unsigned char *tag, size_t tag_len )
    879          {
   \                     mbedtls_cipher_auth_decrypt: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x990E             LDR      R1,[SP, #+56]
   \   00000006   0x9A0F             LDR      R2,[SP, #+60]
   \   00000008   0x9B11             LDR      R3,[SP, #+68]
   \   0000000A   0x9C12             LDR      R4,[SP, #+72]
   \   0000000C   0x9D13             LDR      R5,[SP, #+76]
   \   0000000E   0x9E14             LDR      R6,[SP, #+80]
   \   00000010   0x6807             LDR      R7,[R0, #+0]
   \   00000012   0x787F             LDRB     R7,[R7, #+1]
   \   00000014   0x2F06             CMP      R7,#+6
   \   00000016   0xD110             BNE      ??mbedtls_cipher_auth_decrypt_0
    880          #if defined(MBEDTLS_GCM_C)
    881              if( MBEDTLS_MODE_GCM == ctx->cipher_info->mode )
    882              {
    883                  int ret;
    884          
    885                  *olen = ilen;
   \   00000018   0x9F10             LDR      R7,[SP, #+64]
   \   0000001A   0x6027             STR      R7,[R4, #+0]
    886                  ret = mbedtls_gcm_auth_decrypt( ctx->cipher_ctx, ilen,
    887                                          iv, iv_len, ad, ad_len,
    888                                          tag, tag_len, input, output );
   \   0000001C   0x9305             STR      R3,[SP, #+20]
   \   0000001E   0x9204             STR      R2,[SP, #+16]
   \   00000020   0x9603             STR      R6,[SP, #+12]
   \   00000022   0x9502             STR      R5,[SP, #+8]
   \   00000024   0x9101             STR      R1,[SP, #+4]
   \   00000026   0x9908             LDR      R1,[SP, #+32]
   \   00000028   0x9100             STR      R1,[SP, #+0]
   \   0000002A   0x9B07             LDR      R3,[SP, #+28]
   \   0000002C   0x9A06             LDR      R2,[SP, #+24]
   \   0000002E   0x9910             LDR      R1,[SP, #+64]
   \   00000030   0x6BC0             LDR      R0,[R0, #+60]
   \   00000032   0x.... 0x....      BL       mbedtls_gcm_auth_decrypt
    889          
    890                  if( ret == MBEDTLS_ERR_GCM_AUTH_FAILED )
   \   00000036   0x2111             MOVS     R1,#+17
   \   00000038   0xE013             B.N      ??mbedtls_cipher_auth_decrypt_1
    891                      ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;
    892          
    893                  return( ret );
    894              }
    895          #endif /* MBEDTLS_GCM_C */
    896          #if defined(MBEDTLS_CCM_C)
    897              if( MBEDTLS_MODE_CCM == ctx->cipher_info->mode )
   \                     ??mbedtls_cipher_auth_decrypt_0: (+1)
   \   0000003A   0x6807             LDR      R7,[R0, #+0]
   \   0000003C   0x787F             LDRB     R7,[R7, #+1]
   \   0000003E   0x2F08             CMP      R7,#+8
   \   00000040   0xD114             BNE      ??mbedtls_cipher_auth_decrypt_2
    898              {
    899                  int ret;
    900          
    901                  *olen = ilen;
   \   00000042   0x9F10             LDR      R7,[SP, #+64]
   \   00000044   0x6027             STR      R7,[R4, #+0]
    902                  ret = mbedtls_ccm_auth_decrypt( ctx->cipher_ctx, ilen,
    903                                          iv, iv_len, ad, ad_len,
    904                                          input, output, tag, tag_len );
   \   00000046   0x9605             STR      R6,[SP, #+20]
   \   00000048   0x9504             STR      R5,[SP, #+16]
   \   0000004A   0x9303             STR      R3,[SP, #+12]
   \   0000004C   0x9202             STR      R2,[SP, #+8]
   \   0000004E   0x9101             STR      R1,[SP, #+4]
   \   00000050   0x9908             LDR      R1,[SP, #+32]
   \   00000052   0x9100             STR      R1,[SP, #+0]
   \   00000054   0x9B07             LDR      R3,[SP, #+28]
   \   00000056   0x9A06             LDR      R2,[SP, #+24]
   \   00000058   0x9910             LDR      R1,[SP, #+64]
   \   0000005A   0x6BC0             LDR      R0,[R0, #+60]
   \   0000005C   0x.... 0x....      BL       mbedtls_ccm_auth_decrypt
    905          
    906                  if( ret == MBEDTLS_ERR_CCM_AUTH_FAILED )
   \   00000060   0x210E             MOVS     R1,#+14
   \                     ??mbedtls_cipher_auth_decrypt_1: (+1)
   \   00000062   0x43C9             MVNS     R1,R1            ;; #-15
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD102             BNE      ??mbedtls_cipher_auth_decrypt_3
    907                      ret = MBEDTLS_ERR_CIPHER_AUTH_FAILED;
   \   00000068   0x....             LDR      R0,??DataTable18_5  ;; 0xffff9d00
    908          
    909                  return( ret );
   \   0000006A   0xE000             B        ??mbedtls_cipher_auth_decrypt_3
    910              }
    911          #endif /* MBEDTLS_CCM_C */
    912          
    913              return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
   \                     ??mbedtls_cipher_auth_decrypt_2: (+1)
   \   0000006C   0x....             LDR      R0,??DataTable18_1  ;; 0xffff9f80
   \                     ??mbedtls_cipher_auth_decrypt_3: (+1)
   \   0000006E   0xB009             ADD      SP,SP,#+36
   \   00000070   0xBDF0             POP      {R4-R7,PC}       ;; return
    914          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     mbedtls_cipher_supported

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     supported_init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     mbedtls_cipher_definitions

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xFFFF9F00         DC32     0xffff9f00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     add_pkcs_padding

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     get_pkcs_padding

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0xFFFF9E80         DC32     0xffff9e80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0xFFFF9F80         DC32     0xffff9f80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0xFFFF9D80         DC32     0xffff9d80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0xFFFF9C80         DC32     0xffff9c80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0xFFFF9F00         DC32     0xffff9f00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0xFFFF9E00         DC32     0xffff9e00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0xFFFF9D80         DC32     0xffff9d80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0xFFFF9F80         DC32     0xffff9f80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     add_pkcs_padding

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x........         DC32     get_pkcs_padding

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x........         DC32     get_no_padding

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0xFFFF9D00         DC32     0xffff9d00
    915          #endif /* MBEDTLS_CIPHER_MODE_AEAD */
    916          
    917          #endif /* MBEDTLS_CIPHER_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   add_pkcs_padding
       0   get_no_padding
      16   get_pkcs_padding
      56   mbedtls_cipher_auth_decrypt
        56   -> mbedtls_ccm_auth_decrypt
        56   -> mbedtls_gcm_auth_decrypt
      64   mbedtls_cipher_auth_encrypt
        64   -> mbedtls_ccm_encrypt_and_tag
        64   -> mbedtls_gcm_crypt_and_tag
      32   mbedtls_cipher_check_tag
        32   -> mbedtls_gcm_finish
      32   mbedtls_cipher_crypt
        32   -> mbedtls_cipher_finish
        32   -> mbedtls_cipher_set_iv
        32   -> mbedtls_cipher_update
      32   mbedtls_cipher_finish
        32   -- Indirect call
       8   mbedtls_cipher_free
         8   -- Indirect call
         8   -> __aeabi_memclr
      16   mbedtls_cipher_info_from_string
        16   -> strcmp
       4   mbedtls_cipher_info_from_type
       8   mbedtls_cipher_info_from_values
       8   mbedtls_cipher_init
         8   -> __aeabi_memclr4
       8   mbedtls_cipher_list
       0   mbedtls_cipher_reset
      16   mbedtls_cipher_set_iv
        16   -> __aeabi_memcpy
       0   mbedtls_cipher_set_padding_mode
      16   mbedtls_cipher_setkey
        16   -- Indirect call
      16   mbedtls_cipher_setup
        16   -- Indirect call
        16   -> __aeabi_memclr4
      40   mbedtls_cipher_update
        40   -- Indirect call
        40   -> __aeabi_memcpy
        40   -> mbedtls_gcm_update
        40 __aeabi_uidivmod
      16   mbedtls_cipher_update_ad
        16   -> mbedtls_gcm_starts
       8   mbedtls_cipher_write_tag
         8   -> mbedtls_gcm_finish


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable17
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
      24  add_pkcs_padding
      18  get_no_padding
      94  get_pkcs_padding
     114  mbedtls_cipher_auth_decrypt
     106  mbedtls_cipher_auth_encrypt
      94  mbedtls_cipher_check_tag
      88  mbedtls_cipher_crypt
     220  mbedtls_cipher_finish
      30  mbedtls_cipher_free
      38  mbedtls_cipher_info_from_string
      26  mbedtls_cipher_info_from_type
      44  mbedtls_cipher_info_from_values
      10  mbedtls_cipher_init
      44  mbedtls_cipher_list
      22  mbedtls_cipher_reset
      58  mbedtls_cipher_set_iv
      50  mbedtls_cipher_set_padding_mode
      74  mbedtls_cipher_setkey
      58  mbedtls_cipher_setup
     388  mbedtls_cipher_update
      52  mbedtls_cipher_update_ad
      46  mbedtls_cipher_write_tag
       4  supported_init

 
     4 bytes in section .bss
 1 770 bytes in section .text
 
 1 770 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: none

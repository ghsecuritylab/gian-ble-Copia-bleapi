###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:23
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  .\mbed-os\features\mbedtls\src\ccm.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\ccm.d -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\ccm.s.txt -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\ccm.o
#        .\mbed-os\features\mbedtls\src\ccm.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\ccm.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\features\mbedtls\src\ccm.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\features\mbedtls\src\ccm.c
      1          /*
      2           *  NIST SP800-38C compliant CCM implementation
      3           *
      4           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           *
     19           *  This file is part of mbed TLS (https://tls.mbed.org)
     20           */
     21          
     22          /*
     23           * Definition of CCM:
     24           * http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf
     25           * RFC 3610 "Counter with CBC-MAC (CCM)"
     26           *
     27           * Related:
     28           * RFC 5116 "An Interface and Algorithms for Authenticated Encryption"
     29           */
     30          
     31          #if !defined(MBEDTLS_CONFIG_FILE)
     32          #include "mbedtls/config.h"
     33          #else
     34          #include MBEDTLS_CONFIG_FILE
     35          #endif
     36          
     37          #if defined(MBEDTLS_CCM_C)
     38          
     39          #include "mbedtls/ccm.h"
     40          
     41          #include <string.h>
     42          
     43          #if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)
     44          #if defined(MBEDTLS_PLATFORM_C)
     45          #include "mbedtls/platform.h"
     46          #else
     47          #include <stdio.h>
     48          #define mbedtls_printf printf
     49          #endif /* MBEDTLS_PLATFORM_C */
     50          #endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */
     51          
     52          /* Implementation that should never be optimized out by the compiler */
     53          static void mbedtls_zeroize( void *v, size_t n ) {
     54              volatile unsigned char *p = (unsigned char*)v; while( n-- ) *p++ = 0;
     55          }
     56          
     57          #define CCM_ENCRYPT 0
     58          #define CCM_DECRYPT 1
     59          
     60          /*
     61           * Initialize context
     62           */

   \                                 In section .text, align 2, keep-with-next
     63          void mbedtls_ccm_init( mbedtls_ccm_context *ctx )
     64          {
   \                     mbedtls_ccm_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     65              memset( ctx, 0, sizeof( mbedtls_ccm_context ) );
   \   00000002   0x2140             MOVS     R1,#+64
   \   00000004   0x.... 0x....      BL       __aeabi_memclr4
     66          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
     67          

   \                                 In section .text, align 2, keep-with-next
     68          int mbedtls_ccm_setkey( mbedtls_ccm_context *ctx,
     69                                  mbedtls_cipher_id_t cipher,
     70                                  const unsigned char *key,
     71                                  unsigned int keybits )
     72          {
   \                     mbedtls_ccm_setkey: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0x0017             MOVS     R7,R2
   \   00000008   0x001D             MOVS     R5,R3
     73              int ret;
     74              const mbedtls_cipher_info_t *cipher_info;
     75          
     76              cipher_info = mbedtls_cipher_info_from_values( cipher, keybits, MBEDTLS_MODE_ECB );
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x.... 0x....      BL       mbedtls_cipher_info_from_values
   \   00000012   0x0006             MOVS     R6,R0
     77              if( cipher_info == NULL )
   \   00000014   0xD002             BEQ      ??mbedtls_ccm_setkey_0
     78                  return( MBEDTLS_ERR_CCM_BAD_INPUT );
     79          
     80              if( cipher_info->block_size != 16 )
   \   00000016   0x6970             LDR      R0,[R6, #+20]
   \   00000018   0x2810             CMP      R0,#+16
   \   0000001A   0xD002             BEQ      ??mbedtls_ccm_setkey_1
     81                  return( MBEDTLS_ERR_CCM_BAD_INPUT );
   \                     ??mbedtls_ccm_setkey_0: (+1)
   \   0000001C   0x200C             MOVS     R0,#+12
   \   0000001E   0x43C0             MVNS     R0,R0            ;; #-13
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}
     82          
     83              mbedtls_cipher_free( &ctx->cipher_ctx );
   \                     ??mbedtls_ccm_setkey_1: (+1)
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       mbedtls_cipher_free
     84          
     85              if( ( ret = mbedtls_cipher_setup( &ctx->cipher_ctx, cipher_info ) ) != 0 )
   \   00000028   0x0031             MOVS     R1,R6
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       mbedtls_cipher_setup
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD105             BNE      ??mbedtls_ccm_setkey_2
     86                  return( ret );
     87          
     88              if( ( ret = mbedtls_cipher_setkey( &ctx->cipher_ctx, key, keybits,
     89                                         MBEDTLS_ENCRYPT ) ) != 0 )
   \   00000034   0x2301             MOVS     R3,#+1
   \   00000036   0x002A             MOVS     R2,R5
   \   00000038   0x0039             MOVS     R1,R7
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       mbedtls_cipher_setkey
   \                     ??mbedtls_ccm_setkey_2: (+1)
   \   00000040   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     90              {
     91                  return( ret );
     92              }
     93          
     94              return( 0 );
     95          }
     96          
     97          /*
     98           * Free context
     99           */

   \                                 In section .text, align 2, keep-with-next
    100          void mbedtls_ccm_free( mbedtls_ccm_context *ctx )
    101          {
   \                     mbedtls_ccm_free: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    102              mbedtls_cipher_free( &ctx->cipher_ctx );
   \   00000004   0x.... 0x....      BL       mbedtls_cipher_free
    103              mbedtls_zeroize( ctx, sizeof( mbedtls_ccm_context ) );
   \   00000008   0x2140             MOVS     R1,#+64
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       __aeabi_memclr
    104          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    105          
    106          /*
    107           * Macros for common operations.
    108           * Results in smaller compiled code than static inline functions.
    109           */
    110          
    111          /*
    112           * Update the CBC-MAC state in y using a block in b
    113           * (Always using b as the source helps the compiler optimise a bit better.)
    114           */
    115          #define UPDATE_CBC_MAC                                                      \
    116              for( i = 0; i < 16; i++ )                                               \
    117                  y[i] ^= b[i];                                                       \
    118                                                                                      \
    119              if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, y, 16, y, &olen ) ) != 0 ) \
    120                  return( ret );
    121          
    122          /*
    123           * Encrypt or decrypt a partial block with CTR
    124           * Warning: using b for temporary storage! src and dst must not be b!
    125           * This avoids allocating one more 16 bytes buffer while allowing src == dst.
    126           */
    127          #define CTR_CRYPT( dst, src, len  )                                            \
    128              if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, ctr, 16, b, &olen ) ) != 0 )  \
    129                  return( ret );                                                         \
    130                                                                                         \
    131              for( i = 0; i < len; i++ )                                                 \
    132                  dst[i] = src[i] ^ b[i];
    133          
    134          /*
    135           * Authenticated encryption or decryption
    136           */

   \                                 In section .text, align 2, keep-with-next
    137          static int ccm_auth_crypt( mbedtls_ccm_context *ctx, int mode, size_t length,
    138                                     const unsigned char *iv, size_t iv_len,
    139                                     const unsigned char *add, size_t add_len,
    140                                     const unsigned char *input, unsigned char *output,
    141                                     unsigned char *tag, size_t tag_len )
    142          {
   \                     ccm_auth_crypt: (+1)
   \   00000000   0xB5FF             PUSH     {R0-R7,LR}
   \   00000002   0xB091             SUB      SP,SP,#+68
    143              int ret;
    144              unsigned char i;
    145              unsigned char q;
    146              size_t len_left, olen;
    147              unsigned char b[16];
    148              unsigned char y[16];
    149              unsigned char ctr[16];
    150              const unsigned char *src;
    151              unsigned char *dst;
    152          
    153              /*
    154               * Check length requirements: SP800-38C A.1
    155               * Additional requirement: a < 2^16 - 2^8 to simplify the code.
    156               * 'length' checked later (when writing it to the first block)
    157               */
    158              if( tag_len < 4 || tag_len > 16 || tag_len % 2 != 0 )
   \   00000004   0x9820             LDR      R0,[SP, #+128]
   \   00000006   0x1F00             SUBS     R0,R0,#+4
   \   00000008   0x280D             CMP      R0,#+13
   \   0000000A   0xD23B             BCS      ??ccm_auth_crypt_0
   \   0000000C   0x9820             LDR      R0,[SP, #+128]
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xD438             BMI      ??ccm_auth_crypt_0
    159                  return( MBEDTLS_ERR_CCM_BAD_INPUT );
    160          
    161              /* Also implies q is within bounds */
    162              if( iv_len < 7 || iv_len > 13 )
   \   00000012   0x981A             LDR      R0,[SP, #+104]
   \   00000014   0x1FC0             SUBS     R0,R0,#+7
   \   00000016   0x2807             CMP      R0,#+7
   \   00000018   0xD234             BCS      ??ccm_auth_crypt_0
   \   0000001A   0x9D1C             LDR      R5,[SP, #+112]
    163                  return( MBEDTLS_ERR_CCM_BAD_INPUT );
    164          
    165              if( add_len > 0xFF00 )
   \   0000001C   0x....             LDR      R0,??DataTable14  ;; 0xff01
   \   0000001E   0x4285             CMP      R5,R0
   \   00000020   0xD230             BCS      ??ccm_auth_crypt_0
    166                  return( MBEDTLS_ERR_CCM_BAD_INPUT );
    167          
    168              q = 16 - 1 - (unsigned char) iv_len;
   \   00000022   0x200F             MOVS     R0,#+15
   \   00000024   0x991A             LDR      R1,[SP, #+104]
   \   00000026   0x1A40             SUBS     R0,R0,R1
   \   00000028   0xB2C0             UXTB     R0,R0
   \   0000002A   0x9002             STR      R0,[SP, #+8]
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x7408             STRB     R0,[R1, #+16]
    169          
    170              /*
    171               * First block B_0:
    172               * 0        .. 0        flags
    173               * 1        .. iv_len   nonce (aka iv)
    174               * iv_len+1 .. 15       length
    175               *
    176               * With flags as (bits):
    177               * 7        0
    178               * 6        add present?
    179               * 5 .. 3   (t - 2) / 2
    180               * 2 .. 0   q - 1
    181               */
    182              b[0] = 0;
    183              b[0] |= ( add_len > 0 ) << 6;
   \   00000032   0x1E68             SUBS     R0,R5,#+1
   \   00000034   0x4180             SBCS     R0,R0,R0
   \   00000036   0x43C0             MVNS     R0,R0
   \   00000038   0x0FC0             LSRS     R0,R0,#+31
    184              b[0] |= ( ( tag_len - 2 ) / 2 ) << 3;
    185              b[0] |= q - 1;
   \   0000003A   0x9902             LDR      R1,[SP, #+8]
   \   0000003C   0x1E49             SUBS     R1,R1,#+1
   \   0000003E   0x466A             MOV      R2,SP
   \   00000040   0x7111             STRB     R1,[R2, #+4]
   \   00000042   0x0180             LSLS     R0,R0,#+6
   \   00000044   0x9920             LDR      R1,[SP, #+128]
   \   00000046   0x1E89             SUBS     R1,R1,#+2
   \   00000048   0x0849             LSRS     R1,R1,#+1
   \   0000004A   0x00C9             LSLS     R1,R1,#+3
   \   0000004C   0x4301             ORRS     R1,R1,R0
   \   0000004E   0x4668             MOV      R0,SP
   \   00000050   0x7900             LDRB     R0,[R0, #+4]
   \   00000052   0x4308             ORRS     R0,R0,R1
   \   00000054   0x4669             MOV      R1,SP
   \   00000056   0x7408             STRB     R0,[R1, #+16]
    186          
    187              memcpy( b + 1, iv, iv_len );
   \   00000058   0x9A1A             LDR      R2,[SP, #+104]
   \   0000005A   0x9914             LDR      R1,[SP, #+80]
   \   0000005C   0xA804             ADD      R0,SP,#+16
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \   00000060   0x.... 0x....      BL       __aeabi_memcpy
    188          
    189              for( i = 0, len_left = length; i < q; i++, len_left >>= 8 )
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x9C13             LDR      R4,[SP, #+76]
   \   00000068   0x9902             LDR      R1,[SP, #+8]
   \   0000006A   0x2901             CMP      R1,#+1
   \   0000006C   0xDB08             BLT      ??ccm_auth_crypt_1
    190                  b[15-i] = (unsigned char)( len_left & 0xFF );
   \                     ??ccm_auth_crypt_2: (+1)
   \   0000006E   0xAA04             ADD      R2,SP,#+16
   \   00000070   0x4243             RSBS     R3,R0,#+0
   \   00000072   0x18D2             ADDS     R2,R2,R3
   \   00000074   0x73D4             STRB     R4,[R2, #+15]
   \   00000076   0x1C40             ADDS     R0,R0,#+1
   \   00000078   0x0A24             LSRS     R4,R4,#+8
   \   0000007A   0x9902             LDR      R1,[SP, #+8]
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xDBF6             BLT      ??ccm_auth_crypt_2
    191          
    192              if( len_left > 0 )
   \                     ??ccm_auth_crypt_1: (+1)
   \   00000080   0x2C00             CMP      R4,#+0
   \   00000082   0xD002             BEQ      ??ccm_auth_crypt_3
    193                  return( MBEDTLS_ERR_CCM_BAD_INPUT );
   \                     ??ccm_auth_crypt_0: (+1)
   \   00000084   0x200C             MOVS     R0,#+12
   \   00000086   0x43C0             MVNS     R0,R0            ;; #-13
   \   00000088   0xE175             B        ??ccm_auth_crypt_4
    194          
    195          
    196              /* Start CBC-MAC with first block */
    197              memset( y, 0, 16 );
   \                     ??ccm_auth_crypt_3: (+1)
   \   0000008A   0xA808             ADD      R0,SP,#+32
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0x2200             MOVS     R2,#+0
   \   00000090   0x2300             MOVS     R3,#+0
   \   00000092   0xC01E             STM      R0!,{R1-R4}
    198              UPDATE_CBC_MAC;
   \   00000094   0xA808             ADD      R0,SP,#+32
   \   00000096   0xA904             ADD      R1,SP,#+16
   \   00000098   0x2204             MOVS     R2,#+4
   \                     ??ccm_auth_crypt_5: (+1)
   \   0000009A   0x7803             LDRB     R3,[R0, #+0]
   \   0000009C   0x780C             LDRB     R4,[R1, #+0]
   \   0000009E   0x405C             EORS     R4,R4,R3
   \   000000A0   0x7004             STRB     R4,[R0, #+0]
   \   000000A2   0x7843             LDRB     R3,[R0, #+1]
   \   000000A4   0x784C             LDRB     R4,[R1, #+1]
   \   000000A6   0x405C             EORS     R4,R4,R3
   \   000000A8   0x7044             STRB     R4,[R0, #+1]
   \   000000AA   0x7883             LDRB     R3,[R0, #+2]
   \   000000AC   0x788C             LDRB     R4,[R1, #+2]
   \   000000AE   0x405C             EORS     R4,R4,R3
   \   000000B0   0x7084             STRB     R4,[R0, #+2]
   \   000000B2   0x78C3             LDRB     R3,[R0, #+3]
   \   000000B4   0x78CC             LDRB     R4,[R1, #+3]
   \   000000B6   0x405C             EORS     R4,R4,R3
   \   000000B8   0x70C4             STRB     R4,[R0, #+3]
   \   000000BA   0x1D09             ADDS     R1,R1,#+4
   \   000000BC   0x1D00             ADDS     R0,R0,#+4
   \   000000BE   0x1E52             SUBS     R2,R2,#+1
   \   000000C0   0xD1EB             BNE      ??ccm_auth_crypt_5
   \   000000C2   0xA803             ADD      R0,SP,#+12
   \   000000C4   0x9000             STR      R0,[SP, #+0]
   \   000000C6   0xAB08             ADD      R3,SP,#+32
   \   000000C8   0x2210             MOVS     R2,#+16
   \   000000CA   0xA908             ADD      R1,SP,#+32
   \   000000CC   0x9811             LDR      R0,[SP, #+68]
   \   000000CE   0x.... 0x....      BL       mbedtls_cipher_update
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD000             BEQ      .+4
   \   000000D6   0xE14E             B        ??ccm_auth_crypt_4
    199          
    200              /*
    201               * If there is additional data, update CBC-MAC with
    202               * add_len, add, 0 (padding to a block boundary)
    203               */
    204              if( add_len > 0 )
   \   000000D8   0x2D00             CMP      R5,#+0
   \   000000DA   0xD06F             BEQ      ??ccm_auth_crypt_6
    205              {
    206                  size_t use_len;
    207                  len_left = add_len;
    208                  src = add;
    209          
    210                  memset( b, 0, 16 );
   \   000000DC   0xA804             ADD      R0,SP,#+16
   \   000000DE   0x2100             MOVS     R1,#+0
   \   000000E0   0x2200             MOVS     R2,#+0
   \   000000E2   0x2300             MOVS     R3,#+0
   \   000000E4   0x2400             MOVS     R4,#+0
   \   000000E6   0xC01E             STM      R0!,{R1-R4}
    211                  b[0] = (unsigned char)( ( add_len >> 8 ) & 0xFF );
   \   000000E8   0x0A28             LSRS     R0,R5,#+8
   \   000000EA   0x4669             MOV      R1,SP
   \   000000EC   0x7408             STRB     R0,[R1, #+16]
    212                  b[1] = (unsigned char)( ( add_len      ) & 0xFF );
   \   000000EE   0xA904             ADD      R1,SP,#+16
   \   000000F0   0x704D             STRB     R5,[R1, #+1]
    213          
    214                  use_len = len_left < 16 - 2 ? len_left : 16 - 2;
   \   000000F2   0x260E             MOVS     R6,#+14
   \   000000F4   0x2D0E             CMP      R5,#+14
   \   000000F6   0xD800             BHI      ??ccm_auth_crypt_7
   \   000000F8   0x002E             MOVS     R6,R5
   \                     ??ccm_auth_crypt_7: (+1)
   \   000000FA   0x9F1B             LDR      R7,[SP, #+108]
    215                  memcpy( b + 2, src, use_len );
   \   000000FC   0x0032             MOVS     R2,R6
   \   000000FE   0x0039             MOVS     R1,R7
   \   00000100   0xA804             ADD      R0,SP,#+16
   \   00000102   0x1C80             ADDS     R0,R0,#+2
   \   00000104   0x.... 0x....      BL       __aeabi_memcpy
    216                  len_left -= use_len;
   \   00000108   0x1BAC             SUBS     R4,R5,R6
    217                  src += use_len;
   \   0000010A   0x19BD             ADDS     R5,R7,R6
    218          
    219                  UPDATE_CBC_MAC;
   \   0000010C   0xA808             ADD      R0,SP,#+32
   \   0000010E   0xA904             ADD      R1,SP,#+16
   \   00000110   0x2204             MOVS     R2,#+4
   \                     ??ccm_auth_crypt_8: (+1)
   \   00000112   0x7803             LDRB     R3,[R0, #+0]
   \   00000114   0x780E             LDRB     R6,[R1, #+0]
   \   00000116   0x405E             EORS     R6,R6,R3
   \   00000118   0x7006             STRB     R6,[R0, #+0]
   \   0000011A   0x7843             LDRB     R3,[R0, #+1]
   \   0000011C   0x784E             LDRB     R6,[R1, #+1]
   \   0000011E   0x405E             EORS     R6,R6,R3
   \   00000120   0x7046             STRB     R6,[R0, #+1]
   \   00000122   0x7883             LDRB     R3,[R0, #+2]
   \   00000124   0x788E             LDRB     R6,[R1, #+2]
   \   00000126   0x405E             EORS     R6,R6,R3
   \   00000128   0x7086             STRB     R6,[R0, #+2]
   \   0000012A   0x78C3             LDRB     R3,[R0, #+3]
   \   0000012C   0x78CE             LDRB     R6,[R1, #+3]
   \   0000012E   0x405E             EORS     R6,R6,R3
   \   00000130   0x70C6             STRB     R6,[R0, #+3]
   \   00000132   0x1D09             ADDS     R1,R1,#+4
   \   00000134   0x1D00             ADDS     R0,R0,#+4
   \   00000136   0x1E52             SUBS     R2,R2,#+1
   \   00000138   0xD1EB             BNE      ??ccm_auth_crypt_8
   \   0000013A   0xA803             ADD      R0,SP,#+12
   \   0000013C   0x9000             STR      R0,[SP, #+0]
   \   0000013E   0xAB08             ADD      R3,SP,#+32
   \   00000140   0x2210             MOVS     R2,#+16
   \   00000142   0xA908             ADD      R1,SP,#+32
   \   00000144   0x9811             LDR      R0,[SP, #+68]
   \   00000146   0x.... 0x....      BL       mbedtls_cipher_update
   \   0000014A   0x2800             CMP      R0,#+0
   \   0000014C   0xD002             BEQ      ??ccm_auth_crypt_9
   \   0000014E   0xE112             B        ??ccm_auth_crypt_4
    220          
    221                  while( len_left > 0 )
    222                  {
    223                      use_len = len_left > 16 ? 16 : len_left;
    224          
    225                      memset( b, 0, 16 );
    226                      memcpy( b, src, use_len );
    227                      UPDATE_CBC_MAC;
    228          
    229                      len_left -= use_len;
   \                     ??ccm_auth_crypt_10: (+1)
   \   00000150   0x1BA4             SUBS     R4,R4,R6
    230                      src += use_len;
   \   00000152   0x19AD             ADDS     R5,R5,R6
   \                     ??ccm_auth_crypt_9: (+1)
   \   00000154   0x2C00             CMP      R4,#+0
   \   00000156   0xD031             BEQ      ??ccm_auth_crypt_6
   \   00000158   0x2C11             CMP      R4,#+17
   \   0000015A   0xD301             BCC      ??ccm_auth_crypt_11
   \   0000015C   0x2610             MOVS     R6,#+16
   \   0000015E   0xE000             B        ??ccm_auth_crypt_12
   \                     ??ccm_auth_crypt_11: (+1)
   \   00000160   0x0026             MOVS     R6,R4
   \                     ??ccm_auth_crypt_12: (+1)
   \   00000162   0xA804             ADD      R0,SP,#+16
   \   00000164   0x2100             MOVS     R1,#+0
   \   00000166   0x2200             MOVS     R2,#+0
   \   00000168   0x2300             MOVS     R3,#+0
   \   0000016A   0x2700             MOVS     R7,#+0
   \   0000016C   0xC08E             STM      R0!,{R1-R3,R7}
   \   0000016E   0x0032             MOVS     R2,R6
   \   00000170   0x0029             MOVS     R1,R5
   \   00000172   0xA804             ADD      R0,SP,#+16
   \   00000174   0x.... 0x....      BL       __aeabi_memcpy
   \   00000178   0xA808             ADD      R0,SP,#+32
   \   0000017A   0xA904             ADD      R1,SP,#+16
   \   0000017C   0x2204             MOVS     R2,#+4
   \                     ??ccm_auth_crypt_13: (+1)
   \   0000017E   0x7803             LDRB     R3,[R0, #+0]
   \   00000180   0x780F             LDRB     R7,[R1, #+0]
   \   00000182   0x405F             EORS     R7,R7,R3
   \   00000184   0x7007             STRB     R7,[R0, #+0]
   \   00000186   0x7843             LDRB     R3,[R0, #+1]
   \   00000188   0x784F             LDRB     R7,[R1, #+1]
   \   0000018A   0x405F             EORS     R7,R7,R3
   \   0000018C   0x7047             STRB     R7,[R0, #+1]
   \   0000018E   0x7883             LDRB     R3,[R0, #+2]
   \   00000190   0x788F             LDRB     R7,[R1, #+2]
   \   00000192   0x405F             EORS     R7,R7,R3
   \   00000194   0x7087             STRB     R7,[R0, #+2]
   \   00000196   0x78C3             LDRB     R3,[R0, #+3]
   \   00000198   0x78CF             LDRB     R7,[R1, #+3]
   \   0000019A   0x405F             EORS     R7,R7,R3
   \   0000019C   0x70C7             STRB     R7,[R0, #+3]
   \   0000019E   0x1D09             ADDS     R1,R1,#+4
   \   000001A0   0x1D00             ADDS     R0,R0,#+4
   \   000001A2   0x1E52             SUBS     R2,R2,#+1
   \   000001A4   0xD1EB             BNE      ??ccm_auth_crypt_13
   \   000001A6   0xA803             ADD      R0,SP,#+12
   \   000001A8   0x9000             STR      R0,[SP, #+0]
   \   000001AA   0xAB08             ADD      R3,SP,#+32
   \   000001AC   0x2210             MOVS     R2,#+16
   \   000001AE   0xA908             ADD      R1,SP,#+32
   \   000001B0   0x9811             LDR      R0,[SP, #+68]
   \   000001B2   0x.... 0x....      BL       mbedtls_cipher_update
   \   000001B6   0x2800             CMP      R0,#+0
   \   000001B8   0xD0CA             BEQ      ??ccm_auth_crypt_10
   \   000001BA   0xE0DC             B        ??ccm_auth_crypt_4
    231                  }
    232              }
   \                     ??ccm_auth_crypt_6: (+1)
   \   000001BC   0x4668             MOV      R0,SP
   \   000001BE   0x7900             LDRB     R0,[R0, #+4]
   \   000001C0   0xA90C             ADD      R1,SP,#+48
   \   000001C2   0x7008             STRB     R0,[R1, #+0]
    233          
    234              /*
    235               * Prepare counter block for encryption:
    236               * 0        .. 0        flags
    237               * 1        .. iv_len   nonce (aka iv)
    238               * iv_len+1 .. 15       counter (initially 1)
    239               *
    240               * With flags as (bits):
    241               * 7 .. 3   0
    242               * 2 .. 0   q - 1
    243               */
    244              ctr[0] = q - 1;
    245              memcpy( ctr + 1, iv, iv_len );
   \   000001C4   0x9A1A             LDR      R2,[SP, #+104]
   \   000001C6   0x9914             LDR      R1,[SP, #+80]
   \   000001C8   0xA80C             ADD      R0,SP,#+48
   \   000001CA   0x1C40             ADDS     R0,R0,#+1
   \   000001CC   0x.... 0x....      BL       __aeabi_memcpy
    246              memset( ctr + 1 + iv_len, 0, q );
   \   000001D0   0x9902             LDR      R1,[SP, #+8]
   \   000001D2   0xA80C             ADD      R0,SP,#+48
   \   000001D4   0x9A1A             LDR      R2,[SP, #+104]
   \   000001D6   0x1880             ADDS     R0,R0,R2
   \   000001D8   0x1C40             ADDS     R0,R0,#+1
   \   000001DA   0x.... 0x....      BL       __aeabi_memclr
    247              ctr[15] = 1;
   \   000001DE   0x2001             MOVS     R0,#+1
   \   000001E0   0xA90C             ADD      R1,SP,#+48
   \   000001E2   0x73C8             STRB     R0,[R1, #+15]
    248          
    249              /*
    250               * Authenticate and {en,de}crypt the message.
    251               *
    252               * The only difference between encryption and decryption is
    253               * the respective order of authentication and {en,de}cryption.
    254               */
    255              len_left = length;
   \   000001E4   0x9C13             LDR      R4,[SP, #+76]
    256              src = input;
   \   000001E6   0x9D1D             LDR      R5,[SP, #+116]
    257              dst = output;
   \   000001E8   0x9E1E             LDR      R6,[SP, #+120]
    258          
    259              while( len_left > 0 )
   \                     ??ccm_auth_crypt_14: (+1)
   \   000001EA   0x2C00             CMP      R4,#+0
   \   000001EC   0xD100             BNE      .+4
   \   000001EE   0xE08E             B        ??ccm_auth_crypt_15
    260              {
    261                  size_t use_len = len_left > 16 ? 16 : len_left;
   \   000001F0   0x2C11             CMP      R4,#+17
   \   000001F2   0xD302             BCC      ??ccm_auth_crypt_16
   \   000001F4   0x2010             MOVS     R0,#+16
   \   000001F6   0x9001             STR      R0,[SP, #+4]
   \   000001F8   0xE000             B        ??ccm_auth_crypt_17
   \                     ??ccm_auth_crypt_16: (+1)
   \   000001FA   0x9401             STR      R4,[SP, #+4]
    262          
    263                  if( mode == CCM_ENCRYPT )
   \                     ??ccm_auth_crypt_17: (+1)
   \   000001FC   0x9812             LDR      R0,[SP, #+72]
   \   000001FE   0x2800             CMP      R0,#+0
   \   00000200   0xD12C             BNE      ??ccm_auth_crypt_18
    264                  {
    265                      memset( b, 0, 16 );
   \   00000202   0xA804             ADD      R0,SP,#+16
   \   00000204   0x2100             MOVS     R1,#+0
   \   00000206   0x2200             MOVS     R2,#+0
   \   00000208   0x2300             MOVS     R3,#+0
   \   0000020A   0x2700             MOVS     R7,#+0
   \   0000020C   0xC08E             STM      R0!,{R1-R3,R7}
    266                      memcpy( b, src, use_len );
   \   0000020E   0x9A01             LDR      R2,[SP, #+4]
   \   00000210   0x0029             MOVS     R1,R5
   \   00000212   0xA804             ADD      R0,SP,#+16
   \   00000214   0x.... 0x....      BL       __aeabi_memcpy
    267                      UPDATE_CBC_MAC;
   \   00000218   0xA808             ADD      R0,SP,#+32
   \   0000021A   0xA904             ADD      R1,SP,#+16
   \   0000021C   0x2204             MOVS     R2,#+4
   \                     ??ccm_auth_crypt_19: (+1)
   \   0000021E   0x7803             LDRB     R3,[R0, #+0]
   \   00000220   0x780F             LDRB     R7,[R1, #+0]
   \   00000222   0x405F             EORS     R7,R7,R3
   \   00000224   0x7007             STRB     R7,[R0, #+0]
   \   00000226   0x7843             LDRB     R3,[R0, #+1]
   \   00000228   0x784F             LDRB     R7,[R1, #+1]
   \   0000022A   0x405F             EORS     R7,R7,R3
   \   0000022C   0x7047             STRB     R7,[R0, #+1]
   \   0000022E   0x7883             LDRB     R3,[R0, #+2]
   \   00000230   0x788F             LDRB     R7,[R1, #+2]
   \   00000232   0x405F             EORS     R7,R7,R3
   \   00000234   0x7087             STRB     R7,[R0, #+2]
   \   00000236   0x78C3             LDRB     R3,[R0, #+3]
   \   00000238   0x78CF             LDRB     R7,[R1, #+3]
   \   0000023A   0x405F             EORS     R7,R7,R3
   \   0000023C   0x70C7             STRB     R7,[R0, #+3]
   \   0000023E   0x1D09             ADDS     R1,R1,#+4
   \   00000240   0x1D00             ADDS     R0,R0,#+4
   \   00000242   0x1E52             SUBS     R2,R2,#+1
   \   00000244   0xD1EB             BNE      ??ccm_auth_crypt_19
   \   00000246   0xA803             ADD      R0,SP,#+12
   \   00000248   0x9000             STR      R0,[SP, #+0]
   \   0000024A   0xAB08             ADD      R3,SP,#+32
   \   0000024C   0x2210             MOVS     R2,#+16
   \   0000024E   0xA908             ADD      R1,SP,#+32
   \   00000250   0x9811             LDR      R0,[SP, #+68]
   \   00000252   0x.... 0x....      BL       mbedtls_cipher_update
   \   00000256   0x2800             CMP      R0,#+0
   \   00000258   0xD000             BEQ      .+4
   \   0000025A   0xE08C             B        ??ccm_auth_crypt_4
    268                  }
    269          
    270                  CTR_CRYPT( dst, src, use_len );
   \                     ??ccm_auth_crypt_18: (+1)
   \   0000025C   0xA803             ADD      R0,SP,#+12
   \   0000025E   0x9000             STR      R0,[SP, #+0]
   \   00000260   0xAB04             ADD      R3,SP,#+16
   \   00000262   0x2210             MOVS     R2,#+16
   \   00000264   0xA90C             ADD      R1,SP,#+48
   \   00000266   0x9811             LDR      R0,[SP, #+68]
   \   00000268   0x.... 0x....      BL       mbedtls_cipher_update
   \   0000026C   0x2800             CMP      R0,#+0
   \   0000026E   0xD000             BEQ      .+4
   \   00000270   0xE081             B        ??ccm_auth_crypt_4
   \   00000272   0xE006             B        ??ccm_auth_crypt_20
   \                     ??ccm_auth_crypt_21: (+1)
   \   00000274   0x5C29             LDRB     R1,[R5, R0]
   \   00000276   0xAA04             ADD      R2,SP,#+16
   \   00000278   0x5C12             LDRB     R2,[R2, R0]
   \   0000027A   0x404A             EORS     R2,R2,R1
   \   0000027C   0x5432             STRB     R2,[R6, R0]
   \   0000027E   0x1C40             ADDS     R0,R0,#+1
   \   00000280   0xB2C0             UXTB     R0,R0
   \                     ??ccm_auth_crypt_20: (+1)
   \   00000282   0x9901             LDR      R1,[SP, #+4]
   \   00000284   0x4288             CMP      R0,R1
   \   00000286   0xD3F5             BCC      ??ccm_auth_crypt_21
    271          
    272                  if( mode == CCM_DECRYPT )
   \   00000288   0x9812             LDR      R0,[SP, #+72]
   \   0000028A   0x2801             CMP      R0,#+1
   \   0000028C   0xD12B             BNE      ??ccm_auth_crypt_22
    273                  {
    274                      memset( b, 0, 16 );
   \   0000028E   0xA804             ADD      R0,SP,#+16
   \   00000290   0x2100             MOVS     R1,#+0
   \   00000292   0x2200             MOVS     R2,#+0
   \   00000294   0x2300             MOVS     R3,#+0
   \   00000296   0x2700             MOVS     R7,#+0
   \   00000298   0xC08E             STM      R0!,{R1-R3,R7}
    275                      memcpy( b, dst, use_len );
   \   0000029A   0x9A01             LDR      R2,[SP, #+4]
   \   0000029C   0x0031             MOVS     R1,R6
   \   0000029E   0xA804             ADD      R0,SP,#+16
   \   000002A0   0x.... 0x....      BL       __aeabi_memcpy
    276                      UPDATE_CBC_MAC;
   \   000002A4   0xA808             ADD      R0,SP,#+32
   \   000002A6   0xA904             ADD      R1,SP,#+16
   \   000002A8   0x2204             MOVS     R2,#+4
   \                     ??ccm_auth_crypt_23: (+1)
   \   000002AA   0x7803             LDRB     R3,[R0, #+0]
   \   000002AC   0x780F             LDRB     R7,[R1, #+0]
   \   000002AE   0x405F             EORS     R7,R7,R3
   \   000002B0   0x7007             STRB     R7,[R0, #+0]
   \   000002B2   0x7843             LDRB     R3,[R0, #+1]
   \   000002B4   0x784F             LDRB     R7,[R1, #+1]
   \   000002B6   0x405F             EORS     R7,R7,R3
   \   000002B8   0x7047             STRB     R7,[R0, #+1]
   \   000002BA   0x7883             LDRB     R3,[R0, #+2]
   \   000002BC   0x788F             LDRB     R7,[R1, #+2]
   \   000002BE   0x405F             EORS     R7,R7,R3
   \   000002C0   0x7087             STRB     R7,[R0, #+2]
   \   000002C2   0x78C3             LDRB     R3,[R0, #+3]
   \   000002C4   0x78CF             LDRB     R7,[R1, #+3]
   \   000002C6   0x405F             EORS     R7,R7,R3
   \   000002C8   0x70C7             STRB     R7,[R0, #+3]
   \   000002CA   0x1D09             ADDS     R1,R1,#+4
   \   000002CC   0x1D00             ADDS     R0,R0,#+4
   \   000002CE   0x1E52             SUBS     R2,R2,#+1
   \   000002D0   0xD1EB             BNE      ??ccm_auth_crypt_23
   \   000002D2   0xA803             ADD      R0,SP,#+12
   \   000002D4   0x9000             STR      R0,[SP, #+0]
   \   000002D6   0xAB08             ADD      R3,SP,#+32
   \   000002D8   0x2210             MOVS     R2,#+16
   \   000002DA   0xA908             ADD      R1,SP,#+32
   \   000002DC   0x9811             LDR      R0,[SP, #+68]
   \   000002DE   0x.... 0x....      BL       mbedtls_cipher_update
   \   000002E2   0x2800             CMP      R0,#+0
   \   000002E4   0xD147             BNE      ??ccm_auth_crypt_4
    277                  }
    278          
    279                  dst += use_len;
   \                     ??ccm_auth_crypt_22: (+1)
   \   000002E6   0x9801             LDR      R0,[SP, #+4]
   \   000002E8   0x1836             ADDS     R6,R6,R0
    280                  src += use_len;
   \   000002EA   0x182D             ADDS     R5,R5,R0
    281                  len_left -= use_len;
   \   000002EC   0x1A24             SUBS     R4,R4,R0
    282          
    283                  /*
    284                   * Increment counter.
    285                   * No need to check for overflow thanks to the length check above.
    286                   */
    287                  for( i = 0; i < q; i++ )
   \   000002EE   0x2000             MOVS     R0,#+0
   \                     ??ccm_auth_crypt_24: (+1)
   \   000002F0   0x9902             LDR      R1,[SP, #+8]
   \   000002F2   0x4288             CMP      R0,R1
   \   000002F4   0xDB00             BLT      .+4
   \   000002F6   0xE778             B        ??ccm_auth_crypt_14
    288                      if( ++ctr[15-i] != 0 )
   \   000002F8   0xA90C             ADD      R1,SP,#+48
   \   000002FA   0x4242             RSBS     R2,R0,#+0
   \   000002FC   0x1889             ADDS     R1,R1,R2
   \   000002FE   0x7BCA             LDRB     R2,[R1, #+15]
   \   00000300   0x1C52             ADDS     R2,R2,#+1
   \   00000302   0x73CA             STRB     R2,[R1, #+15]
   \   00000304   0x0612             LSLS     R2,R2,#+24
   \   00000306   0xD000             BEQ      .+4
   \   00000308   0xE76F             B        ??ccm_auth_crypt_14
   \   0000030A   0x1C40             ADDS     R0,R0,#+1
   \   0000030C   0xE7F0             B        ??ccm_auth_crypt_24
    289                          break;
    290              }
    291          
    292              /*
    293               * Authentication: reset counter and crypt/mask internal tag
    294               */
    295              for( i = 0; i < q; i++ )
   \                     ??ccm_auth_crypt_15: (+1)
   \   0000030E   0x2000             MOVS     R0,#+0
   \   00000310   0x9902             LDR      R1,[SP, #+8]
   \   00000312   0x2901             CMP      R1,#+1
   \   00000314   0xDB08             BLT      ??ccm_auth_crypt_25
    296                  ctr[15-i] = 0;
   \                     ??ccm_auth_crypt_26: (+1)
   \   00000316   0x2100             MOVS     R1,#+0
   \   00000318   0xAA0C             ADD      R2,SP,#+48
   \   0000031A   0x4243             RSBS     R3,R0,#+0
   \   0000031C   0x18D2             ADDS     R2,R2,R3
   \   0000031E   0x73D1             STRB     R1,[R2, #+15]
   \   00000320   0x1C40             ADDS     R0,R0,#+1
   \   00000322   0x9902             LDR      R1,[SP, #+8]
   \   00000324   0x4288             CMP      R0,R1
   \   00000326   0xDBF6             BLT      ??ccm_auth_crypt_26
    297          
    298              CTR_CRYPT( y, y, 16 );
   \                     ??ccm_auth_crypt_25: (+1)
   \   00000328   0xA803             ADD      R0,SP,#+12
   \   0000032A   0x9000             STR      R0,[SP, #+0]
   \   0000032C   0xAB04             ADD      R3,SP,#+16
   \   0000032E   0x2210             MOVS     R2,#+16
   \   00000330   0xA90C             ADD      R1,SP,#+48
   \   00000332   0x9811             LDR      R0,[SP, #+68]
   \   00000334   0x.... 0x....      BL       mbedtls_cipher_update
   \   00000338   0x2800             CMP      R0,#+0
   \   0000033A   0xD11C             BNE      ??ccm_auth_crypt_4
   \   0000033C   0xA808             ADD      R0,SP,#+32
   \   0000033E   0xA904             ADD      R1,SP,#+16
   \   00000340   0x2204             MOVS     R2,#+4
   \                     ??ccm_auth_crypt_27: (+1)
   \   00000342   0x7803             LDRB     R3,[R0, #+0]
   \   00000344   0x780C             LDRB     R4,[R1, #+0]
   \   00000346   0x405C             EORS     R4,R4,R3
   \   00000348   0x7004             STRB     R4,[R0, #+0]
   \   0000034A   0x7843             LDRB     R3,[R0, #+1]
   \   0000034C   0x784C             LDRB     R4,[R1, #+1]
   \   0000034E   0x405C             EORS     R4,R4,R3
   \   00000350   0x7044             STRB     R4,[R0, #+1]
   \   00000352   0x7883             LDRB     R3,[R0, #+2]
   \   00000354   0x788C             LDRB     R4,[R1, #+2]
   \   00000356   0x405C             EORS     R4,R4,R3
   \   00000358   0x7084             STRB     R4,[R0, #+2]
   \   0000035A   0x78C3             LDRB     R3,[R0, #+3]
   \   0000035C   0x78CC             LDRB     R4,[R1, #+3]
   \   0000035E   0x405C             EORS     R4,R4,R3
   \   00000360   0x70C4             STRB     R4,[R0, #+3]
   \   00000362   0x1D09             ADDS     R1,R1,#+4
   \   00000364   0x1D00             ADDS     R0,R0,#+4
   \   00000366   0x1E52             SUBS     R2,R2,#+1
   \   00000368   0xD1EB             BNE      ??ccm_auth_crypt_27
    299              memcpy( tag, y, tag_len );
   \   0000036A   0x9A20             LDR      R2,[SP, #+128]
   \   0000036C   0xA908             ADD      R1,SP,#+32
   \   0000036E   0x981F             LDR      R0,[SP, #+124]
   \   00000370   0x.... 0x....      BL       __aeabi_memcpy
    300          
    301              return( 0 );
   \   00000374   0x2000             MOVS     R0,#+0
   \                     ??ccm_auth_crypt_4: (+1)
   \   00000376   0xB015             ADD      SP,SP,#+84
   \   00000378   0xBDF0             POP      {R4-R7,PC}       ;; return
    302          }
    303          
    304          /*
    305           * Authenticated encryption
    306           */

   \                                 In section .text, align 2, keep-with-next
    307          int mbedtls_ccm_encrypt_and_tag( mbedtls_ccm_context *ctx, size_t length,
    308                                   const unsigned char *iv, size_t iv_len,
    309                                   const unsigned char *add, size_t add_len,
    310                                   const unsigned char *input, unsigned char *output,
    311                                   unsigned char *tag, size_t tag_len )
    312          {
   \                     mbedtls_ccm_encrypt_and_tag: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
    313              return( ccm_auth_crypt( ctx, CCM_ENCRYPT, length, iv, iv_len,
    314                                      add, add_len, input, output, tag, tag_len ) );
   \   00000004   0x9C0F             LDR      R4,[SP, #+60]
   \   00000006   0x9406             STR      R4,[SP, #+24]
   \   00000008   0x9C0E             LDR      R4,[SP, #+56]
   \   0000000A   0x9405             STR      R4,[SP, #+20]
   \   0000000C   0x9C0D             LDR      R4,[SP, #+52]
   \   0000000E   0x9404             STR      R4,[SP, #+16]
   \   00000010   0x9C0C             LDR      R4,[SP, #+48]
   \   00000012   0x9403             STR      R4,[SP, #+12]
   \   00000014   0x9C0B             LDR      R4,[SP, #+44]
   \   00000016   0x9402             STR      R4,[SP, #+8]
   \   00000018   0x9C0A             LDR      R4,[SP, #+40]
   \   0000001A   0x9401             STR      R4,[SP, #+4]
   \   0000001C   0x9300             STR      R3,[SP, #+0]
   \   0000001E   0x0013             MOVS     R3,R2
   \   00000020   0x000A             MOVS     R2,R1
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x.... 0x....      BL       ccm_auth_crypt
   \   00000028   0xB008             ADD      SP,SP,#+32
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    315          }
    316          
    317          /*
    318           * Authenticated decryption
    319           */

   \                                 In section .text, align 2, keep-with-next
    320          int mbedtls_ccm_auth_decrypt( mbedtls_ccm_context *ctx, size_t length,
    321                                const unsigned char *iv, size_t iv_len,
    322                                const unsigned char *add, size_t add_len,
    323                                const unsigned char *input, unsigned char *output,
    324                                const unsigned char *tag, size_t tag_len )
    325          {
   \                     mbedtls_ccm_auth_decrypt: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x9E13             LDR      R6,[SP, #+76]
   \   00000008   0x9D15             LDR      R5,[SP, #+84]
    326              int ret;
    327              unsigned char check_tag[16];
    328              unsigned char i;
    329              int diff;
    330          
    331              if( ( ret = ccm_auth_crypt( ctx, CCM_DECRYPT, length,
    332                                          iv, iv_len, add, add_len,
    333                                          input, output, check_tag, tag_len ) ) != 0 )
   \   0000000A   0x9506             STR      R5,[SP, #+24]
   \   0000000C   0xA907             ADD      R1,SP,#+28
   \   0000000E   0x9105             STR      R1,[SP, #+20]
   \   00000010   0x9604             STR      R6,[SP, #+16]
   \   00000012   0x9912             LDR      R1,[SP, #+72]
   \   00000014   0x9103             STR      R1,[SP, #+12]
   \   00000016   0x9911             LDR      R1,[SP, #+68]
   \   00000018   0x9102             STR      R1,[SP, #+8]
   \   0000001A   0x9910             LDR      R1,[SP, #+64]
   \   0000001C   0x9101             STR      R1,[SP, #+4]
   \   0000001E   0x9300             STR      R3,[SP, #+0]
   \   00000020   0x0013             MOVS     R3,R2
   \   00000022   0x0022             MOVS     R2,R4
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x.... 0x....      BL       ccm_auth_crypt
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD11B             BNE      ??mbedtls_ccm_auth_decrypt_0
    334              {
    335                  return( ret );
    336              }
    337          
    338              /* Check tag in "constant-time" */
    339              for( diff = 0, i = 0; i < tag_len; i++ )
   \   0000002E   0x2700             MOVS     R7,#+0
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xAA07             ADD      R2,SP,#+28
   \   00000034   0x9B14             LDR      R3,[SP, #+80]
   \   00000036   0xE008             B        ??mbedtls_ccm_auth_decrypt_1
    340                  diff |= tag[i] ^ check_tag[i];
   \                     ??mbedtls_ccm_auth_decrypt_2: (+1)
   \   00000038   0x46BC             MOV      R12,R7
   \   0000003A   0x5C5F             LDRB     R7,[R3, R1]
   \   0000003C   0x5C50             LDRB     R0,[R2, R1]
   \   0000003E   0x4078             EORS     R0,R0,R7
   \   00000040   0x4667             MOV      R7,R12
   \   00000042   0x4338             ORRS     R0,R0,R7
   \   00000044   0x0007             MOVS     R7,R0
   \   00000046   0x1C49             ADDS     R1,R1,#+1
   \   00000048   0xB2C9             UXTB     R1,R1
   \                     ??mbedtls_ccm_auth_decrypt_1: (+1)
   \   0000004A   0x42A9             CMP      R1,R5
   \   0000004C   0xD3F4             BCC      ??mbedtls_ccm_auth_decrypt_2
    341          
    342              if( diff != 0 )
   \   0000004E   0x2F00             CMP      R7,#+0
   \   00000050   0xD008             BEQ      ??mbedtls_ccm_auth_decrypt_3
    343              {
    344                  mbedtls_zeroize( output, length );
   \   00000052   0x2C00             CMP      R4,#+0
   \   00000054   0xD003             BEQ      ??mbedtls_ccm_auth_decrypt_4
   \   00000056   0x0021             MOVS     R1,R4
   \   00000058   0x0030             MOVS     R0,R6
   \   0000005A   0x.... 0x....      BL       __aeabi_memclr
    345                  return( MBEDTLS_ERR_CCM_AUTH_FAILED );
   \                     ??mbedtls_ccm_auth_decrypt_4: (+1)
   \   0000005E   0x200E             MOVS     R0,#+14
   \   00000060   0x43C0             MVNS     R0,R0            ;; #-15
   \   00000062   0xE000             B        ??mbedtls_ccm_auth_decrypt_0
    346              }
    347          
    348              return( 0 );
   \                     ??mbedtls_ccm_auth_decrypt_3: (+1)
   \   00000064   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ccm_auth_decrypt_0: (+1)
   \   00000066   0xB00B             ADD      SP,SP,#+44
   \   00000068   0xBDF0             POP      {R4-R7,PC}       ;; return
    349          }
    350          
    351          
    352          #if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)
    353          /*
    354           * Examples 1 to 3 from SP800-38C Appendix C
    355           */
    356          
    357          #define NB_TESTS 3
    358          
    359          /*
    360           * The data is the same for all tests, only the used length changes
    361           */

   \                                 In section .text, align 4, keep-with-next
    362          static const unsigned char key[] = {
   \                     key:
   \   00000000   0x40 0x41          DC8 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79
   \              0x42 0x43    
   \              0x44 0x45    
   \              0x46 0x47    
   \              0x48 0x49    
   \              0x4A 0x4B    
   \              0x4C 0x4D    
   \              0x4E 0x4F    
    363              0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
    364              0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f
    365          };
    366          

   \                                 In section .text, align 4, keep-with-next
    367          static const unsigned char iv[] = {
   \                     iv:
   \   00000000   0x10 0x11          DC8 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27
   \              0x12 0x13    
   \              0x14 0x15    
   \              0x16 0x17    
   \              0x18 0x19    
   \              0x1A 0x1B    
    368              0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    369              0x18, 0x19, 0x1a, 0x1b
    370          };
    371          

   \                                 In section .text, align 4, keep-with-next
    372          static const unsigned char ad[] = {
   \                     ad:
   \   00000000   0x00 0x01          DC8 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18
   \              0x02 0x03    
   \              0x04 0x05    
   \              0x06 0x07    
   \              0x08 0x09    
   \              0x0A 0x0B    
   \              0x0C 0x0D    
   \              0x0E 0x0F    
   \              0x10 0x11    
   \              0x12         
   \   00000013   0x13               DC8 19
    373              0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    374              0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    375              0x10, 0x11, 0x12, 0x13
    376          };
    377          

   \                                 In section .text, align 4, keep-with-next
    378          static const unsigned char msg[] = {
   \                     msg:
   \   00000000   0x20 0x21          DC8 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48
   \              0x22 0x23    
   \              0x24 0x25    
   \              0x26 0x27    
   \              0x28 0x29    
   \              0x2A 0x2B    
   \              0x2C 0x2D    
   \              0x2E 0x2F    
   \              0x30         
   \   00000011   0x31 0x32          DC8 49, 50, 51, 52, 53, 54, 55
   \              0x33 0x34    
   \              0x35 0x36    
   \              0x37         
    379              0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    380              0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
    381              0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    382          };
    383          

   \                                 In section .text, align 4, keep-with-next
    384          static const size_t iv_len [NB_TESTS] = { 7, 8,  12 };
   \                     iv_len:
   \   00000000   0x00000007         DC32 7, 8, 12
   \              0x00000008   
   \              0x0000000C   

   \                                 In section .text, align 4, keep-with-next
    385          static const size_t add_len[NB_TESTS] = { 8, 16, 20 };
   \                     add_len:
   \   00000000   0x00000008         DC32 8, 16, 20
   \              0x00000010   
   \              0x00000014   

   \                                 In section .text, align 4, keep-with-next
    386          static const size_t msg_len[NB_TESTS] = { 4, 16, 24 };
   \                     msg_len:
   \   00000000   0x00000004         DC32 4, 16, 24
   \              0x00000010   
   \              0x00000018   

   \                                 In section .text, align 4, keep-with-next
    387          static const size_t tag_len[NB_TESTS] = { 4, 6,  8  };
   \                     tag_len:
   \   00000000   0x00000004         DC32 4, 6, 8
   \              0x00000006   
   \              0x00000008   
    388          

   \                                 In section .text, align 4, keep-with-next
    389          static const unsigned char res[NB_TESTS][32] = {
   \                     res:
   \   00000000   0x71 0x62          DC8 113, 98, 1, 91, 77, 172, 37, 93, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x01 0x5B    
   \              0x4D 0xAC    
   \              0x25 0x5D    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000014   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 210, 161, 240, 224, 81, 234, 95
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0xD2 0xA1    
   \              0xF0 0xE0    
   \              0x51 0xEA    
   \              0x5F         
   \   00000027   0x62 0x08          DC8 98, 8, 26, 119, 146, 7, 61, 89, 61, 31, 198, 79, 191, 172, 205, 0
   \              0x1A 0x77    
   \              0x92 0x07    
   \              0x3D 0x59    
   \              0x3D 0x1F    
   \              0xC6 0x4F    
   \              0xBF 0xAC    
   \              0xCD 0x00    
   \   00000037   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 178, 1, 169, 245, 183, 26, 122, 155
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0xE3    
   \              0xB2 0x01    
   \              0xA9 0xF5    
   \              0xB7 0x1A    
   \              0x7A 0x9B    
   \   00000049   0x1C 0xEA          DC8 28, 234, 236, 205, 151, 231, 11, 97, 118, 170, 217, 164, 66, 138
   \              0xEC 0xCD    
   \              0x97 0xE7    
   \              0x0B 0x61    
   \              0x76 0xAA    
   \              0xD9 0xA4    
   \              0x42 0x8A    
   \   00000057   0xA5 0x48          DC8 165, 72, 67, 146, 251, 193, 176, 153, 81
   \              0x43 0x92    
   \              0xFB 0xC1    
   \              0xB0 0x99    
   \              0x51         
    390              {   0x71, 0x62, 0x01, 0x5b, 0x4d, 0xac, 0x25, 0x5d },
    391              {   0xd2, 0xa1, 0xf0, 0xe0, 0x51, 0xea, 0x5f, 0x62,
    392                  0x08, 0x1a, 0x77, 0x92, 0x07, 0x3d, 0x59, 0x3d,
    393                  0x1f, 0xc6, 0x4f, 0xbf, 0xac, 0xcd },
    394              {   0xe3, 0xb2, 0x01, 0xa9, 0xf5, 0xb7, 0x1a, 0x7a,
    395                  0x9b, 0x1c, 0xea, 0xec, 0xcd, 0x97, 0xe7, 0x0b,
    396                  0x61, 0x76, 0xaa, 0xd9, 0xa4, 0x42, 0x8a, 0xa5,
    397                  0x48, 0x43, 0x92, 0xfb, 0xc1, 0xb0, 0x99, 0x51 }
    398          };
    399          

   \                                 In section .text, align 4, keep-with-next
    400          int mbedtls_ccm_self_test( int verbose )
    401          {
   \                     mbedtls_ccm_self_test: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0A3             SUB      SP,SP,#+140
   \   00000004   0x0004             MOVS     R4,R0
    402              mbedtls_ccm_context ctx;
    403              unsigned char out[32];
    404              size_t i;
    405              int ret;
    406          
    407              mbedtls_ccm_init( &ctx );
   \   00000006   0x2140             MOVS     R1,#+64
   \   00000008   0xA813             ADD      R0,SP,#+76
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
    408          
    409              if( mbedtls_ccm_setkey( &ctx, MBEDTLS_CIPHER_ID_AES, key, 8 * sizeof key ) != 0 )
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2180             MOVS     R1,#+128
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0x.... 0x....      BL       mbedtls_cipher_info_from_values
   \   00000018   0x0005             MOVS     R5,R0
   \   0000001A   0xD013             BEQ      ??mbedtls_ccm_self_test_0
   \   0000001C   0x6968             LDR      R0,[R5, #+20]
   \   0000001E   0x2810             CMP      R0,#+16
   \   00000020   0xD110             BNE      ??mbedtls_ccm_self_test_0
   \   00000022   0xA813             ADD      R0,SP,#+76
   \   00000024   0x.... 0x....      BL       mbedtls_cipher_free
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0xA813             ADD      R0,SP,#+76
   \   0000002C   0x.... 0x....      BL       mbedtls_cipher_setup
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD107             BNE      ??mbedtls_ccm_self_test_0
   \   00000034   0x2301             MOVS     R3,#+1
   \   00000036   0x2280             MOVS     R2,#+128
   \   00000038   0x....             ADR.N    R1,key
   \   0000003A   0xA813             ADD      R0,SP,#+76
   \   0000003C   0x.... 0x....      BL       mbedtls_cipher_setkey
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD003             BEQ      ??mbedtls_ccm_self_test_1
    410              {
    411                  if( verbose != 0 )
   \                     ??mbedtls_ccm_self_test_0: (+1)
   \   00000044   0x2C00             CMP      R4,#+0
   \   00000046   0xD062             BEQ      ??mbedtls_ccm_self_test_2
    412                      mbedtls_printf( "  CCM: setup failed" );
   \   00000048   0x....             ADR.N    R0,?_0
   \   0000004A   0xE05E             B        ??mbedtls_ccm_self_test_3
    413          
    414                  return( 1 );
    415              }
    416          
    417              for( i = 0; i < NB_TESTS; i++ )
   \                     ??mbedtls_ccm_self_test_1: (+1)
   \   0000004C   0x2500             MOVS     R5,#+0
   \   0000004E   0xBF00             Nop      
   \   00000050   0x....             ADR.N    R0,tag_len
   \   00000052   0x9009             STR      R0,[SP, #+36]
   \   00000054   0x....             ADR.N    R6,msg_len
   \   00000056   0xBF00             Nop      
   \   00000058   0x....             ADR.N    R0,add_len
   \   0000005A   0x9008             STR      R0,[SP, #+32]
   \   0000005C   0x....             ADR.N    R7,iv_len
   \   0000005E   0xBF00             Nop      
   \   00000060   0x....             ADR.N    R0,res
   \   00000062   0x9007             STR      R0,[SP, #+28]
    418              {
    419                  if( verbose != 0 )
   \                     ??mbedtls_ccm_self_test_4: (+1)
   \   00000064   0x2C00             CMP      R4,#+0
   \   00000066   0xD004             BEQ      ??mbedtls_ccm_self_test_5
    420                      mbedtls_printf( "  CCM-AES #%u: ", (unsigned int) i + 1 );
   \   00000068   0x1C69             ADDS     R1,R5,#+1
   \   0000006A   0xBF00             Nop      
   \   0000006C   0x....             ADR.N    R0,?_1
   \   0000006E   0x.... 0x....      BL       printf
    421          
    422                  ret = mbedtls_ccm_encrypt_and_tag( &ctx, msg_len[i],
    423                                             iv, iv_len[i], ad, add_len[i],
    424                                             msg, out,
    425                                             out + msg_len[i], tag_len[i] );
    426          
    427                  if( ret != 0 ||
    428                      memcmp( out, res[i], msg_len[i] + tag_len[i] ) != 0 )
   \                     ??mbedtls_ccm_self_test_5: (+1)
   \   00000072   0x6832             LDR      R2,[R6, #+0]
   \   00000074   0x9809             LDR      R0,[SP, #+36]
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x9006             STR      R0,[SP, #+24]
   \   0000007A   0xA80B             ADD      R0,SP,#+44
   \   0000007C   0x1880             ADDS     R0,R0,R2
   \   0000007E   0x9005             STR      R0,[SP, #+20]
   \   00000080   0xA80B             ADD      R0,SP,#+44
   \   00000082   0x9004             STR      R0,[SP, #+16]
   \   00000084   0x....             ADR.N    R0,msg
   \   00000086   0x9003             STR      R0,[SP, #+12]
   \   00000088   0x9808             LDR      R0,[SP, #+32]
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x9002             STR      R0,[SP, #+8]
   \   0000008E   0xBF00             Nop      
   \   00000090   0x....             ADR.N    R0,ad
   \   00000092   0x9001             STR      R0,[SP, #+4]
   \   00000094   0x6838             LDR      R0,[R7, #+0]
   \   00000096   0x9000             STR      R0,[SP, #+0]
   \   00000098   0x....             ADR.N    R3,iv
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0xA813             ADD      R0,SP,#+76
   \   0000009E   0x.... 0x....      BL       ccm_auth_crypt
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD12E             BNE      ??mbedtls_ccm_self_test_6
   \   000000A6   0x9809             LDR      R0,[SP, #+36]
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x900A             STR      R0,[SP, #+40]
   \   000000AC   0x6830             LDR      R0,[R6, #+0]
   \   000000AE   0x9006             STR      R0,[SP, #+24]
   \   000000B0   0x990A             LDR      R1,[SP, #+40]
   \   000000B2   0x1842             ADDS     R2,R0,R1
   \   000000B4   0x9907             LDR      R1,[SP, #+28]
   \   000000B6   0xA80B             ADD      R0,SP,#+44
   \   000000B8   0x.... 0x....      BL       memcmp
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD121             BNE      ??mbedtls_ccm_self_test_6
    429                  {
    430                      if( verbose != 0 )
    431                          mbedtls_printf( "failed\n" );
    432          
    433                      return( 1 );
    434                  }
    435          
    436                  ret = mbedtls_ccm_auth_decrypt( &ctx, msg_len[i],
    437                                          iv, iv_len[i], ad, add_len[i],
    438                                          res[i], out,
    439                                          res[i] + msg_len[i], tag_len[i] );
    440          
    441                  if( ret != 0 ||
    442                      memcmp( out, msg, msg_len[i] ) != 0 )
   \   000000C0   0x980A             LDR      R0,[SP, #+40]
   \   000000C2   0x9005             STR      R0,[SP, #+20]
   \   000000C4   0x....             ADR.N    R0,res
   \   000000C6   0x0169             LSLS     R1,R5,#+5
   \   000000C8   0x1840             ADDS     R0,R0,R1
   \   000000CA   0x9906             LDR      R1,[SP, #+24]
   \   000000CC   0x1840             ADDS     R0,R0,R1
   \   000000CE   0x9004             STR      R0,[SP, #+16]
   \   000000D0   0xA80B             ADD      R0,SP,#+44
   \   000000D2   0x9003             STR      R0,[SP, #+12]
   \   000000D4   0x9807             LDR      R0,[SP, #+28]
   \   000000D6   0x9002             STR      R0,[SP, #+8]
   \   000000D8   0x9808             LDR      R0,[SP, #+32]
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0x9001             STR      R0,[SP, #+4]
   \   000000DE   0xBF00             Nop      
   \   000000E0   0x....             ADR.N    R0,ad
   \   000000E2   0x9000             STR      R0,[SP, #+0]
   \   000000E4   0x683B             LDR      R3,[R7, #+0]
   \   000000E6   0xBF00             Nop      
   \   000000E8   0x....             ADR.N    R2,iv
   \   000000EA   0x9906             LDR      R1,[SP, #+24]
   \   000000EC   0xA813             ADD      R0,SP,#+76
   \   000000EE   0x.... 0x....      BL       mbedtls_ccm_auth_decrypt
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD106             BNE      ??mbedtls_ccm_self_test_6
   \   000000F6   0x6832             LDR      R2,[R6, #+0]
   \   000000F8   0x....             ADR.N    R1,msg
   \   000000FA   0xA80B             ADD      R0,SP,#+44
   \   000000FC   0x.... 0x....      BL       memcmp
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD006             BEQ      ??mbedtls_ccm_self_test_7
    443                  {
    444                      if( verbose != 0 )
   \                     ??mbedtls_ccm_self_test_6: (+1)
   \   00000104   0x2C00             CMP      R4,#+0
   \   00000106   0xD002             BEQ      ??mbedtls_ccm_self_test_2
    445                          mbedtls_printf( "failed\n" );
   \   00000108   0x....             ADR.N    R0,?_2
   \                     ??mbedtls_ccm_self_test_3: (+1)
   \   0000010A   0x.... 0x....      BL       printf
    446          
    447                      return( 1 );
   \                     ??mbedtls_ccm_self_test_2: (+1)
   \   0000010E   0x2001             MOVS     R0,#+1
   \   00000110   0xE020             B        ??mbedtls_ccm_self_test_8
    448                  }
    449          
    450                  if( verbose != 0 )
   \                     ??mbedtls_ccm_self_test_7: (+1)
   \   00000112   0x2C00             CMP      R4,#+0
   \   00000114   0xD003             BEQ      ??mbedtls_ccm_self_test_9
    451                      mbedtls_printf( "passed\n" );
   \   00000116   0xBF00             Nop      
   \   00000118   0x....             ADR.N    R0,?_3
   \   0000011A   0x.... 0x....      BL       printf
    452              }
   \                     ??mbedtls_ccm_self_test_9: (+1)
   \   0000011E   0x1C6D             ADDS     R5,R5,#+1
   \   00000120   0x9807             LDR      R0,[SP, #+28]
   \   00000122   0x3020             ADDS     R0,R0,#+32
   \   00000124   0x9007             STR      R0,[SP, #+28]
   \   00000126   0x1D3F             ADDS     R7,R7,#+4
   \   00000128   0x9808             LDR      R0,[SP, #+32]
   \   0000012A   0x1D00             ADDS     R0,R0,#+4
   \   0000012C   0x9008             STR      R0,[SP, #+32]
   \   0000012E   0x1D36             ADDS     R6,R6,#+4
   \   00000130   0x9809             LDR      R0,[SP, #+36]
   \   00000132   0x1D00             ADDS     R0,R0,#+4
   \   00000134   0x9009             STR      R0,[SP, #+36]
   \   00000136   0x2D03             CMP      R5,#+3
   \   00000138   0xD394             BCC      ??mbedtls_ccm_self_test_4
    453          
    454              mbedtls_ccm_free( &ctx );
   \   0000013A   0xA813             ADD      R0,SP,#+76
   \   0000013C   0x.... 0x....      BL       mbedtls_cipher_free
   \   00000140   0x2140             MOVS     R1,#+64
   \   00000142   0xA813             ADD      R0,SP,#+76
   \   00000144   0x.... 0x....      BL       __aeabi_memclr4
    455          
    456              if( verbose != 0 )
   \   00000148   0x2C00             CMP      R4,#+0
   \   0000014A   0xD002             BEQ      ??mbedtls_ccm_self_test_10
    457                  mbedtls_printf( "\n" );
   \   0000014C   0x....             ADR      R0,??DataTable15  ;; "\n"
   \   0000014E   0x.... 0x....      BL       printf
    458          
    459              return( 0 );
   \                     ??mbedtls_ccm_self_test_10: (+1)
   \   00000152   0x2000             MOVS     R0,#+0
   \                     ??mbedtls_ccm_self_test_8: (+1)
   \   00000154   0xB023             ADD      SP,SP,#+140
   \   00000156   0xBDF0             POP      {R4-R7,PC}       ;; return
    460          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x0000FF01         DC32     0xff01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x20 0x20          DC8 "  CCM: setup failed"
   \              0x43 0x43    
   \              0x4D 0x3A    
   \              0x20 0x73    
   \              0x65 0x74    
   \              0x75 0x70    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x20 0x20          DC8 "  CCM-AES #%u: "
   \              0x43 0x43    
   \              0x4D 0x2D    
   \              0x41 0x45    
   \              0x53 0x20    
   \              0x23 0x25    
   \              0x75 0x3A    
   \              0x20 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_4:
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x66 0x61          DC8 "failed\012"
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x70 0x61          DC8 "passed\012"
   \              0x73 0x73    
   \              0x65 0x64    
   \              0x0A 0x00    
    461          
    462          #endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */
    463          
    464          #endif /* MBEDTLS_CCM_C */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     104   ccm_auth_crypt
       104   -> __aeabi_memclr
       104   -> __aeabi_memcpy
       104   -> mbedtls_cipher_update
      64   mbedtls_ccm_auth_decrypt
        64   -> __aeabi_memclr
        64   -> ccm_auth_crypt
      40   mbedtls_ccm_encrypt_and_tag
        40   -> ccm_auth_crypt
       8   mbedtls_ccm_free
         8   -> __aeabi_memclr
         8   -> mbedtls_cipher_free
       8   mbedtls_ccm_init
         8   -> __aeabi_memclr4
     160   mbedtls_ccm_self_test
       160   -> __aeabi_memclr4
       160   -> ccm_auth_crypt
       160   -> mbedtls_ccm_auth_decrypt
       160   -> mbedtls_cipher_free
       160   -> mbedtls_cipher_info_from_values
       160   -> mbedtls_cipher_setkey
       160   -> mbedtls_cipher_setup
       160   -> memcmp
       160   -> printf
      24   mbedtls_ccm_setkey
        24   -> mbedtls_cipher_free
        24   -> mbedtls_cipher_info_from_values
        24   -> mbedtls_cipher_setkey
        24   -> mbedtls_cipher_setup


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable15
      20  ?_0
      16  ?_1
       8  ?_2
       8  ?_3
       2  ?_4
      20  ad
      12  add_len
     890  ccm_auth_crypt
      12  iv
      12  iv_len
      16  key
     106  mbedtls_ccm_auth_decrypt
      44  mbedtls_ccm_encrypt_and_tag
      18  mbedtls_ccm_free
      10  mbedtls_ccm_init
     344  mbedtls_ccm_self_test
      66  mbedtls_ccm_setkey
      24  msg
      12  msg_len
      96  res
      12  tag_len

 
     2 bytes in section .rodata
 1 754 bytes in section .text
 
 1 754 bytes of CODE  memory
     2 bytes of CONST memory

Errors: none
Warnings: none

###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:58
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        .\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_i2c.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_i2c.d
#        -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_i2c.s.txt
#        -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_i2c.o
#        .\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_i2c.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_i2c.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_i2c.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    BlueNRG1_i2c.c
      4            * @author  VMA Application Team
      5            * @version V2.0.0
      6            * @date    21-March-2016
      7            * @brief   This file provides all the I2C firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "BlueNRG1_i2c.h"

  typedef uint8_t BOOL;  //already defined in "hal_type.h"
                  ^
"C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\TARGET_STEVAL_IDB007V1\device\system_BlueNRG1.h",240  Warning[Pe301]: typedef name has already been declared (with same type)
     24          
     25          
     26          /** @addtogroup BLUENRG1_Peripheral_Driver BLUENRG1 Peripheral Driver
     27            * @{
     28            */
     29          
     30          /** @addtogroup I2C_Peripheral  I2C Peripheral
     31            * @{
     32            */ 
     33          
     34          /** @defgroup I2C_Private_TypesDefinitions Private Types Definitions
     35            * @{
     36            */
     37          
     38          /**
     39            * @}
     40            */
     41          
     42          /** @defgroup I2C_Private_Defines Private Defines
     43            * @{
     44            */
     45          
     46          /* I2C Standard mode */
     47          #define I2C_CR_SM_STD             (0x0)
     48          
     49          /* I2C Fast mode */
     50          #define I2C_CR_SM_FAST            (0x1)
     51          
     52          #define I2C_CLOCK                 (16000000)
     53          
     54          #define I2C_SLAVE_ADDR_EXT10_SMK  (0x03FF)
     55          
     56          
     57          /**
     58            * @}
     59            */
     60          
     61          /** @defgroup I2C_Private_Macros Private Macros
     62            * @{
     63            */
     64          
     65          /**
     66            * @}
     67            */
     68          
     69          /** @defgroup I2C_Private_Variables Private Variables
     70            * @{
     71            */

   \                                 In section .data, align 4
     72          static __I uint16_t Foncycles[4] = {1, 3, 4, 6};
   \                     Foncycles:
   \   00000000   0x0001 0x0003      DC16 1, 3, 4, 6
   \              0x0004 0x0006
     73          
     74          /**
     75            * @}
     76            */
     77          
     78          /** @defgroup I2C_Private_FunctionPrototypes Private Function Prototypes
     79            * @{
     80            */
     81          
     82          /**
     83            * @}
     84            */
     85          
     86          /** @defgroup I2C_Public_Functions Public Functions
     87            * @{
     88            */
     89          
     90          
     91          /**
     92          * @brief  Deinitializes the I2C peripheral registers to their default reset values.
     93          * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
     94          * @retval None
     95          */

   \                                 In section .text, align 2, keep-with-next
     96          void I2C_DeInit(I2C_Type* I2Cx)
     97          {
     98            /* Check the parameters */
     99            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    100          
    101            /* Generate a stop condition */
    102            I2Cx->CR_b.FS_1 = SET;
   \                     I2C_DeInit: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x2280             MOVS     R2,#+128
   \   00000004   0x0212             LSLS     R2,R2,#+8        ;; #+32768
   \   00000006   0x430A             ORRS     R2,R2,R1
   \   00000008   0x6002             STR      R2,[R0, #+0]
    103          
    104            /* Disable the selected I2C peripheral / software reset */
    105            I2Cx->CR_b.PE = RESET;
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x4391             BICS     R1,R1,R2
   \   00000010   0x6001             STR      R1,[R0, #+0]
    106          }
   \   00000012   0x4770             BX       LR               ;; return
    107          
    108          
    109          /**
    110            * @brief  Initializes the I2Cx peripheral according to the specified 
    111            *         parameters in the I2C_InitStruct.
    112            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    113            * @param  I2C_InitStruct: pointer to a @ref I2C_InitType structure that
    114            *         contains the configuration information for the specified I2C peripheral.
    115          * @retval   None
    116            */

   \                                 In section .text, align 2, keep-with-next
    117          void I2C_Init(I2C_Type* I2Cx, I2C_InitType* I2C_InitStruct)
    118          {
   \                     I2C_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    119            uint16_t foncycle;
    120            uint32_t brcnt;
    121          
    122            /* Check the parameters */
    123            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    124            assert_param(IS_I2C_CLOCK_SPEED_I2C(I2C_InitStruct->I2C_ClockSpeed));
    125            assert_param(IS_I2C_OPERATING_MODE(I2C_InitStruct->I2C_OperatingMode));
    126            assert_param(IS_I2C_FILTERING(I2C_InitStruct->I2C_Filtering));
    127            assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
    128            assert_param(IS_FUNCTIONAL_STATE(I2C_InitStruct->I2C_ExtendAddress));
    129            
    130            /* Disable the selected I2C peripheral / software reset */
    131            I2Cx->CR_b.PE = RESET;
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x4388             BICS     R0,R0,R1
   \   0000000C   0x6020             STR      R0,[R4, #+0]
    132          
    133            /* Select the digital filtering */
    134            I2Cx->CR_b.FON = I2C_InitStruct->I2C_Filtering;
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x....             LDR      R1,??DataTable4  ;; 0xffff9fff
   \   00000012   0x4001             ANDS     R1,R1,R0
   \   00000014   0x7968             LDRB     R0,[R5, #+5]
   \   00000016   0x0340             LSLS     R0,R0,#+13
   \   00000018   0x22C0             MOVS     R2,#+192
   \   0000001A   0x01D2             LSLS     R2,R2,#+7        ;; #+24576
   \   0000001C   0x4002             ANDS     R2,R2,R0
   \   0000001E   0x430A             ORRS     R2,R2,R1
   \   00000020   0x6022             STR      R2,[R4, #+0]
    135          
    136            /* Clock rate computation */
    137            foncycle = Foncycles[I2C_InitStruct->I2C_Filtering];
    138            brcnt = I2C_CLOCK - I2C_InitStruct->I2C_ClockSpeed * foncycle;
   \   00000022   0x6829             LDR      R1,[R5, #+0]
   \   00000024   0x....             LDR      R0,??DataTable4_1  ;; 0xf42400
   \   00000026   0x....             LDR      R2,??DataTable4_2
   \   00000028   0x796B             LDRB     R3,[R5, #+5]
   \   0000002A   0x005B             LSLS     R3,R3,#+1
   \   0000002C   0x5AD2             LDRH     R2,[R2, R3]
   \   0000002E   0x434A             MULS     R2,R1,R2
   \   00000030   0x1A80             SUBS     R0,R0,R2
    139          
    140            /* Configure speed in standard mode */
    141            if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
   \   00000032   0x....             LDR      R2,??DataTable4_3  ;; 0x186a1
   \   00000034   0x4291             CMP      R1,R2
   \   00000036   0xD20A             BCS      ??I2C_Init_0
    142            { 
    143              brcnt /= (I2C_InitStruct->I2C_ClockSpeed << 1);
   \   00000038   0x0049             LSLS     R1,R1,#+1
   \   0000003A   0x.... 0x....      BL       __aeabi_uidiv
    144              
    145              I2Cx->CR_b.SM = I2C_CR_SM_STD;
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x2230             MOVS     R2,#+48
   \   00000042   0x4391             BICS     R1,R1,R2
   \   00000044   0x6021             STR      R1,[R4, #+0]
    146              
    147              /* @16MHz 0x0003=>250ns */
    148              I2Cx->SCR_b.SLSU = 0x003;
   \   00000046   0x6861             LDR      R1,[R4, #+4]
   \   00000048   0xB289             UXTH     R1,R1
   \   0000004A   0x0312             LSLS     R2,R2,#+12
   \   0000004C   0xE010             B        ??I2C_Init_1
    149            }
    150            /* Configure speed in fast mode */
    151            else if (I2C_InitStruct->I2C_ClockSpeed <= 400000)
   \                     ??I2C_Init_0: (+1)
   \   0000004E   0x....             LDR      R2,??DataTable4_4  ;; 0x61a81
   \   00000050   0x4291             CMP      R1,R2
   \   00000052   0xD20F             BCS      ??I2C_Init_2
    152            {
    153              brcnt /= (I2C_InitStruct->I2C_ClockSpeed * 3);
   \   00000054   0x004A             LSLS     R2,R1,#+1
   \   00000056   0x1851             ADDS     R1,R2,R1
   \   00000058   0x.... 0x....      BL       __aeabi_uidiv
    154              
    155              I2Cx->CR_b.SM = I2C_CR_SM_FAST;
   \   0000005C   0x6821             LDR      R1,[R4, #+0]
   \   0000005E   0x2230             MOVS     R2,#+48
   \   00000060   0x4391             BICS     R1,R1,R2
   \   00000062   0x2210             MOVS     R2,#+16
   \   00000064   0x430A             ORRS     R2,R2,R1
   \   00000066   0x6022             STR      R2,[R4, #+0]
    156              
    157              /* @16MHz 0x0002=>125ns */
    158              I2Cx->SCR_b.SLSU = 0x0002;
   \   00000068   0x6861             LDR      R1,[R4, #+4]
   \   0000006A   0xB289             UXTH     R1,R1
   \   0000006C   0x2280             MOVS     R2,#+128
   \   0000006E   0x0292             LSLS     R2,R2,#+10       ;; #+131072
   \                     ??I2C_Init_1: (+1)
   \   00000070   0x430A             ORRS     R2,R2,R1
   \   00000072   0x6062             STR      R2,[R4, #+4]
    159            }
    160          
    161            /* Set I2C own address */
    162            MODIFY_REG(I2Cx->SCR, I2C_SLAVE_ADDR_EXT10_SMK, I2C_InitStruct->I2C_OwnAddress1);
   \                     ??I2C_Init_2: (+1)
   \   00000074   0x6861             LDR      R1,[R4, #+4]
   \   00000076   0x0A89             LSRS     R1,R1,#+10
   \   00000078   0x0289             LSLS     R1,R1,#+10
   \   0000007A   0x88EA             LDRH     R2,[R5, #+6]
   \   0000007C   0x4311             ORRS     R1,R1,R2
   \   0000007E   0x6061             STR      R1,[R4, #+4]
    163          
    164            /* Configure the baud rate */
    165            I2Cx->BRCR_b.BRCNT = (uint16_t)brcnt;
   \   00000080   0x8520             STRH     R0,[R4, #+40]
    166          
    167            /* Configure the operating mode */
    168            I2Cx->CR_b.OM = I2C_InitStruct->I2C_OperatingMode;
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x2106             MOVS     R1,#+6
   \   00000086   0x4388             BICS     R0,R0,R1
   \   00000088   0x7929             LDRB     R1,[R5, #+4]
   \   0000008A   0x0049             LSLS     R1,R1,#+1
   \   0000008C   0x2206             MOVS     R2,#+6
   \   0000008E   0x400A             ANDS     R2,R2,R1
   \   00000090   0x4302             ORRS     R2,R2,R0
   \   00000092   0x6022             STR      R2,[R4, #+0]
    169            
    170            if(I2C_InitStruct->I2C_ExtendAddress == ENABLE) {
   \   00000094   0x7A28             LDRB     R0,[R5, #+8]
   \   00000096   0x2801             CMP      R0,#+1
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0xD103             BNE      ??I2C_Init_3
    171              I2Cx->CR_b.SAM = SET;
   \   0000009C   0x2108             MOVS     R1,#+8
   \   0000009E   0x4301             ORRS     R1,R1,R0
   \   000000A0   0x6021             STR      R1,[R4, #+0]
   \   000000A2   0xE002             B        ??I2C_Init_4
    172            }
    173            else {
    174              I2Cx->CR_b.SAM = RESET;
   \                     ??I2C_Init_3: (+1)
   \   000000A4   0x2108             MOVS     R1,#+8
   \   000000A6   0x4388             BICS     R0,R0,R1
   \   000000A8   0x6020             STR      R0,[R4, #+0]
    175            }
    176            
    177            /* Enable the selected I2C peripheral */
    178            I2Cx->CR_b.PE = SET;
   \                     ??I2C_Init_4: (+1)
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x2101             MOVS     R1,#+1
   \   000000AE   0x4301             ORRS     R1,R1,R0
   \   000000B0   0x6021             STR      R1,[R4, #+0]
    179          }
   \   000000B2   0xBD30             POP      {R4,R5,PC}       ;; return
    180          
    181          
    182          /**
    183            * @brief  Fills the I2C_InitStruct with default values.
    184            * @param  I2C_InitStruct: pointer to an @ref I2C_InitType structure which will be initialized.
    185            * @retval None
    186            */

   \                                 In section .text, align 2, keep-with-next
    187          void I2C_StructInit(I2C_InitType* I2C_InitStruct)
    188          {
    189            /*---------------- Reset I2C init structure parameters values ----------------*/
    190            /* initialize the I2C_ClockSpeed member */
    191            I2C_InitStruct->I2C_ClockSpeed = 5000;
   \                     I2C_StructInit: (+1)
   \   00000000   0x....             LDR      R1,??DataTable4_5  ;; 0x1388
   \   00000002   0x6001             STR      R1,[R0, #+0]
    192          
    193            /* initialize the I2C_OperatingMode member */
    194            I2C_InitStruct->I2C_OperatingMode = I2C_OperatingMode_Slave;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7101             STRB     R1,[R0, #+4]
    195          
    196            /* initialize the I2C_Filtering member */
    197            I2C_InitStruct->I2C_Filtering = I2C_Filtering_Off;
   \   00000008   0x7141             STRB     R1,[R0, #+5]
    198          
    199            /* Initialize the I2C_OwnAddress1 member */
    200            I2C_InitStruct->I2C_OwnAddress1 = 0;
   \   0000000A   0x80C1             STRH     R1,[R0, #+6]
    201          
    202            /* Initialize the I2C_AddressingMode member */
    203            I2C_InitStruct->I2C_ExtendAddress = DISABLE;
   \   0000000C   0x7201             STRB     R1,[R0, #+8]
    204          }
   \   0000000E   0x4770             BX       LR               ;; return
    205          
    206          /**
    207            * @brief  Enables or disables the specified I2C peripheral.
    208            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    209            * @param  NewState: functional state @ref FunctionalState
    210            *         This parameter can be: ENABLE or DISABLE.
    211            * @retval None
    212            */

   \                                 In section .text, align 2, keep-with-next
    213          void I2C_Cmd(I2C_Type* I2Cx, FunctionalState NewState)
    214          {
    215            /* Check the parameters */
    216            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    217            assert_param(IS_FUNCTIONAL_STATE(NewState));
    218          
    219            if (NewState != DISABLE) {
   \                     I2C_Cmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xD003             BEQ      ??I2C_Cmd_0
    220              /* Enable the selected I2C peripheral */
    221              I2Cx->CR_b.PE = SET;
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x430A             ORRS     R2,R2,R1
   \   0000000A   0x6002             STR      R2,[R0, #+0]
   \   0000000C   0x4770             BX       LR
    222            }
    223            else {
    224              /* Disable the selected I2C peripheral */
    225              I2Cx->CR_b.PE = RESET;
   \                     ??I2C_Cmd_0: (+1)
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x4391             BICS     R1,R1,R2
   \   00000012   0x6001             STR      R1,[R0, #+0]
    226            }
    227          }
   \   00000014   0x4770             BX       LR               ;; return
    228          
    229          
    230          /**
    231            * @brief  Start an I2C transaction sending the frame specified.
    232            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    233            * @param  tr: pointer to an @ref I2C_TransactionType structure used
    234            *   for this transaction.
    235            * @retval None.
    236            */

   \                                 In section .text, align 2, keep-with-next
    237          void I2C_BeginTransaction(I2C_Type* I2Cx, I2C_TransactionType* tr)
    238          {
    239            
    240            /* Check the parameters */
    241            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    242            assert_param(IS_I2C_OPERATION(tr->Operation));
    243            assert_param(IS_I2C_STARTBYTE(tr->StartByte));
    244            assert_param(IS_I2C_ADDRESSTYPE(tr->AddressType));
    245            assert_param(IS_I2C_OWN_ADDRESS1(tr->Address));
    246            assert_param(IS_I2C_STOPCONDITION(tr->StopCondition));
    247            assert_param(IS_I2C_LENGTH(tr->Length));
    248              
    249            I2Cx->MCR = ((uint32_t)(tr->Operation)) | (((uint32_t)(tr->Address)) << 1) |
    250                  ((uint32_t)(tr->StartByte)) | ((uint32_t)(tr->AddressType)) | 
    251                  ((uint32_t)(tr->StopCondition)) | (((uint32_t)(tr->Length)) << 15);
   \                     I2C_BeginTransaction: (+1)
   \   00000000   0x880B             LDRH     R3,[R1, #+0]
   \   00000002   0x884A             LDRH     R2,[R1, #+2]
   \   00000004   0x0052             LSLS     R2,R2,#+1
   \   00000006   0x431A             ORRS     R2,R2,R3
   \   00000008   0x888B             LDRH     R3,[R1, #+4]
   \   0000000A   0x431A             ORRS     R2,R2,R3
   \   0000000C   0x88CB             LDRH     R3,[R1, #+6]
   \   0000000E   0x431A             ORRS     R2,R2,R3
   \   00000010   0x890B             LDRH     R3,[R1, #+8]
   \   00000012   0x431A             ORRS     R2,R2,R3
   \   00000014   0x8949             LDRH     R1,[R1, #+10]
   \   00000016   0x03C9             LSLS     R1,R1,#+15
   \   00000018   0x4311             ORRS     R1,R1,R2
   \   0000001A   0x60C1             STR      R1,[R0, #+12]
    252            
    253          }
   \   0000001C   0x4770             BX       LR               ;; return
    254          
    255          
    256          /**
    257            * @brief  Enables or disables the general call feature.
    258            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    259            * @param  NewState: functional state @ref FunctionalState
    260            *         This parameter can be: ENABLE or DISABLE.
    261            * @retval None
    262            */

   \                                 In section .text, align 2, keep-with-next
    263          void I2C_GeneralCallCmd(I2C_Type* I2Cx, FunctionalState NewState)
    264          {
    265            /* Check the parameters */
    266            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    267            assert_param(IS_FUNCTIONAL_STATE(NewState));
    268            if (NewState != DISABLE) {
   \                     I2C_GeneralCallCmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xD003             BEQ      ??I2C_GeneralCallCmd_0
    269              /* Enable generall call */
    270              I2Cx->CR_b.SGCM = SET;
   \   00000006   0x2240             MOVS     R2,#+64
   \   00000008   0x430A             ORRS     R2,R2,R1
   \   0000000A   0x6002             STR      R2,[R0, #+0]
   \   0000000C   0x4770             BX       LR
    271            }
    272            else {
    273              /* Disable generall call */
    274              I2Cx->CR_b.SGCM = RESET;
   \                     ??I2C_GeneralCallCmd_0: (+1)
   \   0000000E   0x2240             MOVS     R2,#+64
   \   00000010   0x4391             BICS     R1,R1,R2
   \   00000012   0x6001             STR      R1,[R0, #+0]
    275            }
    276          }
   \   00000014   0x4770             BX       LR               ;; return
    277          
    278          /**
    279            * @brief  Enables or disables the specified I2C interrupts.
    280            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    281            * @param  I2C_IT: specifies the I2C interrupts sources to be enabled or disabled. 
    282            *   This parameter can be any combination of the following values:
    283            *     @arg I2C_IT_TXFE: Tx FIFO empty
    284            *     @arg I2C_IT_TXFNE: TX FIFO nearly empty
    285            *     @arg I2C_IT_TXFF: Tx FIFO full
    286            *     @arg I2C_IT_TXFOVR: Tx FIFO overflow
    287            *     @arg I2C_IT_RXFE: Rx FIFO empty
    288            *     @arg I2C_IT_RXFNF: Rx FIFO nearly full
    289            *     @arg I2C_IT_RXFF: Rx FIFO full
    290            *     @arg I2C_IT_LBR: Length number of bytes received
    291            *     @arg I2C_IT_RFSR: Read from slave request
    292            *     @arg I2C_IT_RFSE: Read from slave empty
    293            *     @arg I2C_IT_WTSR: Write to slave request
    294            *     @arg I2C_IT_MTD: Master transaction done
    295            *     @arg I2C_IT_STD: Slave transaction done
    296            *     @arg I2C_IT_SAL: Slave arbitration lost
    297            *     @arg I2C_IT_MAL: Master arbitration lost
    298            *     @arg I2C_IT_BERR: Bus error
    299            *     @arg I2C_IT_MTDWS: Master transaction done without stop
    300            *     @arg I2C_IT_TIMEOUT: Timeout or Tlow error
    301            * @param  NewState: functional state @ref FunctionalState
    302            *         This parameter can be: ENABLE or DISABLE.
    303            * @retval None
    304            */

   \                                 In section .text, align 2, keep-with-next
    305          void I2C_ITConfig(I2C_Type* I2Cx, uint32_t I2C_IT, FunctionalState NewState)
    306          {
    307            /* Check the parameters */
    308            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    309            assert_param(IS_FUNCTIONAL_STATE(NewState));
    310            assert_param(IS_I2C_IT(I2C_IT));
    311            
    312            if (NewState != DISABLE) {
   \                     I2C_ITConfig: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6AC2             LDR      R2,[R0, #+44]
   \   00000004   0xD002             BEQ      ??I2C_ITConfig_0
    313              /* Enable the selected I2C interrupts */
    314              SET_BIT(I2Cx->IMSCR, I2C_IT);
   \   00000006   0x4311             ORRS     R1,R1,R2
   \   00000008   0x62C1             STR      R1,[R0, #+44]
   \   0000000A   0x4770             BX       LR
    315            }
    316            else {
    317              /* Disable the selected I2C interrupts */
    318              CLEAR_BIT(I2Cx->IMSCR, I2C_IT);
   \                     ??I2C_ITConfig_0: (+1)
   \   0000000C   0x438A             BICS     R2,R2,R1
   \   0000000E   0x62C2             STR      R2,[R0, #+44]
    319            }
    320          }
   \   00000010   0x4770             BX       LR               ;; return
    321          
    322          /**
    323            * @brief  Fills the Tx FIFO with the specified data byte.
    324            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    325            * @param  Data: Byte to be transmitted.
    326            * @retval None
    327            */

   \                                 In section .text, align 2, keep-with-next
    328          void I2C_FillTxFIFO(I2C_Type* I2Cx, uint8_t Data)
    329          {
    330            /* Check the parameters */
    331            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    332            /* Write in the DR register the data to be sent */
    333            I2Cx->TFR = (uint32_t)Data;
   \                     I2C_FillTxFIFO: (+1)
   \   00000000   0x7401             STRB     R1,[R0, #+16]
    334          }
   \   00000002   0x4770             BX       LR               ;; return
    335          
    336          /**
    337            * @brief  Returns the most recent received data by the I2Cx peripheral.
    338            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    339            * @retval uint8_t The value of the received data.
    340            */

   \                                 In section .text, align 2, keep-with-next
    341          uint8_t I2C_ReceiveData(I2C_Type* I2Cx)
    342          {
    343            /* Check the parameters */
    344            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    345            /* Return the data in the DR register */
    346            return I2Cx->RFR_b.RDATA;
   \                     I2C_ReceiveData: (+1)
   \   00000000   0x7E00             LDRB     R0,[R0, #+24]
   \   00000002   0x4770             BX       LR               ;; return
    347          }
    348          
    349          
    350          /**
    351            * @brief  Returns the most recent received data by the I2Cx peripheral.
    352            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    353            * @retval None
    354            */

   \                                 In section .text, align 2, keep-with-next
    355          void I2C_FlushTx(I2C_Type* I2Cx)
    356          {
    357            /* Check the parameters */
    358            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    359            /* Set flush tx flag */
    360            I2Cx->CR_b.FTX = SET;
   \                     I2C_FlushTx: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x2280             MOVS     R2,#+128
   \   00000004   0x430A             ORRS     R2,R2,R1
   \   00000006   0x6002             STR      R2,[R0, #+0]
    361          }
   \   00000008   0x4770             BX       LR               ;; return
    362          
    363          
    364          /**
    365            * @brief  Return the status of the TX FIFO flush operation.
    366            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    367            * @retval I2C_OpStatus operation status @ref I2C_OpStatus
    368            */

   \                                 In section .text, align 2, keep-with-next
    369          I2C_OpStatus I2C_WaitFlushTx(I2C_Type* I2Cx)
    370          {
    371            /* Check the parameters */
    372            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    373          
    374            /* Wait the flush of TX FIFO is completed */
    375            if(I2Cx->CR_b.FTX == SET) {
   \                     I2C_WaitFlushTx: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x0601             LSLS     R1,R0,#+24
   \   00000004   0x0FC9             LSRS     R1,R1,#+31
   \   00000006   0xD001             BEQ      ??I2C_WaitFlushTx_0
    376              return I2C_OP_ONGOING;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
    377            }
    378            else {
    379              return I2C_OP_OK;
   \                     ??I2C_WaitFlushTx_0: (+1)
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0x4770             BX       LR               ;; return
    380            }
    381          }
    382          
    383          
    384          /**
    385            * @brief  Returns the most recent received data by the I2Cx peripheral.
    386            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    387            * @retval None
    388            */

   \                                 In section .text, align 2, keep-with-next
    389          void I2C_FlushRx(I2C_Type* I2Cx)
    390          {
    391            /* Check the parameters */
    392            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    393            /* Set flush rx flag */
    394            I2Cx->CR_b.FRX = SET;
   \                     I2C_FlushRx: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x2280             MOVS     R2,#+128
   \   00000004   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \   00000006   0x430A             ORRS     R2,R2,R1
   \   00000008   0x6002             STR      R2,[R0, #+0]
    395          }
   \   0000000A   0x4770             BX       LR               ;; return
    396          
    397          
    398          /**
    399            * @brief  Return the status of the RX FIFO flush operation.
    400            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    401            * @retval I2C_OpStatus operation status @ref I2C_OpStatus
    402            */

   \                                 In section .text, align 2, keep-with-next
    403          I2C_OpStatus I2C_WaitFlushRx(I2C_Type* I2Cx)
    404          {
    405            /* Check the parameters */
    406            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    407          
    408            /* Wait the flush of TX FIFO is completed */
    409            if(I2Cx->CR_b.FRX == SET) {
   \                     I2C_WaitFlushRx: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x05C1             LSLS     R1,R0,#+23
   \   00000004   0x0FC9             LSRS     R1,R1,#+31
   \   00000006   0xD001             BEQ      ??I2C_WaitFlushRx_0
    410              return I2C_OP_ONGOING;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
    411            }
    412            else {
    413              return I2C_OP_OK;
   \                     ??I2C_WaitFlushRx_0: (+1)
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0x4770             BX       LR               ;; return
    414            }
    415          }
    416          
    417          /**
    418            * @brief  Sets the transmit FIFO threshold by the I2Cx peripheral.
    419            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    420            * @param  TxThres: The value of the threshold 2-byte.
    421            * @retval None
    422            */

   \                                 In section .text, align 2, keep-with-next
    423          void I2C_SetTxThreshold(I2C_Type* I2Cx, uint16_t TxThres)
    424          {
    425            /* Check the parameters */
    426            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    427            assert_param(IS_I2C_TX_THRESHOLD(TxThres));
    428            
    429            /* Set the Tx FIFO Threshold */
    430            I2Cx->TFTR_b.THRESH_TX = TxThres;
   \                     I2C_SetTxThreshold: (+1)
   \   00000000   0x8B82             LDRH     R2,[R0, #+28]
   \   00000002   0x23FC             MOVS     R3,#+252
   \   00000004   0x021B             LSLS     R3,R3,#+8        ;; #+64512
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x0589             LSLS     R1,R1,#+22
   \   0000000A   0x0D89             LSRS     R1,R1,#+22
   \   0000000C   0x4319             ORRS     R1,R1,R3
   \   0000000E   0x8381             STRH     R1,[R0, #+28]
    431          }
   \   00000010   0x4770             BX       LR               ;; return
    432          
    433          /**
    434            * @brief  Sets the receive FIFO threshold by the I2Cx peripheral.
    435            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    436            * @param  RxThres: The value of the threshold 2-byte.
    437            */

   \                                 In section .text, align 2, keep-with-next
    438          void I2C_SetRxThreshold(I2C_Type* I2Cx, uint16_t RxThres)
    439          {
    440            /* Check the parameters */
    441            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    442            assert_param(IS_I2C_RX_THRESHOLD(RxThres));
    443            
    444            /* Set the Rx FIFO Threshold */
    445            I2Cx->RFTR_b.THRESH_RX = RxThres;
   \                     I2C_SetRxThreshold: (+1)
   \   00000000   0x8C02             LDRH     R2,[R0, #+32]
   \   00000002   0x23FC             MOVS     R3,#+252
   \   00000004   0x021B             LSLS     R3,R3,#+8        ;; #+64512
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x0589             LSLS     R1,R1,#+22
   \   0000000A   0x0D89             LSRS     R1,R1,#+22
   \   0000000C   0x4319             ORRS     R1,R1,R3
   \   0000000E   0x8401             STRH     R1,[R0, #+32]
    446          }
   \   00000010   0x4770             BX       LR               ;; return
    447          
    448          
    449          /**
    450            * @brief  Generate a stop condition.
    451            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    452            * @retval None
    453            */

   \                                 In section .text, align 2, keep-with-next
    454          void I2C_GenerateStopCondition(I2C_Type* I2Cx)
    455          {
    456            /* Check the parameters */
    457            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    458          
    459            /* Generate a stop condition */
    460            I2Cx->CR_b.FS_1 = SET;
   \                     I2C_GenerateStopCondition: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x2280             MOVS     R2,#+128
   \   00000004   0x0212             LSLS     R2,R2,#+8        ;; #+32768
   \   00000006   0x430A             ORRS     R2,R2,R1
   \   00000008   0x6002             STR      R2,[R0, #+0]
    461          }
   \   0000000A   0x4770             BX       LR               ;; return
    462          
    463          /**
    464            * @brief  Set the hold time value for data transfer.
    465            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    466            * @param  I2C_HoldTime: specifies the hold time value.
    467            * @retval None
    468            */

   \                                 In section .text, align 2, keep-with-next
    469          void I2C_SetHoldTime(I2C_Type* I2Cx, uint16_t I2C_HoldTime)
    470          {
    471            /* Check the parameters */
    472            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    473            assert_param(IS_I2C_HOLDTIME(I2C_HoldTime));
    474          
    475            I2Cx->THDDAT = I2C_HoldTime;
   \                     I2C_SetHoldTime: (+1)
   \   00000000   0x224C             MOVS     R2,#+76
   \   00000002   0x5281             STRH     R1,[R0, R2]
    476          }
   \   00000004   0x4770             BX       LR               ;; return
    477          
    478          /**
    479            * @brief  Set the hold time value for start condition.
    480            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    481            * @param  I2C_HoldTime: specifies the hold time value.
    482            * @retval None
    483            */

   \                                 In section .text, align 2, keep-with-next
    484          void I2C_SetHoldTimeStartCondition(I2C_Type* I2Cx, uint16_t I2C_HoldTime)
    485          {
    486            /* Check the parameters */
    487            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    488            assert_param(IS_I2C_HOLDTIME(I2C_HoldTime));
    489          
    490            /* Standard mode */
    491            if(I2Cx->CR_b.SM == I2C_CR_SM_STD) {
   \                     I2C_SetHoldTimeStartCondition: (+1)
   \   00000000   0x2203             MOVS     R2,#+3
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x091B             LSRS     R3,R3,#+4
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0xD107             BNE      ??I2C_SetHoldTimeStartCondition_0
    492              I2Cx->THDSTA_FST_STD_b.THDSTA_STD = I2C_HoldTime;
   \   0000000A   0x6D02             LDR      R2,[R0, #+80]
   \   0000000C   0x0A52             LSRS     R2,R2,#+9
   \   0000000E   0x0252             LSLS     R2,R2,#+9
   \   00000010   0x05C9             LSLS     R1,R1,#+23
   \   00000012   0x0DC9             LSRS     R1,R1,#+23
   \   00000014   0x4311             ORRS     R1,R1,R2
   \   00000016   0x6501             STR      R1,[R0, #+80]
   \   00000018   0x4770             BX       LR
    493            }
    494            else if(I2Cx->CR_b.SM == I2C_CR_SM_FAST) {
   \                     ??I2C_SetHoldTimeStartCondition_0: (+1)
   \   0000001A   0x6803             LDR      R3,[R0, #+0]
   \   0000001C   0x091B             LSRS     R3,R3,#+4
   \   0000001E   0x401A             ANDS     R2,R2,R3
   \   00000020   0x2A01             CMP      R2,#+1
   \   00000022   0xD107             BNE      ??I2C_SetHoldTimeStartCondition_1
    495              I2Cx->THDSTA_FST_STD_b.THDSTA_FST = I2C_HoldTime;
   \   00000024   0x6D02             LDR      R2,[R0, #+80]
   \   00000026   0x....             LDR      R3,??DataTable4_6  ;; 0xfe00ffff
   \   00000028   0x4013             ANDS     R3,R3,R2
   \   0000002A   0x0409             LSLS     R1,R1,#+16
   \   0000002C   0x....             LDR      R2,??DataTable4_7  ;; 0x1ff0000
   \   0000002E   0x400A             ANDS     R2,R2,R1
   \   00000030   0x431A             ORRS     R2,R2,R3
   \   00000032   0x6502             STR      R2,[R0, #+80]
    496            }
    497          }
   \                     ??I2C_SetHoldTimeStartCondition_1: (+1)
   \   00000034   0x4770             BX       LR               ;; return
    498          
    499          /**
    500            * @brief  Checks whether the specified I2C interrupt has occurred or not.
    501            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    502            * @param  I2C_IT: specifies the interrupt source to check. 
    503            *         This parameter can be one of the following values:
    504            *         @arg I2C_IT_TXFE: Tx FIFO empty
    505            *         @arg I2C_IT_TXFNE: TX FIFO nearly empty
    506            *         @arg I2C_IT_TXFF: Tx FIFO full
    507            *         @arg I2C_IT_TXFOVR: Tx FIFO overflow
    508            *         @arg I2C_IT_RXFE: Rx FIFO empty
    509            *         @arg I2C_IT_RXFNF: Rx FIFO nearly full
    510            *         @arg I2C_IT_RXFF: Rx FIFO full
    511            *         @arg I2C_IT_LBR: Length number of bytes received
    512            *         @arg I2C_IT_RFSR: Read from slave request
    513            *         @arg I2C_IT_RFSE: Read from slave empty
    514            *         @arg I2C_IT_WTSR: Write to slave request
    515            *         @arg I2C_IT_MTD: Master transaction done
    516            *         @arg I2C_IT_STD: Slave transaction done
    517            *         @arg I2C_IT_SAL: Slave arbitration lost
    518            *         @arg I2C_IT_MAL: Master arbitration lost
    519            *         @arg I2C_IT_BERR: Bus error
    520            *         @arg I2C_IT_MTDWS: Master transaction done without stop
    521            *         @arg I2C_IT_TIMEOUT: Timeout or Tlow error
    522            * @retval  ITStatus: functional state @ref ITStatus
    523            *         This parameter can be: SET or RESET.
    524            */

   \                                 In section .text, align 2, keep-with-next
    525          ITStatus I2C_GetITStatus(I2C_Type* I2Cx, uint32_t I2C_IT)
    526          {
    527            /* Check the parameters */
    528            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    529            assert_param(IS_I2C_IT(I2C_IT));
    530          
    531            /* Check the status of the specified I2C flag */
    532            if (READ_BIT(I2Cx->RISR, I2C_IT) != (uint32_t)RESET) {
   \                     I2C_GetITStatus: (+1)
   \   00000000   0x6B00             LDR      R0,[R0, #+48]
   \   00000002   0x....             B.N      ?Subroutine0
    533              /* I2C_IT is set */
    534              return SET;
    535            }
    536            else {
    537              /* I2C_IT is reset */
    538              return RESET;
    539            }
    540          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x4001             ANDS     R1,R1,R0
   \   00000002   0x1E48             SUBS     R0,R1,#+1
   \   00000004   0x4180             SBCS     R0,R0,R0
   \   00000006   0x43C0             MVNS     R0,R0
   \   00000008   0x0FC0             LSRS     R0,R0,#+31
   \   0000000A   0x4770             BX       LR               ;; return
    541          
    542          /**
    543            * @brief  Checks whether the specified I2C interrupt has occurred or not.
    544            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    545            * @param  I2C_IT: specifies the interrupt source to check. 
    546            *         This parameter can be one of the following values:
    547            *         @arg I2C_IT_TXFE: Tx FIFO empty
    548            *         @arg I2C_IT_TXFNE: TX FIFO nearly empty
    549            *         @arg I2C_IT_TXFF: Tx FIFO full
    550            *         @arg I2C_IT_TXFOVR: Tx FIFO overflow
    551            *         @arg I2C_IT_RXFE: Rx FIFO empty
    552            *         @arg I2C_IT_RXFNF: Rx FIFO nearly full
    553            *         @arg I2C_IT_RXFF: Rx FIFO full
    554            *         @arg I2C_IT_LBR: Length number of bytes received
    555            *         @arg I2C_IT_RFSR: Read from slave request
    556            *         @arg I2C_IT_RFSE: Read from slave empty
    557            *         @arg I2C_IT_WTSR: Write to slave request
    558            *         @arg I2C_IT_MTD: Master transaction done
    559            *         @arg I2C_IT_STD: Slave transaction done
    560            *         @arg I2C_IT_SAL: Slave arbitration lost
    561            *         @arg I2C_IT_MAL: Master arbitration lost
    562            *         @arg I2C_IT_BERR: Bus error
    563            *         @arg I2C_IT_MTDWS: Master transaction done without stop
    564            *         @arg I2C_IT_TIMEOUT: Timeout or Tlow error
    565            * @retval  ITStatus: functional state @ref ITStatus
    566            *         This parameter can be: SET or RESET.
    567            */

   \                                 In section .text, align 2, keep-with-next
    568          ITStatus I2C_GetITPendingBit(I2C_Type* I2Cx, uint32_t I2C_IT)
    569          {
    570            /* Check the parameters */
    571            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    572            assert_param(IS_I2C_IT(I2C_IT));
    573          
    574            /* Check the status of the specified I2C flag */
    575            if (READ_BIT(I2Cx->MISR, I2C_IT) != (uint32_t)RESET) {
   \                     I2C_GetITPendingBit: (+1)
   \   00000000   0x6B40             LDR      R0,[R0, #+52]
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0
    576              /* I2C_IT is set */
    577              return SET;
    578            }
    579            else {
    580              /* I2C_IT is reset */
    581              return RESET;
    582            }
    583          }
    584          
    585          
    586          /**
    587            * @brief  Clears the I2Cx interrupt pending bits.
    588            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    589            * @param  I2C_IT: specifies the interrupt pending bit to clear. 
    590            *         This parameter can be any combination of the following values:
    591            *         @arg I2C_IT_TXFE: Tx FIFO empty
    592            *         @arg I2C_IT_TXFNE: TX FIFO nearly empty
    593            *         @arg I2C_IT_TXFF: Tx FIFO full
    594            *         @arg I2C_IT_TXFOVR: Tx FIFO overflow
    595            *         @arg I2C_IT_RXFE: Rx FIFO empty
    596            *         @arg I2C_IT_RXFNF: Rx FIFO nearly full
    597            *         @arg I2C_IT_RXFF: Rx FIFO full
    598            *         @arg I2C_IT_LBR: Length number of bytes received
    599            *         @arg I2C_IT_RFSR: Read from slave request
    600            *         @arg I2C_IT_RFSE: Read from slave empty
    601            *         @arg I2C_IT_WTSR: Write to slave request
    602            *         @arg I2C_IT_MTD: Master transaction done
    603            *         @arg I2C_IT_STD: Slave transaction done
    604            *         @arg I2C_IT_SAL: Slave arbitration lost
    605            *         @arg I2C_IT_MAL: Master arbitration lost
    606            *         @arg I2C_IT_BERR: Bus error
    607            *         @arg I2C_IT_MTDWS: Master transaction done without stop
    608            *         @arg I2C_IT_TIMEOUT: Timeout or Tlow error
    609            * @retval None
    610            */

   \                                 In section .text, align 2, keep-with-next
    611          void I2C_ClearITPendingBit(I2C_Type* I2Cx, uint32_t I2C_IT)
    612          {
    613            /* Check the parameters */
    614            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    615            assert_param(IS_I2C_IT(I2C_IT));
    616            /* Clear the selected I2C flags */
    617            WRITE_REG(I2Cx->ICR, I2C_IT);
   \                     I2C_ClearITPendingBit: (+1)
   \   00000000   0x6381             STR      R1,[R0, #+56]
    618          }
   \   00000002   0x4770             BX       LR               ;; return
    619          
    620          
    621          /**
    622            * @brief  Get the present state of the operation executed by I2C block.
    623            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    624            * @retval I2C_OpStatus: the I2C operation status @ref I2C_OpStatus
    625            */

   \                                 In section .text, align 2, keep-with-next
    626          I2C_OpStatus I2C_GetStatus(I2C_Type* I2Cx)
    627          {
    628            /* Check the parameters */
    629            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    630          
    631            /* Read the OP status field of the status register */
    632            return (I2C_OpStatus)I2Cx->SR_b.STATUS;
   \                     I2C_GetStatus: (+1)
   \   00000000   0x6940             LDR      R0,[R0, #+20]
   \   00000002   0x0700             LSLS     R0,R0,#+28
   \   00000004   0x0F80             LSRS     R0,R0,#+30
   \   00000006   0x4770             BX       LR               ;; return
    633          }
    634          
    635          
    636          
    637          /**
    638            * @brief  Enables or disables the I2C DMA interface.
    639            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    640            * @param  I2C_DMAReq: specifies the DMA request.
    641            *   This parameter can be any combination of the following values:
    642            *     @arg I2C_DMAReq_Tx: I2C DMA transmit request
    643            *     @arg I2C_DMAReq_Rx: I2C DMA receive request.
    644            * @param  NewState: functional state @ref FunctionalState
    645            *   This parameter can be: ENABLE or DISABLE.   
    646            * @retval None
    647            */

   \                                 In section .text, align 2, keep-with-next
    648          void I2C_DMACmd(I2C_Type* I2Cx, uint16_t I2C_DMAReq, FunctionalState NewState)
    649          {
    650            /* Check the parameters */
    651            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    652            assert_param(IS_I2C_DMAREQ(I2C_DMAReq));  
    653            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
    654          
    655            if (NewState != DISABLE)
   \                     I2C_DMACmd: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0xD001             BEQ      ??I2C_DMACmd_0
    656            {
    657              /* Enable the DMA transfer */
    658              I2Cx->CR |= I2C_DMAReq;
   \   00000006   0x430A             ORRS     R2,R2,R1
   \   00000008   0xE000             B        ??I2C_DMACmd_1
    659            }
    660            else
    661            {
    662              /* Disable the DMA transfer */
    663              I2Cx->CR &= ~I2C_DMAReq;
   \                     ??I2C_DMACmd_0: (+1)
   \   0000000A   0x438A             BICS     R2,R2,R1
   \                     ??I2C_DMACmd_1: (+1)
   \   0000000C   0x6002             STR      R2,[R0, #+0]
    664            }
    665          }
   \   0000000E   0x4770             BX       LR               ;; return
    666          
    667          /**
    668            * @brief  Enables or disables the I2C TX DMA burst mode.
    669            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    670            * @param  NewState: functional state @ref FunctionalState
    671            *   This parameter can be: ENABLE or DISABLE.   
    672            * @retval None
    673            */

   \                                 In section .text, align 2, keep-with-next
    674          void I2C_DMATxBurstMode(I2C_Type* I2Cx, FunctionalState NewState)
    675          {
    676            /* Check the parameters */
    677            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    678            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
    679          
    680            if (NewState != DISABLE)
   \                     I2C_DMATxBurstMode: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8C81             LDRH     R1,[R0, #+36]
   \   00000004   0xD003             BEQ      ??I2C_DMATxBurstMode_0
    681            {
    682              /* Enable the TX DMA burst mode */
    683              I2Cx->DMAR_b.BURST_TX = SET;
   \   00000006   0x2280             MOVS     R2,#+128
   \   00000008   0x0112             LSLS     R2,R2,#+4        ;; #+2048
   \   0000000A   0x430A             ORRS     R2,R2,R1
   \   0000000C   0xE001             B        ??I2C_DMATxBurstMode_1
    684            }
    685            else
    686            {
    687              /* Disable the TX DMA burst mode */
    688              I2Cx->DMAR_b.BURST_TX = RESET;
   \                     ??I2C_DMATxBurstMode_0: (+1)
   \   0000000E   0x....             LDR      R2,??DataTable4_8  ;; 0xf7ff
   \   00000010   0x400A             ANDS     R2,R2,R1
   \                     ??I2C_DMATxBurstMode_1: (+1)
   \   00000012   0x8482             STRH     R2,[R0, #+36]
    689            }
    690          }
   \   00000014   0x4770             BX       LR               ;; return
    691          
    692          /**
    693            * @brief  Set the number of burst of data.
    694            *         If this number is smaller than the transaction length, only one single request are generated.
    695            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral @ref I2C_Type
    696            * @param  I2C_BurstSize: specifies the number of burst request.
    697            * @retval None
    698            */

   \                                 In section .text, align 2, keep-with-next
    699          void I2C_DMATxBurstSize(I2C_Type* I2Cx, uint8_t I2C_BurstSize)
    700          {
    701            /* Check the parameters */
    702            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
    703            assert_param(IS_I2C_BURSTSIZE(I2C_BurstSize));  
    704          
    705            I2Cx->DMAR_b.DBSIZE_TX = I2C_BurstSize;
   \                     I2C_DMATxBurstSize: (+1)
   \   00000000   0x8C82             LDRH     R2,[R0, #+36]
   \   00000002   0x....             LDR      R3,??DataTable4_9  ;; 0xf8ff
   \   00000004   0x4013             ANDS     R3,R3,R2
   \   00000006   0x0209             LSLS     R1,R1,#+8
   \   00000008   0x22E0             MOVS     R2,#+224
   \   0000000A   0x00D2             LSLS     R2,R2,#+3        ;; #+1792
   \   0000000C   0x400A             ANDS     R2,R2,R1
   \   0000000E   0x431A             ORRS     R2,R2,R3
   \   00000010   0x8482             STRH     R2,[R0, #+36]
    706          }
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0xFFFF9FFF         DC32     0xffff9fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     Foncycles

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x000186A1         DC32     0x186a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x00061A81         DC32     0x61a81

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x00001388         DC32     0x1388

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0xFE00FFFF         DC32     0xfe00ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x01FF0000         DC32     0x1ff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x0000F7FF         DC32     0xf7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x0000F8FF         DC32     0xf8ff
    707          
    708          
    709          /**
    710            * @}
    711            */ 
    712          
    713          /**
    714            * @}
    715            */ 
    716          
    717          /**
    718            * @}
    719            */ 
    720          
    721          /******************* (C) COPYRIGHT 2016 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   I2C_BeginTransaction
       0   I2C_ClearITPendingBit
       0   I2C_Cmd
       0   I2C_DMACmd
       0   I2C_DMATxBurstMode
       0   I2C_DMATxBurstSize
       0   I2C_DeInit
       0   I2C_FillTxFIFO
       0   I2C_FlushRx
       0   I2C_FlushTx
       0   I2C_GeneralCallCmd
       0   I2C_GenerateStopCondition
       0   I2C_GetITPendingBit
       0   I2C_GetITStatus
       0   I2C_GetStatus
       0   I2C_ITConfig
      12   I2C_Init
        12 __aeabi_uidiv
       0   I2C_ReceiveData
       0   I2C_SetHoldTime
       0   I2C_SetHoldTimeStartCondition
       0   I2C_SetRxThreshold
       0   I2C_SetTxThreshold
       0   I2C_StructInit
       0   I2C_WaitFlushRx
       0   I2C_WaitFlushTx


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      12  ?Subroutine0
       8  Foncycles
      30  I2C_BeginTransaction
       4  I2C_ClearITPendingBit
      22  I2C_Cmd
      16  I2C_DMACmd
      22  I2C_DMATxBurstMode
      20  I2C_DMATxBurstSize
      20  I2C_DeInit
       4  I2C_FillTxFIFO
      12  I2C_FlushRx
      10  I2C_FlushTx
      22  I2C_GeneralCallCmd
      12  I2C_GenerateStopCondition
       2  I2C_GetITPendingBit
       4  I2C_GetITStatus
       8  I2C_GetStatus
      18  I2C_ITConfig
     180  I2C_Init
       4  I2C_ReceiveData
       6  I2C_SetHoldTime
      54  I2C_SetHoldTimeStartCondition
      18  I2C_SetRxThreshold
      18  I2C_SetTxThreshold
      16  I2C_StructInit
      16  I2C_WaitFlushRx
      16  I2C_WaitFlushTx

 
   8 bytes in section .data
 606 bytes in section .text
 
 606 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: 1

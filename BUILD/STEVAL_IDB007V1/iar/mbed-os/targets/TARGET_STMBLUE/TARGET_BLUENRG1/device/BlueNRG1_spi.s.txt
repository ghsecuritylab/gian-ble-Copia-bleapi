###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:59
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        .\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_spi.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_spi.d
#        -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_spi.s.txt
#        -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_spi.o
#        .\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_spi.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_spi.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_spi.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_spi.c
      1          /**
      2          ******************************************************************************
      3          * @file    BlueNRG1_spi.c
      4          * @author  VMA Application Team
      5            * @version V2.1.0
      6            * @date    31-January-2017
      7          * @brief   This file provides all the SPI firmware functions.
      8          ******************************************************************************
      9          * @attention
     10          *
     11          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13          * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14          * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15          * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16          * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17          *
     18          * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
     19          ******************************************************************************
     20          */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "BlueNRG1_spi.h"

  typedef uint8_t BOOL;  //already defined in "hal_type.h"
                  ^
"C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\TARGET_STEVAL_IDB007V1\device\system_BlueNRG1.h",240  Warning[Pe301]: typedef name has already been declared (with same type)
     24          
     25          /** @addtogroup BLUENRG1_Peripheral_Driver BLUENRG1 Peripheral Driver
     26          * @{
     27          */
     28          
     29          /** @addtogroup SPI_Peripheral  SPI Peripheral
     30          * @{
     31          */ 
     32          
     33          /** @defgroup SPI_Private_TypesDefinitions Private Types Definitions
     34          * @{
     35          */
     36          
     37          /**
     38          * @}
     39          */ 
     40          
     41          /** @defgroup SPI_Private_Defines Private Defines
     42          * @{
     43          */
     44          
     45          #define MAX_SCR         (255)
     46          #define MAX_CPSVDR      (254)
     47          #define MIN_DIVIDER     (1)
     48          #define MAX_DIVIDER     (65024) // MAX_CPSVDR * (MAX_SCR+1)
     49          
     50          #define SPI_CLOCK       (16000000)
     51          
     52          /**
     53          * @}
     54          */
     55          
     56          /** @defgroup SPI_Private_Macros Private Macros
     57          * @{
     58          */
     59          
     60          /**
     61          * @}
     62          */
     63          
     64          /** @defgroup SPI_Private_Variables Private Variables
     65          * @{
     66          */
     67          
     68          /**
     69          * @}
     70          */
     71          
     72          /** @defgroup SPI_Private_FunctionPrototypes Private Function Prototypes
     73          * @{
     74          */
     75          
     76          /**
     77          * @}
     78          */
     79          
     80          /** @defgroup SPI_Private_Functions Private Functions
     81          * @{
     82          */
     83          
     84          /**
     85          * @brief  SPI set baud rate function.
     86          * @param  Baudrate: the SPI baud rate up to 8MHz for master mode
     87          *                   and 1MHz for slave mode.
     88          * @retval  None
     89          */

   \                                 In section .text, align 2, keep-with-next
     90          void SPI_SetBaudrate(uint32_t Baudrate)
     91          {
   \                     SPI_SetBaudrate: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0001             MOVS     R1,R0
     92            uint32_t c;
     93            uint8_t scr = 1;
   \   00000004   0x2401             MOVS     R4,#+1
     94            uint8_t cpsr = 2;
   \   00000006   0x2502             MOVS     R5,#+2
     95            
     96            /* Check the parameters */
     97            assert_param(IS_SPI_BAUDRATE(Baudrate));
     98            
     99            /* bit rate is: 16MHz / (CPSDVR * (1+SCR))
    100            and CPSDVR must be an even number from 2-254.
    101            We calculate (1/2 * CPSDVR) * (1+SCR) */
    102            c = SPI_CLOCK / (2 * Baudrate);
   \   00000008   0x....             LDR      R0,??DataTable24  ;; 0xf42400
   \   0000000A   0x0049             LSLS     R1,R1,#+1
   \   0000000C   0x.... 0x....      BL       __aeabi_uidiv
    103            
    104            /* if the bit rate is possible */
    105            if ((c >= MIN_DIVIDER) && (c <= MAX_DIVIDER)) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD008             BEQ      ??SPI_SetBaudrate_0
   \   00000014   0x....             LDR      R1,??DataTable24_1  ;; 0xfe01
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD205             BCS      ??SPI_SetBaudrate_0
   \   0000001A   0xE001             B        ??SPI_SetBaudrate_1
    106              /* adjust the ratio CPSDVR / (SCR+1) */
    107              while (c > MAX_SCR) {
    108                cpsr <<= 1;
   \                     ??SPI_SetBaudrate_2: (+1)
   \   0000001C   0x006D             LSLS     R5,R5,#+1
    109                c >>= 1;
   \   0000001E   0x0840             LSRS     R0,R0,#+1
    110              }    
   \                     ??SPI_SetBaudrate_1: (+1)
   \   00000020   0x28FF             CMP      R0,#+255
   \   00000022   0xD8FB             BHI      ??SPI_SetBaudrate_2
    111              scr = c - 1;    
   \   00000024   0x1E44             SUBS     R4,R0,#+1
    112            }
    113            /* set dividers */
    114            SPI1->CPSR = cpsr;
   \                     ??SPI_SetBaudrate_0: (+1)
   \   00000026   0x....             LDR      R0,??DataTable25  ;; 0x40400000
   \   00000028   0x7405             STRB     R5,[R0, #+16]
    115            SPI1->CR0_b.SCR = scr;
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0x....             LDR      R2,??DataTable28  ;; 0xffff00ff
   \   0000002E   0x400A             ANDS     R2,R2,R1
   \   00000030   0x0624             LSLS     R4,R4,#+24
   \   00000032   0x0C21             LSRS     R1,R4,#+16
   \   00000034   0x4311             ORRS     R1,R1,R2
   \   00000036   0x6001             STR      R1,[R0, #+0]
    116          }
   \   00000038   0xBD30             POP      {R4,R5,PC}       ;; return
    117          
    118          /**
    119          * @}
    120          */
    121          
    122          /** @defgroup SPI_Public_Functions Public Functions
    123          * @{
    124          */
    125          
    126          /**
    127          * @brief  Deinitializes the SPI peripheral registers to their default
    128          *         reset values.
    129          * @param  None
    130          * @retval None
    131          */

   \                                 In section .text, align 2, keep-with-next
    132          void SPI_DeInit(void)
    133          {
    134            SPI1->CR0   = 0x1C000000;
   \                     SPI_DeInit: (+1)
   \   00000000   0x....             LDR      R0,??DataTable25  ;; 0x40400000
   \   00000002   0x21E0             MOVS     R1,#+224
   \   00000004   0x0549             LSLS     R1,R1,#+21       ;; #+469762048
   \   00000006   0x6001             STR      R1,[R0, #+0]
    135            SPI1->CR1   = 0x00000000;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6041             STR      R1,[R0, #+4]
    136            SPI1->CPSR  = 0x00000000;
   \   0000000C   0x7401             STRB     R1,[R0, #+16]
    137            SPI1->IMSC  = 0x00000000;
   \   0000000E   0x7501             STRB     R1,[R0, #+20]
    138            SPI1->ICR   = 0x00000000;
   \   00000010   0x3020             ADDS     R0,R0,#+32
   \   00000012   0x7001             STRB     R1,[R0, #+0]
    139            SPI1->DMACR = 0x00000000;
   \   00000014   0x7101             STRB     R1,[R0, #+4]
    140            SPI1->RXFRM = 0x00000000;
   \   00000016   0x8101             STRH     R1,[R0, #+8]
    141            SPI1->CHN   = 0x00000000;
   \   00000018   0x60C1             STR      R1,[R0, #+12]
    142            SPI1->WDTXF = 0x00000000;
   \   0000001A   0x8201             STRH     R1,[R0, #+16]
    143          }
   \   0000001C   0x4770             BX       LR               ;; return
    144          
    145          /**
    146          * @brief  Initializes the SPI peripheral according to the specified 
    147          *         parameters in the SPI_InitStruct.
    148          * @param  SPI_InitStruct: pointer to a @ref SPI_InitType structure that
    149          *         contains the configuration information for the specified SPI peripheral.
    150          * @retval None
    151          */

   \                                 In section .text, align 2, keep-with-next
    152          void SPI_Init(SPI_InitType* SPI_InitStruct)
    153          {
   \                     SPI_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    154            /* check the parameters */
    155            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
    156            assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
    157            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
    158            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
    159            
    160            /* Set the specified baud rate */
    161            SPI_SetBaudrate(SPI_InitStruct->SPI_BaudRate);
   \   00000004   0x2501             MOVS     R5,#+1
   \   00000006   0x2602             MOVS     R6,#+2
   \   00000008   0x....             LDR      R0,??DataTable24  ;; 0xf42400
   \   0000000A   0x6861             LDR      R1,[R4, #+4]
   \   0000000C   0x0049             LSLS     R1,R1,#+1
   \   0000000E   0x.... 0x....      BL       __aeabi_uidiv
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD008             BEQ      ??SPI_Init_0
   \   00000016   0x....             LDR      R1,??DataTable24_1  ;; 0xfe01
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD205             BCS      ??SPI_Init_0
   \   0000001C   0xE001             B        ??SPI_Init_1
   \                     ??SPI_Init_2: (+1)
   \   0000001E   0x0076             LSLS     R6,R6,#+1
   \   00000020   0x0840             LSRS     R0,R0,#+1
   \                     ??SPI_Init_1: (+1)
   \   00000022   0x28FF             CMP      R0,#+255
   \   00000024   0xD8FB             BHI      ??SPI_Init_2
   \   00000026   0x1E45             SUBS     R5,R0,#+1
   \                     ??SPI_Init_0: (+1)
   \   00000028   0x....             LDR      R0,??DataTable25  ;; 0x40400000
   \   0000002A   0x7406             STRB     R6,[R0, #+16]
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x....             LDR      R2,??DataTable28  ;; 0xffff00ff
   \   00000030   0x400A             ANDS     R2,R2,R1
   \   00000032   0x062D             LSLS     R5,R5,#+24
   \   00000034   0x0C29             LSRS     R1,R5,#+16
   \   00000036   0x4311             ORRS     R1,R1,R2
   \   00000038   0x6001             STR      R1,[R0, #+0]
    162            
    163            /* Set SPI mode */
    164            SPI1->CR1_b.MS = SPI_InitStruct->SPI_Mode;
   \   0000003A   0x7821             LDRB     R1,[R4, #+0]
   \   0000003C   0x6842             LDR      R2,[R0, #+4]
   \   0000003E   0x2304             MOVS     R3,#+4
   \   00000040   0x439A             BICS     R2,R2,R3
   \   00000042   0x0089             LSLS     R1,R1,#+2
   \   00000044   0x4019             ANDS     R1,R1,R3
   \   00000046   0x4311             ORRS     R1,R1,R2
   \   00000048   0x6041             STR      R1,[R0, #+4]
    165            
    166            /* Set CPOL */
    167            SPI1->CR0_b.SPO = SPI_InitStruct->SPI_CPOL;
   \   0000004A   0x78A1             LDRB     R1,[R4, #+2]
   \   0000004C   0x6802             LDR      R2,[R0, #+0]
   \   0000004E   0x2340             MOVS     R3,#+64
   \   00000050   0x439A             BICS     R2,R2,R3
   \   00000052   0x0189             LSLS     R1,R1,#+6
   \   00000054   0x4019             ANDS     R1,R1,R3
   \   00000056   0x4311             ORRS     R1,R1,R2
   \   00000058   0x6001             STR      R1,[R0, #+0]
    168            
    169            /* Set CPHA */
    170            SPI1->CR0_b.SPH = SPI_InitStruct->SPI_CPHA;
   \   0000005A   0x78E1             LDRB     R1,[R4, #+3]
   \   0000005C   0x6802             LDR      R2,[R0, #+0]
   \   0000005E   0x2380             MOVS     R3,#+128
   \   00000060   0x439A             BICS     R2,R2,R3
   \   00000062   0x01C9             LSLS     R1,R1,#+7
   \   00000064   0x4019             ANDS     R1,R1,R3
   \   00000066   0x4311             ORRS     R1,R1,R2
   \   00000068   0x6001             STR      R1,[R0, #+0]
    171            
    172            /* Set datasize */
    173            SPI1->CR0_b.DSS = SPI_InitStruct->SPI_DataSize;
   \   0000006A   0x7861             LDRB     R1,[R4, #+1]
   \   0000006C   0x6802             LDR      R2,[R0, #+0]
   \   0000006E   0x231F             MOVS     R3,#+31
   \   00000070   0x439A             BICS     R2,R2,R3
   \   00000072   0x06C9             LSLS     R1,R1,#+27
   \   00000074   0x0EC9             LSRS     R1,R1,#+27
   \   00000076   0x4311             ORRS     R1,R1,R2
   \   00000078   0x6001             STR      R1,[R0, #+0]
    174          }
   \   0000007A   0xBD70             POP      {R4-R6,PC}       ;; return
    175          
    176          
    177          /**
    178          * @brief  Fills each SPI_InitStruct member with its default value.
    179          * @param  SPI_InitStruct: pointer to a @ref SPI_InitType structure which will be initialized.
    180          * @retval None
    181          */

   \                                 In section .text, align 2, keep-with-next
    182          void SPI_StructInit(SPI_InitType* SPI_InitStruct)
    183          {
    184            /* Initialize the SPI_Mode member */
    185            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
   \                     SPI_StructInit: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    186            
    187            /* Initialize the SPI_DataSize member */
    188            SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
   \   00000004   0x2107             MOVS     R1,#+7
   \   00000006   0x7041             STRB     R1,[R0, #+1]
    189            
    190            /* Initialize the SPI_CPOL member */
    191            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7081             STRB     R1,[R0, #+2]
    192            
    193            /* Initialize the SPI_CPHA member */
    194            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
   \   0000000C   0x70C1             STRB     R1,[R0, #+3]
    195            
    196            /* Initialize the SPI_BaudRate member */
    197            SPI_InitStruct->SPI_BaudRate = 1000000;
   \   0000000E   0x....             LDR      R1,??DataTable28_1  ;; 0xf4240
   \   00000010   0x6041             STR      R1,[R0, #+4]
    198          }
   \   00000012   0x4770             BX       LR               ;; return
    199          
    200          /**
    201          * @brief  Enables or disables the SPI peripheral.
    202          * @param  NewState: functional state @ref FunctionalState
    203          *         This parameter can be: ENABLE or DISABLE.
    204          * @retval None
    205          */

   \                                 In section .text, align 2, keep-with-next
    206          void SPI_Cmd(FunctionalState NewState)
    207          {
    208            /* Check the parameters */
    209            assert_param(IS_FUNCTIONAL_STATE(NewState));
    210            
    211            if (NewState != DISABLE) {
   \                     SPI_Cmd: (+1)
   \   00000000   0x....             LDR      R1,??DataTable28_2  ;; 0x40400004
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD003             BEQ      ??SPI_Cmd_0
    212              /* Enable the selected SPI peripheral */
    213              SPI1->CR1_b.SSE = SET;
   \   00000008   0x2202             MOVS     R2,#+2
   \   0000000A   0x4302             ORRS     R2,R2,R0
   \   0000000C   0x600A             STR      R2,[R1, #+0]
   \   0000000E   0x4770             BX       LR
    214            }
    215            else {
    216              /* Disable the selected SPI peripheral */
    217              SPI1->CR1_b.SSE = RESET;
   \                     ??SPI_Cmd_0: (+1)
   \   00000010   0x2202             MOVS     R2,#+2
   \   00000012   0x4390             BICS     R0,R0,R2
   \   00000014   0x6008             STR      R0,[R1, #+0]
    218            }
    219          }
   \   00000016   0x4770             BX       LR               ;; return
    220          
    221          /**
    222          * @brief  Enables or disables the specified SPI interrupts.
    223          * @param  SPI_IT: specifies the SPI interrupt source to be enabled or disabled. 
    224          *         This parameter can be any combination of the following values:
    225          *         @arg SPI_IT_TX: Transmit FIFO half empty or less condition interrupt mask.
    226          *         @arg SPI_IT_RX: Receive FIFO half full or less condition interrupt mask.
    227          *         @arg SPI_IT_RT: Receive FIFO not empty and no read prior to timeout period interrupt mask.
    228          *         @arg SPI_IT_ROR: Receive FIFO written to while full condition interrupt mask.
    229          *         @arg SPI_IT_TUR: Transmit underrun interrupt mask.
    230          *         @arg SPI_IT_TE: Transmit FIFO empty interrupt mask.
    231          * @param  NewState: functional state @ref FunctionalState
    232          *         This parameter can be: ENABLE or DISABLE.
    233          * @retval None
    234          */

   \                                 In section .text, align 2, keep-with-next
    235          void SPI_ITConfig(uint8_t SPI_IT, FunctionalState NewState)
    236          {
    237            /* Check the parameters */
    238            assert_param(IS_FUNCTIONAL_STATE(NewState));
    239            assert_param(IS_SPI_CONFIG_IT(SPI_IT));
    240            
    241            if (NewState != DISABLE) {
   \                     SPI_ITConfig: (+1)
   \   00000000   0x....             LDR      R2,??DataTable28_3  ;; 0x40400014
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0x7811             LDRB     R1,[R2, #+0]
   \   00000006   0xD002             BEQ      ??SPI_ITConfig_0
    242              /* Enable the selected SPI interrupts */
    243              SET_BIT(SPI1->IMSC, SPI_IT);
   \   00000008   0x4308             ORRS     R0,R0,R1
   \   0000000A   0x7010             STRB     R0,[R2, #+0]
   \   0000000C   0x4770             BX       LR
    244            }
    245            else {
    246              /* Disable the selected SPI interrupts */
    247              CLEAR_BIT(SPI1->IMSC, SPI_IT);
   \                     ??SPI_ITConfig_0: (+1)
   \   0000000E   0x4381             BICS     R1,R1,R0
   \   00000010   0x7011             STRB     R1,[R2, #+0]
    248            }
    249          }
   \   00000012   0x4770             BX       LR               ;; return
    250          
    251          
    252          /**
    253          * @brief  Enables or disables the output if in slave mode.
    254          * @param  NewState: functional state @ref FunctionalState
    255          *         This parameter can be: ENABLE or DISABLE.
    256          * @retval None
    257          */

   \                                 In section .text, align 2, keep-with-next
    258          void SPI_SlaveModeOutputCmd(FunctionalState NewState)
    259          {
    260            /* Check the parameters */
    261            assert_param(IS_FUNCTIONAL_STATE(NewState));
    262            
    263            if (NewState != DISABLE) {
   \                     SPI_SlaveModeOutputCmd: (+1)
   \   00000000   0x....             LDR      R1,??DataTable28_2  ;; 0x40400004
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD003             BEQ      ??SPI_SlaveModeOutputCmd_0
    264              /* Enable the output */
    265              SPI1->CR1_b.SOD = RESET;
   \   00000008   0x2208             MOVS     R2,#+8
   \   0000000A   0x4390             BICS     R0,R0,R2
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   \   0000000E   0x4770             BX       LR
    266            }
    267            else {
    268              /* Disable the output */
    269              SPI1->CR1_b.SOD = SET;
   \                     ??SPI_SlaveModeOutputCmd_0: (+1)
   \   00000010   0x2208             MOVS     R2,#+8
   \   00000012   0x4302             ORRS     R2,R2,R0
   \   00000014   0x600A             STR      R2,[R1, #+0]
    270            }
    271          }
   \   00000016   0x4770             BX       LR               ;; return
    272          
    273          /**
    274          * @brief  Transmits a Data through the SPI peripheral.
    275          * @param  Data: Data to be transmitted.
    276          * @retval None
    277          */

   \                                 In section .text, align 2, keep-with-next
    278          void SPI_SendData(uint32_t Data)
    279          {
    280            /* Write in the DR register the data to be sent */
    281            SPI1->DR = Data;
   \                     SPI_SendData: (+1)
   \   00000000   0x....             LDR      R1,??DataTable28_4  ;; 0x40400008
   \   00000002   0x6008             STR      R0,[R1, #+0]
    282          }
   \   00000004   0x4770             BX       LR               ;; return
    283          
    284          /**
    285          * @brief  Returns the most recent received data by the SPI peripheral. 
    286          * @param  None
    287          * @retval The value of the received data.
    288          */

   \                                 In section .text, align 2, keep-with-next
    289          uint32_t SPI_ReceiveData(void)
    290          {
    291            /* Return the data in the DR register */
    292            return SPI1->DR;
   \                     SPI_ReceiveData: (+1)
   \   00000000   0x....             LDR      R0,??DataTable28_4  ;; 0x40400008
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    293          }
    294          
    295          /**
    296          * @brief  Configures the data size for the selected SPI.
    297          * @param  SPI_DataSize: specifies the SPI data size.
    298          *         This parameter can be one of the following values:
    299          *         @arg SPI_DataSize_32b: Set data frame format to 32bit
    300          *         ...
    301          *         @arg SPI_DataSize_5b: Set data frame format to 5bit
    302          *         @arg SPI_DataSize_4b: Set data frame format to 4bit
    303          * @retval None
    304          */

   \                                 In section .text, align 2, keep-with-next
    305          void SPI_DataSizeConfig(uint16_t SPI_DataSize)
    306          {
    307            /* Check the parameters */
    308            assert_param(IS_SPI_DATASIZE(SPI_DataSize));
    309            
    310            /* set the datasize */  
    311            SPI1->CR0_b.DSS = SPI_DataSize;
   \                     SPI_DataSizeConfig: (+1)
   \   00000000   0x....             LDR      R1,??DataTable25  ;; 0x40400000
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x231F             MOVS     R3,#+31
   \   00000006   0x439A             BICS     R2,R2,R3
   \   00000008   0x06C0             LSLS     R0,R0,#+27
   \   0000000A   0x0EC0             LSRS     R0,R0,#+27
   \   0000000C   0x4310             ORRS     R0,R0,R2
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    312          }
   \   00000010   0x4770             BX       LR               ;; return
    313          
    314          /**
    315          * @brief  Configures the command size for the selected SPI.
    316          * @param  SPI_DataSize: specifies the SPI command size.
    317          *         This parameter can be one of the following values:
    318          *         @arg SPI_DataSize_32b: Set data frame format to 32bit
    319          *         ...
    320          *         @arg SPI_DataSize_5b: Set data frame format to 5bit
    321          *         @arg SPI_DataSize_4b: Set data frame format to 4bit
    322          * @retval None
    323          */

   \                                 In section .text, align 2, keep-with-next
    324          void SPI_CommandSizeConfig(uint16_t SPI_DataSize)
    325          {
    326            /* Check the parameters */
    327            assert_param(IS_SPI_DATASIZE(SPI_DataSize));
    328            
    329            /* set the datasize */  
    330            SPI1->CR0_b.CSS = SPI_DataSize;
   \                     SPI_CommandSizeConfig: (+1)
   \   00000000   0x....             LDR      R1,??DataTable25  ;; 0x40400000
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x....             LDR      R3,??DataTable28_5  ;; 0xffe0ffff
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x0400             LSLS     R0,R0,#+16
   \   0000000A   0x22F8             MOVS     R2,#+248
   \   0000000C   0x0352             LSLS     R2,R2,#+13       ;; #+2031616
   \   0000000E   0x4002             ANDS     R2,R2,R0
   \   00000010   0x431A             ORRS     R2,R2,R3
   \   00000012   0x600A             STR      R2,[R1, #+0]
    331          }
   \   00000014   0x4770             BX       LR               ;; return
    332          
    333          /**
    334          * @brief  Enable the wait state only for Microwire mode.
    335          * @param  NewState: functional state @ref FunctionalState
    336          *         This parameter can be: ENABLE or DISABLE.
    337          * @retval None
    338          */

   \                                 In section .text, align 2, keep-with-next
    339          void SPI_EnableWaitState(FunctionalState NewState)
    340          {
    341            /* Check the parameters */
    342            assert_param(IS_FUNCTIONAL_STATE(NewState));
    343            
    344            if (NewState != DISABLE) {
   \                     SPI_EnableWaitState: (+1)
   \   00000000   0x....             LDR      R1,??DataTable28_6  ;; 0xfffc3fff
   \   00000002   0x....             LDR      R2,??DataTable28_2  ;; 0x40400004
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0x6810             LDR      R0,[R2, #+0]
   \   00000008   0xD002             BEQ      ??SPI_EnableWaitState_0
    345              /* Enable the wait state  */
    346              SPI1->CR1_b.MSPIWAIT = RESET;
   \   0000000A   0x4001             ANDS     R1,R1,R0
   \   0000000C   0x6011             STR      R1,[R2, #+0]
   \   0000000E   0x4770             BX       LR
    347            }
    348            else {
    349              /* Disable the wait state  */
    350              SPI1->CR1_b.MSPIWAIT = SET;
   \                     ??SPI_EnableWaitState_0: (+1)
   \   00000010   0x4001             ANDS     R1,R1,R0
   \   00000012   0x2080             MOVS     R0,#+128
   \   00000014   0x01C0             LSLS     R0,R0,#+7        ;; #+16384
   \   00000016   0x4308             ORRS     R0,R0,R1
   \   00000018   0x6010             STR      R0,[R2, #+0]
    351            }
    352          }
   \   0000001A   0x4770             BX       LR               ;; return
    353          
    354          
    355          /**
    356          * @brief  Configures the frame format for the selected SPI.
    357          * @param  SPI_FrameFormat: specifies the SPI frame format.
    358          *         This parameter can be one of the following values:
    359          *         @arg SPI_FrmFrmt_Motorola: Set the Motorola SPI frame format
    360          *         @arg SPI_FrmFrmt_Microwire: Set the MicroWire frame format
    361          * @retval None
    362          */

   \                                 In section .text, align 2, keep-with-next
    363          void SPI_FrameFormatConfig(uint8_t SPI_FrameFormat)
    364          {
    365            /* Check the parameters */
    366            assert_param(IS_SPI_FRMFRMT(SPI_FrameFormat));
    367            
    368            /* set the datasize */  
    369            SPI1->CR0_b.FRF = SPI_FrameFormat;
   \                     SPI_FrameFormatConfig: (+1)
   \   00000000   0x....             LDR      R1,??DataTable25  ;; 0x40400000
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x....             LDR      R3,??DataTable28_7  ;; 0xff9fffff
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x0540             LSLS     R0,R0,#+21
   \   0000000A   0x22C0             MOVS     R2,#+192
   \   0000000C   0x03D2             LSLS     R2,R2,#+15       ;; #+6291456
   \   0000000E   0x4002             ANDS     R2,R2,R0
   \   00000010   0x431A             ORRS     R2,R2,R3
   \   00000012   0x600A             STR      R2,[R1, #+0]
    370          }
   \   00000014   0x4770             BX       LR               ;; return
    371          
    372          
    373          /**
    374          * @brief  Checks whether the specified SPI flag is set or not.
    375          * @param  SPI_FLAG: specifies the SPI flag to check. 
    376          *         This parameter can be any combination of the following values:
    377          *         @arg SPI_IT_TX: Transmit FIFO half empty or less condition interrupt mask.
    378          *         @arg SPI_IT_RX: Receive FIFO half full or less condition interrupt mask.
    379          *         @arg SPI_IT_RT: Receive FIFO not empty and no read prior to timeout period interrupt mask.
    380          *         @arg SPI_IT_ROR: Receive FIFO written to while full condition interrupt mask.
    381          *         @arg SPI_IT_TUR: Transmit underrun interrupt mask.
    382          *         @arg SPI_IT_TE: Transmit FIFO empty interrupt mask.
    383          * @retval FlagStatus: functional state @ref FlagStatus
    384          *         This parameter can be: SET or RESET.
    385          */

   \                                 In section .text, align 2, keep-with-next
    386          FlagStatus SPI_GetFlagStatus(uint16_t SPI_FLAG)
    387          {
   \                     SPI_GetFlagStatus: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    388            /* Check the parameters */
    389            assert_param(IS_SPI_GET_FLAG(SPI_FLAG));
    390            
    391            /* Check the status of the specified SPI flag */
    392            if (READ_BIT(SPI1->SR, SPI_FLAG) != (uint16_t)RESET) {
   \   00000002   0x....             LDR      R0,??DataTable28_8  ;; 0x4040000c
   \   00000004   0x....             B.N      ?Subroutine0
    393              /* SPI_FLAG is set */
    394              return SET;
    395            }
    396            else {
    397              /* SPI_FLAG is reset */
    398              return RESET;
    399            }
    400            
    401          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x7800             LDRB     R0,[R0, #+0]
   \   00000002   0x4001             ANDS     R1,R1,R0
   \   00000004   0x1E48             SUBS     R0,R1,#+1
   \   00000006   0x4180             SBCS     R0,R0,R0
   \   00000008   0x43C0             MVNS     R0,R0
   \   0000000A   0x0FC0             LSRS     R0,R0,#+31
   \   0000000C   0x4770             BX       LR               ;; return
    402          
    403          /**
    404          * @brief  Checks whether the specified SPI interrupt has occurred or not.
    405          * @param  SPI_IT: specifies the SPI interrupt source to check. 
    406          *         This parameter can be one of the following values:
    407          *         @arg SPI_IT_TX: Transmit FIFO half empty or less condition interrupt mask.
    408          *         @arg SPI_IT_RX: Receive FIFO half full or less condition interrupt mask.
    409          *         @arg SPI_IT_RT: Receive FIFO not empty and no read prior to timeout period interrupt mask.
    410          *         @arg SPI_IT_ROR: Receive FIFO written to while full condition interrupt mask.
    411          *         @arg SPI_IT_TUR: Transmit underrun interrupt mask.
    412          *         @arg SPI_IT_TE: Transmit FIFO empty interrupt mask.
    413          * @retval  ITStatus: functional state @ref ITStatus
    414          *         This parameter can be: SET or RESET.
    415          */

   \                                 In section .text, align 2, keep-with-next
    416          ITStatus SPI_GetITStatus(uint8_t SPI_IT)
    417          {
   \                     SPI_GetITStatus: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    418            /* Check the parameters */
    419            assert_param(IS_SPI_GET_IT(SPI_IT));
    420            
    421            /* Check the status of the specified SPI interrupt */
    422            if (READ_BIT(SPI1->RIS, SPI_IT) != (uint16_t)RESET) {
   \   00000002   0x....             LDR      R0,??DataTable28_9  ;; 0x40400018
   \   00000004                      REQUIRE ?Subroutine0
   \   00000004                      ;; // Fall through to label ?Subroutine0
    423              /* SPI_IT is set */
    424              return SET;
    425            }
    426            else {
    427              /* SPI_IT is reset */
    428              return RESET;
    429            }
    430            
    431          }
    432          
    433          /**
    434          * @brief  Clears the SPI interrupt pending bits.
    435          * @param  SPI_IT: specifies the SPI interrupt pending bit to clear.
    436          *         This parameter can be one of the following values:
    437          *         @arg SPI_IT_TX: Transmit FIFO half empty or less condition interrupt mask.
    438          *         @arg SPI_IT_RX: Receive FIFO half full or less condition interrupt mask.
    439          *         @arg SPI_IT_RT: Receive FIFO not empty and no read prior to timeout period interrupt mask.
    440          *         @arg SPI_IT_ROR: Receive FIFO written to while full condition interrupt mask.
    441          *         @arg SPI_IT_TUR: Transmit underrun interrupt mask.
    442          *         @arg SPI_IT_TE: Transmit FIFO empty interrupt mask.
    443          * @retval None
    444          */

   \                                 In section .text, align 2, keep-with-next
    445          void SPI_ClearITPendingBit(uint8_t SPI_IT)
    446          {
    447            /* Check the parameters */
    448            assert_param(IS_SPI_CLEAR_IT(SPI_IT));
    449            
    450            /* Clear the selected SPI interrupt pending bit */
    451            CLEAR_BIT(SPI1->ICR, SPI_IT);
   \                     SPI_ClearITPendingBit: (+1)
   \   00000000   0x....             LDR      R1,??DataTable28_10  ;; 0x40400020
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0x4382             BICS     R2,R2,R0
   \   00000006   0x700A             STRB     R2,[R1, #+0]
    452          }
   \   00000008   0x4770             BX       LR               ;; return
    453          
    454          /**
    455          * @brief  Clear all data present within the RX FIFO of the SPI peripherial.
    456          *					SPI peripherial clocks have to be enabled first before the use.
    457          * @param  None
    458          * @retval None
    459          */

   \                                 In section .text, align 2, keep-with-next
    460          void SPI_ClearRXFIFO(void)
    461          {
   \                     SPI_ClearRXFIFO: (+1)
   \   00000000   0x....             LDR      R0,??DataTable28_4  ;; 0x40400008
   \   00000002   0xE000             B        ??SPI_ClearRXFIFO_0
    462            /* Flush the data from SPI RX FIFO */
    463            while(SET == SPI_GetFlagStatus(SPI_FLAG_RNE) ) {
    464              SPI_ReceiveData();
   \                     ??SPI_ClearRXFIFO_1: (+1)
   \   00000004   0x6801             LDR      R1,[R0, #+0]
    465            }	
   \                     ??SPI_ClearRXFIFO_0: (+1)
   \   00000006   0x7901             LDRB     R1,[R0, #+4]
   \   00000008   0x0749             LSLS     R1,R1,#+29
   \   0000000A   0xD4FB             BMI      ??SPI_ClearRXFIFO_1
    466          }
   \   0000000C   0x4770             BX       LR               ;; return
    467          
    468          /**
    469          * @brief  Clear all data present within the TX FIFO of the SPI peripherial.
    470          *					SPI peripherial clocks have to be enabled first before the use.
    471          * @param  None
    472          * @retval None
    473          */

   \                                 In section .text, align 2, keep-with-next
    474          void SPI_ClearTXFIFO(void)
    475          {
    476            uint32_t tmp;
    477          
    478            /* Enable read from the TX FIFO */
    479            SPI1->ITCR_b.SWAPFIFO = SET;
   \                     SPI_ClearTXFIFO: (+1)
   \   00000000   0x....             LDR      R0,??DataTable28_11  ;; 0x40400080
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0x2202             MOVS     R2,#+2
   \   00000006   0x430A             ORRS     R2,R2,R1
   \   00000008   0x7002             STRB     R2,[R0, #+0]
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x....             LDR      R2,??DataTable28_8  ;; 0x4040000c
   \   0000000E   0xE000             B        ??SPI_ClearTXFIFO_0
    480            
    481            /* Flush the data from the TX FIFO till it is not empty. */
    482            while(0 == SPI1->SR_b.TFE) {
    483              tmp |= SPI1->TDR;
   \                     ??SPI_ClearTXFIFO_1: (+1)
   \   00000010   0x68C3             LDR      R3,[R0, #+12]
    484            }
   \                     ??SPI_ClearTXFIFO_0: (+1)
   \   00000012   0x7813             LDRB     R3,[R2, #+0]
   \   00000014   0x420B             TST      R3,R1
   \   00000016   0xD0FB             BEQ      ??SPI_ClearTXFIFO_1
    485            
    486            /* Disable the read from the TX FIFO */
    487            SPI1->ITCR_b.SWAPFIFO = RESET;
   \   00000018   0x7801             LDRB     R1,[R0, #+0]
   \   0000001A   0x22FD             MOVS     R2,#+253
   \   0000001C   0x400A             ANDS     R2,R2,R1
   \   0000001E   0x7002             STRB     R2,[R0, #+0]
    488          
    489          }
   \   00000020   0x4770             BX       LR               ;; return
    490          
    491          /**
    492          * @brief Set the SPI communication mode.
    493          * @param  Mode: specifies the SPI communication mode.
    494          *         This parameter can be one of the following values:
    495          *         @arg SPI_FULL_DUPLEX_MODE:  SPI full duplex communication mode.
    496          *         @arg SPI_TRANSMIT_MODE: SPI transmit communication mode.
    497          *         @arg SPI_RECEIVE_MODE: SPI receive communication mode.
    498          *					@arg SPI_COMBINED_MODE: SPI combined communication mode.
    499          * @retval None
    500          */

   \                                 In section .text, align 2, keep-with-next
    501          void SPI_SetMasterCommunicationMode(uint32_t Mode)
    502          {
    503            /* Check the parameters */
    504            assert_param(IS_SPI_COM_MODE(Mode));
    505            
    506            /* Set the communication mode */
    507            SPI1->CR0_b.SPIM = Mode;
   \                     SPI_SetMasterCommunicationMode: (+1)
   \   00000000   0x....             LDR      R1,??DataTable25  ;; 0x40400000
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x....             LDR      R3,??DataTable28_12  ;; 0xfe7fffff
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x05C0             LSLS     R0,R0,#+23
   \   0000000A   0x22C0             MOVS     R2,#+192
   \   0000000C   0x0452             LSLS     R2,R2,#+17       ;; #+25165824
   \   0000000E   0x4002             ANDS     R2,R2,R0
   \   00000010   0x431A             ORRS     R2,R2,R3
   \   00000012   0x600A             STR      R2,[R1, #+0]
    508          }
   \   00000014   0x4770             BX       LR               ;; return
    509          
    510          /**
    511          * @brief Set the dummy character used for the SPI master communication.
    512          * @param  NullCharacter: Dummy character to be used.
    513          * @retval None
    514          */

   \                                 In section .text, align 2, keep-with-next
    515          void SPI_SetDummyCharacter(uint32_t NullCharacter)
    516          {
    517            /* Set the dummy character */
    518            SPI1->CHN = NullCharacter;
   \                     SPI_SetDummyCharacter: (+1)
   \   00000000   0x....             LDR      R1,??DataTable28_13  ;; 0x4040002c
   \   00000002   0x6008             STR      R0,[R1, #+0]
    519          }
   \   00000004   0x4770             BX       LR               ;; return
    520          
    521          /**
    522          * @brief Set the number of frames to receive from slave.
    523          * @param  Number: Number of frames to receive.
    524          * @retval None
    525          */

   \                                 In section .text, align 2, keep-with-next
    526          void SPI_SetNumFramesToReceive(uint16_t Number)
    527          {
    528            /* Set the number of frames to receive */
    529            SPI1->RXFRM = Number;
   \                     SPI_SetNumFramesToReceive: (+1)
   \   00000000   0x....             LDR      R1,??DataTable28_14  ;; 0x40400028
   \   00000002   0x8008             STRH     R0,[R1, #+0]
    530          }
   \   00000004   0x4770             BX       LR               ;; return
    531          
    532          /**
    533          * @brief Set the number of frames to transmit to slave
    534          * @param  Number: Number of frames to transmit.
    535          * @retval None
    536          */

   \                                 In section .text, align 2, keep-with-next
    537          void SPI_SetNumFramesToTransmit(uint16_t Number)
    538          {
    539            /* Set the number of frames to transmit */
    540            SPI1->WDTXF = Number;
   \                     SPI_SetNumFramesToTransmit: (+1)
   \   00000000   0x....             LDR      R1,??DataTable28_15  ;; 0x40400030
   \   00000002   0x8008             STRH     R0,[R1, #+0]
    541          }
   \   00000004   0x4770             BX       LR               ;; return
    542          
    543          
    544          /**
    545          * @brief  Master can select the slave by driving the CS pin by software.
    546          * @param  NewState: functional state @ref FunctionalState
    547          *         This parameter can be: ENABLE or DISABLE.
    548          * @retval None
    549          */

   \                                 In section .text, align 2, keep-with-next
    550          void SPI_SlaveSwSelection(FunctionalState NewState)
    551          {
    552            /* Check the parameters */
    553            assert_param(IS_FUNCTIONAL_STATE(NewState));
    554            
    555            if (NewState != DISABLE) {
   \                     SPI_SlaveSwSelection: (+1)
   \   00000000   0x....             LDR      R1,??DataTable25  ;; 0x40400000
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD002             BEQ      ??SPI_SlaveSwSelection_0
    556              /* Enable the output */
    557              SPI1->CR0_b.CS1 = RESET;
   \   00000008   0x....             LDR      R2,??DataTable28_16  ;; 0xfbffffff
   \   0000000A   0x4002             ANDS     R2,R2,R0
   \   0000000C   0xE002             B        ??SPI_SlaveSwSelection_1
    558            }
    559            else {
    560              /* Disable the output */
    561              SPI1->CR0_b.CS1 = SET;
   \                     ??SPI_SlaveSwSelection_0: (+1)
   \   0000000E   0x2280             MOVS     R2,#+128
   \   00000010   0x04D2             LSLS     R2,R2,#+19       ;; #+67108864
   \   00000012   0x4302             ORRS     R2,R2,R0
   \                     ??SPI_SlaveSwSelection_1: (+1)
   \   00000014   0x600A             STR      R2,[R1, #+0]
    562            }
    563          }
   \   00000016   0x4770             BX       LR               ;; return
    564          
    565          /**
    566          * @brief  Master can select the slave by driving the CS pin by software.
    567          * @param  Endian: the endian format @ref SPI_Endian_Format_Definition
    568          * @retval None
    569          */

   \                                 In section .text, align 2, keep-with-next
    570          void SPI_EndianFormatReception(uint8_t Endian)
    571          {
    572            /* Check the parameters */
    573            assert_param(IS_SPI_ENDIAN(Endian));
    574            
    575            SPI1->CR1_b.RENDN = Endian;
   \                     SPI_EndianFormatReception: (+1)
   \   00000000   0x....             LDR      R1,??DataTable28_2  ;; 0x40400004
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x2330             MOVS     R3,#+48
   \   00000006   0x439A             BICS     R2,R2,R3
   \   00000008   0x0100             LSLS     R0,R0,#+4
   \   0000000A   0x4003             ANDS     R3,R3,R0
   \   0000000C   0x4313             ORRS     R3,R3,R2
   \   0000000E   0x600B             STR      R3,[R1, #+0]
    576          }
   \   00000010   0x4770             BX       LR               ;; return
    577          
    578          /**
    579          * @brief  Master can select the slave by driving the CS pin by software.
    580          * @param  Endian: the endian format @ref SPI_Endian_Format_Definition
    581          * @retval None
    582          */

   \                                 In section .text, align 2, keep-with-next
    583          void SPI_EndianFormatTransmission(uint8_t Endian)
    584          {
    585            /* Check the parameters */
    586            assert_param(IS_SPI_ENDIAN(Endian));
    587            
    588            SPI1->CR1_b.TENDN = Endian;
   \                     SPI_EndianFormatTransmission: (+1)
   \   00000000   0x....             LDR      R1,??DataTable28_2  ;; 0x40400004
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x....             LDR      R3,??DataTable28_17  ;; 0xfff3ffff
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x0480             LSLS     R0,R0,#+18
   \   0000000A   0x22C0             MOVS     R2,#+192
   \   0000000C   0x0312             LSLS     R2,R2,#+12       ;; #+786432
   \   0000000E   0x4002             ANDS     R2,R2,R0
   \   00000010   0x431A             ORRS     R2,R2,R3
   \   00000012   0x600A             STR      R2,[R1, #+0]
    589          }
   \   00000014   0x4770             BX       LR               ;; return
    590          
    591          
    592          /**
    593          * @brief  Configure the delay between the frames.
    594          *         The MSPIWAIT value is used to insert a wait state between frames.
    595          *         The SSPFRM pulse duration is given by the equation:
    596          *         SSPCLKOUT x {MSPIWAIT - (SCR-1) / [2x(SCR+1)]}.
    597          *         When SCR=1, MSPIWAIT indicates the number of SSPCLKO cycle that
    598          *         the SSPFRM pulse duration should have between frames. 
    599          * @param  Delay: this value must be less than or equal to 15.
    600          *         0 means no delay (default).
    601          * @retval None
    602          */

   \                                 In section .text, align 2, keep-with-next
    603          void SPI_DelayBetweenFrames(uint8_t Delay)
    604          {
    605            /* Check the parameters */
    606            assert_param(IS_SPI_ENDIAN(Delay));
    607            
    608            SPI1->CR1_b.MSPIWAIT = Delay;
   \                     SPI_DelayBetweenFrames: (+1)
   \   00000000   0x....             LDR      R1,??DataTable28_2  ;; 0x40400004
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x....             LDR      R3,??DataTable28_6  ;; 0xfffc3fff
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x0380             LSLS     R0,R0,#+14
   \   0000000A   0x22F0             MOVS     R2,#+240
   \   0000000C   0x0292             LSLS     R2,R2,#+10       ;; #+245760
   \   0000000E   0x4002             ANDS     R2,R2,R0
   \   00000010   0x431A             ORRS     R2,R2,R3
   \   00000012   0x600A             STR      R2,[R1, #+0]
    609          }
   \   00000014   0x4770             BX       LR               ;; return
    610          
    611          
    612          /**
    613          * @brief  Master insert a delay of two clock cycle if enabled.
    614          * @param  NewState: functional state @ref FunctionalState
    615          *         This parameter can be: ENABLE or DISABLE.
    616          * @retval None
    617          */

   \                                 In section .text, align 2, keep-with-next
    618          void SPI_DelayDataInput(FunctionalState NewState)
    619          {
    620            /* Check the parameters */
    621            assert_param(IS_FUNCTIONAL_STATE(NewState));
    622            
    623            if (NewState != DISABLE) {
   \                     SPI_DelayDataInput: (+1)
   \   00000000   0x....             LDR      R1,??DataTable28_2  ;; 0x40400004
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD002             BEQ      ??SPI_DelayDataInput_0
    624              /* Enable the output */
    625              SPI1->CR1_b.DATAINDEL = RESET;
   \   00000008   0x....             LDR      R2,??DataTable28_18  ;; 0xffdfffff
   \   0000000A   0x4002             ANDS     R2,R2,R0
   \   0000000C   0xE002             B        ??SPI_DelayDataInput_1
    626            }
    627            else {
    628              /* Disable the output */
    629              SPI1->CR1_b.DATAINDEL = SET;
   \                     ??SPI_DelayDataInput_0: (+1)
   \   0000000E   0x2280             MOVS     R2,#+128
   \   00000010   0x0392             LSLS     R2,R2,#+14       ;; #+2097152
   \   00000012   0x4302             ORRS     R2,R2,R0
   \                     ??SPI_DelayDataInput_1: (+1)
   \   00000014   0x600A             STR      R2,[R1, #+0]
    630            }
    631          }
   \   00000016   0x4770             BX       LR               ;; return
    632          
    633          
    634          /**
    635            * @brief  Sets the SPI interrupt FIFO level.
    636            * @param  SPI_TX_FIFO_LEV: specifies the transmit interrupt FIFO level.
    637            *   This parameter can be one of the following values:
    638            *   @arg FIFO_TX_LEV_1: interrupt when TX FIFO contains 1 element or more
    639            *   @arg FIFO_TX_LEV_4: interrupt when TX FIFO contains 4 elements or more
    640            *   @arg FIFO_TX_LEV_8: interrupt when TX FIFO contains 8 elements or more
    641            * @retval None
    642            */

   \                                 In section .text, align 2, keep-with-next
    643          void SPI_TxFifoInterruptLevelConfig(uint8_t SPI_TX_FIFO_LEV)
    644          {
    645              /* Check the parameters */
    646            assert_param(IS_SPI_FIFO_LEV(SPI_TX_FIFO_LEV));
    647          
    648            SPI1->CR1_b.TXIFLSEL = SPI_TX_FIFO_LEV;
   \                     SPI_TxFifoInterruptLevelConfig: (+1)
   \   00000000   0x....             LDR      R1,??DataTable28_2  ;; 0x40400004
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x....             LDR      R3,??DataTable28_19  ;; 0xffffe3ff
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x0280             LSLS     R0,R0,#+10
   \   0000000A   0x22E0             MOVS     R2,#+224
   \   0000000C   0x0152             LSLS     R2,R2,#+5        ;; #+7168
   \   0000000E   0x4002             ANDS     R2,R2,R0
   \   00000010   0x431A             ORRS     R2,R2,R3
   \   00000012   0x600A             STR      R2,[R1, #+0]
    649          }
   \   00000014   0x4770             BX       LR               ;; return
    650          
    651          /**
    652            * @brief  Sets the SPI interrupt FIFO level.
    653            * @param  SPI_RX_FIFO_LEV: specifies the receive interrupt FIFO level.
    654            *   This parameter can be one of the following values:
    655            *   @arg FIFO_RX_LEV_1: interrupt when RX FIFO contains 1 element or more
    656            *   @arg FIFO_RX_LEV_4: interrupt when RX FIFO contains 4 elements or more
    657            *   @arg FIFO_RX_LEV_8: interrupt when RX FIFO contains 8 elements or more
    658            *   
    659            * @retval None
    660            */

   \                                 In section .text, align 2, keep-with-next
    661          void SPI_RxFifoInterruptLevelConfig(uint8_t SPI_RX_FIFO_LEV)
    662          {
    663              /* Check the parameters */
    664            assert_param(IS_SPI_FIFO_LEV(SPI_RX_FIFO_LEV));
    665          
    666            SPI1->CR1_b.RXIFLSEL = SPI_RX_FIFO_LEV;
   \                     SPI_RxFifoInterruptLevelConfig: (+1)
   \   00000000   0x....             LDR      R1,??DataTable28_2  ;; 0x40400004
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x....             LDR      R3,??DataTable28_20  ;; 0xfffffc7f
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x01C0             LSLS     R0,R0,#+7
   \   0000000A   0x22E0             MOVS     R2,#+224
   \   0000000C   0x0092             LSLS     R2,R2,#+2        ;; #+896
   \   0000000E   0x4002             ANDS     R2,R2,R0
   \   00000010   0x431A             ORRS     R2,R2,R3
   \   00000012   0x600A             STR      R2,[R1, #+0]
    667          }
   \   00000014   0x4770             BX       LR               ;; return
    668          
    669          /**
    670            * @brief  Enables or disables the SPI DMA interface.
    671            * @param  SPI_DMAReq: specifies the DMA request.
    672            *   This parameter can be any combination of the following values:
    673            *     @arg SPI_DMAReq_Tx: SPI DMA transmit request
    674            *     @arg SPI_DMAReq_Rx: SPI DMA receive request.
    675            * @param  NewState: functional state @ref FunctionalState
    676            *   This parameter can be: ENABLE or DISABLE.   
    677            * @retval None
    678            */

   \                                 In section .text, align 2, keep-with-next
    679          void SPI_DMACmd(uint8_t SPI_DMAReq, FunctionalState NewState)
    680          {
    681            /* Check the parameters */
    682            assert_param(IS_SPI_DMAREQ(SPI_DMAReq));  
    683            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
    684          
    685            if (NewState != DISABLE)
   \                     SPI_DMACmd: (+1)
   \   00000000   0x....             LDR      R2,??DataTable28_21  ;; 0x40400024
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0x7811             LDRB     R1,[R2, #+0]
   \   00000006   0xD002             BEQ      ??SPI_DMACmd_0
    686            {
    687              /* Enable the DMA transfer */
    688              SPI1->DMACR |= SPI_DMAReq;
   \   00000008   0x4308             ORRS     R0,R0,R1
   \   0000000A   0x7010             STRB     R0,[R2, #+0]
   \   0000000C   0x4770             BX       LR
    689            }
    690            else
    691            {
    692              /* Disable the DMA transfer */
    693              SPI1->DMACR &= (uint8_t)~SPI_DMAReq;
   \                     ??SPI_DMACmd_0: (+1)
   \   0000000E   0x4381             BICS     R1,R1,R0
   \   00000010   0x7011             STRB     R1,[R2, #+0]
    694            }
    695          }
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x0000FE01         DC32     0xfe01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x40400000         DC32     0x40400000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0xFFFF00FF         DC32     0xffff00ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   0x40400004         DC32     0x40400004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   0x40400014         DC32     0x40400014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \   00000000   0x40400008         DC32     0x40400008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \   00000000   0xFFE0FFFF         DC32     0xffe0ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_6:
   \   00000000   0xFFFC3FFF         DC32     0xfffc3fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_7:
   \   00000000   0xFF9FFFFF         DC32     0xff9fffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_8:
   \   00000000   0x4040000C         DC32     0x4040000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_9:
   \   00000000   0x40400018         DC32     0x40400018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_10:
   \   00000000   0x40400020         DC32     0x40400020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_11:
   \   00000000   0x40400080         DC32     0x40400080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_12:
   \   00000000   0xFE7FFFFF         DC32     0xfe7fffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_13:
   \   00000000   0x4040002C         DC32     0x4040002c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_14:
   \   00000000   0x40400028         DC32     0x40400028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_15:
   \   00000000   0x40400030         DC32     0x40400030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_16:
   \   00000000   0xFBFFFFFF         DC32     0xfbffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_17:
   \   00000000   0xFFF3FFFF         DC32     0xfff3ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_18:
   \   00000000   0xFFDFFFFF         DC32     0xffdfffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_19:
   \   00000000   0xFFFFE3FF         DC32     0xffffe3ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_20:
   \   00000000   0xFFFFFC7F         DC32     0xfffffc7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_21:
   \   00000000   0x40400024         DC32     0x40400024
    696          
    697          /**
    698          * @}
    699          */ 
    700          
    701          /**
    702          * @}
    703          */ 
    704          
    705          /**
    706          * @}
    707          */ 
    708          
    709          /******************* (C) COPYRIGHT 2016 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   SPI_ClearITPendingBit
       0   SPI_ClearRXFIFO
       0   SPI_ClearTXFIFO
       0   SPI_Cmd
       0   SPI_CommandSizeConfig
       0   SPI_DMACmd
       0   SPI_DataSizeConfig
       0   SPI_DeInit
       0   SPI_DelayBetweenFrames
       0   SPI_DelayDataInput
       0   SPI_EnableWaitState
       0   SPI_EndianFormatReception
       0   SPI_EndianFormatTransmission
       0   SPI_FrameFormatConfig
       0   SPI_GetFlagStatus
       0   SPI_GetITStatus
       0   SPI_ITConfig
      16   SPI_Init
        16 __aeabi_uidiv
       0   SPI_ReceiveData
       0   SPI_RxFifoInterruptLevelConfig
       0   SPI_SendData
      12   SPI_SetBaudrate
        12 __aeabi_uidiv
       0   SPI_SetDummyCharacter
       0   SPI_SetMasterCommunicationMode
       0   SPI_SetNumFramesToReceive
       0   SPI_SetNumFramesToTransmit
       0   SPI_SlaveModeOutputCmd
       0   SPI_SlaveSwSelection
       0   SPI_StructInit
       0   SPI_TxFifoInterruptLevelConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable25
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_10
       4  ??DataTable28_11
       4  ??DataTable28_12
       4  ??DataTable28_13
       4  ??DataTable28_14
       4  ??DataTable28_15
       4  ??DataTable28_16
       4  ??DataTable28_17
       4  ??DataTable28_18
       4  ??DataTable28_19
       4  ??DataTable28_2
       4  ??DataTable28_20
       4  ??DataTable28_21
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable28_7
       4  ??DataTable28_8
       4  ??DataTable28_9
      14  ?Subroutine0
      10  SPI_ClearITPendingBit
      14  SPI_ClearRXFIFO
      34  SPI_ClearTXFIFO
      24  SPI_Cmd
      22  SPI_CommandSizeConfig
      20  SPI_DMACmd
      18  SPI_DataSizeConfig
      30  SPI_DeInit
      22  SPI_DelayBetweenFrames
      24  SPI_DelayDataInput
      28  SPI_EnableWaitState
      18  SPI_EndianFormatReception
      22  SPI_EndianFormatTransmission
      22  SPI_FrameFormatConfig
       6  SPI_GetFlagStatus
       4  SPI_GetITStatus
      20  SPI_ITConfig
     124  SPI_Init
       6  SPI_ReceiveData
      22  SPI_RxFifoInterruptLevelConfig
       6  SPI_SendData
      58  SPI_SetBaudrate
       6  SPI_SetDummyCharacter
      22  SPI_SetMasterCommunicationMode
       6  SPI_SetNumFramesToReceive
       6  SPI_SetNumFramesToTransmit
      24  SPI_SlaveModeOutputCmd
      24  SPI_SlaveSwSelection
      20  SPI_StructInit
      22  SPI_TxFifoInterruptLevelConfig

 
 798 bytes in section .text
 
 798 bytes of CODE memory

Errors: none
Warnings: 1

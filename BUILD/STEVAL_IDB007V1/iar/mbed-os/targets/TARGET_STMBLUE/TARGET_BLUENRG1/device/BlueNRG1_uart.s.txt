###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       19/Mar/2018  13:33:59
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        .\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_uart.c
#    Command line =  
#        --no_wrap_diagnostics -e --diag_suppress=Pa050,Pa084,Pa093,Pa082 -Oh
#        --enable_restrict --cpu Cortex-M0 --thumb --dlib_config
#        DLib_Config_Full.h --vla -DTARGET_CORTEX -DTARGET_UVISOR_UNSUPPORTED
#        -DTARGET_STMBLUE -D__MBED_CMSIS_RTOS_CM -DTARGET_STEVAL_IDB007V1
#        -DMBED_BUILD_TIMESTAMP=1521462769.94 -DTARGET_CORTEX_M -DDEVICE_SPI=1
#        -DTARGET_LIKE_MBED -DARM_MATH_CM0 -DTARGET_RELEASE -D__CORTEX_M0
#        -DTARGET_BLUENRG1 -D__MBED__=1 -DTARGET_M0 -DTOOLCHAIN_object
#        -DDEVICE_SERIAL=1 -D__CMSIS_RTOS -DTOOLCHAIN_IAR
#        -DTARGET_LIKE_CORTEX_M0 -DFEATURE_BLE=1 -f
#        .\BUILD\STEVAL_IDB007V1\IAR\.includes_dcedd7aa577106f9c79229685e6ddb41.txt
#        (-I. -I./BLUE1 -I./BLUE1/Bluetooth_LE -I./BLUE1/Bluetooth_LE/inc
#        -I./BLUE1/Bluetooth_LE/library -I./BLUE1/LSM6DS3 -I./BLUE1/SensorDemo
#        -I./BLUE1/sdk_hal -I./BLUE1/sdk_hal/inc -I./BLUE1/sdk_hal/src
#        -I./Beacon_inc -I./mbed-os -I./mbed-os/cmsis
#        -I./mbed-os/cmsis/TARGET_CORTEX_M
#        -I./mbed-os/cmsis/TARGET_CORTEX_M/TOOLCHAIN_IAR -I./mbed-os/drivers
#        -I./mbed-os/events -I./mbed-os/events/equeue -I./mbed-os/features
#        -I./mbed-os/features/FEATURE_BLE -I./mbed-os/features/FEATURE_BLE/ble
#        -I./mbed-os/features/FEATURE_BLE/ble/generic
#        -I./mbed-os/features/FEATURE_BLE/ble/pal
#        -I./mbed-os/features/FEATURE_BLE/ble/services
#        -I./mbed-os/features/FEATURE_BLE/source
#        -I./mbed-os/features/FEATURE_BLE/source/generic
#        -I./mbed-os/features/FEATURE_BLE/source/services
#        -I./mbed-os/features/FEATURE_BLE/targets
#        -I./mbed-os/features/filesystem -I./mbed-os/features/filesystem/bd
#        -I./mbed-os/features/filesystem/fat
#        -I./mbed-os/features/filesystem/fat/ChaN -I./mbed-os/features/mbedtls
#        -I./mbed-os/features/mbedtls/importer -I./mbed-os/features/mbedtls/inc
#        -I./mbed-os/features/mbedtls/inc/mbedtls
#        -I./mbed-os/features/mbedtls/platform
#        -I./mbed-os/features/mbedtls/platform/inc
#        -I./mbed-os/features/mbedtls/platform/src
#        -I./mbed-os/features/mbedtls/src -I./mbed-os/features/mbedtls/targets
#        -I./mbed-os/features/nanostack -I./mbed-os/hal
#        -I./mbed-os/hal/storage_abstraction -I./mbed-os/platform
#        -I./mbed-os/rtos -I./mbed-os/rtos/TARGET_CORTEX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx4
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Config
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Include
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/RTX/Source/TOOLCHAIN_IAR/TARGET_M0
#        -I./mbed-os/rtos/TARGET_CORTEX/rtx5/Source -I./mbed-os/targets
#        -I./mbed-os/targets/TARGET_STMBLUE
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/TARGET_STEVAL_IDB007V1/device/TOOLCHAIN_IAR
#        -I./mbed-os/targets/TARGET_STMBLUE/TARGET_BLUENRG1/device -I./settings
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/BUILD
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed
#        -IC:/Users/Gianluca/mbedCLIdev/gian-ble-Copia-bleapi/mbed-os/features/unsupported/tests/mbed/env)
#        --preinclude=.\BUILD\STEVAL_IDB007V1\IAR\mbed_config.h --dependencies
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_uart.d
#        -l
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_uart.s.txt
#        -o
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_uart.o
#        .\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_uart.c
#    Locale       =  Italian_Italy.1252
#    List file    =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_uart.s.txt
#    Object file  =  
#        .\BUILD\STEVAL_IDB007V1\IAR\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_uart.o
#
###############################################################################

C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\device\BlueNRG1_uart.c
      1          /**
      2            ******************************************************************************
      3            * @file    BlueNRG1_uart.c
      4            * @author  VMA Application Team
      5            * @version V2.0.0
      6            * @date    21-March-2016
      7            * @brief   This file provides all the UART firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "BlueNRG1_uart.h"

  typedef uint8_t BOOL;  //already defined in "hal_type.h"
                  ^
"C:\Users\Gianluca\mbedCLIdev\gian-ble-Copia-bleapi\mbed-os\targets\TARGET_STMBLUE\TARGET_BLUENRG1\TARGET_STEVAL_IDB007V1\device\system_BlueNRG1.h",240  Warning[Pe301]: typedef name has already been declared (with same type)
     24          
     25          /** @addtogroup BLUENRG1_Peripheral_Driver BLUENRG1 Peripheral Driver
     26            * @{
     27            */
     28          
     29          /** @addtogroup UART_Peripheral  UART Peripheral
     30            * @{
     31            */
     32          
     33          /** @defgroup UART_Private_TypesDefinitions Private Types Definitions
     34            * @{
     35            */
     36          
     37          /**
     38            * @}
     39            */
     40          
     41          /** @defgroup UART_Private_Defines Private Defines
     42            * @{
     43            */
     44          #define UART_CLOCK       (16000000)
     45          
     46          /**
     47            * @}
     48            */
     49          
     50          /** @defgroup UART_Private_Macros Private Macros
     51            * @{
     52            */
     53          
     54          /**
     55            * @}
     56            */
     57          
     58          /** @defgroup UART_Private_Variables Private Variables
     59            * @{
     60            */
     61          
     62          /**
     63            * @}
     64            */
     65          
     66          /** @defgroup UART_Private_FunctionPrototypes Private Function Prototypes
     67            * @{
     68            */
     69          
     70          /**
     71            * @}
     72            */
     73          
     74          /** @defgroup UART_Public_Functions Public Functions
     75            * @{
     76            */
     77          
     78          
     79          /**
     80            * @brief  Enables or disables the UART peripheral.
     81            * @param  NewState: functional state @ref FunctionalState
     82            *         This parameter can be: ENABLE or DISABLE.
     83            * @retval None
     84            */

   \                                 In section .text, align 2, keep-with-next
     85          void UART_Cmd(FunctionalState NewState)
     86          {
     87            /* Check the parameters */
     88            assert_param(IS_FUNCTIONAL_STATE(NewState));
     89            
     90            if (NewState != DISABLE) {
   \                     UART_Cmd: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24  ;; 0x40300030
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD003             BEQ      ??UART_Cmd_0
     91              /* Enable the selected UART by setting the UARTEN bit in the UARTCR register */
     92              UART->CR_b.EN = SET;
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x4302             ORRS     R2,R2,R0
   \   0000000C   0x600A             STR      R2,[R1, #+0]
   \   0000000E   0x4770             BX       LR
     93            }
     94            else {
     95              /* Disable the selected UART by clearing the UARTEN bit in the UARTCR register */
     96              UART->CR_b.EN = RESET;
   \                     ??UART_Cmd_0: (+1)
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x4390             BICS     R0,R0,R2
   \   00000014   0x6008             STR      R0,[R1, #+0]
     97            }
     98          }
   \   00000016   0x4770             BX       LR               ;; return
     99          
    100          
    101          /**
    102          * @brief  Deinitializes the UART peripheral registers to their default
    103          *         reset values.
    104          * @param  None
    105          * @retval None
    106          */

   \                                 In section .text, align 2, keep-with-next
    107          void UART_DeInit(void)
    108          {
    109            UART->TIMEOUT   = 0x000001FF;
   \                     UART_DeInit: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_1  ;; 0x4030000c
   \   00000002   0x....             LDR      R0,??DataTable24_2  ;; 0x1ff
   \   00000004   0x6008             STR      R0,[R1, #+0]
    110            UART->LCRH_RX   = 0x00000000;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x7408             STRB     R0,[R1, #+16]
    111            UART->IBRD      = 0x00000000;
   \   0000000A   0x8308             STRH     R0,[R1, #+24]
    112            UART->FBRD      = 0x00000000;
   \   0000000C   0x7708             STRB     R0,[R1, #+28]
    113            UART->LCRH_TX   = 0x00000000;
   \   0000000E   0x3120             ADDS     R1,R1,#+32
   \   00000010   0x7008             STRB     R0,[R1, #+0]
    114            UART->CR        = 0x00040300;
   \   00000012   0x0B0A             LSRS     R2,R1,#+12
   \   00000014   0x604A             STR      R2,[R1, #+4]
    115            UART->IFLS      = 0x00000012;
   \   00000016   0x2212             MOVS     R2,#+18
   \   00000018   0x720A             STRB     R2,[R1, #+8]
    116            UART->IMSC      = 0x00000000;
   \   0000001A   0x8188             STRH     R0,[R1, #+12]
    117            UART->ICR       = 0x00000000;
   \   0000001C   0x8308             STRH     R0,[R1, #+24]
    118            UART->DMACR     = 0x00000000;
   \   0000001E   0x7708             STRB     R0,[R1, #+28]
    119            UART->XFCR      = 0x00000000;
   \   00000020   0x3124             ADDS     R1,R1,#+36
   \   00000022   0x7008             STRB     R0,[R1, #+0]
    120            UART->XON1      = 0x00000000;
   \   00000024   0x7108             STRB     R0,[R1, #+4]
    121            UART->XON2      = 0x00000000;
   \   00000026   0x7208             STRB     R0,[R1, #+8]
    122            UART->XOFF1     = 0x00000000;
   \   00000028   0x7308             STRB     R0,[R1, #+12]
    123            UART->XOFF2     = 0x00000000;
   \   0000002A   0x7408             STRB     R0,[R1, #+16]
    124          }
   \   0000002C   0x4770             BX       LR               ;; return
    125          
    126          
    127          /**
    128            * @brief  Initializes the UART peripheral according to the specified
    129            *         parameters in the UART_InitStruct.
    130            * @param  UART_InitStruct: pointer to a @ref UART_InitType structure
    131            *         that contains the configuration information for the specified UART.
    132            * @retval None
    133            */

   \                                 In section .text, align 2, keep-with-next
    134          void UART_Init(UART_InitType* UART_InitStruct)
    135          {
   \                     UART_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    136            uint32_t divider;
    137            uint16_t ibrd, fbrd;
    138          
    139            /* Check the parameters */
    140            assert_param(IS_UART_BAUDRATE(UART_InitStruct->UART_BaudRate));  
    141            assert_param(IS_UART_WORD_LENGTH(UART_InitStruct->UART_WordLengthTransmit));
    142            assert_param(IS_UART_WORD_LENGTH(UART_InitStruct->UART_WordLengthReceive));
    143            assert_param(IS_UART_STOPBITS(UART_InitStruct->UART_StopBits));
    144            assert_param(IS_UART_PARITY(UART_InitStruct->UART_Parity));
    145            assert_param(IS_UART_MODE(UART_InitStruct->UART_Mode));
    146            assert_param(IS_UART_HW_FLOW_CONTROL(UART_InitStruct->UART_HardwareFlowControl));
    147            assert_param(IS_FUNCTIONAL_STATE(UART_InitStruct->UART_FifoEnable));
    148            
    149            /*---------------------------- UART BaudRate Configuration -----------------------*/
    150            
    151            divider = (UART_CLOCK<<7) / (16 * UART_InitStruct->UART_BaudRate);
   \   00000004   0x....             LDR      R0,??DataTable24_3  ;; 0x7a120000
   \   00000006   0x6821             LDR      R1,[R4, #+0]
   \   00000008   0x0109             LSLS     R1,R1,#+4
   \   0000000A   0x.... 0x....      BL       __aeabi_uidiv
    152            
    153            ibrd = divider >> 7;
   \   0000000E   0x09C2             LSRS     R2,R0,#+7
    154            UART->IBRD = ibrd;
   \   00000010   0x....             LDR      R1,??DataTable24_4  ;; 0x4030001c
   \   00000012   0x810A             STRH     R2,[R1, #+8]
    155            fbrd = ((divider - (ibrd <<7) + 1) >> 1);
   \   00000014   0x0412             LSLS     R2,R2,#+16
   \   00000016   0x0A52             LSRS     R2,R2,#+9
   \   00000018   0x1A80             SUBS     R0,R0,R2
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x0840             LSRS     R0,R0,#+1
    156            if (fbrd > 0x3f) {
   \   0000001E   0xB282             UXTH     R2,R0
   \   00000020   0x2A40             CMP      R2,#+64
   \   00000022   0xDB02             BLT      ??UART_Init_0
    157              ibrd++;
    158              fbrd = (fbrd - 0x3F) & 0x3F;
   \   00000024   0x383F             SUBS     R0,R0,#+63
   \   00000026   0x0680             LSLS     R0,R0,#+26
   \   00000028   0x0E80             LSRS     R0,R0,#+26
    159            }
    160            UART->FBRD = fbrd;
   \                     ??UART_Init_0: (+1)
   \   0000002A   0x7308             STRB     R0,[R1, #+12]
    161            
    162            /*---------------------------- UART Word Length Configuration -----------------------*/
    163            UART->LCRH_TX_b.WLEN_TX = UART_InitStruct->UART_WordLengthTransmit;
   \   0000002C   0x2060             MOVS     R0,#+96
   \   0000002E   0x229F             MOVS     R2,#+159
   \   00000030   0x7C0B             LDRB     R3,[R1, #+16]
   \   00000032   0x4013             ANDS     R3,R3,R2
   \   00000034   0x7925             LDRB     R5,[R4, #+4]
   \   00000036   0x016D             LSLS     R5,R5,#+5
   \   00000038   0x4005             ANDS     R5,R5,R0
   \   0000003A   0x431D             ORRS     R5,R5,R3
   \   0000003C   0x740D             STRB     R5,[R1, #+16]
    164            UART->LCRH_RX_b.WLEN_RX = UART_InitStruct->UART_WordLengthReceive;
   \   0000003E   0x780B             LDRB     R3,[R1, #+0]
   \   00000040   0x401A             ANDS     R2,R2,R3
   \   00000042   0x7963             LDRB     R3,[R4, #+5]
   \   00000044   0x015B             LSLS     R3,R3,#+5
   \   00000046   0x4018             ANDS     R0,R0,R3
   \   00000048   0x4310             ORRS     R0,R0,R2
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    165            
    166            /*---------------------------- UART Stop Bits Configuration -----------------------*/
    167            UART->LCRH_TX_b.STP2_TX = UART_InitStruct->UART_StopBits;
   \   0000004C   0x2008             MOVS     R0,#+8
   \   0000004E   0x22F7             MOVS     R2,#+247
   \   00000050   0x7C0B             LDRB     R3,[R1, #+16]
   \   00000052   0x4013             ANDS     R3,R3,R2
   \   00000054   0x79A5             LDRB     R5,[R4, #+6]
   \   00000056   0x00ED             LSLS     R5,R5,#+3
   \   00000058   0x2608             MOVS     R6,#+8
   \   0000005A   0x402E             ANDS     R6,R6,R5
   \   0000005C   0x431E             ORRS     R6,R6,R3
   \   0000005E   0x740E             STRB     R6,[R1, #+16]
    168            UART->LCRH_RX_b.STP2_RX = UART_InitStruct->UART_StopBits;
   \   00000060   0x780B             LDRB     R3,[R1, #+0]
   \   00000062   0x401A             ANDS     R2,R2,R3
   \   00000064   0x79A3             LDRB     R3,[R4, #+6]
   \   00000066   0x00DB             LSLS     R3,R3,#+3
   \   00000068   0x4018             ANDS     R0,R0,R3
   \   0000006A   0x4310             ORRS     R0,R0,R2
   \   0000006C   0x7008             STRB     R0,[R1, #+0]
    169            
    170            /*---------------------------- UART Parity Configuration -----------------------*/
    171            if(UART_InitStruct->UART_Parity == UART_Parity_No) {
   \   0000006E   0x79E2             LDRB     R2,[R4, #+7]
   \   00000070   0x0010             MOVS     R0,R2
   \   00000072   0xD107             BNE      ??UART_Init_1
    172              UART->LCRH_TX_b.PEN_TX = RESET;
   \   00000074   0x20FD             MOVS     R0,#+253
   \   00000076   0x7C0A             LDRB     R2,[R1, #+16]
   \   00000078   0x4002             ANDS     R2,R2,R0
   \   0000007A   0x740A             STRB     R2,[R1, #+16]
    173              UART->LCRH_RX_b.PEN_RX = RESET;
   \   0000007C   0x780A             LDRB     R2,[R1, #+0]
   \   0000007E   0x4010             ANDS     R0,R0,R2
   \   00000080   0x7008             STRB     R0,[R1, #+0]
   \   00000082   0xE01D             B        ??UART_Init_2
    174            }
    175            else if(UART_InitStruct->UART_Parity == UART_Parity_Odd) {
   \                     ??UART_Init_1: (+1)
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0x2A02             CMP      R2,#+2
   \   00000088   0x7C0A             LDRB     R2,[R1, #+16]
   \   0000008A   0x4603             MOV      R3,R0
   \   0000008C   0xD10B             BNE      ??UART_Init_3
    176              UART->LCRH_TX_b.PEN_TX = SET;
   \   0000008E   0x4313             ORRS     R3,R3,R2
   \   00000090   0x740B             STRB     R3,[R1, #+16]
    177              UART->LCRH_TX_b.EPS_TX = RESET;
   \   00000092   0x22FB             MOVS     R2,#+251
   \   00000094   0x7C0B             LDRB     R3,[R1, #+16]
   \   00000096   0x4013             ANDS     R3,R3,R2
   \   00000098   0x740B             STRB     R3,[R1, #+16]
    178              UART->LCRH_RX_b.PEN_RX = SET;
   \   0000009A   0x780B             LDRB     R3,[R1, #+0]
   \   0000009C   0x4318             ORRS     R0,R0,R3
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
    179              UART->LCRH_RX_b.EPS_RX = RESET;
   \   000000A0   0x7808             LDRB     R0,[R1, #+0]
   \   000000A2   0x4002             ANDS     R2,R2,R0
   \   000000A4   0xE00B             B        ??UART_Init_4
    180            }
    181            else {
    182              UART->LCRH_TX_b.PEN_TX = SET;
   \                     ??UART_Init_3: (+1)
   \   000000A6   0x4313             ORRS     R3,R3,R2
   \   000000A8   0x740B             STRB     R3,[R1, #+16]
    183              UART->LCRH_TX_b.EPS_TX = SET;    
   \   000000AA   0x2204             MOVS     R2,#+4
   \   000000AC   0x7C0B             LDRB     R3,[R1, #+16]
   \   000000AE   0x2504             MOVS     R5,#+4
   \   000000B0   0x431D             ORRS     R5,R5,R3
   \   000000B2   0x740D             STRB     R5,[R1, #+16]
    184              UART->LCRH_RX_b.PEN_RX = SET;
   \   000000B4   0x780B             LDRB     R3,[R1, #+0]
   \   000000B6   0x4318             ORRS     R0,R0,R3
   \   000000B8   0x7008             STRB     R0,[R1, #+0]
    185              UART->LCRH_RX_b.EPS_RX = SET;    
   \   000000BA   0x7808             LDRB     R0,[R1, #+0]
   \   000000BC   0x4302             ORRS     R2,R2,R0
   \                     ??UART_Init_4: (+1)
   \   000000BE   0x700A             STRB     R2,[R1, #+0]
    186            }
    187          
    188            /*---------------------------- UART Mode Configuration -----------------------*/
    189            UART->CR_b.RXE = UART_InitStruct->UART_Mode&1;
   \                     ??UART_Init_2: (+1)
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0x694A             LDR      R2,[R1, #+20]
   \   000000C4   0x....             LDR      R3,??DataTable24_5  ;; 0xfffffdff
   \   000000C6   0x4013             ANDS     R3,R3,R2
   \   000000C8   0x7A22             LDRB     R2,[R4, #+8]
   \   000000CA   0x4002             ANDS     R2,R2,R0
   \   000000CC   0x0252             LSLS     R2,R2,#+9
   \   000000CE   0x431A             ORRS     R2,R2,R3
   \   000000D0   0x614A             STR      R2,[R1, #+20]
    190            UART->CR_b.TXE = (UART_InitStruct->UART_Mode>>1)&1;
   \   000000D2   0x694A             LDR      R2,[R1, #+20]
   \   000000D4   0x....             LDR      R3,??DataTable24_6  ;; 0xfffffeff
   \   000000D6   0x4013             ANDS     R3,R3,R2
   \   000000D8   0x7A22             LDRB     R2,[R4, #+8]
   \   000000DA   0x0852             LSRS     R2,R2,#+1
   \   000000DC   0x4002             ANDS     R2,R2,R0
   \   000000DE   0x0212             LSLS     R2,R2,#+8
   \   000000E0   0x431A             ORRS     R2,R2,R3
   \   000000E2   0x614A             STR      R2,[R1, #+20]
    191          
    192            /*---------------------------- UART Hardware flow control Configuration -----------------------*/
    193            UART->CR_b.RTSEN = UART_InitStruct->UART_HardwareFlowControl&1;
   \   000000E4   0x694A             LDR      R2,[R1, #+20]
   \   000000E6   0x....             LDR      R3,??DataTable24_7  ;; 0xffffbfff
   \   000000E8   0x4013             ANDS     R3,R3,R2
   \   000000EA   0x7A62             LDRB     R2,[R4, #+9]
   \   000000EC   0x4002             ANDS     R2,R2,R0
   \   000000EE   0x0392             LSLS     R2,R2,#+14
   \   000000F0   0x431A             ORRS     R2,R2,R3
   \   000000F2   0x614A             STR      R2,[R1, #+20]
    194            UART->CR_b.CTSEN = (UART_InitStruct->UART_HardwareFlowControl>>1)&1;
   \   000000F4   0x694A             LDR      R2,[R1, #+20]
   \   000000F6   0x....             LDR      R3,??DataTable24_8  ;; 0xffff7fff
   \   000000F8   0x4013             ANDS     R3,R3,R2
   \   000000FA   0x7A62             LDRB     R2,[R4, #+9]
   \   000000FC   0x0852             LSRS     R2,R2,#+1
   \   000000FE   0x4010             ANDS     R0,R0,R2
   \   00000100   0x03C0             LSLS     R0,R0,#+15
   \   00000102   0x4318             ORRS     R0,R0,R3
   \   00000104   0x6148             STR      R0,[R1, #+20]
    195          
    196            /*---------------------------- UART Fifo Configuration -----------------------*/
    197            UART->LCRH_TX_b.FEN_TX = (uint8_t)UART_InitStruct->UART_FifoEnable;
   \   00000106   0x2010             MOVS     R0,#+16
   \   00000108   0x22EF             MOVS     R2,#+239
   \   0000010A   0x7C0B             LDRB     R3,[R1, #+16]
   \   0000010C   0x4013             ANDS     R3,R3,R2
   \   0000010E   0x7AA5             LDRB     R5,[R4, #+10]
   \   00000110   0x012D             LSLS     R5,R5,#+4
   \   00000112   0x4005             ANDS     R5,R5,R0
   \   00000114   0x431D             ORRS     R5,R5,R3
   \   00000116   0x740D             STRB     R5,[R1, #+16]
    198            UART->LCRH_RX_b.FEN_RX = (uint8_t)UART_InitStruct->UART_FifoEnable;
   \   00000118   0x780B             LDRB     R3,[R1, #+0]
   \   0000011A   0x401A             ANDS     R2,R2,R3
   \   0000011C   0x7AA3             LDRB     R3,[R4, #+10]
   \   0000011E   0x011B             LSLS     R3,R3,#+4
   \   00000120   0x4018             ANDS     R0,R0,R3
   \   00000122   0x4310             ORRS     R0,R0,R2
   \   00000124   0x7008             STRB     R0,[R1, #+0]
    199          
    200          }
   \   00000126   0xBD70             POP      {R4-R6,PC}       ;; return
    201          
    202          /**
    203            * @brief  Fills each UART_InitStruct member with its default value.
    204            * @param  UART_InitStruct: pointer to a @ref UART_InitTypeDef structure
    205            *         which will be initialized.
    206            * @retval None
    207            */

   \                                 In section .text, align 2, keep-with-next
    208          void UART_StructInit(UART_InitType* UART_InitStruct)
    209          {
    210            /* UART_InitStruct members default value */
    211            UART_InitStruct->UART_BaudRate = 115200;
   \                     UART_StructInit: (+1)
   \   00000000   0x21E1             MOVS     R1,#+225
   \   00000002   0x0249             LSLS     R1,R1,#+9        ;; #+115200
   \   00000004   0x6001             STR      R1,[R0, #+0]
    212            UART_InitStruct->UART_WordLengthTransmit = UART_WordLength_8b;
   \   00000006   0x2103             MOVS     R1,#+3
   \   00000008   0x7101             STRB     R1,[R0, #+4]
    213            UART_InitStruct->UART_WordLengthReceive = UART_WordLength_8b;
   \   0000000A   0x7141             STRB     R1,[R0, #+5]
    214            UART_InitStruct->UART_StopBits = UART_StopBits_1;
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x7182             STRB     R2,[R0, #+6]
    215            UART_InitStruct->UART_Parity = UART_Parity_No;
   \   00000010   0x71C2             STRB     R2,[R0, #+7]
    216            UART_InitStruct->UART_Mode = UART_Mode_Rx | UART_Mode_Tx;
   \   00000012   0x7201             STRB     R1,[R0, #+8]
    217            UART_InitStruct->UART_HardwareFlowControl = UART_HardwareFlowControl_None; 
   \   00000014   0x7242             STRB     R2,[R0, #+9]
    218            UART_InitStruct->UART_FifoEnable = DISABLE;
   \   00000016   0x7282             STRB     R2,[R0, #+10]
    219          }
   \   00000018   0x4770             BX       LR               ;; return
    220          
    221          /**
    222            * @brief  Enables or disables the specified UART interrupts.
    223            * @param  UART_IT: specifies the UART interrupt sources to be enabled or disabled.
    224            *   This parameter can be a any combination of the following values:
    225          	*   @arg UART_IT_TXFE:  Tx FIFO empty interrupt
    226            *   @arg UART_IT_XO:    XOFF interrupt
    227            *   @arg UART_IT_OE:    Overrun error interrupt
    228            *   @arg UART_IT_BE:    Break error interrupt
    229            *   @arg UART_IT_PE:    Parity error interrupt
    230            *   @arg UART_IT_FE:    Framing error interrupt
    231            *   @arg UART_IT_RT:    Receive timeout interrupt
    232            *   @arg UART_IT_TX:    Transmit interrupt
    233            *   @arg UART_IT_RX:    Receive interrupt
    234            *   @arg UART_IT_CTS:   CTS interrupt.
    235            * @param  NewState: functional state @ref FunctionalState
    236            *         This parameter can be: ENABLE or DISABLE.
    237            * @retval None
    238            */

   \                                 In section .text, align 2, keep-with-next
    239          void UART_ITConfig(uint16_t UART_IT, FunctionalState NewState)
    240          {
    241            /* Check the parameters */
    242            assert_param(IS_UART_CONFIG_IT(UART_IT));
    243            assert_param(IS_FUNCTIONAL_STATE(NewState));
    244          
    245            if (NewState != DISABLE) {
   \                     UART_ITConfig: (+1)
   \   00000000   0x....             LDR      R2,??DataTable24_9  ;; 0x40300038
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0x8811             LDRH     R1,[R2, #+0]
   \   00000006   0xD002             BEQ      ??UART_ITConfig_0
    246              /* Enable specified interrupts */
    247              SET_BIT(UART->IMSC, UART_IT);
   \   00000008   0x4308             ORRS     R0,R0,R1
   \   0000000A   0x8010             STRH     R0,[R2, #+0]
   \   0000000C   0x4770             BX       LR
    248            }
    249            else {
    250              /* Disable specified interrupts */
    251              CLEAR_BIT(UART->IMSC, UART_IT);
   \                     ??UART_ITConfig_0: (+1)
   \   0000000E   0x4381             BICS     R1,R1,R0
   \   00000010   0x8011             STRH     R1,[R2, #+0]
    252            }
    253          }
   \   00000012   0x4770             BX       LR               ;; return
    254          
    255          /**
    256            * @brief  Transmits single data through the UART peripheral.
    257            * @param  Data: the data to transmit.
    258            * @retval None
    259            */

   \                                 In section .text, align 2, keep-with-next
    260          void UART_SendData(uint16_t Data)
    261          {
    262            /* Check the parameters */
    263            assert_param(IS_UART_DATA(Data)); 
    264              
    265            /* Transmit Data */
    266            UART->DR = (Data & (uint16_t)0x01FF);
   \                     UART_SendData: (+1)
   \   00000000   0x05C0             LSLS     R0,R0,#+23
   \   00000002   0x0DC0             LSRS     R0,R0,#+23
   \   00000004   0x....             LDR      R1,??DataTable24_10  ;; 0x40300000
   \   00000006   0x8008             STRH     R0,[R1, #+0]
    267          }
   \   00000008   0x4770             BX       LR               ;; return
    268          
    269          /**
    270            * @brief  Returns the most recent received data by the UART peripheral.
    271            * @param  None
    272            * @retval uint16_t: The received data.
    273            */

   \                                 In section .text, align 2, keep-with-next
    274          uint16_t UART_ReceiveData(void)
    275          {
    276            /* Check the parameters */
    277            
    278            /* Receive Data */
    279            return (uint16_t)(UART->DR & 0x00FF);
   \                     UART_ReceiveData: (+1)
   \   00000000   0x....             LDR      R0,??DataTable24_10  ;; 0x40300000
   \   00000002   0x8800             LDRH     R0,[R0, #+0]
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x4770             BX       LR               ;; return
    280          }
    281          
    282          /**
    283            * @brief  Enables or disables the break command.
    284            * @param  NewState: functional state @ref FunctionalState
    285            *         This parameter can be: ENABLE or DISABLE.
    286            * @retval None
    287            */

   \                                 In section .text, align 2, keep-with-next
    288          void UART_BreakCmd(FunctionalState NewState)
    289          {
    290            /* Check the parameters */
    291            assert_param(IS_FUNCTIONAL_STATE(NewState));
    292            
    293            UART->LCRH_TX_b.BRK = (uint8_t)NewState;
   \                     UART_BreakCmd: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_11  ;; 0x4030002c
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0x23FE             MOVS     R3,#+254
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x07C2             LSLS     R2,R0,#+31
   \   0000000A   0x0FD2             LSRS     R2,R2,#+31
   \   0000000C   0x431A             ORRS     R2,R2,R3
   \   0000000E   0x700A             STRB     R2,[R1, #+0]
    294          }
   \   00000010   0x4770             BX       LR               ;; return
    295          
    296          /**
    297            * @brief  Enables or disables the request to send command.
    298            * @param  NewState: functional state @ref FunctionalState
    299            *         This parameter can be: ENABLE or DISABLE.
    300            * @retval None
    301            */

   \                                 In section .text, align 2, keep-with-next
    302          void UART_RequestToSendCmd(FunctionalState NewState)
    303          {
    304            /* Check the parameters */
    305            assert_param(IS_FUNCTIONAL_STATE(NewState));
    306            
    307            UART->CR_b.RTS = (uint8_t)NewState;
   \                     UART_RequestToSendCmd: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24  ;; 0x40300030
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x....             LDR      R3,??DataTable24_12  ;; 0xfffff7ff
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x02C0             LSLS     R0,R0,#+11
   \   0000000A   0x2280             MOVS     R2,#+128
   \   0000000C   0x0112             LSLS     R2,R2,#+4        ;; #+2048
   \   0000000E   0x4010             ANDS     R0,R0,R2
   \   00000010   0x4318             ORRS     R0,R0,R3
   \   00000012   0x6008             STR      R0,[R1, #+0]
    308          }
   \   00000014   0x4770             BX       LR               ;; return
    309          
    310          
    311          /**
    312            * @brief  Checks whether the specified UART flag is set or not.
    313            * @param  UART_FLAG: specifies the flag to check.
    314            *   This parameter can be one of the following values:
    315            *     @arg UART_FLAG_CTS:   Clear to send
    316            *     @arg UART_FLAG_BUSY:  UART busy
    317            *     @arg UART_FLAG_RXFE:  Receive FIFO empty
    318            *     @arg UART_FLAG_TXFF:  Transmit FIFO full
    319            *     @arg UART_FLAG_RXFF:  Receive FIFO full
    320            *     @arg UART_FLAG_TXFE:  Transmit FIFO empty
    321            *     @arg UART_FLAG_FE:    Framing error
    322            *     @arg UART_FLAG_PE:    Parity error
    323            *     @arg UART_FLAG_BE:    Break error
    324            *     @arg UART_FLAG_OE:    Overrun error.
    325          * @retval FlagStatus: functional state @ref FlagStatus
    326          *         This parameter can be: SET or RESET.
    327            */

   \                                 In section .text, align 2, keep-with-next
    328          FlagStatus UART_GetFlagStatus(uint32_t UART_FLAG)
    329          {
    330            /* Check the parameters */
    331            assert_param(IS_UART_FLAG(UART_FLAG));
    332            
    333            if (UART_FLAG & 0x80000000) {
   \                     UART_GetFlagStatus: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_13  ;; 0x40300004
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD506             BPL      ??UART_GetFlagStatus_0
    334              if (UART->RSR & UART_FLAG) {
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x4008             ANDS     R0,R0,R1
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
   \   0000000C   0x4180             SBCS     R0,R0,R0
   \   0000000E   0x43C0             MVNS     R0,R0
   \   00000010   0x0FC0             LSRS     R0,R0,#+31
    335                return SET;
    336              }
    337              else {
    338                return RESET;
   \   00000012   0x4770             BX       LR
    339              }
    340            }
    341            else {
    342              if (UART->FR & UART_FLAG) {
   \                     ??UART_GetFlagStatus_0: (+1)
   \   00000014   0x8A89             LDRH     R1,[R1, #+20]
   \   00000016   0x4008             ANDS     R0,R0,R1
   \   00000018   0x1E41             SUBS     R1,R0,#+1
   \   0000001A   0x4189             SBCS     R1,R1,R1
   \   0000001C   0x43C9             MVNS     R1,R1
   \   0000001E   0x0FC8             LSRS     R0,R1,#+31
    343                return SET;
    344              }
    345              else {
    346                return RESET;
   \   00000020   0x4770             BX       LR               ;; return
    347              }  
    348            }
    349            
    350          }
    351          
    352          /**
    353            * @brief  Clears the UART pending flags.
    354            * @param  UART_FLAG: specifies the flag to clear.
    355            *   This parameter can be any combination of the following values:
    356            *     @arg UART_FLAG_FE:  Framing error
    357            *     @arg UART_FLAG_PE:  Parity error
    358            *     @arg UART_FLAG_BE:  Break error
    359            *     @arg UART_FLAG_OE:  Overrun error
    360            * @retval None
    361            */

   \                                 In section .text, align 2, keep-with-next
    362          void UART_ClearFlag(uint32_t UART_FLAG)
    363          {
    364            /* Check the parameters */
    365            assert_param(IS_UART_CLEAR_FLAG(UART_FLAG));
    366             
    367            UART->ECR = UART_FLAG;
   \                     UART_ClearFlag: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_13  ;; 0x40300004
   \   00000002   0x6008             STR      R0,[R1, #+0]
    368          }
   \   00000004   0x4770             BX       LR               ;; return
    369          
    370          /**
    371            * @brief  Checks whether the specified UART interrupt has occurred or not.
    372            * @param  UART_IT: specifies the UART interrupt source to check.
    373            *   This parameter can be one of the following values:
    374          	*   @arg UART_IT_TXFE:  Tx FIFO empty interrupt
    375            *   @arg UART_IT_XO:    XOFF interrupt
    376            *   @arg UART_IT_OE:    Overrun error interrupt
    377            *   @arg UART_IT_BE:    Break error interrupt
    378            *   @arg UART_IT_PE:    Parity error interrupt
    379            *   @arg UART_IT_FE:    Framing error interrupt
    380            *   @arg UART_IT_RT:    Receive timeout interrupt
    381            *   @arg UART_IT_TX:    Transmit interrupt
    382            *   @arg UART_IT_RX:    Receive interrupt
    383            *   @arg UART_IT_CTS:   CTS interrupt
    384            * @retval  ITStatus: functional state @ref ITStatus
    385            *         This parameter can be: SET or RESET.
    386            */

   \                                 In section .text, align 2, keep-with-next
    387          ITStatus UART_GetITStatus(uint16_t UART_IT)
    388          {
   \                     UART_GetITStatus: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    389            /* Check the parameters */
    390            assert_param(IS_UART_CONFIG_IT(UART_IT));
    391             
    392            if ((UART->RIS & UART_IT) != (uint16_t)RESET) {
   \   00000002   0x....             LDR      R0,??DataTable24_14  ;; 0x4030003c
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x4001             ANDS     R1,R1,R0
   \   00000008   0x1E48             SUBS     R0,R1,#+1
   \   0000000A   0x4180             SBCS     R0,R0,R0
   \   0000000C   0x43C0             MVNS     R0,R0
   \   0000000E   0x0FC0             LSRS     R0,R0,#+31
    393              return SET;
    394            }
    395            else {
    396              return RESET;
   \   00000010   0x4770             BX       LR               ;; return
    397            }  
    398          }
    399          
    400          /**
    401            * @brief  Clears the UART interrupt pending bits.
    402            * @param  UART_IT: specifies the interrupt pending bit to clear.
    403            *   This parameter can be any combination of the following values:
    404          	*   @arg UART_IT_TXFE:  Tx FIFO empty interrupt
    405            *   @arg UART_IT_XO:    XOFF interrupt
    406            *   @arg UART_IT_OE:    Overrun error interrupt
    407            *   @arg UART_IT_BE:    Break error interrupt
    408            *   @arg UART_IT_PE:    Parity error interrupt
    409            *   @arg UART_IT_FE:    Framing error interrupt
    410            *   @arg UART_IT_RT:    Receive timeout interrupt
    411            *   @arg UART_IT_TX:    Transmit interrupt
    412            *   @arg UART_IT_RX:    Receive interrupt
    413            *   @arg UART_IT_CTS:   CTS interrupt
    414            *   
    415            * @retval None
    416            */

   \                                 In section .text, align 2, keep-with-next
    417          void UART_ClearITPendingBit(uint16_t UART_IT)
    418          {
    419            /* Check the parameters */
    420            assert_param(IS_UART_CONFIG_IT(UART_IT));
    421            
    422            UART->ICR = UART_IT;
   \                     UART_ClearITPendingBit: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_15  ;; 0x40300044
   \   00000002   0x8008             STRH     R0,[R1, #+0]
    423          }
   \   00000004   0x4770             BX       LR               ;; return
    424          
    425          
    426          /**
    427            * @brief  Sets the UART interrupt FIFO level.
    428            * @param  UART_TxFifo_Level: specifies the transmit interrupt FIFO level.
    429            *   This parameter can be one of the following values:
    430            *   @arg FIFO_LEV_1_64: interrupt when Tx FIFO becomes <= 1/64 full 
    431            *   @arg FIFO_LEV_1_32: interrupt when Tx FIFO becomes <= 1/32 full 
    432            *   @arg FIFO_LEV_1_16: interrupt when Tx FIFO becomes <= 1/16 full 
    433            *   @arg FIFO_LEV_1_8: interrupt when Tx FIFO becomes <= 1/8 full 
    434            *   @arg FIFO_LEV_1_4: interrupt when Tx FIFO becomes <= 1/4 full
    435            *   @arg FIFO_LEV_1_2: interrupt when Tx FIFO becomes <= 1/2 full 
    436            *   @arg FIFO_LEV_3_4: interrupt when Tx FIFO becomes <= 3/4 full 
    437            * @retval None
    438            */

   \                                 In section .text, align 2, keep-with-next
    439          void UART_TxFifoIrqLevelConfig(uint8_t UART_TxFifo_Level)
    440          {
    441              /* Check the parameters */
    442            assert_param(IS_FIFO_LEV(UART_TxFifo_Level));
    443          
    444            UART->IFLS_b.TXIFLSEL = UART_TxFifo_Level;
   \                     UART_TxFifoIrqLevelConfig: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_16  ;; 0x40300034
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0x23F8             MOVS     R3,#+248
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x0740             LSLS     R0,R0,#+29
   \   0000000A   0x0F40             LSRS     R0,R0,#+29
   \   0000000C   0x4318             ORRS     R0,R0,R3
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    445          }
   \   00000010   0x4770             BX       LR               ;; return
    446          
    447          /**
    448            * @brief  Sets the UART interrupt FIFO level.
    449            * @param  UART_RxFifo_Level: specifies the receive interrupt FIFO level.
    450            *   This parameter can be one of the following values:
    451            *   @arg FIFO_LEV_1_64: interrupt when Rx FIFO becomes >= 1/64 full 
    452            *   @arg FIFO_LEV_1_32: interrupt when Rx FIFO becomes >= 1/32 full 
    453            *   @arg FIFO_LEV_1_16: interrupt when Rx FIFO becomes >= 1/16 full 
    454            *   @arg FIFO_LEV_1_8: interrupt when Rx FIFO becomes >= 1/8 full 
    455            *   @arg FIFO_LEV_1_4: interrupt when Rx FIFO becomes >= 1/4 full
    456            *   @arg FIFO_LEV_1_2: interrupt when Rx FIFO becomes >= 1/2 full 
    457            *   @arg FIFO_LEV_3_4: interrupt when Rx FIFO becomes >= 3/4 full
    458            * @retval None
    459            */

   \                                 In section .text, align 2, keep-with-next
    460          void UART_RxFifoIrqLevelConfig(uint8_t UART_RxFifo_Level)
    461          {
    462              /* Check the parameters */
    463            assert_param(IS_FIFO_LEV(UART_RxFifo_Level));
    464          
    465            UART->IFLS_b.RXIFLSEL = UART_RxFifo_Level;
   \                     UART_RxFifoIrqLevelConfig: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_16  ;; 0x40300034
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0x23C7             MOVS     R3,#+199
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x00C0             LSLS     R0,R0,#+3
   \   0000000A   0x2238             MOVS     R2,#+56
   \   0000000C   0x4002             ANDS     R2,R2,R0
   \   0000000E   0x431A             ORRS     R2,R2,R3
   \   00000010   0x700A             STRB     R2,[R1, #+0]
    466          }
   \   00000012   0x4770             BX       LR               ;; return
    467          
    468          /**
    469            * @brief  UART timeout value for the interrupt.
    470            *         The receive timeout interrupt is asserted when
    471            *         the RX FIFO is not empty and no further data is received
    472            *         over a programmed timeout period.
    473            * @param  UART_Timeout: is a value less than 0x400000.
    474            *         The value is calculated as:
    475            *         UART_Timeout = timeout * OverSamplingFactor  * BaudRate
    476            *         Where OverSamplingFactor is 16 if OVSFACT == 0 and is 8 if OVSFACT == 1
    477            * @retval None
    478            */

   \                                 In section .text, align 2, keep-with-next
    479          void UART_TimeoutConfig(uint32_t UART_Timeout)
    480          {
    481            /* Check the parameters */
    482            assert_param(IS_UART_TIMEOUT(UART_Timeout)); 
    483              
    484            /* Set the timeout value */
    485            UART->TIMEOUT = UART_Timeout;
   \                     UART_TimeoutConfig: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_1  ;; 0x4030000c
   \   00000002   0x6008             STR      R0,[R1, #+0]
    486          }
   \   00000004   0x4770             BX       LR               ;; return
    487          
    488          
    489          
    490          /**
    491            * @brief  Enables or disables the UART DMA interface.
    492            * @param  UART_DMAReq: specifies the DMA request.
    493            *   This parameter can be any combination of the following values:
    494            *     @arg UART_DMAReq_Tx: UART DMA transmit request.
    495            *     @arg UART_DMAReq_Rx: UART DMA receive request.
    496            * @param  NewState: functional state @ref FunctionalState
    497            *         This parameter can be: ENABLE or DISABLE.
    498            * @retval None
    499            */

   \                                 In section .text, align 2, keep-with-next
    500          void UART_DMACmd(uint8_t UART_DMAReq, FunctionalState NewState)
    501          {
    502            /* Check the parameters */
    503            assert_param(IS_UART_DMAREQ(UART_DMAReq));  
    504            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
    505          
    506            if (NewState != DISABLE)
   \                     UART_DMACmd: (+1)
   \   00000000   0x....             LDR      R2,??DataTable24_17  ;; 0x40300048
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0x7811             LDRB     R1,[R2, #+0]
   \   00000006   0xD002             BEQ      ??UART_DMACmd_0
    507            {
    508              /* Enable the DMA transfer for selected requests by setting the DMAT and/or
    509                 DMAR bits in the UART CR3 register */
    510              UART->DMACR |= UART_DMAReq;
   \   00000008   0x4308             ORRS     R0,R0,R1
   \   0000000A   0x7010             STRB     R0,[R2, #+0]
   \   0000000C   0x4770             BX       LR
    511            }
    512            else
    513            {
    514              /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
    515                 DMAR bits in the UART CR3 register */
    516              UART->DMACR &= (uint8_t)~UART_DMAReq;
   \                     ??UART_DMACmd_0: (+1)
   \   0000000E   0x4381             BICS     R1,R1,R0
   \   00000010   0x7011             STRB     R1,[R2, #+0]
    517            }
    518          }
   \   00000012   0x4770             BX       LR               ;; return
    519          
    520          
    521          
    522          /**
    523            * @brief  Enables or disables the UART software flow control.
    524            * @param  NewState: functional state @ref FunctionalState
    525            *         This parameter can be: ENABLE or DISABLE.
    526            * @retval None
    527            */

   \                                 In section .text, align 2, keep-with-next
    528          void UART_SwFlowControl(FunctionalState NewState)
    529          {
    530            /* Check the parameters */
    531            assert_param(IS_FUNCTIONAL_STATE(NewState));
    532            
    533            if (NewState != DISABLE) {
   \                     UART_SwFlowControl: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_18  ;; 0x40300050
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x7808             LDRB     R0,[R1, #+0]
   \   00000006   0xD002             BEQ      ??UART_SwFlowControl_0
    534              /* Enable UART software flow control */
    535              UART->XFCR_b.SFEN = SET;
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x4302             ORRS     R2,R2,R0
   \   0000000C   0xE001             B        ??UART_SwFlowControl_1
    536            }
    537            else {
    538              /* Disable UART software flow control */
    539              UART->XFCR_b.SFEN = RESET;
   \                     ??UART_SwFlowControl_0: (+1)
   \   0000000E   0x22FE             MOVS     R2,#+254
   \   00000010   0x4002             ANDS     R2,R2,R0
   \                     ??UART_SwFlowControl_1: (+1)
   \   00000012   0x700A             STRB     R2,[R1, #+0]
    540            }
    541          }
   \   00000014   0x4770             BX       LR               ;; return
    542          
    543          
    544          /**
    545            * @brief  Sets the UART flow control mode for reception.
    546            * @param  UART_RxSwFlowCtrlMode: specifies the software flow control used for RX.
    547            *   This parameter can be one of the following values:
    548            *   @arg NO_SW_FLOW_CTRL: No software flow control
    549            *   @arg SW_FLOW_CTRL_XON1_XOFF1: Software flow control XON1 and XOFF1
    550            *   @arg SW_FLOW_CTRL_XON2_XOFF2: Software flow control XON2 and XOFF2
    551            *   @arg SW_FLOW_CTRL_ALL_CHARS: Software flow control XON1 and XOFF1, XON2 and XOFF2
    552            * @retval None
    553            */

   \                                 In section .text, align 2, keep-with-next
    554          void UART_RxSwFlowControlMode(uint8_t UART_RxSwFlowCtrlMode)
    555          {
    556              /* Check the parameters */
    557            assert_param(IS_SW_FLOW_CTRL(UART_RxSwFlowCtrlMode));
    558          
    559            UART->XFCR_b.SFRMOD = UART_RxSwFlowCtrlMode;
   \                     UART_RxSwFlowControlMode: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_18  ;; 0x40300050
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0x23F9             MOVS     R3,#+249
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x0040             LSLS     R0,R0,#+1
   \   0000000A   0x2206             MOVS     R2,#+6
   \   0000000C   0x4002             ANDS     R2,R2,R0
   \   0000000E   0x431A             ORRS     R2,R2,R3
   \   00000010   0x700A             STRB     R2,[R1, #+0]
    560          }
   \   00000012   0x4770             BX       LR               ;; return
    561          
    562          /**
    563            * @brief  Sets the UART flow control mode for transmission.
    564            * @param  UART_TxSwFlowCtrlMode: specifies the software flow control used for TX.
    565            *   This parameter can be one of the following values:
    566            *   @arg NO_SW_FLOW_CTRL: No software flow control
    567            *   @arg SW_FLOW_CTRL_XON1_XOFF1: Software flow control XON1 and XOFF1
    568            *   @arg SW_FLOW_CTRL_XON2_XOFF2: Software flow control XON2 and XOFF2
    569            *   @arg SW_FLOW_CTRL_ALL_CHARS: Software flow control XON1 and XOFF1, XON2 and XOFF2
    570            * @retval None
    571            */

   \                                 In section .text, align 2, keep-with-next
    572          void UART_TxSwFlowControlMode(uint8_t UART_TxSwFlowCtrlMode)
    573          {
    574              /* Check the parameters */
    575            assert_param(IS_SW_FLOW_CTRL(UART_TxSwFlowCtrlMode));
    576          
    577            UART->XFCR_b.SFTMOD = UART_TxSwFlowCtrlMode;
   \                     UART_TxSwFlowControlMode: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_18  ;; 0x40300050
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0x23E7             MOVS     R3,#+231
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0x00C0             LSLS     R0,R0,#+3
   \   0000000A   0x2218             MOVS     R2,#+24
   \   0000000C   0x4002             ANDS     R2,R2,R0
   \   0000000E   0x431A             ORRS     R2,R2,R3
   \   00000010   0x700A             STRB     R2,[R1, #+0]
    578          }
   \   00000012   0x4770             BX       LR               ;; return
    579          
    580          
    581          /**
    582            * @brief  Enables or disables the UART XON any bit.
    583            * @param  NewState: functional state @ref FunctionalState
    584            *         This parameter can be: ENABLE or DISABLE.
    585            * @retval None
    586            */

   \                                 In section .text, align 2, keep-with-next
    587          void UART_XonAnyBit(FunctionalState NewState)
    588          {
    589            /* Check the parameters */
    590            assert_param(IS_FUNCTIONAL_STATE(NewState));
    591            
    592            if (NewState != DISABLE) {
   \                     UART_XonAnyBit: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_18  ;; 0x40300050
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x7808             LDRB     R0,[R1, #+0]
   \   00000006   0xD002             BEQ      ??UART_XonAnyBit_0
    593              /* Enable the UART XON any bit */
    594              UART->XFCR_b.XONANY = SET;
   \   00000008   0x2220             MOVS     R2,#+32
   \   0000000A   0x4302             ORRS     R2,R2,R0
   \   0000000C   0xE001             B        ??UART_XonAnyBit_1
    595            }
    596            else {
    597              /* Disable the UART XON any bit */
    598              UART->XFCR_b.XONANY = RESET;
   \                     ??UART_XonAnyBit_0: (+1)
   \   0000000E   0x22DF             MOVS     R2,#+223
   \   00000010   0x4002             ANDS     R2,R2,R0
   \                     ??UART_XonAnyBit_1: (+1)
   \   00000012   0x700A             STRB     R2,[R1, #+0]
    599            }
    600          }
   \   00000014   0x4770             BX       LR               ;; return
    601          
    602          
    603          /**
    604            * @brief  Enables or disables the UART special character detection.
    605            * @param  NewState: functional state @ref FunctionalState
    606            *         This parameter can be: ENABLE or DISABLE.
    607            * @retval None
    608            */

   \                                 In section .text, align 2, keep-with-next
    609          void UART_SpecialCharDetect(FunctionalState NewState)
    610          {
    611            /* Check the parameters */
    612            assert_param(IS_FUNCTIONAL_STATE(NewState));
    613            
    614            if (NewState != DISABLE) {
   \                     UART_SpecialCharDetect: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_18  ;; 0x40300050
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x7808             LDRB     R0,[R1, #+0]
   \   00000006   0xD002             BEQ      ??UART_SpecialCharDetect_0
    615              /* Enable the UART special character detection */
    616              UART->XFCR_b.SPECHAR = SET;
   \   00000008   0x2240             MOVS     R2,#+64
   \   0000000A   0x4302             ORRS     R2,R2,R0
   \   0000000C   0xE001             B        ??UART_SpecialCharDetect_1
    617            }
    618            else {
    619              /* Disable the UART special character detection */
    620              UART->XFCR_b.SPECHAR = RESET;
   \                     ??UART_SpecialCharDetect_0: (+1)
   \   0000000E   0x22BF             MOVS     R2,#+191
   \   00000010   0x4002             ANDS     R2,R2,R0
   \                     ??UART_SpecialCharDetect_1: (+1)
   \   00000012   0x700A             STRB     R2,[R1, #+0]
    621            }
    622          }
   \   00000014   0x4770             BX       LR               ;; return
    623          
    624          
    625          /**
    626            * @brief  Sets the UART flow control mode for transmission.
    627            * @param  uint8_t: specifies the flow control character.
    628            * @retval None
    629            */

   \                                 In section .text, align 2, keep-with-next
    630          void UART_Xon1Char(uint8_t UART_XonChar)
    631          {
    632              /* Check the parameters */
    633            assert_param(IS_SW_FLOW_CTRL(UART_XonChar));
    634          
    635            UART->XON1 = UART_XonChar;
   \                     UART_Xon1Char: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_19  ;; 0x40300054
   \   00000002   0x7008             STRB     R0,[R1, #+0]
    636          }
   \   00000004   0x4770             BX       LR               ;; return
    637          
    638          /**
    639            * @brief  Sets the UART flow control mode for transmission.
    640            * @param  uint8_t: specifies the flow control character.
    641            * @retval None
    642            */

   \                                 In section .text, align 2, keep-with-next
    643          void UART_Xon2Char(uint8_t UART_XonChar)
    644          {
    645              /* Check the parameters */
    646            assert_param(IS_SW_FLOW_CTRL(UART_XonChar));
    647          
    648            UART->XON2 = UART_XonChar;
   \                     UART_Xon2Char: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_20  ;; 0x40300058
   \   00000002   0x7008             STRB     R0,[R1, #+0]
    649          }
   \   00000004   0x4770             BX       LR               ;; return
    650          
    651          /**
    652            * @brief  Sets the UART flow control mode for transmission.
    653            * @param  uint8_t: specifies the flow control character.
    654            * @retval None
    655            */

   \                                 In section .text, align 2, keep-with-next
    656          void UART_Xoff1Char(uint8_t UART_XoffChar)
    657          {
    658              /* Check the parameters */
    659            assert_param(IS_SW_FLOW_CTRL(UART_XoffChar));
    660          
    661            UART->XOFF1 = UART_XoffChar;
   \                     UART_Xoff1Char: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_21  ;; 0x4030005c
   \   00000002   0x7008             STRB     R0,[R1, #+0]
    662          }
   \   00000004   0x4770             BX       LR               ;; return
    663          
    664          /**
    665            * @brief  Sets the UART flow control mode for transmission.
    666            * @param  uint8_t: specifies the flow control character.
    667            * @retval None
    668            */

   \                                 In section .text, align 2, keep-with-next
    669          void UART_Xoff2Char(uint8_t UART_XoffChar)
    670          {
    671              /* Check the parameters */
    672            assert_param(IS_SW_FLOW_CTRL(UART_XoffChar));
    673          
    674            UART->XOFF2 = UART_XoffChar;
   \                     UART_Xoff2Char: (+1)
   \   00000000   0x....             LDR      R1,??DataTable24_22  ;; 0x40300060
   \   00000002   0x7008             STRB     R0,[R1, #+0]
    675          }
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x40300030         DC32     0x40300030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x4030000C         DC32     0x4030000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0x000001FF         DC32     0x1ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   0x7A120000         DC32     0x7a120000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \   00000000   0x4030001C         DC32     0x4030001c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_5:
   \   00000000   0xFFFFFDFF         DC32     0xfffffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_6:
   \   00000000   0xFFFFFEFF         DC32     0xfffffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_7:
   \   00000000   0xFFFFBFFF         DC32     0xffffbfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_8:
   \   00000000   0xFFFF7FFF         DC32     0xffff7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_9:
   \   00000000   0x40300038         DC32     0x40300038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_10:
   \   00000000   0x40300000         DC32     0x40300000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_11:
   \   00000000   0x4030002C         DC32     0x4030002c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_12:
   \   00000000   0xFFFFF7FF         DC32     0xfffff7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_13:
   \   00000000   0x40300004         DC32     0x40300004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_14:
   \   00000000   0x4030003C         DC32     0x4030003c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_15:
   \   00000000   0x40300044         DC32     0x40300044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_16:
   \   00000000   0x40300034         DC32     0x40300034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_17:
   \   00000000   0x40300048         DC32     0x40300048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_18:
   \   00000000   0x40300050         DC32     0x40300050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_19:
   \   00000000   0x40300054         DC32     0x40300054

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_20:
   \   00000000   0x40300058         DC32     0x40300058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_21:
   \   00000000   0x4030005C         DC32     0x4030005c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_22:
   \   00000000   0x40300060         DC32     0x40300060
    676          
    677          /**
    678            * @}
    679            */
    680          
    681          /**
    682            * @}
    683            */
    684          
    685          /**
    686            * @}
    687            */
    688          
    689          /******************* (C) COPYRIGHT 2016 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   UART_BreakCmd
       0   UART_ClearFlag
       0   UART_ClearITPendingBit
       0   UART_Cmd
       0   UART_DMACmd
       0   UART_DeInit
       0   UART_GetFlagStatus
       0   UART_GetITStatus
       0   UART_ITConfig
      16   UART_Init
        16 __aeabi_uidiv
       0   UART_ReceiveData
       0   UART_RequestToSendCmd
       0   UART_RxFifoIrqLevelConfig
       0   UART_RxSwFlowControlMode
       0   UART_SendData
       0   UART_SpecialCharDetect
       0   UART_StructInit
       0   UART_SwFlowControl
       0   UART_TimeoutConfig
       0   UART_TxFifoIrqLevelConfig
       0   UART_TxSwFlowControlMode
       0   UART_Xoff1Char
       0   UART_Xoff2Char
       0   UART_Xon1Char
       0   UART_Xon2Char
       0   UART_XonAnyBit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_10
       4  ??DataTable24_11
       4  ??DataTable24_12
       4  ??DataTable24_13
       4  ??DataTable24_14
       4  ??DataTable24_15
       4  ??DataTable24_16
       4  ??DataTable24_17
       4  ??DataTable24_18
       4  ??DataTable24_19
       4  ??DataTable24_2
       4  ??DataTable24_20
       4  ??DataTable24_21
       4  ??DataTable24_22
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable24_9
      18  UART_BreakCmd
       6  UART_ClearFlag
       6  UART_ClearITPendingBit
      24  UART_Cmd
      20  UART_DMACmd
      46  UART_DeInit
      34  UART_GetFlagStatus
      18  UART_GetITStatus
      20  UART_ITConfig
     296  UART_Init
       8  UART_ReceiveData
      22  UART_RequestToSendCmd
      20  UART_RxFifoIrqLevelConfig
      20  UART_RxSwFlowControlMode
      10  UART_SendData
      22  UART_SpecialCharDetect
      26  UART_StructInit
      22  UART_SwFlowControl
       6  UART_TimeoutConfig
      18  UART_TxFifoIrqLevelConfig
      20  UART_TxSwFlowControlMode
       6  UART_Xoff1Char
       6  UART_Xoff2Char
       6  UART_Xon1Char
       6  UART_Xon2Char
      22  UART_XonAnyBit

 
 820 bytes in section .text
 
 820 bytes of CODE memory

Errors: none
Warnings: 1
